<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2678944-A1" country="EP" doc-number="2678944" kind="A1" date="20140101" family-id="46718981" file-reference-id="277629" date-produced="20180823" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146550553" ucid="EP-2678944-A1"><document-id><country>EP</country><doc-number>2678944</doc-number><kind>A1</kind><date>20140101</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-11859315-A" is-representative="NO"><document-id mxw-id="PAPP154824476" load-source="docdb" format="epo"><country>EP</country><doc-number>11859315</doc-number><kind>A</kind><date>20110608</date><lang>EN</lang></document-id><document-id mxw-id="PAPP183608511" load-source="docdb" format="original"><country>EP</country><doc-number>11859315.1</doc-number><date>20110608</date></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140446142" ucid="CA-2011050350-W" load-source="docdb"><document-id format="epo"><country>CA</country><doc-number>2011050350</doc-number><kind>W</kind><date>20110608</date></document-id></priority-claim><priority-claim mxw-id="PPC140449673" ucid="US-201161446528-P" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201161446528</doc-number><kind>P</kind><date>20110225</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-2017199560" load-source="docdb">H04N  19/124       20140101AFI20150929BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1962106864" load-source="docdb" scheme="CPC">H04N  19/124       20141101 FI20160309BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2004749408" load-source="docdb" scheme="CPC">H04N  19/147       20130101 LI20151102BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2004750381" load-source="docdb" scheme="CPC">H04N  19/177       20141101 LI20151102BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2004750449" load-source="docdb" scheme="CPC">H04N  19/174       20141101 LI20151102BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2004750591" load-source="docdb" scheme="CPC">H04N  19/176       20130101 LI20151102BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2004750597" load-source="docdb" scheme="CPC">H04N  19/192       20141101 LI20151102BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2004751074" load-source="docdb" scheme="CPC">H04N  19/70        20130101 LI20151102BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2004751289" load-source="docdb" scheme="CPC">H04N  19/463       20141101 LI20151102BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2004752682" load-source="docdb" scheme="CPC">H04N  19/172       20130101 LI20151102BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2004752751" load-source="docdb" scheme="CPC">H04N  19/61        20141101 LI20151102BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2004753058" load-source="docdb" scheme="CPC">H04N  19/196       20141101 LI20151102BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2004753360" load-source="docdb" scheme="CPC">H04N  19/194       20141101 LA20151102BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132184143" lang="DE" load-source="patent-office">VERFAHREN UND VORRICHTUNGEN ZUR DATENKOMPRIMIERUNG ANHAND VON OFFSET-BASIERTEN ADAPTIVEN REKONSTRUKTIONSSTUFEN</invention-title><invention-title mxw-id="PT132184144" lang="EN" load-source="patent-office">METHODS AND DEVICES FOR DATA COMPRESSION USING OFFSET-BASED ADAPTIVE RECONSTRUCTION LEVELS</invention-title><invention-title mxw-id="PT132184145" lang="FR" load-source="patent-office">PROCÉDÉS ET DISPOSITIFS DE COMPRESSION DE DONNÉES UTILISANT DES NIVEAUX DE RECONSTRUCTION ADAPTATIFS FONDÉS SUR UN DÉCALAGE</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR918162427" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>BLACKBERRY LTD</last-name><address><country>CA</country></address></addressbook></applicant><applicant mxw-id="PPAR918171059" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>BLACKBERRY LIMITED</last-name></addressbook></applicant><applicant mxw-id="PPAR918986054" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>BlackBerry Limited</last-name><iid>101413722</iid><address><street>2200 University Avenue East</street><city>Waterloo, ON N2K 0A7</city><country>CA</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR918137869" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>HE DAKE</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918161002" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>HE, DAKE</last-name></addressbook></inventor><inventor mxw-id="PPAR918989414" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>HE, DAKE</last-name><address><street>295 Phillip Street Ext. 78760</street><city>Waterloo, Ontario N2L 3W8</city><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918140634" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>YU XIANG</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918149410" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>YU, XIANG</last-name></addressbook></inventor><inventor mxw-id="PPAR918989848" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>YU, XIANG</last-name><address><street>295 Phillip Street Ext. 74329</street><city>Waterloo, Ontario N2L 3W8</city><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918159614" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>WANG JING</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918164976" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>WANG, JING</last-name></addressbook></inventor><inventor mxw-id="PPAR918985591" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>WANG, JING</last-name><address><street>295 Phillip Street Ext. 75923</street><city>Waterloo, Ontario N2L 3W8</city><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918171431" load-source="docdb" sequence="4" format="epo"><addressbook><last-name>YANG EN-HUI</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918134841" load-source="docdb" sequence="4" format="intermediate"><addressbook><last-name>YANG, EN-HUI</last-name></addressbook></inventor><inventor mxw-id="PPAR918979593" load-source="patent-office" sequence="4" format="original"><addressbook><last-name>YANG, EN-HUI</last-name><address><street>295 Phillip Street Ext. 78706</street><city>Waterloo, Ontario N2L 3W8</city><country>CA</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR918990023" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Patel, Binesh</last-name><iid>101344772</iid><address><street>Barker Brettell LLP 100 Hagley Road</street><city>Edgbaston Birmingham West Midlands B16 8QQ</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="CA-2011050350-W"><document-id><country>CA</country><doc-number>2011050350</doc-number><kind>W</kind><date>20110608</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2012113055-A1"><document-id><country>WO</country><doc-number>2012113055</doc-number><kind>A1</kind><date>20120830</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS548919032" load-source="docdb">AL</country><country mxw-id="DS548831830" load-source="docdb">AT</country><country mxw-id="DS548919033" load-source="docdb">BE</country><country mxw-id="DS548894776" load-source="docdb">BG</country><country mxw-id="DS548912854" load-source="docdb">CH</country><country mxw-id="DS548909114" load-source="docdb">CY</country><country mxw-id="DS548831831" load-source="docdb">CZ</country><country mxw-id="DS548812034" load-source="docdb">DE</country><country mxw-id="DS548919038" load-source="docdb">DK</country><country mxw-id="DS548909115" load-source="docdb">EE</country><country mxw-id="DS548859257" load-source="docdb">ES</country><country mxw-id="DS548894777" load-source="docdb">FI</country><country mxw-id="DS548894778" load-source="docdb">FR</country><country mxw-id="DS548919039" load-source="docdb">GB</country><country mxw-id="DS548919040" load-source="docdb">GR</country><country mxw-id="DS548919041" load-source="docdb">HR</country><country mxw-id="DS548831832" load-source="docdb">HU</country><country mxw-id="DS548912855" load-source="docdb">IE</country><country mxw-id="DS548919046" load-source="docdb">IS</country><country mxw-id="DS548894779" load-source="docdb">IT</country><country mxw-id="DS548909116" load-source="docdb">LI</country><country mxw-id="DS548812035" load-source="docdb">LT</country><country mxw-id="DS548831833" load-source="docdb">LU</country><country mxw-id="DS548812036" load-source="docdb">LV</country><country mxw-id="DS548812037" load-source="docdb">MC</country><country mxw-id="DS548910883" load-source="docdb">MK</country><country mxw-id="DS548910884" load-source="docdb">MT</country><country mxw-id="DS548831834" load-source="docdb">NL</country><country mxw-id="DS548859258" load-source="docdb">NO</country><country mxw-id="DS548831835" load-source="docdb">PL</country><country mxw-id="DS548812038" load-source="docdb">PT</country><country mxw-id="DS548831836" load-source="docdb">RO</country><country mxw-id="DS548812039" load-source="docdb">RS</country><country mxw-id="DS548831837" load-source="docdb">SE</country><country mxw-id="DS548812040" load-source="docdb">SI</country><country mxw-id="DS548912856" load-source="docdb">SK</country><country mxw-id="DS548912857" load-source="docdb">SM</country><country mxw-id="DS548910885" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><abstract mxw-id="PA99627091" ref-ucid="WO-2012113055-A1" lang="EN" load-source="patent-office"><p num="0000">Encoding and decoding methods are presented that used offset-based adaptive reconstruction levels. The offset data is inserted in the bitstream with the encoded video data. The offset data may be differential data and may be an index to an array of offset values from which the differential offset is calculated by the decoder. The offset to an adaptive reconstruction level may be adjusted for each slice. The offsets may be specific to a particular level/index and data type. In some cases, offsets may only be sent for a subset of the levels. Higher levels may apply no offset, may apply an average offset, or may apply the offset used for the highest level having a level- specific offset.</p></abstract><abstract mxw-id="PA99825598" ref-ucid="WO-2012113055-A1" lang="EN" source="national office" load-source="docdb"><p>Encoding and decoding methods are presented that used offset-based adaptive reconstruction levels. The offset data is inserted in the bitstream with the encoded video data. The offset data may be differential data and may be an index to an array of offset values from which the differential offset is calculated by the decoder. The offset to an adaptive reconstruction level may be adjusted for each slice. The offsets may be specific to a particular level/index and data type. In some cases, offsets may only be sent for a subset of the levels. Higher levels may apply no offset, may apply an average offset, or may apply the offset used for the highest level having a level- specific offset.</p></abstract><abstract mxw-id="PA99627092" ref-ucid="WO-2012113055-A1" lang="FR" load-source="patent-office"><p num="0000">L'invention concerne des procédés de codage et de décodage utilisant des niveaux de reconstruction adaptatifs fondés sur un décalage. Les données de décalage sont insérées dans le flux binaire en association avec les données vidéo codées. Les données de décalage peuvent être des données différentielles et peuvent être un indice correspondant à un ensemble de valeurs de décalage à partir desquelles le décalage différentiel est calculé par le décodeur. Le décalage affectant un niveau de reconstruction adaptatif peut être ajusté pour chaque tranche. Les décalages peuvent être propres à un niveau/indice et à un type de données particuliers. Dans certains cas, les décalages peuvent n'être envoyés que pour un sous-ensemble des niveaux. Des niveaux plus élevés peuvent n'appliquer aucun décalage, peuvent appliquer un décalage moyen ou peuvent appliquer le décalage utilisé pour le niveau le plus élevé ayant un décalage propre à un niveau.</p></abstract><abstract mxw-id="PA99825599" ref-ucid="WO-2012113055-A1" lang="FR" source="national office" load-source="docdb"><p>L'invention concerne des procédés de codage et de décodage utilisant des niveaux de reconstruction adaptatifs fondés sur un décalage. Les données de décalage sont insérées dans le flux binaire en association avec les données vidéo codées. Les données de décalage peuvent être des données différentielles et peuvent être un indice correspondant à un ensemble de valeurs de décalage à partir desquelles le décalage différentiel est calculé par le décodeur. Le décalage affectant un niveau de reconstruction adaptatif peut être ajusté pour chaque tranche. Les décalages peuvent être propres à un niveau/indice et à un type de données particuliers. Dans certains cas, les décalages peuvent n'être envoyés que pour un sous-ensemble des niveaux. Des niveaux plus élevés peuvent n'appliquer aucun décalage, peuvent appliquer un décalage moyen ou peuvent appliquer le décalage utilisé pour le niveau le plus élevé ayant un décalage propre à un niveau.</p></abstract><description mxw-id="PDES50931771" ref-ucid="WO-2012113055-A1" lang="EN" load-source="patent-office"><!-- EPO <DP n="2"/>--><p id="p0001" num="0001"> METHODS AND DEVICES FOR DATA COMPRESSION USING OFFSET-BASED ADAPTIVE RECONSTRUCTION LEVELS </p><p id="p0002" num="0002">FIELD </p><p id="p0003" num="0003"> [0001] The present application generally relates to data compression and, in particular, to methods and devices for using adaptive reconstruction levels in quantization and de- quantization. </p><p id="p0004" num="0004">BACKGROUND </p><p id="p0005" num="0005">[0002] Data compression occurs in a number of contexts. It is very commonly used in communications and computer networking to store, transmit, and reproduce information efficiently. It finds particular application in the encoding of images, audio and video. Video presents a significant challenge to data compression because of the large amount of data required for each video frame and the speed with which encoding and decoding often needs to occur. The current state-of-the-art for video encoding is the ITU-T H.264/AVC video coding standard. It defines a number of different profiles for different applications, including the Main profile, Baseline profile and others. A next-generation video encoding standard is currently under development through a joint initiative of MPEG-TTU: High Efficiency Video Coding (HEVC). </p><p id="p0006" num="0006"> [0003] There are a number of standards for encoding/decoding images and videos, including H.264, that use block-based coding processes. In these processes, the image or frame is divided into blocks, typically 4x4 or 8x8, and the blocks are spectrally transformed into coefficients, quantized, and entropy encoded. In many cases, the data being transformed is not the actual pixel data, but is residual data following a prediction operation. Predictions can be intra-frame, i.e. block-to-block within the frame/image, or inter-frame, i.e. between frames (also called motion prediction). It is expected that HEVC will also have these features. 
<!-- EPO <DP n="3"/>-->
 [0004] When spectrally transforming residual data, many of these standards prescribe the use of a discrete cosine transform (DCT) or some variant thereon. The resulting DCT coefficients are then quantized using a quantizer that employs a uniform quantization step size, i.e. a uniform partitioning of the data space. </p><p id="p0007" num="0007">[0005] Work in lossy compression, e.g., audio/voice coding, video coding, image coding, etc., tends to focus on improving rate-distortion performance. That is, the objective of most encoding and decoding schemes is to find an optimal balance between distortion and coding rate. A rate-distortion optimization expression of the type J = D + 1R is typically used, wherein the Lagrangian multiplier λ represents the desired trade-off between coding rate and distortion. </p><p id="p0008" num="0008"> [0006] It would be advantageous to provide for an improved encoder, decoder and method of encoding or decoding. </p><p id="p0009" num="0009">BRIEF SUMMARY </p><p id="p0010" num="0010">[0007] The present application describes methods and encoders/decoders for achieving rate-distortion improvements in lossy data compression. In some embodiments, the data compression process or devices described herein may be applied to the encoding and decoding of audio data, image data, and/or video data. In particular, the present application describes a method and process of data compression that uses adaptive reconstruction levels within a quantization operation. </p><p id="p0011" num="0011"> [0008] Tn one aspect, the present application describes an adaptive scheme of computing and transmitting the reconstruction levels for scalar quantizers to achieve a better rate distortion coding performance without materially increasing the coding complexity. From the rate distortion coding performance point of view, the example processes herein achieve significant distortion reduction while requiring a very small number of bits. From the coding complexity point of view, the at least one example method is simple and fast because it involves solving a quadratic optimization problem on the encoder side. On the decoder side, the at least one example method with adaptive reconstruction levels does not increase the computational complexity, and involves only some extra memory consumption. 
<!-- EPO <DP n="4"/>-->
 [0009] In another aspect, the present application describes a method of decoding a bitstream of encoded compressed data. The method includes entropy decoding the encoded compressed data to obtain indices and to obtain offset data associated with at least one of the indices; determining an associated reconstruction level for each index, wherein the associated reconstruction level for said at least one of the indices is determined by adjusting a predetermined reconstruction level using the offset data; and reconstructing a data point for each obtained index using that index's associated reconstruction level. </p><p id="p0012" num="0012"> [0010] In yet another aspect, the present application describes a method for encoding transform domain coefficients for a group of coding units, wherein the transform domain coefficients are quantized by a quantizer that associates each transform domain coefficient with an index based upon in which sub-part of a partitioned data space that transform domain coefficient is found. The method includes determining the average transform domain coefficient for each sub-part; calculating an offset for each sub-part by determining a difference between the average transform domain coefficient for that sub-part and a predetermined reconstruction level for that sub-part; and entropy encoding the indices associated with the transform domain coefficients, and entropy encoding at least one of the offsets, to output a bitstream of encoded data. </p><p id="p0013" num="0013"> [0011] Tn another aspect, the present application provides a method of decoding a bitstream of compressed data. The method includes extracting offset data from the bitstream, wherein the offset data is associated with an index; calculating a reconstruction level for the index by adjusting a predetermined reconstruction level using the offset data; decoding the compressed data to obtain a plurality of quantized transform coefficients; and dequantizing each quantized transform coefficient that corresponds to the index to generate a data point using the index's calculated reconstruction level. </p><p id="p0014" num="0014">[0012] In yet a further aspect, the present application describes a method for encoding transform domain coefficients for a group of coding units, wherein the transform domain coefficients are quantized by a quantizer that associates each transform domain coefficient with an index based upon in which sub-part of a partitioned data space that transform domain coefficient is located. The method includes determining the average transform domain coefficient at least one of the sub-parts; calculating an offset for that sub-part by determining a difference between the average transform domain coefficient for that sub-part and a 
<!-- EPO <DP n="5"/>-->
 predetermined reconstruction level for that sub-part; and entropy encoding the indices associated with the transform domain coefficients to output a bitstream of compressed data and inserting into the bitstream offset data from which the offset for that sub-part can be calculated. </p><p id="p0015" num="0015">[0013] In a further aspect, the present application describes encoders and decoders configured to implement such methods of encoding and decoding. </p><p id="p0016" num="0016"> [0014] In yet a further aspect, the present application describes computer-readable media storing computer-executable program instructions which, when executed, configured a processor to perform the described methods of encoding and/or decoding. </p><p id="p0017" num="0017">[0015] In yet an additional aspect, the present application describes a processor- readable medium storing a bitstream of encoded compressed data, wherein the compressed data, when decoded, is structured to include a plurality of consecutive portions, and wherein each portion includes video data containing indices representing quantized transform domain coefficients obtained through a video encoding process for a group of coding units, and offset data for adjusting one or more predetermined reconstruction levels used in dequantizing the quantized transform domain coefficients. </p><p id="p0018" num="0018"> [0016] Other aspects and features of the present application will be understood by those of ordinary skill in the art from a review of the following description of examples in conjunction with the accompanying figures. </p><p id="p0019" num="0019">BRIEF DESCRIPTION OF THE DRAWINGS </p><p id="p0020" num="0020">[0017] Reference will now be made, by way of example, to the accompanying drawings which show example embodiments of the present application, and in which: </p><p id="p0021" num="0021"> [0018] Figure 1 shows, in block diagram form, an encoder for encoding video; </p><p id="p0022" num="0022">[0019] Figure 2 shows, in block diagram form, a decoder for decoding video; </p><p id="p0023" num="0023"> [0020] Figure 3 shows an example of a partitioned data space; </p><p id="p0024" num="0024"> [0021] Figure 4 shows an example of data point distribution within a sub-part of the partitioned data space; 
<!-- EPO <DP n="6"/>-->
 [0022] Figure 5 shows, in flowchart form, an example method for encoding data points using quantization with adaptive reconstruction levels; </p><p id="p0025" num="0025"> [0023] Figure 6 shows, in flowchart form, an example method for encoding video data using soft-decision quantization with adaptive reconstruction levels; </p><p id="p0026" num="0026">[0024] Figure 7 shows, in flowchart form, an example method of decoding video data that has been encoded using quantization with adaptive reconstruction levels; </p><p id="p0027" num="0027"> [0025] Figure 8 shows a flow diagram for an example method of encoding indices using offsets for adaptive reconstruction levels; </p><p id="p0028" num="0028"> [0026] Figure 9 diagrammatically shows an example bitstream format; </p><p id="p0029" num="0029">[0027] Figure 10 shows a flow diagram for an example method of decoding encoded compressed data using offset-based adaptive reconstruction levels; </p><p id="p0030" num="0030"> [0028] Figure 11 shows a simplified block diagram of an example embodiment of an encoder; </p><p id="p0031" num="0031"> [0029] Figure 12 shows a simplified block diagram of an example embodiment of a decoder; and </p><p id="p0032" num="0032"> [0030] Figure 13 shows, in flowchart form, an example decoding process using offset- based adaptive reconstruction levels. </p><p id="p0033" num="0033"> [0031] Similar reference numerals may have been used in different figures to denote similar components. </p><p id="p0034" num="0034">DESCRIPTION OF EXAMPLE EMBODIMENTS </p><p id="p0035" num="0035"> [0032] Tn the description that follows, some example embodiments are described with reference to the H.264 standard for video coding. Those ordinarily skilled in the art will understand that the present application is not limited to H.264 but may be applicable to other video coding/decoding standards, including possible future standards, such as HEVC, multiview coding standards, scalable video coding standards, and reconfigurable video coding standards. It will also be appreciated that the present application is not necessarily limited to video coding/decoding and may be applicable to audio coding/decoding, image 
<!-- EPO <DP n="7"/>-->
 coding/decoding, or the lossy coding/decoding of any other data. The present application is broadly applicable to any lossy data compression process that employs quantization irrespective of the type of data being coded/decoded. </p><p id="p0036" num="0036"> [0033] In the description that follows, when referring to video or images the terms frame, slice, tile and rectangular slice group may be used somewhat interchangeably. Those of skill in the art will appreciate that, in the case of the H.264 standard, a frame may contain one or more slices. It will also be appreciated that certain encoding/decoding operations are performed on a frame-by-frame basis, some are performed on a slice-by-slice basis, some tile- by-tile, and some by rectangular slice group, depending on the particular requirements of the applicable image or video coding standard. In any particular embodiment, the applicable image or video coding standard may determine whether the operations described below are performed in connection with frames and/or slices and/or tiles and/or rectangular slice groups, as the case may be. Accordingly, those ordinarily skilled in the art will understand, in light of the present disclosure, whether particular operations or processes described herein and particular references to frames, slices, tiles, rectangular slice groups are applicable to frames, slices, tiles, rectangualar slice groups, or some or all of those for a given embodiment. This also applies to coding units, groups of coding units, etc., as will become apparent in light of the description below. </p><p id="p0037" num="0037"> [0034] In the discussion that follows, reference is made to DCT coefficients and the DCT domain; however, it will be appreciated that this application is not limited the encoding of DCT coefficients, the encoding of block-based transform coefficients, the encoding of block-based data, or any particular data type. </p><p id="p0038" num="0038"> [0035] To the extent that the processes or methods described below are applied to images and/or video they may be applied to a portion of a video or image, such as a frame, a slice, a Group-of-Pictures (GOP), or on any other basis, such as to a coding unit, or group of coding units. To the extent that the process or methods described herein are applied to audio, such as music or voice data, they may be applied to a grouping or sequence of data points, e.g. an audio sample. </p><p id="p0039" num="0039"> [0036] Reference is now made to Figure 1 , which shows, in block diagram form, an encoder 10 for encoding video. Reference is also made to Figure 2, which shows a block diagram of a decoder 50 for decoding video. It will be appreciated that the encoder 10 and 
<!-- EPO <DP n="8"/>-->
 decoder 50 described herein may each be implemented on an application-specific or general purpose computing device, containing one or more processing elements and memory. The operations performed by the encoder 10 or decoder 50, as the case may be, may be implemented by way of application-specific integrated circuit, for example, or by way of stored program instructions executable by a general purpose processor. The device may include additional software, including, for example, an operating system for controlling basic device functions. The range of devices and platforms within which the encoder 10 or decoder 50 may be implemented will be appreciated by those ordinarily skilled in the art having regard to the following description. </p><p id="p0040" num="0040">[0037] The encoder 10 receives a video source 12 and produces an encoded bitstream</p><p id="p0041" num="0041">14. The decoder 50 receives the encoded bitstream 14 and outputs a decoded video frame 16. The encoder 10 and decoder 50 may be configured to operate in conformance with a number of video compression standards. For example, the encoder 10 and decoder 50 may be H.264/AVC compliant. In other embodiments, the encoder 10 and decoder 50 may conform to other video compression standards, including evolutions of the H.264/AVC standard, like HEVC. </p><p id="p0042" num="0042"> [0038] The encoder 10 includes a spatial predictor 21 , a coding mode selector 20, transform processor 22, quantizer 24, and entropy encoder 26. As will be appreciated by those ordinarily skilled in the art, the coding mode selector 20 determines the appropriate coding mode for the video source, for example whether the subject frame/slice is of T, P, or B type, and whether particular coding units (e.g. macroblocks) within the frame/slice are inter or intra coded. The transform processor 22 performs a transform upon the spatial domain data. In particular, the transform processor 22 applies a block-based transform to convert spatial domain data to spectral components. For example, in many embodiments a discrete cosine transform (DCT) is used. Other transforms, such as a discrete sine transform or others may be used in some instances. The block-based transform is performed on a macroblock or sub- block basis, depending on the size of the macroblocks. In the H.264 standard, for example, a typical 16x16 macroblock contains sixteen 4x4 transform blocks and the DCT process is performed on the 4x4 blocks. In some cases, the transform blocks may be 8x8, meaning there are four transform blocks per macroblock. In yet other cases, the transform blocks may be 
<!-- EPO <DP n="9"/>-->
 other sizes. In some cases, a 16x16 macroblock may include a non-overlapping combination of 4x4 and 8x8 transform blocks. </p><p id="p0043" num="0043"> [0039] Applying the block-based transform to a block of pixel data results in a set of transform domain coefficients. A "set" in this context is an ordered set in which the coefficients have coefficient positions. In some instances the set of transform domain coefficients may be considered a "block" or matrix of coefficients. In the description herein the phrases a "set of transform domain coefficients" or a "block of transform domain coefficients" are used interchangeably and are meant to indicate an ordered set of transform domain coefficients. </p><p id="p0044" num="0044">[0040] The set of transform domain coefficients is quantized by the quantizer 24. The quantized coefficients and associated information are then encoded by the entropy encoder 26. </p><p id="p0045" num="0045"> [0041] Intra-coded frames/slices (i.e. type I) are encoded without reference to other frames/slices. Tn other words, they do not employ temporal prediction. However intra-coded frames do rely upon spatial prediction within the frame/slice, as illustrated in Figure 1 by the spatial predictor 21. That is, when encoding a particular block the data in the block may be compared to the data of nearby pixels within blocks already encoded for that frame/slice. Using a prediction algorithm, the source data of the block may be converted to residual data. The transform processor 22 then encodes the residual data. H.264, for example, prescribes nine spatial prediction modes for 4x4 transform blocks. In some embodiments, each of the nine modes may be used to independently process a block, and then rate-distortion optimization is used to select the best mode. </p><p id="p0046" num="0046"> [0042] The H.264 standard also prescribes the use of motion prediction/compensation to take advantage of temporal prediction. Accordingly, the encoder 10 has a feedback loop that includes a de-quantizer 28, inverse transform processor 30, and deblocking processor 32. These elements mirror the decoding process implemented by the decoder 50 to reproduce the frame/slice. A frame store 34 is used to store the reproduced frames. Tn this manner, the motion prediction is based on what will be the reconstructed frames at the decoder 50 and not on the original frames, which may differ from the reconstructed frames due to the lossy compression involved in encoding/decoding. A motion predictor 36 uses the frames/slices stored in the frame store 34 as source frames/slices for comparison to a current frame for the purpose of identifying similar blocks. Accordingly, for macroblocks to which motion 
<!-- EPO <DP n="10"/>-->
 prediction is applied, the "source data" which the transform processor 22 encodes is the residual data that comes out of the motion prediction process. For example, it may include information regarding the reference frame, a spatial displacement or "motion vector", and residual pixel data that represents the differences (if any) between the reference block and the current block. Information regarding the reference frame and/or motion vector may not be processed by the transform processor 22 and/or quantizer 24, but instead may be supplied to the entropy encoder 26 for encoding as part of the bitstream along with the quantized coefficients. </p><p id="p0047" num="0047"> [0043] Those ordinarily skilled in the art will appreciate the details and possible variations for implementing H.264 encoders. </p><p id="p0048" num="0048"> [0044] The decoder 50 includes an enlropy decoder 52, dequantizer 54, inverse transform processor 56, spatial compensator 57, and deblocking processor 60. A frame buffer 58 supplies reconstructed frames for use by a motion compensator 62 in applying motion compensation. The spatial compensator 57 represents the operation of recovering the video data for a particular intra-coded block from a previously decoded block. </p><p id="p0049" num="0049"> [0045] The bitstream 14 is received and decoded by the entropy decoder 52 to recover the quantized coefficients. Side information may also be recovered during the entropy decoding process, some of which may be supplied to the motion compensation loop for use in motion compensation, if applicable. For example, the entropy decoder 52 may recover motion vectors and/or reference frame information for inter-coded macroblocks. </p><p id="p0050" num="0050"> [0046] The quantized coefficients are then dequantized by the dequantizer 54 to produce the transform domain coefficients, which are then subjected to an inverse transform by the inverse transform processor 56 to recreate the "video data". It will be appreciated that, in some cases, such as with an intra-coded macroblock, the recreated "video data" is the residual data for use in spatial compensation relative to a previously decoded block within the frame. The spatial compensator 57 generates the video data from the residual data and pixel data from a previously decoded block. In other cases, such as inter-coded macroblocks, the recreated "video data" from the inverse transform processor 56 is the residual data for use in motion compensation relative to a reference block from a different frame. Both spatial and motion compensation may be referred to herein as "prediction operations". 
<!-- EPO <DP n="11"/>-->
 [0047] The motion compensator 62 locates a reference block within the frame buffer</p><p id="p0051" num="0051">58 specified for a particular inter-coded macroblock. It does so based on the reference frame information and motion vector specified for the inter-coded macroblock. It then supplies the reference block pixel data for combination with the residual data to arrive at the reconstructed video data for that macroblock. </p><p id="p0052" num="0052"> [0048] A deblocking process may then be applied to a reconstructed frame/slice, as indicated by the deblocking processor 60. After deblocking, the frame/slice is output as the decoded video frame 16, for example for display on a display device. It will be understood that the video playback machine, such as a computer, set-top box, DVD or Blu-Ray player, and/or mobile handheld device, may buffer decoded frames in a memory prior to display on an output device. </p><p id="p0053" num="0053"> [0049] It is expected that HEVC-compliant encoders and decoders will have many of these same or similar features. </p><p id="p0054" num="0054">Quantization </p><p id="p0055" num="0055"> [0050] For a given block of pixels x with a prediction p, the residual is z = x—p. In this example, the block of pixels x and residual z are the same size as the transform matrix t. The residual z is transformed (for example by using a DCT) to generate the set of transform domain coefficients c. The coefficients c are quantized using a selected quantization step size q to produce a set of quantized coefficients u. This may be expressed as: </p><p id="p0056" num="0056"> u = round ( c /q + /<sup>'</sup>) (1) </p><p id="p0057" num="0057"> [0051] where an input c is quantized to u by applying the quantization step size q, and l&gt;f&gt;0 is a rounding offset. Because the quantization output is calculated by a deterministic function, this is also called hard-decision quantization. </p><p id="p0058" num="0058"> [0052] The quantization operation can be viewed from a rate-distortion point-of-view.</p><p id="p0059" num="0059">In fact, the quantization operation can be refined so as to select indices u such that the selected indices result in a minimum rate-distortion cost. The minimum rate-distortion cost may be expressed as follows: </p><p id="p0060" num="0060"> min I c - u * q I <sup>2</sup> + λ - r(n) (2) </p><p id="p0061" num="0061"> u 
<!-- EPO <DP n="12"/>-->
 [0053] In Equation (2), c is the matrix of transform coefficients, q is the quantization step size, and u is the corresponding matrix of indices to which the coefficients have been quantized. The symbol · stands for element-wise multiplication between matrixes, λ is the Lagrangian multiplier, a constant that is determined by end users based on their preference of the coding rate and the video quality. A relatively small λ puts more preference on better quality, while a larger λ emphasizes on a lower coding rate. r(u) represents the rate function by entropy coding for the indices u, and r(u) represents the rate function for encoding and transmitting u. The entropy coding may be any suitable or applicable entropy coding scheme. In the case of JPEG images, for example, the coding may be Huffman coding. In the case of H.264 video, the coding may be CAVLC or CAB AC coding. Yet other context-dependent or context-independent coding schemes may be applicable in particular embodiments. Clearly, the quantization output from Equation (2) is not given by a deterministic function anymore, but is the output of an optimization process that relates to both the rate and the distortion. Thus, it is named soft-decision quantization. </p><p id="p0062" num="0062">[0054] Example embodiments of soft-decision quantization are described in US patent publication no. 2007/0217506 filed by Yang et al. (hereinafter "Yang"). The Yang publication describes the optimization of u given a fixed q. This is termed "soft-decision quantization", since the transform domain coefficients themselves are treated as free- parameters in the rate-distortion optimization. The application of soft-decision quantization to H.264 encoding using CAVLC is described in Yang, and it may include the use of a trellis to search for a set of quantized coefficients u that result in a minimum cumulative rate-distortion for a given entropy encoding scheme. In the example described in Yang, the H.264 CAVLC encoding scheme was used for illustration. </p><p id="p0063" num="0063"> [0055] In H.264 and in many other coding schemes the quantization step sizes are predetermined, and in a particular instance the encoder selects one of the quantization step sizes to use for quantizing a particular set of data points, whether a block, slice, frame, etc. The encoder then only needs to transmit an index or indicator so as to inform the decoder which quantization step size was used. </p><p id="p0064" num="0064"> [0056] Reference is now made to Figure 3, which graphically illustrates a portion of a data space 100. In this example, the data space 100 contains the set of data points to be quantized using a selected quantization scheme. Conceptually, in order to perform 
<!-- EPO <DP n="13"/>-->
 quantization, the data space 100 may be considered to be partitioned into sub-parts A<sub>0</sub>, A<sub>1 ;</sub> . . . AN, where N+l is the number of sub-parts. Each sub-part may be referenced by its index u, where u = 0, 1, . . . , N. A data point falling within one of the sub-parts A, is quantized to index u=i. Reconstruction levels q<sub>u</sub> are at the midpoint of their respective sub-parts. When the decoder reconstructs a data point, it reconstructs it as reconstruction level q<sub>l{</sub>; in the case of u=i the data point is reconstructed as qi irrespective of where within the sub-part A, the actual data point was located. With a quantization step size of q, each reconstruction level is given by i- q. If the source data is uniform, then the assumption of a midpoint reconstruction level will result in minimal distortion; however the assumption of a uniform distribution of source data may be inaccurate in many cases. </p><p id="p0065" num="0065"> [0057] Reference is now made to Figure 4, which shows an example sub-part A,. The midpoint reconstruction level is shown as qi. The non-uniform distribution of the source data points is shown as reference numeral 102. It will be appreciated that data points with a distribution as shown by 102 would be better represented by an adaptive reconstruction level at or near q . The adaptive reconstruction level may be based upon the actual distribution of data points that are associated with or assigned the index /, i.e. that are located within the subpart A,. The adaptive reconstruction level may be based upon the arithmetic mean or median or mode, in some embodiments. By adjusting the reconstruction level to reflect the distribution of the actual data points within a sub-part A;, the presently described process compensates for some of the distortion attributable to the non-uniform distribution of the data points when relying upon an assumption of uniformity. </p><p id="p0066" num="0066"> [0058] In many data compression processes, when quantization is performed the partitioning of the data space and selection of the reconstruction levels are not considered separately. For example, in ITU-T H.264/AVC, both are subsumed under the selection of a quantization step size. The present applicants have recognized that the partitioning of the data space and the selection of a reconstruction level for each sub-part may be considered separately, and need not be based upon a pre-determined reconstruction level, for example at the midpoint of the sub-part as in ITU-T H.264/AVC. </p><p id="p0067" num="0067"> [0059] Thus, the quantization under this process becomes a two-stage operation. First, the data points are assigned to a quantization index (i.e. based on the partitioning of the data space, the data points are grouped into sub-parts). The partitioning/quantization at this 
<!-- EPO <DP n="14"/>-->
 first stage may be uniform, non-uniform, predetermined hard-decision quantization, or soft- decision quantization. The step size/partition size may be selected from amongst a preset number of candidate step sizes/partition sizes based on a rate-distortion optimization process. In all these possible variations, the data points are each assigned one of the indices for the selected quantization partition structure. </p><p id="p0068" num="0068"> [0060] Second, the adaptive reconstruction level for each sub-part of the partitioned data space (e.g. each index) is determined. The adaptive reconstruction level may be based upon an averaging of actual data points falling within the sub-part. The averaging may occur over a block or coding unit, group of blocks or coding units, slice, frame, group-of -pictures (GOP) or other suitable collection of data points given the specific application. It may also occur over a group of coding units or frames having a common quantization parameter qP. In some cases the same frame or GOP may have coding units with different qP, in which case those coding units having the same qP may be considered a group of coding units for the purpose of determining adaptive reconstruction levels for that group of coding units. </p><p id="p0069" num="0069">[0061] The selection of the adaptive reconstruction level for each index may be based upon a rate-distortion analysis. In other words, it may be based upon selecting a </p><p id="p0070" num="0070">reconstruction level that minimizes the total distortion given the actual data points within the sub-part. Tt may further be based upon minimizing a cost function including distortion from the difference between the reconstruction level and the actual data points and the rate cost associated with transmitting the reconstruction level. The rate cost associated with transmitting the reconstruction level may be based upon the encoding scheme used to entropy encode the reconstruction levels. </p><p id="p0071" num="0071"> [0062] Reference is now made to Figure 5, which shows, in flowchart form, a method</p><p id="p0072" num="0072">200 of quantizing data. The method 200 is for quantizing and encoding a plurality data points. The data points fall within a data space that may be considered to be partitioned into a set of sub-parts for the purpose of the quantization. Each of the sub-parts has an associated quantization index. </p><p id="p0073" num="0073"> [0063] In operation 202, a quantization index is assigned to each of the data points. In other words, each data point falling within a sub-part is assigned the quantization index of that sub-part. The quantization that occurs in operation 202 may be hard-decision quantization or 
<!-- EPO <DP n="15"/>-->
 soft-decision quantization. The partitioning of the data space may be uniform or nonuniform. </p><p id="p0074" num="0074"> [0064] Once the data points have been quantized in operation 202, i.e. have each been assigned a quantization index, then in operation 204 an adaptive reconstruction level is calculated for each quantization index. The adaptive reconstruction level of a given index is calculated based on minimizing the joint cost of the total distortion from quantizing the data points within that sub-part and the rate of transmitting the adaptive reconstruction level. A Lagrangian rate-distortion cost expression may be used to determine the minimum cost and select the corresponding adaptive reconstruction level. </p><p id="p0075" num="0075">[0065] Once the adaptive reconstruction level for each index has been calculated in operation 204, then in operation 206 the adaptive reconstruction levels and the quantized data points are entropy encoded. It will be understood that the data points themselves are not encoded, but rather the quantization indices that have been assigned to them by the quantization of operation 202. Any suitable entropy encoding process or scheme may be used to encode the reconstruction levels. Selection of a suitable entropy encoding method, including selection of no encoding, is within the skill of an ordinary person familiar with the art. </p><p id="p0076" num="0076"> [0066] In one example embodiment, given the quantization indices u<sup>11</sup> for a group of blocks c", the adaptive reconstruction levels are calculated to minimize a joint cost of the total distortion and the extra rate for transmitting the reconstruction levels. For each quantization index u, let c<sub>u</sub> i, c<sub>u 2</sub>, c<sub>u m</sub> denote the input source symbols (for example, DCT coefficients in H.264 before quantization) which are quantized to u, where m is an integer depending upon u. Then we find q<sub>u</sub> such that q<sub>u</sub> minimizes </p><p id="p0077" num="0077"> (c<sub>u,</sub>i-ii-q<sub>u</sub> +(c<sub>u</sub> -u-q<sub>u</sub>f+...+(c<sub>U!m</sub>-u-q<sub>u</sub>)<sup>2</sup>+ λ<sup>■</sup> r(q<sub>u</sub> ) (3) </p><p id="p0078" num="0078">[0067] where r(q<sub>u</sub>) denotes the length function of a prefix code for q<sub>u</sub> according to the selected entropy encoding scheme. </p><p id="p0079" num="0079"> [0068] Reference is now made to Figure 6, which shows, in flowchart form, an example method 300 of encoding video data. This example method 300 illustrates the specific application of the quantization process described above in the context of video 
<!-- EPO <DP n="16"/>-->
 encoding. The method 300 may be implemented in a video encoder using hardware, software, or a combination thereof. </p><p id="p0080" num="0080"> [0069] In operation 302 blocks of transform domain coefficients c are obtained. It will be appreciated that there are many preceding steps, including performing motion or spatial prediction and obtaining residual values, with or without rate-distortion optimization. The transform domain coefficients c are obtained through spectral transform of the residual data, in some instances using a DCT operation. In many instances, the transform is performed on a block-by-block basis. The H.264 standard, for example, prescribes a DCT operation performed on 4x4 or 8x8 blocks of residual data. The resulting set of transform domain coefficients c include 16 or 64 data points, as the case may be. It will be appreciated that some of the operations described herein may also be performed on a block-by-block basis. However, in many cases the method 300 of determining adaptive reconstruction levels may be performed for groups of blocks at a time, such as a slice, frame, GOP, or other grouping of blocks of data. </p><p id="p0081" num="0081">[0070] In operation 304, given a set of reconstruction levels q<sub>u</sub> for a partitioning with indices u, soft decision quantization is performed to quantize the transform domain coefficients c, i.e. to assign an index u for each transform domain coefficient c. The soft decision quantization may include selecting indices u that minimize a total rate-distortion cost. Equation (2) above is an example expression that may be used to find indices resulting in a minimum total rate-distortion cost. The initial set of reconstruction levels q<sub>u</sub> may be those reconstruction levels associated with the current quantization step size, as prescribed by the applicable encoding standard. In at least one example, the initial set of reconstruction levels is simply the preselected quantization step size q. </p><p id="p0082" num="0082"> [0071] Out of operation 304, the transform domain coefficients c are each quantized and represented by an assigned index u. In operation 306, those assigned indices u are fixed and adaptive reconstruction levels q<sub>u</sub> are found that minimize a rate-distortion cost, such as that given by Equation (3) above. After operation 306, each index u has an updated reconstruction level (referred to herein as an adaptive reconstruction level) q<sub>u</sub>. </p><p id="p0083" num="0083"> [0072] The process may be iterative. That is, operations 304 and 306 may be repeated by fixing the reconstruction levels in operation 304 to find indices that minimize the cost expression of Equation (2) and then fixing the indices in operation 306 to find the 
<!-- EPO <DP n="17"/>-->
 reconstruction levels that minimize the cost expression of Equation (3), repeatedly. Operation 308 may include an evaluation of whether to stop the iterative loop of operations 304 and 306. In this example operation 308 determines whether the adaptive reconstruction levels q<sub>u</sub> have changed by more than a threshold amount γ. If so, then operations 304 and 306 are repeated. Tf not, then the method 300 moves to operation 310, where the video is entropy encoded. This operation 310 includes entropy encoding the indices u and the adaptive reconstruction levels q«-</p><p id="p0084" num="0084">[0073] Decoding of an encoded video is now illustrated by way of the example method 400 shown in Figure 7. The example method 400 is preceded by obtaining or receiving the encoded video data, for example over a computer network, a broadcast network, a cellular network, a short-range network, or from a digital recording device such as a DVD or other computer-readable medium. In operation 402 the bitstream of encoded video data is entropy decoded to obtain the indices u and the adaptive reconstruction levels q<sub>u</sub>. In operation 404, the transform domain coefficients are reconstructed as u q<sub>u</sub>. The reconstructed transform domain coefficients are then inverse transformed in operation 406, and suitable spatial or motion compensation is applied, as the case may be, in operation 408. Tn operation 410 the video is output, for example to a display screen or through a video output port. </p><p id="p0085" num="0085"> [0074] It will be appreciated that in some embodiments, an adaptive reconstruction level q<sub>u</sub> may not be encoded and transmitted for every sub-part. Some sub-parts may have too few data points to justify sending an adaptive reconstruction level q<sub>u</sub> from a rate-distortion point of view. In other cases, some sub-parts may have a data point distribution with a median that does not deviate significantly from the midpoint of the sub-part, meaning that the adaptive reconstruction level q<sub>u</sub> is nearly identical to the midpoint and the distortion gain does not outweigh the rate cost associated with sending the adaptive reconstruction level q<sub>u</sub>. </p><p id="p0086" num="0086">[0075] In some embodiments, the rate distortion cost of transmitting a given reconstruction level may be evaluated. Specifically, a parameter, called the rate value, may be calculated and the adaptive reconstruction level is transmitted if the rate value is greater than the number of bits that is needed to transmit this reconstruction level. In one example embodiment, the rate value may be expressed as: 
<!-- EPO <DP n="18"/>-->
 
<img id="imgf000018_0001" he="11" wi="19" file="imgf000018_0001.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="yes"/>
 </p><p id="p0087" num="0087"> where N, is the number of data points in the sub-part A<sub>t</sub>. </p><p id="p0088" num="0088"> [0076] In one embodiment, the encoder and decoder may be configured such that the encoder calculates and transmits adaptive reconstruction levels q„ for lower indices. As soon as the encoder encounters an index in which the adaptive reconstruction level q<sub>u</sub> should not be sent, due to a rate-distortion analysis, then the encoder ceases to calculate adaptive reconstruction levels for higher indices and inserts a stop code in the encoding of the adaptive reconstruction levels q<sub>u</sub> to indicate to the decoder that no further levels will be sent for higher indices. Other methods or operations for determining which adaptive reconstruction levels to send may be used. </p><p id="p0089" num="0089"> [0077] In a case study of residual coding for video compression, a simple scheme of signaling adaptive reconstruction levels for only a few selected sub-parts as the corresponding average of data points within those sub-parts has proved to improve the rate distortion performance significantly. </p><p id="p0090" num="0090">[0078] In one possible embodiment, a finite set of quantizers with various reconstruction levels may be constructed or preconfigured. In the encoding process, the encoder may dynamically select one quantizer from the set of quantizers on the basis that it realizes the best rate-distortion performance, i.e. lowest cost, among the candidate quantizers of the set. The choice of quantizer is then communicated to the decoder in the output bitstream. </p><p id="p0091" num="0091"> [0079] In yet a further embodiment, rather than sending reconstruction levels q<sub>u</sub>, the encoder may send an offset value δ for each reconstruction level. That is, the adaptive reconstruction level for indices u=i is given by i q + Si. The offset δ, for sub-part Ai may be calculated as <sup>~</sup>q<sub>i</sub>— i- q, where q<sub>t</sub> is the calculated adaptive reconstruction level for that sub-part Ai, and q is the non-adaptive quantization step size used to quantize the data points. As noted previously, ¾ may be calculated by taking the mean (or median, etc.) of the data points within the sub-part A<sub>t</sub>. That is, the j<sup>'</sup>-th reconstruction level may be represented by the offset (or average deviation) of the data points,
<img id="imgf000018_0002" he="5" wi="7" file="imgf000018_0002.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="no"/>
 , from the conventional reconstruction point of i q, which is expressed as: 
<!-- EPO <DP n="19"/>-->
 .<sup>(</sup>') —i - q (5) </p><p id="p0092" num="0092">[0080] In Equation (5), N, is the number of data points in the sub-part A,, and
<img id="imgf000019_0001" he="5" wi="7" file="imgf000019_0001.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="no"/>
 i is the n data point within the sub-part A,. </p><p id="p0093" num="0093"> [0081] It will be appreciated that in an alternative implementation, the offset &lt;¾ may be calculated as an offset to the quantization step size q, instead of an offset to the reconstruction level i- q. That is the offset &lt;¾ would result in a reconstruction level of i- (q+ ¾· Similarly, the offset ό<sub>ί</sub> may be calculated as an offset to the index i, which results in a reconstruction level of ( + 5i)- q. It will be appreciated that any of the embodiments described herein may be implemented using these variations for expressing the offset. </p><p id="p0094" num="0094">[0082] Tt may be noted that there is a difference between the offset of reconstruction levels shown in Equation (5) and the adaptive rounding offset,/, mentioned above in connection with Equation (1). The rounding offset is applied on the encoder side to change the quantization partitions and it is not needed by the decoder. On the other hand, the reconstruction level offset here is computed on the encoder side and is communicated to the decoder to be used to enhance the reconstruction. </p><p id="p0095" num="0095"> [0083] In one example embodiment, the transmitted adaptive reconstruction level information, whether it is explicit reconstruction levels q<sub>u</sub> or offsets &lt;5„, may be normalized. For example, the offsets may be normalized by dividing by q, thereby resulting in a real number within a limited range of (0, 1), which can be represented by a fixed point integer that is relatively easily encoded. Accordingly, in various possible embodiments, the encoder and decoder may be configured to use adaptive reconstruction levels in quantization by sending explicit reconstruction levels, normalized explicit reconstruction levels, offsets for determining the reconstruction levels, or normalized offsets for determining the </p><p id="p0096" num="0096">reconstruction levels. In yet further embodiments, any of these possible implementations may use differential encoding from the previously sent level/offset for a given sub-part. </p><p id="p0097" num="0097"> [0084] As mentioned above, the rate-distortion analysis may result in sending adaptive reconstruction level data (whether levels or offsets) for only some of the sub-parts. In simulations and testing it has been found that the rate-distortion analysis often results in sending of adaptive reconstruction data for only the first two sub-parts, e.g. indices u = 1 and 
<!-- EPO <DP n="20"/>-->
 2. These are also usually the sub-parts that contain the largest share of the data points. In other words, the majority of data points that are quantized fall into the first couple of indices. Thus, the rate-distortion analysis, for example as described above, may, in one embodiment, be simplified such that the decision to transmit adaptive reconstruction level data for a sub- part is based upon the number of data points quantized to that index. Tn other words, the encoder may count the number of data points in a sub-part A„ i.e. quantized to index i, and if the number of data points exceeds a threshold number, T, then the adaptive reconstruction level qi or offset , for that index u-i is transmitted in the bitstream. In some embodiments, the threshold number may be index-dependent, i.e. T,. </p><p id="p0098" num="0098">[0085] Using the number of data points as a determinant for whether to send an adaptive reconstruction level or offset avoids the need to include signaling in the bitstream as to which indices have adaptive reconstruction levels or offset, because the decoder can count the number of data points for each sub-part A, by simply counting the indices u=i and thus identify, based on the thresholds, whether an adaptive reconstruction level or offset is in the bitstream. In some embodiments, the thresholds may be preset within the encoder and decoder. In some embodiments, the thresholds may be configurable and may be </p><p id="p0099" num="0099">communicated to the decoder in initial header information of the bitstream. </p><p id="p0100" num="0100"> [0086] In one embodiment, the count of data points may not be separately collected for each sub-part. It may be too computationally costly to differentiate all sub-parts and collect counts for all sub-parts. Accordingly, in one embodiment, the total count for all parts is collected and used to estimate the count for each sub-part based on some empirical formula (e.g., the first sub-part corresponds to 80% of the total count), and then a sub-part-specific threshold is applied. </p><p id="p0101" num="0101">[0087] As noted above, it has been found in simulations that the rate-distortion decision on whether to send adaptive reconstruction levels often results in only sending levels/offsets for the first two or three indices. It has also been found that the offsets amongst the remaining sub-parts are somewhat consistent. Accordingly, in some embodiments the encoder may calculate an average of the remaining offsets and may transmit the average offset d for use in adjusting the reconstruction levels of those sub-parts for which there is not an explicit transmitted adaptive reconstruction level offset. 
<!-- EPO <DP n="21"/>-->
 [0088] Reference is now made to Figure 8, which shows a flow diagram for an example method 500 of encoding data. The method 500 begins in operation 502 with initializing reconstruction levels. In operation 504, encoding of a current frame begins. As will be appreciated, the encoding includes determining coding mode, motion vectors, residual data, etc., for coding units within the frame. The residual data is transformed to realize transfonn domain coefficients (TCOEFFs), which are then quantized to quantized TCOEFFs, i.e. , indices u. The TCOEFFs are data points within the data space Si. The quantization operation converts the data points within respective sub-parts A, to respective indices u-i. In this embodiment, hard-decision quantization with a fixed quantizer is presumed; however, in other embodiments soft-decision quantization may be employed in operation 504. </p><p id="p0102" num="0102"> [0089] As noted in operation 506, the encoder determines, for each sub-part A, (e.g. index u=i), the offset e&gt;, and the number of data points (TCOEFFs) within that sub-part A,. In operation 508, the encoder assesses for each sub-part Α,· whether the number of data points /V, in that sub-part exceeds the threshold value T for that sub-part. If so, then in operation 506 the calculated offset , for that subpart A, is placed in the bitstream. </p><p id="p0103" num="0103"> [0090] In operation 510, the encoder calculates an average offset value d based on the calculated offset values for those sub-parts that did not have enough data points to meet the criteria of Ni &gt;Γ;. Tn some embodiments, the average offset d may be calculated over all the sub-parts. In some embodiments, the average offset d may be calculated as a weighted average based on the number of data points per sub-part. In this embodiment, the average offset d is the weighted average for those sub-parts that did not meet the criteria of N, &gt;T,. An example formula for the average offset d is: 
<img id="imgf000021_0001" he="12" wi="40" file="imgf000021_0001.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="no"/>
 </p><p id="p0104" num="0104"> [0091] It will be appreciated that operations 504, 506,508, and 510 are not necessarily implemented linearly. For example, the counting of data points and determination as to whether they exceed a threshold can occur within the encoding process of operation 504. As another example, the average offset is not necessarily inserted in the bitstream after the explicit offsets are inserted; in some cases, the average offset may be placed ahead of any explicit offsets. 
<!-- EPO <DP n="22"/>-->
 [0092] The bitstream is output as indicated in operation 512. </p><p id="p0105" num="0105"> [0093] As indicated in operation 514, in this embodiment the reconstruction levels used to make coding decision in the encoding process of operation 504 are updated using the offset data calculated in operations 506 and 508. In one embodiment, average offset data may be used for those sub-parts that had too few data points; however, in other embodiments, the actual offsets for each sub-part are used in operation 514 to update reconstruction levels. The updated reconstruction levels are then used by the encoder in performing the encoding of the next group of coding units, whether it is a frame, slice, GOP, etc. </p><p id="p0106" num="0106"> [0094] It will be appreciated that the process shown in Figure 8 can be performed with respect to a group of coding units. A group of coding units can be a frame, slice, tile, rectangular slice group, GOP, or other grouping of coding units. In one embodiment, the group of coding units is all coding units within a frame or GOP having the same qP parameter. </p><p id="p0107" num="0107"> [0095] In the embodiment shown in Figure 8, the current frame for which offsets are calculated is not re-encoded using adaptive reconstruction levels. Rather it is transmitted together with the offset data for reconstruction at the decoder. The decoder uses the offsets to adjust the reconstruction levels for the current frame. </p><p id="p0108" num="0108"> [0096] In one exemplary embodiment, a set of adaptive reconstruction levels may be assigned to a group of coding units, with each coding unit (CU) covering an MxM area. In some examples, M may be equal to 16, or 32, or 64, or 128 as is proposed in developmental work on HEVC. Suppose that each group of coding units contains J CUs, where J might be a parameter specified in the side information. In one case, the exemplary decoding process with adaptive reconstruction levels may be described as follow: </p><p id="p0109" num="0109"> 1. Decode adaptive reconstruction level data (or offset data), for example, from the slice header, to determine a set of adaptive reconstruction levels; </p><p id="p0110" num="0110"> 2. Initialize a counter numCUs = 0; </p><p id="p0111" num="0111"> 3. Decode indices for one CU and reconstruct the CU by reconstructing the data points of the CU from the indices using the adaptive quantization levels; </p><p id="p0112" num="0112"> 4. Increase the counter numCUs by one; 
<!-- EPO <DP n="23"/>-->
 5. Repeat operations 2 through 4 until the counter numCUs == J; and</p><p id="p0113" num="0113">6. Repeat operations 1 through 5 until the slice is completely decoded. </p><p id="p0114" num="0114"> [0097] In the above-described embodiment the adaptive reconstruction level data or offset data may be explicit adaptive reconstruction levels or offsets, or may be differentially encoded. That is, the adaptive reconstruction level may be obtained by first using previously determined adaptive reconstruction levels to derive a prediction, and then add the prediction to a decoded prediction residual. </p><p id="p0115" num="0115"> [0098] In the embodiment described above, each adaptive reconstruction level or offset, or, equivalently, its prediction residual, may be described by using N<sub>b</sub> bits. </p><p id="p0116" num="0116">[0099] In yet another exemplary embodiment, the decoding process for a group of J</p><p id="p0117" num="0117">CUs can be described as follows: </p><p id="p0118" num="0118"> 1. Initialize the counter numCUs = 0; </p><p id="p0119" num="0119"> 2. Decode indices for one CU and store all decoded syntax elements; </p><p id="p0120" num="0120"> 3. Increase the counter numCUs by one; </p><p id="p0121" num="0121"> 4. Repeat operations 2 and 3 until numCUs == J; </p><p id="p0122" num="0122"> 5. Decode adaptive reconstruction level data to determine the set of adaptive </p><p id="p0123" num="0123"> reconstruction levels, and reconstruct the J CUs by using these adaptive reconstruction levels; and </p><p id="p0124" num="0124"> 6. Repeat operations 1 through 5 until the slice is completely decoded. </p><p id="p0125" num="0125">[00100] While the two embodiments described above use the number of CUs to control the decoding process, i.e. to indicate when the bitstream will contain new adaptive reconstruction level data, another embodiment may use a different parameter. For example, in another embodiment the parameter for the decoding procedure is the total number of non-zero coefficients, as exemplified in the following sample process: </p><p id="p0126" num="0126"> 1. Initialize counter NNZtotal = 0; </p><p id="p0127" num="0127"> 2. Decode indices for one CU, add the number of nonzero coefficients in the current CU to NNZtotal, and store all decoded syntax elements; </p><p id="p0128" num="0128"> 3. Repeat operation 2 until NNZtotal reaches a given threshold; 
<!-- EPO <DP n="24"/>-->
 4. Decode adaptive reconstruction level data to determine a set of adaptive reconstruction levels, and reconstruct all stored CUs by using these adaptive reconstruction levels; and </p><p id="p0129" num="0129"> 5. Repeat operations 1 through 4 until a whole frame is decoded and reconstructed. </p><p id="p0130" num="0130">[00101] In one implementation of the example process above, the decoding of adaptive reconstruction level data may further be controlled by a set of counters named NNZcounter(i), which count the number of nonzero coefficients falling into the * subpart. Accordingly, operation 4 of the process above may be implemented as: </p><p id="p0131" num="0131"> 4a. Set z<sup>'</sup>=l . </p><p id="p0132" num="0132"> 4b. If NNZcounter(z<sup>'</sup>) &gt; ThresholdNNZ, decode an offset δ for the z<sup>'</sup>-th adaptive </p><p id="p0133" num="0133"> reconstruction level. </p><p id="p0134" num="0134"> 4c. Repeat operation 4a. when i is smaller than a threshold Tc. </p><p id="p0135" num="0135"> 4d. If NNZcounter(Tc) &gt; ThresholdNNZ, decode an average offset δ , which will be used for all remaining reconstruction levels. </p><p id="p0136" num="0136">[00102] The ThresholdNNZ in the above exemplary process may be determined by empirical observations. One suitable choice for use in some example HEVC coding is 100. The threshold Tc may also determined based on data statistics. One suitable choice for use in some example HEVC coding is 3. </p><p id="p0137" num="0137"> [00103] The above exemplary process for decoding offset data (or adaptive reconstruction level data) involves counting the number of nonzero coefficients for many different reconstruction levels, which introduces extra computational complexity to both the encoder and the decoder. Tn some cases, the complexity increase might be undesired. Tn these cases, one total counter, named NNZtotal may be used. An example process using this variation is outlined below: </p><p id="p0138" num="0138"> 4a. Set z<sup>'</sup>=l. </p><p id="p0139" num="0139"> 4b. If NNZtotal &gt; Threshold(z<sup>'</sup>), decode an offset &lt;¾ for the z<sup>'</sup>-th reconstruction level</p><p id="p0140" num="0140">4c. Repeat operation 4b. when i is smaller than a threshold Tt. 
<!-- EPO <DP n="25"/>-->
 4d. If NNZtotal &gt; Threshold(Tt), decode an average offset for all remaining reconstruction levels. </p><p id="p0141" num="0141"> [00104] The variable Threshold^<sup>'</sup>) in the above exemplary embodiment may be determined based on the empirical observation of the ratio among the number of different reconstruction levels. One possible choice of the ratio in video codecs, such as HEVC, may be 14:2: 1 , in a case where the threshold is set to Tt=3. Correspondingly, one choice of those thresholds might be Thr* 17/14, Thr* 17/2, and Thr* 17, where Thr is a constant, for which 60 may be a suitable choice in some cases, meaning that it is likely worth transmitting adaptive reconstruction level data (e.g. offset data) for every 60 nonzero coefficients. </p><p id="p0142" num="0142">[00105] The N<sub>¾</sub>-bit representation of a reconstruction offset in the above exemplary embodiment may vary for different applications. For HEVC, observations show that 5-bit precision is sufficient for achieving acceptable rate distortion performance. In one example implementation, this 5-bit representation is achieved using a two-step process. First, the whole range of (0, q) is represented with a 9-bits precision uniformly. Second, the 9-bits numbers are quantized to 5-bit, following a rule of ensuring a uniform distribution of δ<sup>2</sup>. Note that the rate value of each reconstruction offset is proportional to δ<sup>2</sup>. </p><p id="p0143" num="0143"> [00106] A finite precision, e.g. an Ni,-bit, representation of a reconstruction offset may be further entropy coded by either using variable-length coding or arithmetic coding to reduce the average rate. </p><p id="p0144" num="0144">[00107] In another example embodiment, transmission and usage of adaptive reconstruction levels may mainly be controlled by the total number of nonzero coefficients. Specifically, the decoder monitors the NNZcounter and compares it with some threshold after receiving each coding unit. In this example, the number of total coding units is not used. Yet, it will be noted that the NNZcounter will be checked against the threshold at the coding unit boundary. </p><p id="p0145" num="0145"> [00108] In yet another example embodiment, the control mechanism for usage of adaptive reconstruction levels might be signaled to the decoder. For example, a flag might be inserted to the slice header or a frame header, to indicate which of the following mechanisms is used to control the transmission and usage of adaptive reconstruction levels: 1) the total number of nonzero coefficients; 2) the number of CUs; or 3) a combination of these two methods. 
<!-- EPO <DP n="26"/>-->
 [00109] In another embodiment, this single pass procedure is used, but the adjustment of conventional reconstruction levels in operation 514 is omitted. That is, the offsets are not used to adjust reconstruction levels for encoding of the next frame (or other group of coding units). </p><p id="p0146" num="0146">[00110] Tn yet another embodiment, a two-pass procedure may be used in which the current frame (or other group of coding units) is re-encoded in operation 504 using the adaptive reconstruction levels determined in operation 506. The changes in reconstruction level may result in different rate-distortion decisions, which can change the coding mode and motion vector decisions made during encoding. The offsets are then transmitted with the re- encoded video so that the decoder can reconstruct the video using the same reconstruction levels used in the encoding decisions. It will be appreciated, that the two-pass procedure adds some delay and complexity to the encoding process. </p><p id="p0147" num="0147"> [00111] In yet a further embodiment, the frame (or other grouping of coding units) may be iteratively re-encoded until a change in rate-distortion or offset values is less than a threshold amount. A process of this nature was illustrated and described above in connection with Figure 6. </p><p id="p0148" num="0148"> [00112] Reference is now may to Figure 9, which diagrammatically shows an example format of a portion of a bitstream 600. The bitstream contains encoded data 602, which contains, among other things, the entropy encoded indices for a group of coding units, such as a frame, slice, GOP, etc. The bitstream also includes encoded offset data 604. The encoded offset data 604, in this embodiment, includes average offset data 606. The encoded offset data 604 may also include zero or more explicit offsets 608 (shown as 608a and 608b), depending on whether the number of data points or a rate-distortion analysis justified the sending of an explicit offset for at least one of the sub-parts. In this example, two explicit offsets 608a and608b are shown in the bitstream 600. Further encoded data 610 may follow the offset data 604. </p><p id="p0149" num="0149"> [00113] The bitstream 600 may be transmitted in digital form using any of a number of protocols. For example, in some cases the bitstream 600 may be streamed or downloaded over a packet-based connection, such as an IP connection, whether wired, wireless, or both. Various communications protocols may be used to facilitate transmission. In some cases, the 
<!-- EPO <DP n="27"/>-->
 bitstream 600 may be stored on a processor-readable memory, such as a flash memory, DVD, Blu-Ray™ disc, or any other storage medium, whether optical, magnetic, or other. </p><p id="p0150" num="0150"> [00114] An example method 700 for decoding compressed data is shown in Figure 10 in flow diagram format. </p><p id="p0151" num="0151">[00115] The method 700 begins with receipt of the bitstream by the decoder in operation 702. The bitstream may be received by reading data from a processor-readable memory or receiving the data from a remote source over a data connection. Operation 702 also indicates initialization of the thresholds T, . The initialized thresholds may be specified in the bitstream or may be default values. In some cases, if the thresholds are default values then they may be overridden or modified by threshold data specified in the bitstream. </p><p id="p0152" num="0152"> [00116] In operation 704, the decoder entropy decodes a portion of the bitstream to obtain indices u, i.e. the quantized TCOEFFs, for a group of coding units (a frame, or slice, etc.). The decoder counts the number of each of the indices obtained in operation 704, i.e. the number of data points N, in each sub-part. The decoder may then determine in operation 706 whether the number of data points N,- for each index/sub-part exceeds its respective threshold Γ, </p><p id="p0153" num="0153"> [00117] In operation 708, the decoder extracts the average offset value d from the bitstream and, based upon the determination made in operation 706, any explicit offset values that are expected to be in the bitstream because N, &gt;7j for that index i. </p><p id="p0154" num="0154">[00118] The decoder then, in operation 710, reconstructs the data points, i.e. </p><p id="p0155" num="0155">dequantizes the indices u, using adaptive reconstruction levels, where the adaptive reconstruction levels are based upon the predefined reconstruction levels adjusted using offset data obtained in operation 708. For any indices for which an explicit offset was extracted, the adaptive reconstruction level is determined using that explicit offset. For any other indices, the adaptive reconstruction level is determined using the average offset value d . </p><p id="p0156" num="0156"> [00119] The decoder may repeat operations 704 to 710 provided the bitstream has additional encoded data for a next group of coding units, as indicated by operation 712. </p><p id="p0157" num="0157"> [00120] It will be appreciated that the dequantized data resulting from operation 710 is then processed by the decoder in the remainder of the decoding process. For example, the dequantized data is inverse transformed to produce reconstructed residual data, which may 
<!-- EPO <DP n="28"/>-->
 then be subjected to motion or spatial compensation processes to generate reconstructed video data. </p><p id="p0158" num="0158"> [00121] Observations have shown that the adaptive reconstruction level statistics are related to the quantization parameter (qP) and to the data type. In general, four data types may be identified: InterY, TnterUV, TntraY, and IntraUV. The InterY data type refers to Luma residue values from an Inter prediction process. InterUV data type refers to Chroma residue values from an Inter prediction process. Similarly, IntraY data type refers to Luma residue data from an Intra prediction process, and IntraUV data type refers to Chroma residue values from an Intra prediction process. </p><p id="p0159" num="0159">[00122] In view of these observations, offset data for adaptively adjusting </p><p id="p0160" num="0160">reconstruction levels may be specific to a data type and to a portion of the data using a give qP value. For example, in HEVC development it is expected that each frame or slice may have a specific qP value. In some embodiments, a qP value may be specified for a group-of- pictures (GOP). In yet other embodiments, the qP value may be specified for another grouping of blocks of data. Each portion of data, e.g. frame or slice, may have offset values for one or more data types for each reconstruction level being adjusted. </p><p id="p0161" num="0161"> [00123] It has also been observed that, although there are a large number of reconstruction levels covering a wide range (in HEVC the levels are specified using 12 bits), the vast majority of data points falls within the first few levels. Accordingly, it is these first few levels that occur most frequently and that are worth adaptively adjusting to reflect empirical statistics of the data. In some embodiments, a parameter may be specified, such as ARL_range, to signal to the decoder how many of the reconstruction levels are to be adapted; i.e. , how many levels have associated offset data in the bitstream. In another embodiment, the number of level may be preconfigured or preset for a particular encoder/decoder; for example, through signaling the ARL_range parameter in a header to the video data, or elsewhere in the bitstream. </p><p id="p0162" num="0162"> [00124] Referring now to Figure 13, an example process 800 for decoding encoded data using adaptive reconstruction levels will be described. The process 800 may be implemented by a decoder. The decoder may, in some implementations, include a decoding application executing on a computing device, such as a video playback machine, a personal computer, a television, a mobile device, a tablet, or any other digital processing device. 
<!-- EPO <DP n="29"/>-->
 [00125] The process 800 begins in operation 802 with determining that adaptive reconstruction levels are to be used. As noted above, in some instances adaptive </p><p id="p0163" num="0163">reconstruction levels may be specific to a frame or slice, if each frame or slice has its own qP specified. Accordingly, operation 802 may include checking a flag or other indicator in the frame or slice header to determine whether adaptive reconstruction levels are enabled for this particular frame or slice. </p><p id="p0164" num="0164"> [00126] In operation 804, the decoder determines which data types have associated adaptive reconstruction level data. Not every data type will necessarily have offset data in the bitstream. For example, in some instances the encoder may use adaptive reconstruction levels for the Inter Luma residuals for the first four reconstruction levels, but may only use adaptive reconstruction levels for the Inter Chroma residuals for the first two reconstruction levels. Operation 804 may include extracting flags, indicators, or other data from the bitstream that indicates to the decoder for which data types there is offset data in the bitstream for certain levels. Operation 804 may also include determining how many levels have offset data and, if there is offset data for a level, for which data types. In some cases, the levels and data types may be preset or preconfigured; however, in other cases, the levels and/or the data types involved may be signaled in the bitstream. </p><p id="p0165" num="0165"> [00127] Tn operation 806, the decoder extracts offset data from the bitstream. Based on operation 804, it knows whether there is offset data for particular levels and/or data types. Accordingly, it extracts this data in operation 806. Tn some embodiments, the offset data is absolute offset data. In some cases, it is differential offset data, meaning it is an offset relative to a most recent offset for the same index/data type. In some implementations, the offset data in the bitstream may be an index to an ordered array of offset values, i.e. a pointer to one of the offset values in the array. In one example, the offset values may range from— N to +N, wherein N is a maximum offset value. </p><p id="p0166" num="0166"> [00128] Having extracted the offset data, and in some case having determined the offset value from the offset data, the decoder then, in operation 808, calculates the adaptive reconstruction levels for each level and data type involved. In particular, the decoder adjusts a predetermined reconstruction level for that level (index) and data type using the offset data for that level and data type extracted in operation 806. The predetermined reconstruction level may be the unadjusted reconstruction level in some implementations. The 
<!-- EPO <DP n="30"/>-->
 predetermined reconstruction level may be the most-recently used (i.e. previously adjusted) adaptive reconstruction level. </p><p id="p0167" num="0167"> [00129] The predetermined reconstruction level may be adjusted by adding the extracted offset value to a previously used and stored offset value (in the case of differential offsets). The updated offset value may then be used to adjust the original unadjusted reconstruction level to arrive at the adaptive reconstruction level. </p><p id="p0168" num="0168"> [00130] Once the adaptive reconstruction levels have been determined for the various levels and data types, then in operation 810 the decoder entropy decodes the encoded data in the bitstream to obtain indices (quantized transform domain coefficients). </p><p id="p0169" num="0169">[00131] In operation 812, the decoder reconstructs data points by dequantizing the quantized transform domain coefficients. In the case of those coefficients (indices) that have an associated adaptive reconstruction level, the adaptive reconstruction level is used to reconstruct the data point. For example, the data point for an adaptive reconstruction level may be reconstructed by multiplying the adaptive reconstruction level by the quantization step size specified by the q. In some instances, the multiplication may further include scaling, such as is seen in H.264/AVC or HEVC. In some instances this scaling may be part of the inverse transfonn process, such that the resulting data point is a scaled inverse-transformed dequantized residual value. </p><p id="p0170" num="0170"> [00132] This example process 800 is further illustrated by the following syntax example. </p><p id="p0171" num="0171"> [00133] The slice header syntax may specify a syntax function: arl_param() for implementing adaptive reconstruction levels. An example of this syntax function may be given by: </p><p id="p0172" num="0172"> arl_param() { Descriptor arl_slice_flag </p><p id="p0173" num="0173"> If(arl_slice_flag) </p><p id="p0174" num="0174"> { </p><p id="p0175" num="0175"> arl_interY_flag u(l) if (arl_interY_flag) </p><p id="p0176" num="0176"> { </p><p id="p0177" num="0177"> read_arl_data(ARL_TYPE_INTERY) </p><p id="p0178" num="0178"> arl_interUV_flag u(l ) if (arl_interUV_flag) 
<!-- EPO <DP n="31"/>-->
 { </p><p id="p0179" num="0179"> read_arl _data(ARL_TYPE_INTERUV) </p><p id="p0180" num="0180"> } u(lj</p><p id="p0181" num="0181">} </p><p id="p0182" num="0182"> arl_intraY_flag u(l) if(arl_intraY_flag) </p><p id="p0183" num="0183"> { </p><p id="p0184" num="0184"> rcad_arl_data ( ARL_T YPE_INTR A Y) ; </p><p id="p0185" num="0185"> arl_intraUV_flag u( l ) if(arl_intraUV_flag) </p><p id="p0186" num="0186"> I </p><p id="p0187" num="0187"> read_arl_data (ARL_TYPE_INTRAUV) </p><p id="p0188" num="0188"> } </p><p id="p0189" num="0189"> } </p><p id="p0190" num="0190"> } </p><p id="p0191" num="0191"> } read_arl_data (arl_data_type_id) { </p><p id="p0192" num="0192"> arl_delta_id [ slice_qp] [ arl_data_type_id] [ 1 ] vlc(v) for(i=2; i&lt;=4;i++){ </p><p id="p0193" num="0193"> arl_delta_i_available u( l ) if (arl_delta_i_available = = 1) { </p><p id="p0194" num="0194"> arl_delta_idx[slice_qp] [ arl_data_type_id] [i] vlc(v)</p><p id="p0195" num="0195">} </p><p id="p0196" num="0196"> else </p><p id="p0197" num="0197"> break </p><p id="p0198" num="0198"> } </p><p id="p0199" num="0199"> } </p><p id="p0200" num="0200">[00134] It will be noted that in this example, it is predetermined that adaptive reconstruction levels are specified for the first level and, possibly, for the second through fourth levels, as indicated by the arl_delta_i_available flag in each case. Note that the value of 4 is an exemplary choice for the parameter of level range, which may take other values. The association between arl_data_type_id and the data type names may, in one example, be: </p><p id="p0201" num="0201"> arl_data_type_id Data type </p><p id="p0202" num="0202">0 ARL_TYPE_INTRAY </p><p id="p0203" num="0203"> 1 ARL_TYPE_INRAUV </p><p id="p0204" num="0204"> 2 ARL_TYPE_INTERY </p><p id="p0205" num="0205"> 3 ARL_TYPE_INTERUV 
<!-- EPO <DP n="32"/>-->
 [00135] It will be appreciated that other mechanisms for signaling ARL parameters may be used. Indeed, in some cases, the ARL data may be provided as slice training bits and the statistics of the current slice may be used to determine which levels or data types have ARL data present. For example, a number of non-zero coefficients algorithm may be used, such as is described above. </p><p id="p0206" num="0206"> [00136] The syntax element arl_delta_idx[qP] [DataType] [i] specifies the offset for index i for data type DataType with quantization parameter qP. The parameter </p><p id="p0207" num="0207">arl_delta_idx[qP] [DataType] [i] may be a pointer to an offset value in an array. The parameter may be converted to the offset value as follows: </p><p id="p0208" num="0208"> ARLoff setd[qP] [DataType] [i] = Idx2Delta [ arl_delta_idx[] [DataType] [i] ] </p><p id="p0209" num="0209"> [00137] where the array, Idx2Delta is defined, in one example, as: </p><p id="p0210" num="0210"> int Idx2Delta[16] = {-15, -13, -11, -9, -7, -5, -3, 0, 1, 3, 5, 7, 9, 11, 13, 15 }; </p><p id="p0211" num="0211"> [00138] The ARLoffsetd, which is a differential offset, is then used to update </p><p id="p0212" num="0212"> ARLoffset, the most-recently-used offset value for the same index, qP and DataType to produce an updated offset value: </p><p id="p0213" num="0213"> ARLoffset[qP] [DataType] [i] += ARLoff setd[qP] [DataType] [ι] , l
<img id="imgf000032_0001" he="4" wi="14" file="imgf000032_0001.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="no"/>
 </p><p id="p0214" num="0214"> ARLoffsetfqP] [DataType] [i] += ARLoff setd[qP] [DataType] [4] , i&gt;4; </p><p id="p0215" num="0215"> [00139] It will be appreciated from the foregoing formulas that, in this example implementation, ARLoffsets are individually calculated for each of the first four levels, and the level 4 offset is applied to all levels above four. The updated ARLoffset is then applied to find the reconstruction level for each index: </p><p id="p0216" num="0216"> ARL[qP] [DataType] [i] = ARLoff set[qP] [DataType] [i] + (i«7), i&gt;0 ; </p><p id="p0217" num="0217"> [00140] It will be noted that the index value is left shifted by 7 bits, i.e. multiplied by</p><p id="p0218" num="0218">128. The value of 7 is an exemplary choice for setting the computation precision and other values may be used. The ARL is later descaled by 128, with the net effect being that the offset value is divided by 128. With a range of -15 to +15, this ensures that the differential change in the offset varies from slice-to-slice by no more than + 1 /1 28 or about 12%. </p><p id="p0219" num="0219"> [00141] The ARL value is then used in the dequantization operation. For example, the dequantization operation in one example may be expressed as: 
<!-- EPO <DP n="33"/>-->
 di<sub>j</sub> = sgn icy) * ( ARL[qP][DataType][ abs(<sub>Cij</sub> )] * </p><p id="p0220" num="0220"> LevelScale<sub>(</sub>„<sub>SWnS)</sub>[ qP'¾6 ][ i ][ j ] ) « ( qP/6 + trafoPrecisionExt - 7), with i, j = 0..nS-l (6) </p><p id="p0221" num="0221">[00142] The resulting data point dy is calculated based upon the decoded quantized transform domain coefficient C (sometimes also referred to as an "index") multiplied by the updated ARL value and a scaling factor that reflects a non-integer portion of the inverse transformation operation. The dequantization operation reflected in the above Equation (6) further includes a bitshift operation that incorporates both the descaling by 128 (the -7 component), and the dequantization. </p><p id="p0222" num="0222">[00143] It will be understood that the foregoing pseudo-code, expressions and equations provided one example implementation of the present decoding process. The present application is not limited to this particular example implementation. </p><p id="p0223" num="0223"> [00144] Through experimental simulations, it has been found that using offset-based adaptive reconstruction levels with hard-decision quantization, under the low-complexity low- delay setting of HEVC codec, outperforms the anchor codec with SDQ by 1 % in terms of rate-distortion performance and realizes a computational complexity savings of 10% due to removal of the SDQ procedure. It may be noted that encoding complexity has become a bottleneck in the development of HEVC. The processes and methods described herein provide a desirable quantization design with a good trade-off between rate distortion coding performance and computational complexity. </p><p id="p0224" num="0224"> [00145] Reference is now made to Figure 11, which shows a simplified block diagram of an example embodiment of an encoder 900. The encoder 900 includes a processor 902, memory 904, and an encoding application 906. The encoding application 906 may include a computer program or application stored in memory 904 and containing instructions for configuring the processor 902 to perform steps or operations such as those described herein. For example, the encoding application 906 may encode and output bitstreams encoded in accordance with the adaptive reconstruction level process described herein. The input data points may relate to audio, images, video, or other data that may be subject of a lossy data compression scheme. The encoding application 906 may include a quantization module 908 configured to determine an adaptive reconstruction level for each index of a partition structure. The encoding application 906 may include an entropy encoder 26 configured to 
<!-- EPO <DP n="34"/>-->
 entropy encode the adaptive reconstruction levels q<sub>u</sub> or offset data, and other data. It will be understood that the encoding application 906 may be stored in on a computer readable medium, such as a compact disc, flash memory device, random access memory, hard drive, etc. </p><p id="p0225" num="0225">[00146] Reference is now also made to Figure 12, which shows a simplified block diagram of an example embodiment of a decoder 1000. The decoder 1000 includes a processor 1002, a memory 1004, and a decoding application 1006. The decoding application 1006 may include a computer program or application stored in memory 1004 and containing instructions for configuring the processor 1002 to perform steps or operations such as those described herein. The decoding application 1006 may include an entropy decoder 1008 and a de-quantization module 1010 configured to obtain offset data or adaptive reconstruction levels q<sub>u</sub> and use that obtained data to reconstruct transform domain coefficients or other such data points. It will be understood that the decoding application 1006 may be stored in on a computer readable medium, such as a compact disc, flash memory device, random access memory, hard drive, etc. </p><p id="p0226" num="0226"> [00147] It will be appreciated that the decoder and/or encoder according to the present application may be implemented in a number of computing devices, including, without limitation, servers, suitably programmed general purpose computers, audio/video encoding and playback devices, set-top television boxes, television broadcast equipment, and mobile devices. The decoder or encoder may be implemented by way of software containing instructions for configuring a processor to carry out the functions described herein. The software instructions may be stored on any suitable computer-readable memory, including CDs, RAM, ROM, Flash memory, etc. </p><p id="p0227" num="0227"> [00148] It will be understood that the encoder described herein and the module, routine, process, thread, or other software component implementing the described method/process for configuring the encoder may be realized using standard computer programming techniques and languages. The present application is not limited to particular processors, computer languages, computer programming conventions, data structures, other such implementation details. Those skilled in the art will recognize that the described processes may be implemented as a part of computer-executable code stored in volatile or non-volatile memory, as part of an application-specific integrated chip (ASIC), etc. 
<!-- EPO <DP n="35"/>-->
 [00149] Certain adaptations and modifications of the described embodiments can be made. Therefore, the above discussed embodiments are considered to be illustrative and not restrictive. 
</p></description><claims mxw-id="PCLM44727733" ref-ucid="WO-2012113055-A1" lang="EN" load-source="patent-office"><claim id="clm-0001" num="0001"><!-- EPO <DP n="36"/>--><claim-text/><claim-text>WHAT IS CLAIMED IS </claim-text><claim-text>1. A method of decoding a bitstream of compressed data, the method comprising: </claim-text><claim-text> extracting offset data from the bitstream, wherein the offset data is associated with an index; </claim-text><claim-text> calculating a reconstruction level for the index by adjusting a predetermined </claim-text><claim-text> reconstruction level using the offset data; </claim-text><claim-text> decoding the compressed data to obtain a plurality of quantized transform coefficients; and </claim-text><claim-text> dequantizing each quantized transform coefficient that corresponds to the index to generate a data point using the index' s calculated reconstruction level. </claim-text><claim-text>2. The method claimed in claim 1 , wherein the predetermined reconstruction level comprises a previously-adjusted reconstruction level for the index. </claim-text><claim-text>3. The method claimed in claim 1 or claim 2, wherein the offset data comprises a pointer to an offset value in an array of offset values, and wherein calculating comprises adding the offset value to the index to generate the calculated reconstruction level. </claim-text><claim-text> 4. The method claimed in claim 1 or claim 2, wherein the offset data comprises a pointer to an offset value in an array of offset values, and wherein calculating comprises adding the offset value to a previously-used offset for the index to generate an updated offset, and adding the updated offset to an unadjusted reconstruction level for the index. </claim-text><claim-text> 5. The method claimed in claim 1 or claim 2, wherein calculating comprises converting the offset data to an offset value, and adding the offset value to the index scaled by a shift factor, and wherein dequantizing includes downscaling by the shift factor. </claim-text><claim-text>6. The method claimed in any one of claims 1 to 5, wherein extracting includes extracting data type flags from the bitstream that indicate whether offset data is contained in the bitstream for particular data types. </claim-text><claim-text> 7. The method claimed in claim 6, wherein the particular data types include Inter Luma data, 
<!-- EPO <DP n="37"/>-->
 Inter Chroma data, Intra Luma data, and Intra Chroma data. </claim-text><claim-text> 8. The method claimed in any one of claims 1 to 7, wherein dequantizing comprises </claim-text><claim-text> multiplying the calculated reconstruction level by a scaled quantization factor to generate the data point. </claim-text><claim-text> 9. The method claimed in any one of claims 1 to 8, wherein dequantizing further includes reconstructing residues, which includes inverse transforming, and wherein the data point comprises a reconstructed scaled inverse-transformed dequantized residual. </claim-text><claim-text> 10. The method claimed in any one of claims 1 to 9, wherein the plurality of quantized </claim-text><claim-text> transform coefficients corresponds to a coding unit. </claim-text><claim-text> 1 1. A decoder for decoding a bitstream of compressed data, the decoder comprising: </claim-text><claim-text> a processor; </claim-text><claim-text> a memory; and </claim-text><claim-text> a decoding application stored in memory and containing instructions for configuring the processor to decode the compressed data using the method claimed in any one of claims 1 to 10. </claim-text><claim-text> 12. A processor-readable medium storing processor-executable instructions which, when executed, configures one or more processors to perform the method claimed in any one of claims 1 to 10. </claim-text><claim-text> 13. A method for encoding transform domain coefficients for a group of coding units, wherein the transform domain coefficients are quantized by a quantizer that associates each transform domain coefficient with an index based upon in which sub-part of a partitioned data space that transform domain coefficient is located, the method comprising: </claim-text><claim-text> determining the average transform domain coefficient at least one of the sub-parts; calculating an offset for that sub-part by determining a difference between the average transform domain coefficient for that sub-part and a predetermined reconstruction level for that sub-part; and </claim-text><claim-text> entropy encoding the indices associated with the transform domain coefficients to output a bitstream of compressed data and inserting into the bitstream offset data 
<!-- EPO <DP n="38"/>-->
 from which the offset for that sub-part can be calculated. </claim-text><claim-text> 14. The method claimed in claim 13, wherein the determining, calculated and entropy </claim-text><claim-text> encoding are applied on a slice-by-slice basis. </claim-text><claim-text> 1 . The method claimed in claim 14, wherein the determining, calculating and entropy </claim-text><claim-text> encoding are further applied on a data-type basis, and wherein inserting includes inserting flags indicating the data types for which offset data is inserted in the bitstream. </claim-text><claim-text> 16. The method claimed in claim 15, wherein the data types include Inter Luma data, Inter Chroma data, Intra Luma data, and Intra Chroma data. </claim-text><claim-text> 17. The method claimed in any one of claims 13 to 16, wherein the offset data comprises differential offset data specifying the difference between the calculated offset and a previously-used offset for that sub-part. </claim-text><claim-text> 18. The method claimed in any one of claims 13 to 17, wherein the offset data comprises a pointer to a value in a predetermined array of offset values. </claim-text><claim-text> 19. An encoder for encoding transform domain coefficients for a group of coding units, the encoder comprising: </claim-text><claim-text> a processor; </claim-text><claim-text> a memory storing the data points; and </claim-text><claim-text> an encoding application stored in memory and containing instructions for configuring the processor to encode the transform domain coefficients using the method claimed in any one of claims 13 to 19. </claim-text><claim-text> 20. A processor-readable medium storing processor-executable instructions which, when executed, configures one or more processors to perform the method claimed in any one of claims 13 to 19. 
</claim-text></claim></claims><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
