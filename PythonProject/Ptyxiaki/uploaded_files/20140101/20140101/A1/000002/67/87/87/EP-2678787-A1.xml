<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2678787-A1" country="EP" doc-number="2678787" kind="A1" date="20140101" family-id="46719704" file-reference-id="305897" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146551282" ucid="EP-2678787-A1"><document-id><country>EP</country><doc-number>2678787</doc-number><kind>A1</kind><date>20140101</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-12749564-A" is-representative="NO"><document-id mxw-id="PAPP154825205" load-source="docdb" format="epo"><country>EP</country><doc-number>12749564</doc-number><kind>A</kind><date>20120222</date><lang>EN</lang></document-id><document-id mxw-id="PAPP179672002" load-source="docdb" format="original"><country>EP</country><doc-number>12749564.6</doc-number><date>20120222</date></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140453053" ucid="US-201113077417-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201113077417</doc-number><kind>A</kind><date>20110331</date></document-id></priority-claim><priority-claim mxw-id="PPC140450096" ucid="US-201113077479-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201113077479</doc-number><kind>A</kind><date>20110331</date></document-id></priority-claim><priority-claim mxw-id="PPC140449055" ucid="US-201161446364-P" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201161446364</doc-number><kind>P</kind><date>20110224</date></document-id></priority-claim><priority-claim mxw-id="PPC140451035" ucid="US-2012026152-W" linkage-type="W" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>2012026152</doc-number><kind>W</kind><date>20120222</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL2104295547" load-source="docdb">H03M   7/46        20060101ALI20140725BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL2104297032" load-source="docdb">H03M   7/40        20060101ALI20140725BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL2104297612" load-source="docdb">G06F  17/30        20060101AFI20140725BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-2036691877" load-source="docdb" scheme="CPC">G06F  17/30168     20130101 FI20150722BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2036694174" load-source="docdb" scheme="CPC">H03M   7/46        20130101 LI20150722BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2036699549" load-source="docdb" scheme="CPC">H03M   7/40        20130101 LI20150722BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2036700856" load-source="docdb" scheme="CPC">G06F  17/3023      20130101 LI20150722BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2036700905" load-source="docdb" scheme="CPC">G06F  17/30221     20130101 LI20150722BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132186330" lang="DE" load-source="patent-office">VERBESSERTE KODIERUNG UND DEKODIERUNG VON DATEN VARIABLER LÄNGE MIT GRUPPENFORMATEN</invention-title><invention-title mxw-id="PT132186331" lang="EN" load-source="patent-office">IMPROVED ENCODING AND DECODING OF VARIABLE-LENGTH DATA WITH GROUP FORMATS</invention-title><invention-title mxw-id="PT132186332" lang="FR" load-source="patent-office">CODAGE ET DÉCODAGE AMÉLIORÉS DE DONNÉES DE LONGUEUR VARIABLE EN FORMATS DE GROUPES</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR918150205" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>A9 COM INC</last-name><address><country>US</country></address></addressbook></applicant><applicant mxw-id="PPAR918149064" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>A9.COM, INC.</last-name></addressbook></applicant><applicant mxw-id="PPAR918993303" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>A9.COM, INC.</last-name><iid>100803248</iid><address><street>130 Lytton Avenue, Suite 300</street><city>Palo Alto, CA 94301-1044</city><country>US</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR918143401" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>ROSE DANIEL E</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918142241" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>ROSE, DANIEL, E.</last-name></addressbook></inventor><inventor mxw-id="PPAR918979750" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>ROSE, DANIEL, E.</last-name><address><street>410 Terry Ave North</street><city>Seattle, WA 48109</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918143927" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>STEPANOV ALEXANDER A</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918168005" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>STEPANOV, Alexander, A.</last-name></addressbook></inventor><inventor mxw-id="PPAR918987005" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>STEPANOV, Alexander, A.</last-name><address><street>410 Terry Ave North</street><city>Seattle, WA 48109</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918170502" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>GANGOLLI ANIL RAMESH</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918163441" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>GANGOLLI, Anil, Ramesh</last-name></addressbook></inventor><inventor mxw-id="PPAR918983995" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>GANGOLLI, Anil, Ramesh</last-name><address><street>410 Terry Ave North</street><city>Seattle, WA 48109</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918161706" load-source="docdb" sequence="4" format="epo"><addressbook><last-name>OBEROI PARAMJIT S</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918137901" load-source="docdb" sequence="4" format="intermediate"><addressbook><last-name>OBEROI, Paramjit, S.</last-name></addressbook></inventor><inventor mxw-id="PPAR918980214" load-source="patent-office" sequence="4" format="original"><addressbook><last-name>OBEROI, Paramjit, S.</last-name><address><street>410 Terry Ave North</street><city>Seattle, WA 48109</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918150175" load-source="docdb" sequence="5" format="epo"><addressbook><last-name>ERNST RYAN JACOB</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918148273" load-source="docdb" sequence="5" format="intermediate"><addressbook><last-name>ERNST, Ryan, Jacob</last-name></addressbook></inventor><inventor mxw-id="PPAR918991613" load-source="patent-office" sequence="5" format="original"><addressbook><last-name>ERNST, Ryan, Jacob</last-name><address><street>410 Terry Ave North</street><city>Seattle, WA 48109</city><country>US</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR918978773" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Leeming, John Gerard</last-name><iid>101302739</iid><address><street>J A Kemp &amp; Co 14 South Square Gray's Inn</street><city>London Greater London WC1R 5JJ</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="US-2012026152-W"><document-id><country>US</country><doc-number>2012026152</doc-number><kind>W</kind><date>20120222</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2012116086-A1"><document-id><country>WO</country><doc-number>2012116086</doc-number><kind>A1</kind><date>20120830</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS548927090" load-source="docdb">AL</country><country mxw-id="DS548816116" load-source="docdb">AT</country><country mxw-id="DS548927091" load-source="docdb">BE</country><country mxw-id="DS548837142" load-source="docdb">BG</country><country mxw-id="DS548930727" load-source="docdb">CH</country><country mxw-id="DS548934757" load-source="docdb">CY</country><country mxw-id="DS548816117" load-source="docdb">CZ</country><country mxw-id="DS548927092" load-source="docdb">DE</country><country mxw-id="DS548934758" load-source="docdb">DK</country><country mxw-id="DS548934759" load-source="docdb">EE</country><country mxw-id="DS548865695" load-source="docdb">ES</country><country mxw-id="DS548837143" load-source="docdb">FI</country><country mxw-id="DS548930728" load-source="docdb">FR</country><country mxw-id="DS548927093" load-source="docdb">GB</country><country mxw-id="DS548934760" load-source="docdb">GR</country><country mxw-id="DS548927098" load-source="docdb">HR</country><country mxw-id="DS548816118" load-source="docdb">HU</country><country mxw-id="DS548865696" load-source="docdb">IE</country><country mxw-id="DS548934761" load-source="docdb">IS</country><country mxw-id="DS548930729" load-source="docdb">IT</country><country mxw-id="DS548934762" load-source="docdb">LI</country><country mxw-id="DS548837144" load-source="docdb">LT</country><country mxw-id="DS548914089" load-source="docdb">LU</country><country mxw-id="DS548837145" load-source="docdb">LV</country><country mxw-id="DS548837150" load-source="docdb">MC</country><country mxw-id="DS548914158" load-source="docdb">MK</country><country mxw-id="DS548914159" load-source="docdb">MT</country><country mxw-id="DS548837151" load-source="docdb">NL</country><country mxw-id="DS548930730" load-source="docdb">NO</country><country mxw-id="DS548837152" load-source="docdb">PL</country><country mxw-id="DS548865697" load-source="docdb">PT</country><country mxw-id="DS548927099" load-source="docdb">RO</country><country mxw-id="DS548865698" load-source="docdb">RS</country><country mxw-id="DS548837153" load-source="docdb">SE</country><country mxw-id="DS548929435" load-source="docdb">SI</country><country mxw-id="DS548930731" load-source="docdb">SK</country><country mxw-id="DS548930732" load-source="docdb">SM</country><country mxw-id="DS548934763" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><abstract mxw-id="PA99618862" ref-ucid="WO-2012116086-A1" lang="EN" load-source="patent-office"><p num="0000">Embodiments provide methods and systems for encoding and decoding variable-length data, which may include methods for encoding and decoding search engine posting lists. Embodiments may include different encoding formats including group unary, packed unary, and/or packed binary formats. Some embodiments may utilize single instruction multiple data (SIMD) instructions that may perform a parallel shuffle operation on encoded data as part of the decoding processes. Some embodiments may utilize lookup tables to determine shuffle sequences and/or masks and/or shifts to be utilized in the decoding processes. Some embodiments may utilize hybrid formats.</p></abstract><abstract mxw-id="PA99818547" ref-ucid="WO-2012116086-A1" lang="EN" source="national office" load-source="docdb"><p>Embodiments provide methods and systems for encoding and decoding variable-length data, which may include methods for encoding and decoding search engine posting lists. Embodiments may include different encoding formats including group unary, packed unary, and/or packed binary formats. Some embodiments may utilize single instruction multiple data (SIMD) instructions that may perform a parallel shuffle operation on encoded data as part of the decoding processes. Some embodiments may utilize lookup tables to determine shuffle sequences and/or masks and/or shifts to be utilized in the decoding processes. Some embodiments may utilize hybrid formats.</p></abstract><abstract mxw-id="PA99618863" ref-ucid="WO-2012116086-A1" lang="FR" load-source="patent-office"><p num="0000">Des modes de réalisation concernent des procédés et des systèmes de codage et de décodage de données de longueur variable, notamment des procédés de codage et de décodage de listes de correspondances de moteur de recherche. Des modes de réalisation peuvent comporter différents formats de codage, parmi lesquels des formats unaires en groupes, des formats unaires compressés et/ou des formats binaires compressés. Certains modes de réalisation peuvent utiliser des instructions SIMD (instruction unique à données multiples) susceptibles d'exécuter une opération de réorganisation parallèle sur des données codées en tant que partie des processus de décodage. Certains modes de réalisation peuvent utiliser des tables de correspondances pour déterminer des séquences et/ou des masques et/ou des décalages de réorganisation devant être utilisés au cours des processus de décodage. Certains modes de réalisation peuvent utiliser des formats hybrides.</p></abstract><abstract mxw-id="PA99818548" ref-ucid="WO-2012116086-A1" lang="FR" source="national office" load-source="docdb"><p>Des modes de réalisation concernent des procédés et des systèmes de codage et de décodage de données de longueur variable, notamment des procédés de codage et de décodage de listes de correspondances de moteur de recherche. Des modes de réalisation peuvent comporter différents formats de codage, parmi lesquels des formats unaires en groupes, des formats unaires compressés et/ou des formats binaires compressés. Certains modes de réalisation peuvent utiliser des instructions SIMD (instruction unique à données multiples) susceptibles d'exécuter une opération de réorganisation parallèle sur des données codées en tant que partie des processus de décodage. Certains modes de réalisation peuvent utiliser des tables de correspondances pour déterminer des séquences et/ou des masques et/ou des décalages de réorganisation devant être utilisés au cours des processus de décodage. Certains modes de réalisation peuvent utiliser des formats hybrides.</p></abstract><description mxw-id="PDES50929977" ref-ucid="WO-2012116086-A1" lang="EN" load-source="patent-office"><!-- EPO <DP n="2"/>--><p id="p0001" num="0001"> IMPROVED ENCODING AND DECODING OF VARIABLE-LENGTH </p><p id="p0002" num="0002"> DATA WITH GROUP FORMATS </p><p id="p0003" num="0003">BACKGROUND </p><p id="p0004" num="0004"> [0001] A typical search engine indexing algorithm utilizes an inverted index data structure. This is conceptually similar to the index in the back of a book; it is an index data structure mapping content, such as a list of words, to its location in a document (or set of documents). In the context of a search engine, the documents are commonly web pages, e-mail messages, and the like. The occurrence of a word in a document may be called a posting, and the list of all documents containing a word may be called a posting list. Just as a book index entry lists page numbers, a posting list may contain document identification numbers (docIDs). When a search engine receives a query, it can look up the posting list for each word in the query and combines the results. In order to combine the results efficiently, the postings may be stored in order of their docIDs. </p><p id="p0005" num="0005">[0002] It may be desirable to store posting lists in as little space as possible. By using the differences between adjacent docIDs rather than the docIDs themselves, the postings can contain smaller numbers. There are numerous other examples, from general databases to the MIDI specification, where data might be coded more compactly and then decoded at a later point, where often the decoding happens repeatedly based on when the data may be needed. There are a variety of techniques developed for storing data in less space. However, the methods may have deficiencies including speed limitations or storage efficiency limitations. </p><p id="p0006" num="0006">BRIEF DESCRIPTION OF THE DRAWINGS </p><p id="p0007" num="0007">[0003] Various embodiments in accordance with the present disclosure will be described with reference to the drawings, in which: </p><p id="p0008" num="0008">1 004 J FIG. 1 illustrates an environment in which various embodiments can be implemented; </p><p id="p0009" num="0009">[0005] FIG. 2A illustrates a split unary encoding format that can be used in accordance with some embodiments; 
<!-- EPO <DP n="3"/>-->
 [0006] FIG. 2B illustrates an example of data encoded with a split unary encoding format in accordance with some embodiments; </p><p id="p0010" num="0010">[0007] FIG. 3A illustrates a packed unary encoding format that can be used in accordance with some embodiments; </p><p id="p0011" num="0011">[0008] FIG. 3B illustrates an example of data encoded with a packed unary encoding format in accordance with some embodiments; </p><p id="p0012" num="0012">[0009] FIG. 4A illustrates a packed binary encoding format that can be used in accordance with some embodiments; </p><p id="p0013" num="0013">[0010] FIG. 4B illustrates an example of data encoded with a packed binary encoded format in accordance with some embodiments; </p><p id="p0014" num="0014">[0011] FIG. 5A illustrates a group binary encoding format that can be used in accordance with some embodiments; </p><p id="p0015" num="0015">[0012] FIG. 5B illustrates an example of data encoded with a group binary encoding format in accordance with some embodiments; </p><p id="p0016" num="0016">[0013] FIG. 6 A illustrates a group unary encoding format that can be used in accordance with some embodiments; </p><p id="p0017" num="0017">[0014] FIG. 6B illustrates example of data encoded with a group unary encoding format in accordance with some embodiments; </p><p id="p0018" num="0018">[0015] FIG. 6C illustrates a group unary encoding format that can be used in accordance with some embodiments; </p><p id="p0019" num="0019">[0016] FIG. 7 A illustrates a group unary encoding format that can be used in accordance with some embodiments; </p><p id="p0020" num="0020">[0017] FIG. 7B illustrates an example of data encoded with a group unary encoding format in accordance with some embodiments; </p><p id="p0021" num="0021">[0018] FIG. 7C illustrates a group unary encoding format that can be used in accordance with some embodiments; 
<!-- EPO <DP n="4"/>-->
 [0019J FIG. 8 illustrates a method for encoding document identification numbers for a search engine posting list that can be used in accordance with some embodiments; </p><p id="p0022" num="0022">[0020] FIG. 9 illustrates a method for encoding variable-length data that can be used in accordance with some embodiments; </p><p id="p0023" num="0023">[0021] FIG. 10 illustrates a parallel shuffle operation that can be used in accordance with some embodiments; </p><p id="p0024" num="0024">[0022] FIG. 11 illustrates a parallel shuffle operation that can be used in accordance with some embodiments; </p><p id="p0025" num="0025">[0023] FIG. 12 illustrates a method of decoding that can be used in accordance with some embodiments; </p><p id="p0026" num="0026">[0024] FIG. 13 illustrates how to construct a shuffle sequence that can be used in accordance with some embodiments; </p><p id="p0027" num="0027">[0025] FIG. 14 illustrates a method for decoding encoded document identification numbers differences in a search engine posting list that can be used in accordance with some </p><p id="p0028" num="0028">embodiments; </p><p id="p0029" num="0029">[0026] FIG. 15 illustrates a method for decoding variable-length data that can be used in accordance with some embodiments; </p><p id="p0030" num="0030">[0027] FIG. 16 illustrates a hybrid unary sequence encoding format that can be used in accordance with some embodiments; </p><p id="p0031" num="0031">[0028] FIG. 17 illustrates an example of data encoded with a hybrid unary sequence encoding format in accordance with some embodiments; </p><p id="p0032" num="0032">[0029] FIG. 18 illustrates a hybrid encoding format with run of blocks with constant-length descriptor that can be used in accordance with some embodiments; </p><p id="p0033" num="0033">[0030] FIG. 19 illustrates an example of data encoded with a hybrid encoding format with run of blocks with constant-length d escriptor in accordance with some embodiments; 
<!-- EPO <DP n="5"/>-->
 [0031] FIG. 20 illustrates a hybrid encoding format with run with constant-length descriptor that can be used in accordance with some embodiments; </p><p id="p0034" num="0034">[0032] FIG. 21 illustrates an example of data encoded with a hybrid encoding format with run with constant-length descriptor in accordance with some embodiments; </p><p id="p0035" num="0035">[0033] FIG. 22 illustrates a hybrid encoding format with run with variable-length descriptor that can be used in accordance with some embodiments; and </p><p id="p0036" num="0036">[0034] FIG. 23 illustrates an example of data encoded with a hybrid encoding format with ran with variable-length descriptor in accordance with some embodiments. </p><p id="p0037" num="0037">DETAILED DESCRIPTION </p><p id="p0038" num="0038">[0035] Systems and methods in accordance with various embodiments of the present disclosure may overcome one or more of the aforementioned and other deficiencies experienced in conventional approaches to encoding and decoding data sets. In particular, various approaches provide for improved encoding and/or decoding of data sets including sequences of integers, such as those encountered with search engine posting lists, for example. </p><p id="p0039" num="0039">[0036] Methods, systems, and/or devices are provided for decoding encoded document identification number differences in a search engine posting list utilizing parallel shuffle operations in accordance with various embodiments. In one embodiment, decoding encoded document identification number differences includes reading one or more descriptors. Each descriptor includes size information regarding a group of encoded document identification number differences. In some embodiments, encoded document identification number differences are encoded with a group unary format. Multiple data representing the group of encoded document identification number differences arc read. The group of encoded document identification number differences is linked with the one or more descriptors. One or more shuffle sequences linked with the one or more descriptors from a lookup table are identified. One or more parallel shuffle operations are performed on the multiple data representing the group of encoded document identification number differences using the identified shuffle sequences. The one or more parallel shuffle operations include inserting one or more sequences 
<!-- EPO <DP n="6"/>-->
 of zeros into the multiple data. Multiple decoded document identification number differences from the shuffled multiple data representing the group of encoded document identification number differences are determined. </p><p id="p0040" num="0040">[0037] Methods, systems, and/or devices for decoding variable-length data are provided in accordance with various embodiments. In some embodiments, decoding variable-length data includes reading one or more blocks of data. Each block of data represents multiple encoded variable-length data. One or more descriptors linked with the one or more blocks of data are read. One or more shuffle sequences linked with the one or more descriptors are identified from a lookup table. One or more shuffle operations are performed on the one or more blocks of data using the one or more identified shuffle sequences. Multiple decoded variable-length data are determined from the shuffled one or more blocks of data. </p><p id="p0041" num="0041">[0038] In some embodiments, performing the one or more shuffle operations includes inserting one or more sequences of zeros into the shuffled one or more blocks of data to represent one or more portions of the one or more blocks of data in a standard format, such as a 32-bit representation of an integer. The one or more data blocks may represent multiple integers encoded in a variable-length representation. In some embodiments, the one or more data blocks may represent other data encoded in a variable-length representation. </p><p id="p0042" num="0042">[0039] Determining the multiple decoded variable-length data from the shuffled one or more blocks of data may also include determining a partial result from the shuffled one or more blocks of data. A remaining portion associated with the partial result may be determined from another block of data. Such embodiments may utilize complete block variations as discussed above. In some cases, the one or more shuffle operations may include one or more parallel shuffle instructions from a single instruction multiple data (SIMD) processor instruction set. </p><p id="p0043" num="0043">[0040] Some embodiments may include identifying one or more offsets linked with the one or more descriptors. The one or more offsets linked with the one or more descriptors may include an input offset with a fixed size; in some cases, the one ore more offsets linked with the one or more descriptors may include an output offset with a variable size. The fixed size may depend on a number of bytes included in one or more blocks of data and the one or more descriptors. The one or more offsets linked with the one or more descriptors may include an input offset with 
<!-- EPO <DP n="7"/>-->
 a variable size. The variable size may depend on a number of data represented by the block of data. Some embodiments may also include identifying output offsets. </p><p id="p0044" num="0044">[0041] The technology described herein includes several variable-length encoding formats and decoding methods and systems that may enable the use of very fast decoding methods. In some cases, the formats also may enable greater data compression. Although embodiments may be utilized for search engine posting lists, the technology described herein can be used in other situations where it may be beneficial to store a list of numbers or other data sets compactly and decode them efficiently, such as with databases. </p><p id="p0045" num="0045">[0042] Embodiments may provide numerous advantages including, but not limited to, avoiding branches that may interfere with the effectiveness of deep pipelines in some processors that use deep pipelines. Embodiments may read and write data more often than would be done in traditional variable length encoding and decoding, including reading data unaligned in some cases (instead of on object size boundaries), rather than deciding how much may need to be read. Some embodiments may utilize precomputing possible decoding options and storing that information in one or more tables. Some embodiments may operate on many bytes in parallel using single instruction multiple data (SIMD) instructions. Some embodiments may utilize a SIMD instruction such as a shuffle instruction like packed shuffle bytes (PSHUFB). Some embodiments may utilize descriptor bits and/or descriptor bytes the include length information regarding the data. </p><p id="p0046" num="0046">[0043] Methods for decoding a standard format more efficiently are provided. The format may be referred to as varint-SU: it includes a variable-length integer encoding (varint) with a split (S) unary (U) representation of the length of the encoded integer. The method may utilize parallel processing for decoding this format, with a variation that works even if the compressed bytes may not be stored in the natural machine order. Embodiments may operate on a group of bytes of encoded data at one time. In one embodiment, a block of 8 bytes is operated on at one time.</p><p id="p0047" num="0047">The method may include extracting or collecting descriptor bits, which may be continuation and termination bits, in parallel. In some embodiments, this extraction or collection process uses a packed move mask bytes (PMOVMSKB) instruction. The method may use the extracted bits as an offset into a table of precomputed shuffle sequences. A parallel permutation instruction, such as PSHUFB, may use the shuffle sequence to determine how to decode the data. A series of bit 
<!-- EPO <DP n="8"/>-->
 shift operations may be done to remove the original continuation and/or termination bits from the decoded data. </p><p id="p0048" num="0048">[0044] In some embodiments, encoding formats along with decoding methods are provided that involve a packed unary (PU) representation. This format may be referred to as varint-PU. In some instances, this may include moving the continuation and/or termination bits into a single descriptor that can be found in the first byte. This may allow the data bits to be stored contiguously in memory, which may make it possible to decode more efficiently. </p><p id="p0049" num="0049">[0045] In some embodiments, methods for decoding a group of encoded integers that are stored as a block are provided The format may include a group binary (GB) representation, which may be referred to as varint-GB in some embodiments. In some instances, this method may utilize a shuffle instruction, such as a PSHUFB instruction, to decode groups of data bytes in parallel. Shuffle sequences may be obtained from a table designated by the value of a descriptor byte. </p><p id="p0050" num="0050">[0046] In some embodiments, encoding formats and decoding methods for a groups of integers simultaneously are provided. This format, in some instances, may include a format that may include a group unary (GU) representation. For example, for a group of 8 byte integers </p><p id="p0051" num="0051">(potentially incomplete), the format may be referred to as varint-G8IU with unary length encoding. </p><p id="p0052" num="0052">[0047] Another encoding format referred to herein is varint G8CU, which represents a group of 8 byte information (each complete) with unary length encoding. Varint-G8CU generally refers to an instance when an integer or data would not fit in the remaining space in a block during encoding. In that case, a first part of the data may be stored in the current data block, and the remaining part of the data may be carried over to be stored in the next block. Embodiments may include decoding methods that include tables that take into account the information about the carry between blocks. </p><p id="p0053" num="0053">[0048] In some embodiments, variations of the variable length encoding formats are provided that includes a hybrid that utilizes at least one of the above compression schemes along with a bit vector to save space. In some embodiments, the variable length encoding format may include a group unary format. Embodiments may include detecting if a sequence of upcoming integers or 
<!-- EPO <DP n="9"/>-->
 data to be encoded are very small, such that more than one of the integers or data may be encoded into one byte. These integers or data may be stored as a bit vector. For example, the nth bit may represent whether a document at position base + n is in a posting list. A special descriptor value may indicate whether the group of data bytes should be interpreted as using the one of the variable-length integer formats, or as a bit vector. </p><p id="p0054" num="0054">[0049] In some embodiments, variations of the variable length encoding formats are provided that include a hybrid of the compression scheme and run-length encoding to save space. </p><p id="p0055" num="0055">Embodiments may encode a run of similar data, such as a ran of all Is, by storing the length of the run instead of the values themselves. </p><p id="p0056" num="0056">[0050] Embodiments that utilize one of the group formats may easily be extended to larger groups, and this might provide additional efficiency gains for processors that may provide wider parallelism (for example, a 256-bit registers). </p><p id="p0057" num="0057">[0051] FIG. 1 illustrates an example of an environment 100 for implementing aspects in accordance with various embodiments. As will be appreciated, although a Web-based environment is used for purposes of explanation, different enviromnents may be used, as appropriate, to implement various embodiments. An electronic client device 102 can include any appropriate device operable to send and receive requests, messages, or information over an appropriate network 104 and convey information back to a user of the device. Examples of such client devices include personal computers, cell phones, handheld messaging devices, laptop computers, set-top boxes, personal data assistants, electronic book readers, and the like. The network can include any appropriate network, including an intranet, the Internet, a cellular network, a local area network, or any other such network or combination thereof. Components used for such a system can depend at least in part upon the type of network and/or environment selected. Protocols and components for communicating via such a network are well known and will not be discussed herein in detail. Communication over the network can be enabled by wired or wireless connections, and combinations thereof. In this example, the network includes the</p><p id="p0058" num="0058">Internet, as the environment includes a Web server 106 for receiving requests and serving content in response thereto, although for other networks an alternative device serving a similar purpose could be used as would be apparent to one of ordinary skill in the art. Some </p><p id="p0059" num="0059">embodiments may utilize a single electronic client device 102. 
<!-- EPO <DP n="10"/>-->
 10052 J The illustrative environment includes at least one application server 108 and a plurality of resources, servers, hosts, instances, routers, switches, data stores, and/or other such </p><p id="p0060" num="0060">components defining what will be referred to herein as a data plane 110, although it should be understood that resources of this plane are not limited to storing and providing access to data. It should be understood that there can be several application servers, layers, or other elements, processes, or components, which may be chained or otherwise configured, which can interact to perform tasks such as obtaining data from an appropriate data store. As used herein the term "data store" refers to any device or combination of devices capable of storing, accessing, and retrieving data, which may include any combination and number of data servers, databases, data storage devices, and data storage media, in any standard, distributed, or clustered environment. The application server can include any appropriate hardware and software for integrating with the data store as needed to execute aspects of one or more applications for the client device, handling a majority of the data access and business logic for an application. The application server provides admission control services in cooperation with the data store, and is able to generate content such as text, graphics, audio, and/or video to be transferred to the user, which may be served to the user by the Web server in the form of HTML, XML, or another appropriate structured language in this example. In some embodiments, the Web server 106, application server 108 and similar components can be considered to be part of the data plane. The handling of all requests and responses, as well as the delivery of content between the client device 102 and the application server 108, can be handled by the Web server. It should be understood that the Web and application servers are not required and are merely example components, as structured code can be executed on any appropriate device or host machine as discussed elsewhere herein. </p><p id="p0061" num="0061">[0053] The data stores of the data plane 110 can include several separate data tables, databases, or other data storage mechanisms and media for storing data relating to a particular aspect. For example, the data plane illustrated includes mechanisms for storing production data 112 and user information 116, which can be used to serve content for the production side. The data plane also is shown to include a mechanism for storing log data 114, which can be used for purposes such as reporting and analysis. It should be understood that there can be many other aspects that may need to be stored in a data store, such as for page image information and access right </p><p id="p0062" num="0062">information, which can be stored in any of the above listed mechanisms as appropriate or in 
<!-- EPO <DP n="11"/>-->
 additional mechanisms in the data plane 110. The data plane 110 is operable, through logic associated therewith, to receive instructions from the application server 108 and obtain, update, or otherwise process data, instructions, or other such information in response thereto. In one example, a user might submit a search request for a certain type of item. In this case, components of the data plane might access the user information to verify the identity of the user, and access the catalog detail information to obtain information about items of that type. The information then can be returned to the user, such as in a results listing on a Web page that the user is able to view via a browser on the user device 102. Information for a particular item of interest can be viewed in a dedicated page or window of the browser. </p><p id="p0063" num="0063">[0054] Each sei<sup>~</sup>ver typically will include an operating system that provides executable program instructions for the general administration and operation of that server, and typically will include a computer-readable medium storing instructions that, when executed by a processor of the server, enable the server to perform its intended functions. Suitable implementations for the operating system and general functionality of the servers are known or commercially available, and are readily implemented by persons having ordinary skill in the art, particularly in light of the disclosure herein. </p><p id="p0064" num="0064">[0055] The environment in one embodiment is a distributed computing environment utilizing several computer systems and components that are interconnected via communication links, using one or more computer networks or direct connections. However, it will be appreciated by those of ordinary skill in the art that such a system could operate equally well in a system having fewer or a greater number of components than are illustrated in FIG. 1. Thus, the depiction of the system 100 in FIG. 1 should be taken as being illustrative in nature, and not limiting to the scope of the disclosure. </p><p id="p0065" num="0065">10056] An environment such as that illustrated in FIG. I can be useful for various content providers or other such entities, wherein multiple hosts and various types of resources might be used to perform tasks such as serving content, authenticating users, allocating resources, or performing any of a number of other such tasks. Some of these hosts may be configured to offer similar functionality, while other servers might be configured to perform at least some different functions. 
<!-- EPO <DP n="12"/>-->
 [0057] Embodiments provide a variety of methods of variable-length encoding. Some embodiments may include byte-oriented encodings. Byte-oriented encoding includes the following properties. All significant bits of the natural binary representation are preserved. Each byte contains bits from only one integer or data. Data bits within a single byte of the encoding preserve the ordering they had in the original data or integer. All bits from a single integer or data precede all bits from the next integer or next data. </p><p id="p0066" num="0066">[0058] Byte-oriented formats for encoding may vary along a variety of dimensions. For example, the length of the data or integer may be expressed in a binary or a unary representation. In some cases, the bits representing the length of the data or integer can be stored adjacent to the data bits of the corresponding integer or data so that some data bytes contain both data and length information. In some instances the bits representing the lengths of several integers or data can be grouped together into one or more bytes distinct from the bytes containing data bits. </p><p id="p0067" num="0067">[0059] In some embodiments, the bits of a unary or binary representation or format may be packed or grouped contiguously. The bits of a unary representation may also be split across the bytes of the encoded integer or data. In some cases, the binary representation may be split across the bytes of the encoded integer or data. In some embodiments, the set of bits used to represent the length of one or more encoded integers or data may be referred to as a descriptor, since it may describe how the data bits are organized. A descriptor may be located contiguous with the data bits. In some cases, a descriptor may be located non-contiguous with the data bits. </p><p id="p0068" num="0068">[0060] In some embodiments, each encoded integer or data may include at least one byte. Both binary and unary descriptors may represent the length n of the integer or data by recording the value n- 1. This reduces the number of bits required to represent a given length. </p><p id="p0069" num="0069">Alternatively, the length of the integer or data may include storing length as n, which may allow the length zero to represent an arbitrary constant with zero data bytes. </p><p id="p0070" num="0070">[0061] The aspects discussed above may be utilized to provide description for different byte- oriented encoding formats. These aspects may be used to encode formats for integers that can be encoded in four bytes or less. Some instances, however, may expand to cover encoding data in general. Furthermore, the encoding principles may also be utilized for examples where the data and/or integer may involve more than four bytes. 
<!-- EPO <DP n="13"/>-->
 [0062] The following describes several different embodiments for different variable-length encodings. Additional embodiments may be constructed within the scope of this disclosure. In general, embodiments may include encoded values that may have different lengths. The lengths may be encoded in one or more descriptors. Two properties may be utilized to describe a descriptor for different encoding types. A first descriptor property may include an arrangement description. The arrangement description for a descriptor may be referred to as split, packed, or group. As mentioned above, a split descriptor may include distributing bits of the descriptor that provide length information among several bytes that also include information regarding one or more integers or data. A packed descriptor may refer to descriptor bits being packed together. In some embodiments, a packed descriptor may precede the encoding of respective integers or data. A group descriptor may include grouping together the descriptors for several integers or data. </p><p id="p0071" num="0071">[0063] A second descriptor property may include a length encoding description Some length encoding descriptions may be unary, utilizing individual bits, while some length encoding descriptions may be binary, utilizing two bits. Some embodiments may utilize more bits based on the length of an encoded integer or data of interest. </p><p id="p0072" num="0072">[0064] There are numerous variations of some of these formats that may be found in different embodiments. Bytes of the encoded data may be stored in little-endian or big-endian order, which is known in the art. Descriptor bits may be stored in the least significant (LS) or most significant bits (MSB). While these choices are sometimes described as arbitrary conventions, in practice there may be efficiency considerations that make certain variants attractive for certain machine architectures. For example, in a split unary representation (discussed below), representing termination as 0 in the most significant bit may allow the common case of a one- byte integer to be decoded without any shifts or masks. In other example, for packed </p><p id="p0073" num="0073">representations, it may be beneficial to use the least-significant bits to benefit from unaligned loads, keeping the data bits together. While traditional decoding methods may run more efficiently when the representation preserves native byte ordering, the performance of the SIMD methods discussed below may not depend on the ordering. The following examples will generally involve little-endian order, however, big-endian order may be adapted from what is described. For example, with packed encodings (discussed below), descriptors may be stored in 
<!-- EPO <DP n="14"/>-->
 least significant bits and shift to get the data with little-endian machines. For big-endian machines, descriptors for packed encodings may be stored in the most significant bits and mask to get data. In addition, the sense of 1 and 0 in descriptor bits may be swapped in some embodiments. </p><p id="p0074" num="0074">[0065] Some embodiment may utilize unary representations for a descriptor. For the unary formats, a natural convention may be utilized where the quantity may be represented by the number of consecutive 1 bits, which may be referred to as continuation bits, followed by a terminating 0, which may be referred to as a terminating bit. Some embodiments may reverse this convention using consecutive 0 bits followed by a terminating 1. Utilizing the natural convention and starting from the least significant bit, for example, the bits 01 11 may represent the number 3 in one embodiment. </p><p id="p0075" num="0075">[0066] In some embodiments, a split unary format may be viewed as representing the length of the encoded integer or data in the sequence of continuation and/or termination bits. The descriptor bits may be viewed as distributed continuation bits, where a bit in each byte may signify continuation or termination. For example, a three-byte integer encoding may look like this: </p><p id="p0076" num="0076">1 xxxxxxx </p><p id="p0077" num="0077"> lxxxxxxx </p><p id="p0078" num="0078"> Oxxxxxxx </p><p id="p0079" num="0079"> Notice that the leading bits may form the unary number 2, representing the length 3. This may be referred to as varint-SU in some embodiments, since it is a variable-length representation of integers with length information split across several bytes and represented in unary. In some embodiments, a split unary representation may use the most significant bit as the continuation or termination bit. This may allow embodiments to avoid shift for the terminal byte case. It may also allow for a compiler to use sign checking to test the bit. Some embodiments may, however, utilize the least significant bit of a byte for the continuation or termination bit. </p><p id="p0080" num="0080">[0067] FIG. 2A provides an example of an embodiment of a split unary representation of a byte consisting of 8 bits, with a descriptor bit 210 located in the most significant bit (MSB) and seven data bits 220 located in the remaining bits of the byte. FIG. 2B provides an example 
<!-- EPO <DP n="15"/>-->
 where an integer, 123456, may be represented using a split unary representation, where each byte includes a 1 in the MSB, or left most bit in each byte, 211 and 212, for example, if the representation continues to the next byte, and a 0 213 if the end of the integer is reached. </p><p id="p0081" num="0081">[0068] Some embodiments may include a packed unary representation of a descriptor. This may be referred to as varint-PU in some embodiments, and may be similar to varint-SU, but with the descriptor bits packed together. The packed bits may be collected in the low-order bits of a first byte rather than being split across all bytes. The choice of low-order bits to hold the descriptor may be appropriate for little-endian encodings on little-endian architectures, which is generally known in the art, so that all data bits for one integer are contiguous. For the same reason, on big-endian architectures, placing the descriptor in the high-order bits and using big- endian encoding may be more efficient to decode. FIG. 3A provides one example of an embodiment of a packed unary representation, where n descriptor bits are packed together in the least-significant (LS) bits 310, with 7n data bits in the most significant bits 320. This provides an example of a little-endian architecture. With a big-endian architecture, the descriptor bits may be please in the most significant bits. A table 330 provides four examples of how n descriptor bits may be utilized to represent the number of bytes in the data bits. FIG. 3B shows an example of a packed unary representation of the number 123456, where the first 3 low order bits 011 311 represent the information that the number involves 3 bytes 321. </p><p id="p0082" num="0082">[0069] Embodiments may also include group unary representations that are discussed in more detail below. </p><p id="p0083" num="0083">[0070] Some embodiments may utilize a packed binary representation of a descriptor. For example, two bits of a first byte may be reserved to indicate the length of the encoded integer or data in binary. FIG. 4A provides an example for an embodiment where two descriptor bits 410 are utilized, along with up to 30 data bits 420. A table 430 provides four examples of how the two descriptor bits 410 may be utilized to represent the number of data bits. Some embodiments may utilize more or less data bits. FIG. 4B provides one example of how a packed binary representation may be utilized to encode 123456. To represent 123456 involves 17 data bits, which is more than 16 bits (i.e. two bytes) and less than 25 bits (i.e. 3 bytes). The two descriptor bits 411 thus represent that three bytes 421 are provided for the data bits. In this case, the descriptor bits 411 represent the length of 3 bytes as 10. 
<!-- EPO <DP n="16"/>-->
 [0071] Other embodiments may utilize other representations. For example, a split binary representation may be utilized in some cases where binary descriptor bits may be split across several bytes for a given integer or data representation. Some embodiments may include group binary representations, which are discussed in more detail below. </p><p id="p0084" num="0084">[0072] Some embodiments may utilize binary length descriptors where the descriptor length may be fixed in advance. While embodiments described herein generally involving binary formats that are shown with fixed length, some embodiments may utilize additional metadata to store the length of a descriptor itself. In addition, some embodiments may include splitting a fixed-length k-bit binary descriptor (one bit per byte), which may result in a byte-oriented integer encoding that may require at least k bytes. </p><p id="p0085" num="0085">[0073] Some encoding formats may group several integers or data together. This may provide opportunities for exploiting SIMD parallelism. Some embodiments may include encodings that satisfy a byte-oriented encoding property that is byte-preserving, where each byte containing significant bits in the original (unencoded) integer or data appears without modification in the encoded form. </p><p id="p0086" num="0086">[0074] Embodiments with group encoding may include separating the descriptor bytes from the data bytes. The separation of descriptor bytes from data bytes in group formats may allow for more efficient decoding in some embodiments. This separation may enable the use of tables to simplify the decoding process. Packed and split representations, however, may also benefit from the use of tables as discussed below in more detail. In some embodiments, group formats may avoid bitwise manipulation that may otherwise be required to eliminate interspersed descriptor bits. In particular, embodiments with byte-preserving encodings may be especially amenable to decoding with the SIMD techniques, described in more detail below. </p><p id="p0087" num="0087">[0075] FIG. 5 A illustrates an example of group binary format byte ordering. In the FIG.5A example, the byte ordering includes a group of four integers (520-a, 520-b. 520-c, and 520-d) that is preceded by a descriptor byte 510 containing four 2-bit binary numbers. Each 2-bit binary number represents the length of a corresponding integer (e.g. reading right to left, the first 2-bit number represents integer 0 520-a, the next 2-bit number represents integer 1 520-b, and so on). This format shown in FIG. 5 A may generally be referred to as varint-GB format. 
<!-- EPO <DP n="17"/>-->
 [00761 FIG. 5B shows how four hexadecimal numbers OxAAAA 521-a, OxBBBBBB 521-b, OxCC 521-c, OxDDDDDDDD 521-d may be represented using a group binary format in little- endian byte order. The four integers occupy, correspondingly, 2 bytes, 3 bytes, 1 byte, and 4 bytes. The descriptor byte 51 Irepresents the length n of each byte by a 2-bit binary value n- 1. Using this example, the descriptor byte 511 shown in FIG. 5B includes the values 01, 10, 00, and 1 1 (read from right to left) respectively. 01 represents the 2 byte length of integer OxAAAA 521-a; 10 represents the 3 byte length of integer OxBBBBBB 521-b; 00 represents the 1 byte length of integer OxCC 521-c; 1 1 represents the 4 byte length of integer OxDDDDDDDD 521-d. To maintain a consistent order between descriptor bits and data bytes, some embodiments may store the first binary length in the least significant bits. Thus the descriptor byte 511 for the four integers shown in FIG. 5B may be represented asl 1001001. Byte addresses increase from right to left, matching the order of increasing bit significance. The order of pairs of bits in the descriptor matches the order of the integers. </p><p id="p0088" num="0088">[0077J Some embodiments of a group binary format involve a fixed number of integers occupying a variable number of bytes, storing their lengths in binary. In contrast, some embodiments of a group unary format involve a fixed number of bytes encoding a variable number of integers, storing their lengths in unary. For example, in one embodiment, referred to as varint-GU, 8 data bytes may be grouped together along with one descriptor byte containing the unary representations of the lengths of each encoded integer. Each of the 8 data bytes may encode as few as two integers and as many as eight integers, depending on their size. The number of zeros in the descriptor indicates the number of integers encoded in the group. An embodiment of a group unary format is shown in FIG. 6A. In this embodiment, a block size of 8 620 may be the minimal size that can use every bit of the descriptor byte 610; larger multiples of 8 are possible for some embodiments. FIG. 6B provides an example of encoding four integers using a group unary format. In this example, the same four integers OxAAAA, OxBBBBBB, OxCC, and OxDDDDDDDD as shown with the group binary format in FIG. 5B are used to illustrate a group unary format. Encoding these values would involve 10 bytes, but only 8 bytes are available in the block. The first three integers OxAAAA 621-a, OxBBBBBB 621-b, and OxCC 621-c fit into the block using 6 bytes, leaving 2 bytes of padding 630. The final integer OxDDDDDDDD is left for the next block (not shown). The descriptor 611 contains the three 
<!-- EPO <DP n="18"/>-->
 unary values 01 (representing the 2-byte length of OxAAAA 621-a, 01 1 representing the 3 -byte length of OxBBBBBB 621-b, and 0 representing the 1-byte length of OxCC 621-c, along with two padding bits 11 representing the 2 bytes of padding 630. These are arranged in the same order as the integers, giving the descriptor a binary value of 1 1001101. </p><p id="p0089" num="0089">[0078] FIG. 6C provides an example of a group unary format that may encode up to 16 data bytes. In embodiment, two descriptor bytes (612-a and 612-b respectively) are utilized, where the first descriptor byte 612-a describes a first block of up to 8 data bytes 622-a and a second descriptor byte 612-b describes a second block of up to 8 data bytes 622-b. Other embodiments of a group unary format may encode even more data bytes, such as for 24 or 32 data bytes, merely by way of example, where an addition descriptor byte may be provided for each additional group of 8 data bytes. While this examples shows descriptor bytes that are contiguous with the data bytes, some embodiments may include descriptor bytes that are not contiguous with the data bytes. </p><p id="p0090" num="0090">[0079] Since not every group of encoded bytes, which may represent integers in some embodiments, may fit evenly into an 8-byte block, some embodiments may provide variations of the encoding. These may be referred to as incomplete or complete in some cases. </p><p id="p0091" num="0091">[0080] In an incomplete block variation, which may be referred to as varint-G8IU in some embodiments, embodiments may store as many integers as fit in 8 bytes, leaving the data block incomplete if necessary. In the embodiments discussed, 8 refers to the number of bytes in a data block. An embodiment of an incomplete block variation was discussed above with respect to FIG. 6B. The remaining space may be padded with zeros, but may be ignored on decoding. When there is no additional integer to decode, the final (most significant) bits of the descriptor may be an unterminated sequence of 1 bits. Some embodiments may include a variation of this encoding format that uses variable size data blocks and avoids padding. </p><p id="p0092" num="0092">[0081] In embodiments that utilize a complete block variation, which may be referred to as varint-G8CU in one embodiment, all the bytes in a data block may be filled. For example, in an varint-G8CU embodiment, all eight bytes in a data block are filed. As before, the number of zero bits in the descriptor indicates the number of complete integers encoded. In situations where an integer exceeds the remaining space in the current block, as much of that integer as fits 
<!-- EPO <DP n="19"/>-->
 is placed in the current block. The remaining bytes of that integer are carried over into the next data block. Similarly, the corresponding descriptor bits are carried over to the next block's descriptor byte. FIG. 7 A provides an example of a group unary format with complete block, with 8 data bytes r 720 and a descriptor byte 710; it is similar to FIG. 6A. FIG. 7B shows how bytes may be carried over to the next data block. Again, merely for example purposes, FIG. 7B shows the same four integers ΟχΑΑΑΑ,ΟχΒΒΒΒΒΒ, OxCC and OxDDDDDDDD as used in several other examples. The first three integers 721 and the corresponding descriptor bits 711 are stored exactly as in varint-G81U. However, varint-G8CU may handle the fourth integer differently. Its first two bytes 722 are placed in the first data block, filling it entirely, and the remaining two bytes 723 go into the following block. The two descriptor bits corresponding to these last two bytes 712 go into the next block's descriptor byte. Although spread across two descriptor bytes, the unary value of the descriptor bits for this fourth integer still represents the length -1 of the encoded integer. </p><p id="p0093" num="0093">[0082] FIG. 7C provides an example of a group unary format that may utilize two descriptor bytes 713 followed by 16 data bytes 724. This embodiment may be implemented, for example, with a 128 bit register. </p><p id="p0094" num="0094">[0083] FIG. 8 provides a computer-implemented method 800 for encoding document identification numbers for a search engine posting list in accordance with various embodiments. Method 800 may be implemented in environments and devices as seen in environment 100 of FIG. 1, for example. Method 800 may also include and/or utilize aspects of the group formats discussed with respect to FIGS. 6A-C and/or 7A-C. Under control of one or more computer systems configured with executable instructions, method 800 includes determining a block size for data storage 802. Multiple document identification numbers for the search engine posting list are received 804. Differences between adjacent document identification numbers are determined 806. An encoded representation of each document identification number difference is determined 808. The encoded representations of th e document identification number differences use variable-length representations. A sequential of the multiple encoded representations of the document identification number differences is identified 810. A sum of respective sizes of the encoded representation of each document identification number difference of the sequential is less than or equal to the determined block size for data storage. One or more descriptors are 
<!-- EPO <DP n="20"/>-->
 generated 812. The descriptors provide information regarding the number of encoded representations of document identification number differences in the sequential of encoded representations of document identification number differences and the size of each respective encoded representation of a respective document identification number difference. The descriptors may represent the size of each respective encoded representation of a document identification number difference with a unary representation of each respective size. The one or more descriptors and the sequential of encoded representations of the document identifications differences are stored 814. The sequential of encoded representations of the document identification number differences is stored as a group and the one or more descriptors are stored contiguous with the group of encoded representations of document identification number differences. </p><p id="p0095" num="0095">[0084] FIG. 9 provides a computer-implemented method 900 for encoding data using variable- length representations in accordance with various embodiments. Method 900 may be </p><p id="p0096" num="0096">implemented in environments and devices as seen in environment 100 of FIG. 1, for example. Method 800 may also include and/or utilize aspects of the group formats discussed with respect to FIGS. 6A-C, 7A-C, and/or method 800 of FIG. 8. Under control of one or more computer systems configured with executable instructions, method 900 includes determining a block size for data storage 902. Multiple data items are identified 904. In some cases, the data items are delta-gaps. An encoded representation of each data item is determined 906. The encoded representations of the data items use variable-length representations. A first subset of the multiple encoded representations of the data items are identified 908. A sum of respective sizes of the encoded representations of the data items from the first subset of the multiple encoded representations of data items is less than or equal to the determined block size for data storage. A first descriptor is generated 910. The first descriptor represents the respective sizes of the encoded representations of the data items of the first subset. The first subset of the multi ple encoded representations of the data items is stored as a first stored group 912. The first descriptor is also stored 914. </p><p id="p0097" num="0097">[0085] In some embodiments, the first descriptor is stored contiguous with the first stored group, while in other cases the descriptor may be stored non-contiguous with the first stored group. The descriptor may represent the size of each respective encoded representation for each 
<!-- EPO <DP n="21"/>-->
 data item in a unary format. A unary format may include describing the respective size of each encoded representation for each data item as the unary size minus one, while separating the representation of each respective length by a zero. In some cases, padding information may be inserted into the first descriptor representing a difference in size between the first subset and the determined block size of data. This may be the case when the size of the multiple encoded representations for the data items is less than the determined block size for data storage. </p><p id="p0098" num="0098">[0086] In some embodiments, an additional encoded representation of a respective data item from the multiple encoded representations of the data items may be identified. At least a first portion of the additional encoded representation of the respective data item may be stored as part of the first stored grouped. At least a second portion of the additional encoded representation of the respective data item may be stored as part of a second stored group. A second descriptor may be generated in these cases. The second descriptor may represent in part the size of at least the second portion of the additional encoded representation of the respective data item as part of the second stored group. </p><p id="p0099" num="0099">[0087] Embodiments may include several different decoding methods that may be utilized to decode one or more of the encoding formats discussed above. These decoding methods may also be useful for other encoding formats that may not necessarily be discussed in this disclosure. Some embodiments may utilize single instruction multiple data (SIMD) instructions. </p><p id="p0100" num="0100">Embodiments may utilize such instructions to act in parallel on multiple bytes found with the different encoded formats. </p><p id="p0101" num="0101">[0088] Some embodiments may utilize SIMD instructions available for different platforms, including, but not limited to Intel ® 64 architecture implemented in processors by Intel and AMD and in extensive use in many data centers. In the Intel ® 64 architecture, a series of SIMD enhancements have been added over time. Among the SIMD capabilities are 16-byte XMM vector registers and parallel instructions for operating on them. Some embodiments may utilize SIMD instructions for other formats to provide similar or different capabilities to the Intel ® 64 architecture. </p><p id="p0102" num="0102">[0089] Some embodiments may utilize a shuffle instruction. Merely by way of example, the PSHUFB instruction, introduced wit SSSE3 in 2006, may be utilized in some embodiments. It 
<!-- EPO <DP n="22"/>-->
 performs a permutation ("'shuffle") of bytes in an XMM register, allowing the insertion of zeros in specified positions. PSHUFB has two operands, a location containing the data and a register containing a shuffle sequence. If the original value of the data operand is preserved, PSHUFB can be viewed as transforming a source sequence (sre) of bytes to a destination sequence (dst) according to the shuffle sequence (shf). The following provides one example of pseudocode that may provide a shuffle sequence as seen with PSHUFB. for 0 &lt; &lt; 16 do in parallel </p><p id="p0103" num="0103"> if shuffie†] &gt; 0 then </p><p id="p0104" num="0104"> dstfij 4- src[shufflo[«| mod 10[ </p><p id="p0105" num="0105"> els</p><p id="p0106" num="0106"><img id="imgf000022_0001" he="5" wi="19" file="imgf000022_0001.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="no"/></p><p id="p0107" num="0107"> end </p><p id="p0108" num="0108">[0090] Merely by way of example, the ith value in a shuffle sequence indicates which source byte to place in the ith destination byte. In some embodiments, if the ith value in the shuffle sequence is negative, a zero is placed in the corresponding destination byte. </p><p id="p0109" num="0109">[0091] Some embodiments may utilize other S1MD shuffle instructions besides the PSHUFB instruction. For example, VPERM from the AltiVec/VMX instruction set for the PowerPC processor may provide similar functionality for the purposes of the decoding methods discuss below. In addition, other shuffle instructions for other platforms may provide functions and may be utilized in different embodiments. </p><p id="p0110" num="0110">[0092] The example illustrated in FIG. 1 shows how PSHUFB can be used to reverse the byte order of four 32-bit integers at once with index sequence i 1010, shuffle sequence shf 1020, source sequence sre 1030, and destination sequence dst 1040. </p><p id="p0111" num="0111">[0093] Some embodiment as discussed above may include byte-preserving formats that remove leading zero bytes while retaining the significant bytes intact for one or more integers or data of interest. Decoding may then include reinserting the zero bytes in the right places. Some embodiments may utilize a shuffle sequence that may be constructed by inserting - I s in a sequence {0, 1, 2, 3, ...}. Some embodiments may utilize something besides a -1 to insert in the sequence of integers. With this sequence, a shuffle instruction, such as PS HUFB, may copy the significant data bytes while inserting the missing zeros. 
<!-- EPO <DP n="23"/>-->
 [0094] An example of using a shuffle instruction, such as PSHUFB, to decode one of the encoded formats discussed above in shown in FIG. 11. In this example, the encoded format is a group unary format referred to as varint-G8IU. This is same data represented in FIG. 6B. FIG. 11 shows a shuffle sequence shf 1120, an index sequence i 1110, a source sequence src 1130 of the encoded format, and destination sequence dst 1140 for the decoded data. For example, the right most byte (i.e. the byte with the lowest address) of the shuffle sequence, 0, at index 0, takes the 0<sup>th</sup> source byte and puts it in the 0<sup>th</sup> destination byte. In general, the ith shuffle sequence entry instructs which entry location the source to pick from and then place in the ith destination location. As another example, FIG. 11 shows that for i = 4, the shuffle sequence says that the source at index 2 is to be placed at destination with index 4. In addition, when the shuffle sequence has a -1 (which may be represented in different ways in other embodiments) zero values s are place in the destination at that index. As an example, at index i =3, the shuffle sequence has a -1, in which case, zeros will be place at the destination at index i=3. In this particular example, 3 integers are decoded, resulting in an output offset of 3 as noted in the figure. </p><p id="p0112" num="0112">[0095] For a given format, a correct shuffle sequence may be precomputed for a particular data block and its corresponding descriptor byte. For possible values of the descriptor (and sometimes additional state), a table of any shuffle sequence may be built that might be needed at decode time. </p><p id="p0113" num="0113">[0096] In some embodiments, the table entries also contain a precomputed offset. For a group binary format, such varint-GB format, the offset may indicate how many bytes were consumed to decode 4 integers; it may output 16 bytes for example. Other embodiments may output more or less bytes and made involve more or less integers in some cases. For the group unary formats, such as varint-GU formats, the offset may indicate how many integers were decoded; it may consume 8 bytes for example. Other embodiments may consume more bytes if utilized. </p><p id="p0114" num="0114">[0097] Table construction may occur only once in some embodiments, while table lookup may occur every time a group is decoded. </p><p id="p0115" num="0115">[0098] Given the availability of these tables, a general method of decoding may be described as follows: 
<!-- EPO <DP n="24"/>-->
 1. read a chunk of data and its corresponding descriptor; </p><p id="p0116" num="0116">2. look up the appropriate shuffle sequence and/or offset from the table; </p><p id="p0117" num="0117">3. perform the shuffle; </p><p id="p0118" num="0118">4. write the result; </p><p id="p0119" num="0119">5. advance the input and output pointers. </p><p id="p0120" num="0120">[0099] FIG. 12 provides a block diagram for some methods of decoding in accordance with some embodiments. At block 1202, data and one or more descriptors corresponding to the data are read. At block 1204, one or more shuffle sequences associated with the descriptor(s) are identified from a table that may be precomputed. At block 1206, a shuffle operation is performed on the data using the shuffle sequence. This operation may occur in parallel. At block 1208, a decoded result is written from the shuffled data. In some embodiments, information about how much data has been read will returned. </p><p id="p0121" num="0121">[0100] The following provides different implementations of the above steps for several different formats, though other embodiments may utilize more or less of these steps for other formats. </p><p id="p0122" num="0122">[0101] Embodiments allow for several integers or data to be decoded simultaneously with very few instructions. Some embodiments may not require conditionals, and thus avoid performance penalties due to branch misprediction. Logical complexity may be shifted from the code to the tabic. Embodiments may include reads and writes of a fixed amount and then rely on the table to determine how much input data or output data it has actually processed. This may require that the input and output buffers have at least this amount available to read or write. </p><p id="p0123" num="0123">[0102] In some embodiments, data blocks are not aligned on any fixed boundary. Some embodiments may depend on the ability of a CPU to perform unaligned reads and writes efficiently. </p><p id="p0124" num="0124">[0103] Some embodiments may utilize parallel decoding, which may be described in some cases using pseudocode such as the following: 
<!-- EPO <DP n="25"/>-->
 Decodes a, chunk of data mmg p mllel (SIMD<sup>'</sup> ) shuffle, </p><p id="p0125" num="0125"> input I src, dst, state </p><p id="p0126" num="0126"> output: src <sub>j</sub>, dst, state </p><p id="p0127" num="0127"> 1 begin </p><p id="p0128" num="0128"> 2 ciese read, (src, 1 ) </p><p id="p0129" num="0129"> 3 data &lt;r— read (src + I, 16) </p><p id="p0130" num="0130"> 4 entry ÷- ta,bl <sub>;</sub>,<sub>n</sub>,<sub>iat</sub>[desc, state] </p><p id="p0131" num="0131"> 5 sbiiflScAadWritG(dato, ei try.s3iiiffieSoqiieii.ee,, dst) </p><p id="p0132" num="0132"> i sre ÷- src + entiy.inputOffset </p><p id="p0133" num="0133"> 7 dst — cist + entry.outputOflset </p><p id="p0134" num="0134"> S state ÷- efffcry,Ptat.e </p><p id="p0135" num="0135"> 9 re urn a , dst. sl te </p><p id="p0136" num="0136">10 end </p><p id="p0137" num="0137">[0104] Because this method constitutes an inner loop of a decoding process, embodiments may inline the implementation to avoid function call overhead. Embodiments, as shown above in the pseudocode, may take three inputs: </p><p id="p0138" num="0138">• src - a pointer to the input byte stream of encoded values; </p><p id="p0139" num="0139"> • dst - a pointer to the output stream of integers in case of varint-GB, and varint- G8IU; in the case of varint-G8CU, dst may be a pointer to an output stream of bytes, since decoding a block of varint-G8CU may result in writing a portion of a decoded integer; and </p><p id="p0140" num="0140"> • state - auxiliary state, which may be used for varint-G8CU to indicate the number of bytes modulo 4 of the last integer written. </p><p id="p0141" num="0141"> [0105] Embodiments may read encoded values from the input stream, output decoded integers or data to the output stream and return as its result the new positions of src, dst, and the updated state. </p><p id="p0142" num="0142">[0106] Some embodiments may read 16 bytes, which is the size of some registers, such as the XMM register used by the PSHUFB operation. However, more bytes may be read; for example, some registers may have a smaller or larger size, such as for 8 bytes or 32 bytes, merely by way of example. The number of bytes corresponding to a single byte descriptor may be 8 for the unary formats and may be at most 16 for the binary format. </p><p id="p0143" num="0143">[0107] Embodiments may utilize different tables for each format. For example the table may have 256 entries for the varint- GB and varint-G8IU formats, one for each descriptor value. For 
<!-- EPO <DP n="26"/>-->
 varint-G8CU format, the table may have 4x256 = 1024 entries, because there may be an entry for each descriptor and state pair, and the state is an integer i, with 0 = i &lt; 4. </p><p id="p0144" num="0144">[0108] Some embodiments may utilize an operation such as the shuffleAnd Write operation that uses the PSHUFB operation with the provided shuffle sequence to expand the 16 bytes of data inserting zeros into the correct positions, and then writes its result to the destination. Other embodiments may similarly utilize use a shuffle sequence along with a parallel shuffle operation to expand a series of bytes of data with the insertion of zeros into correction positions and writing the result. </p><p id="p0145" num="0145">[0109] In the varint-GB case, the shuffle sequence may be a 16-byte sequence describing a single PSHUFB operation. A single PSHUFB may be sufficient because the group contains four encoded integers, and thus the output may not exceed 16 bytes. </p><p id="p0146" num="0146">[0110] For decoding the group unary formats in some embodiments, the shuffle sequence may be a 32-byte sequence specifying two PSHUFB operations. The second PSHUFB may be required for the unary formats because an 8-byte data block may encode up to 8 integers, which can expand to 32 bytes. The output of the first PSHUFB may be written to locations beginning at dst, and the output of the second PSHUFB to locations beginning at dst + 16. To avoid conditionals, the second shuffle may be performed, even when the output does not exceed 16 bytes. Since PSHUFB rearranges the register in place, the corresponding register may be reloaded with the original data before the second PSHUFB. Some embodiments may only involve a single shuffle operation. Some embodiments may utilize one shuffle rather than two shuffles. </p><p id="p0147" num="0147">[0111] For some unary formats, the input offset, by which may increment the src in the above pseudocode, may be 8 bytes. For varint-GSIU. the output offset measured in units of decoded integers may vary between 2 and 8, except for the last block of a sequence, which might contain between 1 and 8 integers. For varint-G8CU, decoding one block may result in writing a portion of a decoded integer, so the output is a byte stream and the offset is measured in byte units. The output is between 8 and 32 bytes, except for the last block of the sequence which may output between 1 and 32 bytes. 
<!-- EPO <DP n="27"/>-->
 [0112] In the case of the binary format, the output offset may be a constant 4 integers. </p><p id="p0148" num="0148">Embodiments of the varint-GB format may have auxiliary information to deal with sequences of length not divisible by 4. This may be done using length information stored separately or the convention that zero values may not appear in the sequence, so terminal zeros may be ignored. The input offset may vary between 4 and 16 bytes. For these encoding embodiments, the input offset may account for the additional one byte of the descriptor as well. Variable offsets may be precomputed and stored in the format table. </p><p id="p0149" num="0149">[0113] For the varint-G8CU format, the table also may contain the new state information indicating the number of bytes in the last integer to be used to decode the subsequent block. </p><p id="p0150" num="0150">[0114] For each of the encoded formats, a decoding table may be constructed in advance. Such decoding tables may be utilized in methods for decoding, such as that described above. Each table may include a table entry corresponding to each possible descriptor value and state value. Each table entry logically contains four things: </p><p id="p0151" num="0151">• a shuffle sequence </p><p id="p0152" num="0152"> • an input offset </p><p id="p0153" num="0153"> • an output offset </p><p id="p0154" num="0154"> • the state value to use for the subsequent block </p><p id="p0155" num="0155">For some of the formats, some of these values are constant over all entries in the table, and so do not need to be stored explicitly. </p><p id="p0156" num="0156">[0115] The table construction process can take as input a descriptor byte value and a state value. It can build the shuffle sequence for the entry and compute the input and output offsets and next state. </p><p id="p0157" num="0157">[0116] Some embodiments may deal with valid descriptor values, those which could actually arise from encoding. For varint-GB, all possible byte values may be valid. For the group unary formats, a descriptor may be valid if the distance between consecutive zero bits does not exceed 4. </p><p id="p0158" num="0158">[0117] The methods for constructing shuffle sequences, offset values, and the next state value may depend on the following abstract functions in some embodiments: 
<!-- EPO <DP n="28"/>-->
• num(d) gives the number of integers whose encoding is completed in the group described by the descriptor value d. For varint-GB, this is 4 (except for the las block where it may be 1 to 4).. For the group unary formats, this value may be the number of 0 (termination) bits in d.</p><p id="p0159" num="0159">• len(d; i) gives the length of the ith integer in the group, for each i, 0 = i &lt; n. This may be the length determined by the ith individual bit pair in d for varint-GB, or the ith unary value in d for the unary formats. </p><p id="p0160" num="0160"> • rem(d) gives the number of bytes modulo 4 in the last encoded integer in the group. This may be needed for varint-G8CU, where it is equal to the number of leading Is in the descriptor. For the other formats, it may be 0. </p><p id="p0161" num="0161">[0118] Embodiments may construct a shuffle sequence that may be utilized to insert -1 s (or other possible numbers to present blocks of zeros) in a sequence {0, 1, 2, 3, ...} representing the byte positions in one block of the source data being decoded. The resulting shuffle sequence may be utilized by a shuffle instruction, such as the PSHUFB instruction, to copy the significant data bytes while inserting the missing leading zeros. The following pseudocode provides one description of the construction of a shuffle sequence for a given descriptor value that may be utilized for different embodiments: 
<!-- EPO <DP n="29"/>-->
</p><p id="p0162" num="0162">Construct &amp; shuffle seq ence for &amp; given descriptor value </p><p id="p0163" num="0163"> inpi.it : clesc descriptor buie vat e </p><p id="p0164" num="0164"> : state tf?r- mmiber o bytes- of the in mpl e integer 1 1 lit, tie ,<sup>*</sup>n &gt;, $ Mock output: slmffk? the shuffle sequence for tiie given descriptor mid slate name begin for 0 &lt; i &lt; mirrt(desc) do </p><p id="p0165" num="0165"> for 0 &lt; a &lt; s do </p><p id="p0166" num="0166"> if n &lt; lenf dcsc, 1) then </p><p id="p0167" num="0167"> shiifBeJk] ÷- j else </p><p id="p0168" num="0168"> sbuifleikj i—— <sup>"</sup>I </p><p id="p0169" num="0169"> end </p><p id="p0170" num="0170"> k k - 1 </p><p id="p0171" num="0171"> end end </p><p id="p0172" num="0172"> for 0 &lt; II &lt; rem(dese) do </p><p id="p0173" num="0173"> slraffleikj f- j </p><p id="p0174" num="0174"> j »— j -j- i. </p><p id="p0175" num="0175"> k -~ k - - ί </p><p id="p0176" num="0176"> tiiifl</p><p id="p0177" num="0177"> eturn s!mlffic </p><p id="p0178" num="0178">The above shuffle sequence construction pseudocode includes two inputs: </p><p id="p0179" num="0179">• desc: the descriptor value </p><p id="p0180" num="0180"> • state: the number of bytes modulo 4 written from the last integer in the prior group. For varint-GB and varint-G8IU, the value of state is always 0, since only complete integers are written in a given data block in these formats. </p><p id="p0181" num="0181">[01 19] The first loop iterates over every completed integer in the group corresponding to the given descriptor. For each completed integer in the group, the inner loop sets the shuffle sequence to move the encoded bytes from the source of the shuffle operation, inserting - 1 s to produce the leading zeros necessary to complete the decoded integer. Here the variable j advances over the source data positions in the data block, while the variable k advances over the 
<!-- EPO <DP n="30"/>-->
 positions in the shuffle sequence, which correspond to destination positions of the shuffle operation. </p><p id="p0182" num="0182">[0120] The concluding loop may be needed for varint-G8CU. It sets the remainder of the shuffle sequence to transfer encoded bytes from the source for the last incomplete integer in the group. The loop has no effect for the other group formats, where rem(desc) is zero. </p><p id="p0183" num="0183">[0121] Embodiments may also compute input offsets. For the unary formats, the input offset may equal the number of block data bytes along with the number of descriptor bytes. For example, the offset would be 9 in the case where there is a block of 8 bytes of data and 1 descriptor byte. For the group binary format, such as varint-GB, the input offset for a given descriptor d may be described as: </p><p id="p0184" num="0184"> 3 
<img id="imgf000030_0001" he="3" wi="7" file="imgf000030_0001.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="no"/>
 which is the sum of the lengths of the integers in the group plus 1 for the descriptor byte. </p><p id="p0185" num="0185">[0122] The output offset for varint-GB and varint-G8IU may equal to num(d) integers, where i may be 4 for varint-GB. The output offset for varint-G8CU may be represented as: </p><p id="p0186" num="0186">4<sup>■</sup> nnm(d) - state + remW) . </p><p id="p0187" num="0187">The state value for the subsequent block may be 0 for varint-GB and varint-G8IU and rem(d) for varint-G8CU. </p><p id="p0188" num="0188">[0123] Some embodiments may utilize specific implementations of the methods described above. For example, the following description provides several specific methods for decoding some of the specific formats discussed above. </p><p id="p0189" num="0189">[0124] In some embodiments, to decode a group of integers (which may be 4 in some embodiments) in varint-GB, the length and shuffle sequence entries may be looked up in a table indicated by the descriptor, the shuffle sequence may be applied to the input data, and the input may be advanced by the length found in the table. The output may advance by the length of 4 integers ( i. e. 16 bytes). This may be shown in following pseudocode. This method may be 
<!-- EPO <DP n="31"/>-->
 applicable and adaptable to other group binary formats and some of the other formats, such as a split unary format. </p><p id="p0190" num="0190">Decodes 4 integers stored, in var -GB format using parallel shuffle. </p><p id="p0191" num="0191"> input : source-position, destination-position </p><p id="p0192" num="0192"> output: writes to d s mation, returns new source position </p><p id="p0193" num="0193"> begin </p><p id="p0194" num="0194"> descriptor first byte of source data </p><p id="p0195" num="0195"> vector register ÷- next 10 bytes of source data </p><p id="p0196" num="0196"> shut3e-sequeii.ee table [descriptor j . shuffle </p><p id="p0197" num="0197"> shuffle vector register using shuffle-sequence </p><p id="p0198" num="0198"> write result from vector register to destination position </p><p id="p0199" num="0199"> return source-position - tahleldescriptor] .offeet </p><p id="p0200" num="0200"> end </p><p id="p0201" num="0201">[0125] A table of lengths and shuffle sequences that may be utilized with the above decoding may be constructed in different ways. In some embodiments, the table has an entry for each possible value of the descriptor byte. Iterating over all possible values of the descriptor byte, the table entry may be constructed for a given descriptor byte value. The length stored in the table may be the sum of the lengths described by each pair of bits in the descriptor byte, plus one to advance past the descriptor byte itself. The shuffle sequence may be built so as to map bytes from the source to the destination, but may be padded with - Is in order to fill each decoded integer with leading zeros up to four bytes. The following may describe one way of constructing such a table. This method of table constraction may be applicable and adaptable to other group binary formats and some of the other formats, such as a split unary format. 
<!-- EPO <DP n="32"/>-->
</p><p id="p0202" num="0202">Construct a single shuffle and, length table entry for the v rint~GD decoder. in ut : descriptor byte value </p><p id="p0203" num="0203"> output: shuffle-sequence , length </p><p id="p0204" num="0204"> begin </p><p id="p0205" num="0205"> length, -s— 1 </p><p id="p0206" num="0206"> soiirce-pos 4- 0 </p><p id="p0207" num="0207"> skuffie-pos 4- 0</p><p id="p0208" num="0208"><img id="imgf000032_0001" he="5" wi="40" file="imgf000032_0001.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="yes"/></p><p id="p0209" num="0209"> leegth-i 4— value of ith pair from descriptor byte + 1 </p><p id="p0210" num="0210"> length — length + lciigth-i</p><p id="p0211" num="0211"><img id="imgf000032_0002" he="5" wi="42" file="imgf000032_0002.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="yes"/></p><p id="p0212" num="0212"> if j &lt; length-i then</p><p id="p0213" num="0213"><img id="imgf000032_0003" he="6" wi="51" file="imgf000032_0003.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="yes"/>
 - sourcc-pos </p><p id="p0214" num="0214"> source-pos 4— souree-pos →- 1 </p><p id="p0215" num="0215"> else </p><p id="p0216" num="0216"> shuffle-sequeace[shiiffle-posj 1 </p><p id="p0217" num="0217"> end </p><p id="p0218" num="0218"> shuffle-pos — sliuffle-pos + 1 </p><p id="p0219" num="0219"> end </p><p id="p0220" num="0220"> ■end </p><p id="p0221" num="0221"> ' J. i ¾ </p><p id="p0222" num="0222">[0126] Decoding varint-G8IU may be somewhat more complicated than decoding varint-GB. Because as many as 8 integers may be encoded in a single block, their decoded form may occupy as many as 32 bytes. Since some architectures, such as the Intel ® 64 XMM vector registers, may only have 16 bytes, two shuffles may be perfonned to produce the full 32 bytes of output. Some embodiments may be able to decode with only one shuffle operation. Rather than checking to see whether the second shuffle is necessary, some embodiments may simply perform both shuffles every time and detennine how much of the output data to keep. The following pseudocode provides one description one such method of decoding 8 bytes in a varint-G81U format: 
<!-- EPO <DP n="33"/>-->
 Decodes 8 bytes stored in varin GS format using two shuffles. </p><p id="p0223" num="0223"> input : source-position, destination-position </p><p id="p0224" num="0224"> output: writes to destination, returns new destination-position </p><p id="p0225" num="0225"> begin </p><p id="p0226" num="0226"> descriptor first byte of source data </p><p id="p0227" num="0227"> vector register *— next 16 bytes of source data </p><p id="p0228" num="0228"> skuffle-sequenee-1 taWe[desaipk»r...shufflel </p><p id="p0229" num="0229"> shuffle- sequence- 2 4— table [descriptor] .shuffle2 </p><p id="p0230" num="0230"> length ÷- tabl kiescriptor] .length </p><p id="p0231" num="0231"> shuffle vector register using shiiffie-sequeiice-l</p><p id="p0232" num="0232"> rite result from vector register to destination-position, </p><p id="p0233" num="0233"> shuffle vector register using shuffle-sequence- 2 </p><p id="p0234" num="0234"> write result, from vector register to destination-position + 16 </p><p id="p0235" num="0235"> return destination- osition + length </p><p id="p0236" num="0236"> end </p><p id="p0237" num="0237">[0127] After decoding one block of varint-G81U, the input may be advanced by 8 bytes, but the output position may advance a variable amount depending on the number of integers decoded. In some embodiments, the vector register may be filled with 16 bytes of input data, even though only 8-byte block may be decoded. This method may be applicable and adaptable to other group unary formats and some of the other formats, such as a split unary format. </p><p id="p0238" num="0238">[0128] In one embodiment, the operation of constructing a shuffle sequence 1320 with positions 1310 for a given descriptor is shown in FIG. 13. This is the same data represented in FIG. 6B. For this example, the descriptor byte contains 1 1001 101 , the output length is 3 4-byte integers. Since only 12 bytes of output are produced, the output of the second shuffle is not needed in this case. The length and shuffle sequence entries may be constructed for a table, one for each possible value of the descriptor byte. The following pseudocode shows one example of how each table entry may be created. This method may copy the byte positions (from 0 to 7) to the shuffle sequence, but each time it encounters a terminal (zero) bit in the descriptor, it may pad the shuffle sequence with enough -1 s to complete the current output integer with leading (most-significant) zero bytes. 
<!-- EPO <DP n="34"/>-->
 Construct the two shuffle sequences for a given table entry for the v rint-G8IU dncadcr. Wc build a pair of adjacent KJ-hyic shuffle scquxmrx-Λ H a single 32-byic sequence. </p><p id="p0239" num="0239"> input : descriptor byte value </p><p id="p0240" num="0240"> output: pair of shuffle: sequences, length </p><p id="p0241" num="0241"> begin</p><p id="p0242" num="0242"><img id="imgf000034_0001" he="5" wi="41" file="imgf000034_0001.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="yes"/></p><p id="p0243" num="0243"> shuffle-sequenctifi 1—— 1 </p><p id="p0244" num="0244"> end </p><p id="p0245" num="0245"> hybcR-rtimai.iiing»in iitcgcr «~ 4 </p><p id="p0246" num="0246"> SGurce-pos 4— 0 </p><p id="p0247" num="0247"> shuffle-pos 4- 0</p><p id="p0248" num="0248"><img id="imgf000034_0002" he="5" wi="39" file="imgf000034_0002.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="yes"/></p><p id="p0249" num="0249"> sliuftie-seq uence [shuffle-pos] 4— source-pos </p><p id="p0250" num="0250"> source-pos 4— source-pos + 1 </p><p id="p0251" num="0251"> ni iffle-pos 4- sliuffle-poH + 1 </p><p id="p0252" num="0252"> if bytcj rnm imrig-in-wt-cger &gt; 0 t hen. </p><p id="p0253" num="0253"> bytes-reinaiiiirig-iii-intoger - - liytes-rcmairiiiig-iii-iiiiegeT— 1 </p><p id="p0254" num="0254"> end </p><p id="p0255" num="0255"> if l†h Ut of descriptor h te = 0 then </p><p id="p0256" num="0256"> shuffle-pos 4- sliuffle-ptjs + In'tes-remaining-iii-irite er </p><p id="p0257" num="0257"> hytes~i'ei.!ii'.iii]iiig-i.n~integer 4— 4 </p><p id="p0258" num="0258"> end </p><p id="p0259" num="0259"> end </p><p id="p0260" num="0260"> sliuffie-sequence-l 4— shufBe-sequeiieej0..15j </p><p id="p0261" num="0261"> sliiiflle-seqiifcai.ee- 2 -f- s hi iff le-s«qi..i tstice [16, ,31] </p><p id="p0262" num="0262"> length 4— number of zeros in descriptor byte </p><p id="p0263" num="0263"> end. </p><p id="p0264" num="0264">[0129] In some embodiments, table entries may be constructed for all possible byte values, but not all byte values may correspond to valid possible descriptors. While valid descriptors may not have more than three consecutive 1 bits (indicating an encoded integer 4 bytes in length), invalid descriptors may. In order to guard against this condition, the "bytes-remaining-in-integer &gt; 0" test may be utilized in the above pseudocode. </p><p id="p0265" num="0265">[0130] Embodiments that involve decoding the varint-G8CU format may involve additional complexity. For example, an integer that does not fit entirely into a data block may be partially written, with its remaining bytes stored in the succeeding data block. For this reason, embodiments with a table for this format used for lengths and shuffle sequences may contain 
<!-- EPO <DP n="35"/>-->
 different data in cases where different numbers of bytes carry over. The table can be viewed as having two dimensions, one indexed by the number of bytes written so far in a partially decoded integer, and the other indexed by the descriptor byte value. In addition, each table entry may contain not only the shuffle sequences and output length, but also the new value of the partial output byte count. Some embodiments may thus utilize a decoding method for one block of varint-G8CU as described in the following pseudo code. </p><p id="p0266" num="0266">Decodes 8 bytes stored in varint-GSCU format using two shuffles. </p><p id="p0267" num="0267"> input : source-position,, partial-output-coiint. destination-position </p><p id="p0268" num="0268"> output: writes to destination, returns new destination-position and new </p><p id="p0269" num="0269"> partial-output-count </p><p id="p0270" num="0270"> begin </p><p id="p0271" num="0271"> descriptor — first byte of source data </p><p id="p0272" num="0272"> vector register *- next 16 bytes of source data </p><p id="p0273" num="0273"> shuffle- sequence- 1 - table [partial-output-countj [descriptor j.sliufflel </p><p id="p0274" num="0274"> shuffle-sequence-2 -r- taMe[partial-output-&lt; nn† d« _iptorl.shnffie2 </p><p id="p0275" num="0275"> length tablejpartial-outpiit-coiintifdescriptor] length </p><p id="p0276" num="0276"> partial-output-count i~ table [partial-output-count] descriptor] .partial-output shuffle vector register rising slmffle-seqiieiiee- 1 </p><p id="p0277" num="0277"> write result from vector register to destination-position </p><p id="p0278" num="0278"> shuffle vector register using sliiiffie-seciience~2 </p><p id="p0279" num="0279"> write result from vector register to destination-position + 16 </p><p id="p0280" num="0280"> return { destination- osition 4- length, partiftl-output-count </p><p id="p0281" num="0281"> end </p><p id="p0282" num="0282">[0131] Table construction for varint-G8CU may be similar to varint-G8IU, but the method may take into account the fact that a number of bytes (referred to here as partial-output-count) for a partially encoded integer may have already been written while decoding the previous block. This may be shown in the following pseudo code that may be utilized to construct shuffle sequences for a table that may be utilized for decoding some fonnats such as varint-G8CU for some embodiments. Because output may no longer be guaranteed to produce complete 32-bit integers, output position may need to be advanced in byte units rather than integers. The length computation in the following pseudocode may reflect this difference. 
<!-- EPO <DP n="36"/>-->
 Construct th,e two .ihmffle sequences for a given table entry for the v rint-GSCU decoder. We build a pair of adjacent 16-byte shuffle apiences as a single -bytr, sequence. </p><p id="p0283" num="0283"> input : descriptor byte value, old-partial-output-couiit </p><p id="p0284" num="0284"> output: pair of shuffle sequences, length, new-partial-output-count </p><p id="p0285" num="0285"> begin </p><p id="p0286" num="0286"> for i from. 0 to SI do </p><p id="p0287" num="0287"> ahtiffle-8equence|i] 1 </p><p id="p0288" num="0288"> end </p><p id="p0289" num="0289"> bytes-reriiaiiiiiig-iii-iiiteger -5— 4— old-partial-output-count </p><p id="p0290" num="0290"> source-pos 0 </p><p id="p0291" num="0291"> shuffle-pas - 0</p><p id="p0292" num="0292"><img id="imgf000036_0001" he="5" wi="39" file="imgf000036_0001.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="yes"/></p><p id="p0293" num="0293"> shuffle-sequencejshufflc-pos} «- source-pos </p><p id="p0294" num="0294"> source-pas - source-pos + 1 </p><p id="p0295" num="0295"> shuffle-pos 4- shuffle-pos + 1 </p><p id="p0296" num="0296"> if bytcs-rrm ivdng-m-integer &gt; 0 then</p><p id="p0297" num="0297"> ytes- remaining-in-integer - r&gt;ytes-remaining-in-iiitcger— 1 end </p><p id="p0298" num="0298"> if itk bit of descriptor byte = 0 then </p><p id="p0299" num="0299"> shuffle-pos e— shuffle-pos + bytns-rcmaining-m-mteger </p><p id="p0300" num="0300"> bvtes-remaining-in-iiiteger 4 </p><p id="p0301" num="0301"> end </p><p id="p0302" num="0302"> end </p><p id="p0303" num="0303"> shuffle-sequenec-l— shuffle-sequencc!O.. IS i </p><p id="p0304" num="0304"> shuffle-sequence- 2 4— shuffle-sequence 16..31] </p><p id="p0305" num="0305"> new-partial-output-count 4- number of leading 1 hits in descriptor byte </p><p id="p0306" num="0306"> length ÷- (4 * zeros in descriptor byte -t- new-partial-output-count) - old-partial-output-count </p><p id="p0307" num="0307"> end </p><p id="p0308" num="0308">[0132] While the above provides several different examples of decoding methods and table construction methods for group formats in accordance with various embodiments, other methods for decoding and table construction may be utilized with in the scope of this disclosure. </p><p id="p0309" num="0309">[0133] Furthermore, the above decoding and/or table construction methods may be utilized by other embodiments that may utilize a parallel shuffle operation and/or a table for decoding other encoding formats, such as a split unary, a split binary, a packed unary, and/or a packed unary format. 
<!-- EPO <DP n="37"/>-->
 [0134] In one embodiment, a method for decoding a split unary format may be provided. </p><p id="p0310" num="0310">Embodiments may utilize a parallel method that may utilize SIMD instructions for decoding this format. Some embodiments may operate on a block of bytes, such as 8 bytes for example, of encoded data at a time. The encoded data may be encoded according to a split unary encoding format. The descriptor bits, which may be continuation bits or termination bits, found in each byte may be extracted or collected in parallel. In some embodiments, this collection process may utilize a SIMD instruction such as PMOVMSKB instruction. For example, a PMOVMSKB instruction may extract the most significant bits from a collection of bytes. Other parallel instructions may also be utilized to collect or extract these bits. The extracted bits, which may be referred to as a descriptor, may be used as an offset into a table of precomputed shuffle sequences. A parallel permutation instruction, such as PSHUFB, using the shuffle sequence may be used to determine how to decode the data. In some embodiments, a series of bit shift operations may be applied to remove or sanitize the original continuation and/or termination bits from the decoded data. A similar method for decoding using a table and a shuffle operation may be utilized for split binary encoded format. Some embodiments may achieve a similar result using an individual step, even in case where a change in byte order occurs. This process may involve pre-computing a shuffle sequence that composes two permutations, where one permutation decodes the format and another permutation changes the byte order. </p><p id="p0311" num="0311">[0135] In some embodiments, methods for constructing tables for a group unary format such as varint-G8IU as discussed above may be utilized to decode a split unary encoded data using a shuffle instruction such as PSHUFB. </p><p id="p0312" num="0312">[0136] FIG. 14 provides a computer-implemented method 1400 for decoding encoded document identification number differences in a search engine posting list in accordance with various embodiments. Method 1400 may be implemented in environments and devices as seen in environment 100 of FIG. 1, for example. Method 1400 may also include and/or utilize aspects of decoding group formats as discussed above, including group formats as described at least with respect to FIGS. 5A-C, 6A-C and/or 7A-C. Under control f one or more computer systems configured with executable instructions, method 1400 includes reading one or more descriptors 1402. Each descriptor includes size information regarding a group of encoded document identification number differences. In some embodiments, encoded document 
<!-- EPO <DP n="38"/>-->
 identification number differences are encoded with a group unary format. Multiple data representing the group of encoded document identification number differences are read 1404, where the group of encoded document identification number differences is linked with the one or more descriptors. One or more shuffle sequences linked with the one or more descriptors from a lookup table are identified 1406. One or more parallel shuffle operations are performed on the multiple data representing the group of encoded document identification number differences using the identified shuffle sequences 1408. The one or more parallel shuffle operations include inserting one or more sequences of zeros into the multiple data. Multiple decoded document identification number differences from the shuffled multiple data representing the group of encoded document identification number differences are determined 1410. </p><p id="p0313" num="0313">[0137] FIG. 15 provides a computer-implemented method 1500 for decoding variable-length data in accordance with various embodiments. Method 1500 may be implemented in </p><p id="p0314" num="0314">environments and devices as seen in environment 100 of FIG. 1, for example. Method 1500 may also include and/or utilize aspects of decoding group formats as discussed above, including group formats as described at least with respect to FIGS. 5A-C, 6A-C and/or 7A-C, and/or method 1400 of FIG. 14. Under control of one or more computer systems configured with executable instructions, method 1500 includes reading one or more blocks of data 1502. Each block of data represents multiple encoded variable-length data. One or more descriptors linked with the one or more blocks of data are read 1504. One or more shuffle sequences linked with the one or more descriptors are identified from a lookup table 1506. One or more shuffle operations are performed on the one or more blocks of data using the one or more identified shuffle sequences 1508. Multiple decoded variable-length data are determined from the shuffled one or more blocks of data 1510. </p><p id="p0315" num="0315">[0138] In some embodiments, performing the one or more shuffle operations includes inserting one or more sequences of zeros into the shuffled one or more blocks of data to represent one or more portions of the one or more blocks of data in a standard format, such as a 32-bit representation of an integer. The one or more data blocks may represent multiple variable-length integers. In some embodiments, the one or more data blocks may represent other variable-length data. 
<!-- EPO <DP n="39"/>-->
[0139] Determining the multiple decoded variable-length data from the shuffled one or more blocks of data may also include determining a partial result from the shuffled one or more blocks of data. A remaining portion associated with the partial result may be determined from another block of data. Such embodiments may utilize complete block variations as discussed above. In some cases, the one or more shuffle operations may include one or more parallel shuffle instructions from a single instruction multiple data (SIMD) processor instruction set. </p><p id="p0316" num="0316">[0140] Some embodiments may include identifying one or more offsets linked with the one or more descriptors. The one or more offsets linked with the one or more descriptors may include an input offset with a fixed size; in some cases, the one or more offsets linked with the one or more descriptors may include an output offset with a variable size The fixed size may depend on a number of bytes included in one or more blocks of data and the one or more descriptors. The one or more offsets linked with the one or more descriptors may include an input offset with a variable size. The variable size may depend on a number of data represented by the block of data. Some embodiments may also include identifying other output offsets. </p><p id="p0317" num="0317">[0141] Embodiments that involve packed formats, such as packed unary or packed binary, may also utilize decoding methods that share some similarities with those discussed above. </p><p id="p0318" num="0318">Embodiments that involve decoding packed formats may include precomputing tables that are used for masking and shifting the bits of the encoded format. In some embodiments that utilize the packed binary format for example, the low order two bits of the first byte can indicate how many bytes may be needed to encode an integer. A method for decoding such a packed binary format may include the following steps. A group of bytes, which may be four in some cases, may be read into contiguous memory. The first byte of the read data may be used to look up in a table of masks. The result may be shifted to the right 2 bits to eliminate the descriptor. A mask may be applied to determine which bytes to keep and output the result. An input pointer may be moved by the amount by the descriptor. </p><p id="p0319" num="0319">[0142] Embodiments that may decode packed formats may avoid conditionals or loops. In some embodiments, shift and mask may be combined into the same statement that writes to the output; this may avoid the need to save a copy of the descriptor. In some embodiments, the masks may just have 1-bits all the way across the bytes that may be wanted, and 0-bits across the bytes that are not wanted. 
<!-- EPO <DP n="40"/>-->
 [0143] A similar method may be utilized in some embodiments to decode packed unary formats. In some embodiments, instead of shifting 2 bits as in the case of packed binary formats, embodiments may shift different amounts according to a table. </p><p id="p0320" num="0320">[0144] Some embodiments may utilize additional auxiliary encoding methods as discussed next. These may be referred to as hybrid encodings or formats. In these hybrid formats, a marker may be used to indicate whether the base form of encoding is used, or a more compressed alternate form. </p><p id="p0321" num="0321">[0145] In some embodiments, a variation of the variable length encoding formats is provided that includes a hybrid of a given compression scheme and a bit vector to save space. In some embodiments, the variable length encoding format may include a group unary format. </p><p id="p0322" num="0322">Embodiments may include detecting if every member of a sequence of upcoming integers or data to be encoded are very small, such that more than one of the integers or data may be encoded into one byte. These integers or data may be stored as a bit vector. For example, the nth bit may represent whether a document at position base + n is in a posting list. A special descriptor value may indicate whether the group of data bytes should be interpreted as using the one of the variable-length integer formats, or as a bit vector. </p><p id="p0323" num="0323">[0146] Embodiments that utilize a bit vector may store data regarding small integers or data in a unary format or sequence. Unary sequences may represent a sequence of small values a, b, c, ... by concatenating the unary representations of a- 1 , b- 1 , c- 1... separated by zeros . Such sequences may be preceded by a byte indicating the length of the sequence representation in bytes. Merely by way of example, runs of integers less than 8 may be packed into unary sequences. A unary sequence may be used when the encoded values for two or more integers fit into a single byte, i.e., their sum is less than or equal to 8. This may guarantee that this form of encoding uses no more space than the corresponding variable length representation from one of the other formats discussed above. </p><p id="p0324" num="0324">[0147] For example, the following hybrid unary sequence methods may be applied to group unary formats including G8IU and G8CU. At each block boundary, one can potentially switch to an alternate encoding in which a sequence of small numbers, which may be delta-gaps in some cases, is encoded as a sequence of unary numbers. The low-order four bits of the descriptor may 
<!-- EPO <DP n="41"/>-->
 be used as the marker 1610, as shown in FIG. 16. For example, if their value is 1111, which would not occur in a valid G8IU or G8CU descriptor, it can indicate that the data bytes are encoded using the alternate compressed form. Other markers may be utilized in some cases to indicate that an alternate compressed form is being used. In this example, the high-order four bits 1615 of the descriptor represent one less than the length in bytes of the unary sequence representation. </p><p id="p0325" num="0325">[0148] Different conditions may be used to determine when to switch from the base to the alternate compressed format. In one embodiment, the encoder looks at the next two integers to be encoded. If the next two integers both would fit into one byte using a unary representation, then a unary sequence starting with those values can be created, and can continues until either the maximum byte length (16) is reached, or until the unary representation of the next delta-gap would exceed 8, the size of one byte in bits. If the two integers would not fit into one byte using a unary representation, then the base encoding (such as G8IU or G8CU, for example)is used for this block. </p><p id="p0326" num="0326">[0149] For example, suppose the next sequence of values to be encoded is: </p><p id="p0327" num="0327">2,1,1 ,4,1 ,1 ,3,1,5,1 ,2,9. The unary encoding of the first two values would be 01 and 0. Since the concatenated values occupy less than a byte, a compressed unary sequence could be used. Each unary value is concatenated until the value 9 is reached, which cannot be represented in one byte in unary. The values prior to the 9 can be stored as one unary sequence, which is shown in FIG. 17. The sequence occupies 22 bits 1720, which require 3 bytes of storage. A marker 1710 of 1 1 1 1 is used to indicate a hybrid format is being used. The high order bits 1715 in the descriptor can be set to 0010, which is one less than 3 in binary. If additional bits are left in the final byte, they are set to 1 1725; high-order Is in the final byte of the sequence are always ignored on decoding, since they represent an unterminated unary value. </p><p id="p0328" num="0328">[0150] In some embodiments, a variation of the variable length encoding formats is provided that includes a hybrid of a given compression scheme and run-length encoding to save space. In some embodiments, the variable length encoding format may include a group unary format.</p><p id="p0329" num="0329">Embodiments may encode a run of similar data, such as a run of all 1 s, by storing the length of the run instead of the values themselves. Merely by way of example, longs runs of the value 1 may occur frequently in some indices. In the context of some product searches, the repetition 
<!-- EPO <DP n="42"/>-->
 may be found because of the repetition of a common word, such as a product type or name. Embodiments may include several different run-length encodings. Some embodiments may include a run with constant-length descriptor. These embodiments may include runs of length between 3 and 258 that may be encoded in a single byte representing length -3. Some embodiments may include a run with variable-length descriptor. These embodiments may include runs of length between 3 and 2<sup>Λ</sup>28 + 2 that may be encoded using a split unary format as discussed above. Some embodiments may include a run of blocks with a constant-length descriptor. These embodiments may include runs of length 8m for m in [1,16] that may be encoded in 4 bits with the binary value m-1. Some embodiments may utilize run-length encoding when the runs of 1 are of length at least 3. This may ensure that the run-length encoding uses no more space than a corresponding variable length representation. </p><p id="p0330" num="0330">[0151] The following provides an example of a hybrid encoding with runs of blocks with constant length descriptor (RBC). This example may be applied to group unary formats, including G8IU and G8CU. </p><p id="p0331" num="0331">[0152] For example, if a particular value is very common in the data, it is possible to achieve high compression by looking for consecutive runs of that value, and storing just the length of the run. In some applications, the value 1 is very common, so the following will specifically represent runs of Is in this fashion. Of course, runs of other constants could be encoded in a similar way. In order to save space, blocks of b consecutive Is can be counted, where b is the granularity of the counter. For the following examples, b will equal 8, though other values of b can clearly be used. </p><p id="p0332" num="0332">[0153] As discussed above, at each block boundary, one can potentially switch to an alternate encoding in which a run of consecutive I s is represented by a count indicating the length of the run. The low-order four bits of the descriptor can used as the marker. For example, as shown in FIG. 18, a marker 1810, represented as 111 1 in this example, which would not occur in a valid G8IU or G8CU descriptor, may be utilize to indicate that the high order bits of the descriptor represent the run length as follows. If the binary value of the high order 4 bits 1815 is v, the length of the run is b * (v + 1). This allows the representation of a run whose length is any multiple of b between b and 16b. 
<!-- EPO <DP n="43"/>-->
 [0154] A compressed RBC encoding may be utilized whenever an upcoming run of b or more Is is seen, for example. The RBC sequence can terminate either when 128 values have been encoded, or when the run of 1 s ends. If the length of an upcoming run of 1 s is not a multiple of b, the largest multiple not exceeding the length of the run can be used, and the remaining values are stored in the next block using the regular base encoding (together with whatever other upcoming values are to be stored in that block). This representation is extremely compact; it does not require any data bytes; all the information is in the descriptor byte. </p><p id="p0333" num="0333">[0155] For example, suppose the next values in the sequence are </p><p id="p0334" num="0334"> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5. Since b=8 and there are at least 8 ones, a run-length- encoded sequence can be constructed. The number of ones in the run is 19, which is 2 * 8 + 3. The nearest multiple of 8 is 16, so the RBC representation for just those 16 can be used. The "2" represents the number of groups 8; the value 2-1=1 can be stored, as shown in FIG. 19 at reference number 1915. And again, a marker 1910, represented as 1111 in this example, is also utilized. </p><p id="p0335" num="0335">[0156] Some embodiments may include a hybrid encoding scheme with run with constant length descriptor (RC). This method applies primarily to split unary format (varint-SU), but could also be combined with group unary or packed unary. The following provides a description of an implementation with split unary, though it may be modified to apply to the other unary formats. </p><p id="p0336" num="0336">[0157] As discussed above, runs of a constant value may be represented by their length. </p><p id="p0337" num="0337">However, for this example, a separate descriptor byte is not utilized in the SU format. Therefore, a value zero may be utilized as a marker 2010 as shown in FIG. 20; this may require that the value zero does not occur in the input (which is the case for delta-gaps in a posting list, for example). Each byte in the encoded representation may either be the initial byte in a varint-SU- encoded integer, or the value zero which is the marker for the RC format. If the value is nonzero, this byte can be the first in a normal SU-encoded integer. If the value is zero, the next byte can be used to store the run length information. Specifically, for a run of length r &gt; 2, the binary value of r-3 is stored in the byte, as shown at reference number 2020. This allows encodings of runs of length from 3 to 258. 
<!-- EPO <DP n="44"/>-->
 [0158] To determine when to use the RC format, the upcoming sequence of values can be examined. If at least the next three values are Is, the entire run of Is (up to 258) can be encoded in the compressed form. Otherwise, the next value in SU format can be stored. The threshold on the minimum length needed to switch to RC format need not be 3; 3 is the minimum threshold that insures that the encoding is more compact than varint-SU. </p><p id="p0338" num="0338">[0159] For example, suppose the next values in the sequence are </p><p id="p0339" num="0339"> 1,1,1 ,1 ,1,1 ,1,1,1,1,1,1,1,1,1,1,1,1,1 ,5. FIG. 21 shows an example of storing this sequence of ones in the RC format. Since the sequence starts with at least three 1 s, the entire sequence of ones can be encoded in RC format. This means storing zeros in the first byte 2110, and the run length of 19, minus 3, in the second byte 2120. The 5 after the run can be stored in the base varint-SU format. </p><p id="p0340" num="0340">[0160] Some embodiments may include a hybrid encoding method with run with variable length descriptor (RV). This method applies primarily to split unary format (varint-SU), but could also be combined with group unary or packed unary. </p><p id="p0341" num="0341">[0161] As discussed above, runs of a constant value can be represented by their length and use the value zero in the first byte as a marker 2210 as seen in FIG. 22; this may require that the value zero does not occur in the input (which is the case for delta-gaps in a posting list, for example). Each byte in the encoded representation may either be the initial byte in a varint-SU- encoded integer, or the value zero which is the marker for the RV format, If the value is nonzero, this byte can be the first in a normal SU-encoded integer. If the value is zero, the next 1 -4 bytes 2220 can be used to store the run length information in varint-SU format. The length of the run is stored, not the values themselves. Again, for a run of length r &gt; 2, the binary value of r-3 can be stored in the encoded representation. Because varint-SU can store integers up to 2<sup>A</sup>28-1 in four bytes, this allows encodings of runs of length from 3 to 2<sup>A</sup>28 + 2. </p><p id="p0342" num="0342">[0162] The criteria for deciding whether to use the RV format can be the same as for the RC format: The upcoming sequence of values can be examined. If at least the next three values are I s, the entire run of 1 s (up to 2<sup>A</sup>28 + 2) can be encoded in the compressed form. Otherwise, the next value can be stored in SU format. The threshold on the minimum length needed to switch 
<!-- EPO <DP n="45"/>-->
 to RV format need not be 3; 3 is the minimum threshold that insures that the encoding is more compact than varint-SU. </p><p id="p0343" num="0343">[0163] For example, suppose the next values in the sequence are 300 ones followed by a different number. Since the sequence starts with at least three Is, the entire sequence can be encoded in RV format. This means storing zero in the first byte, and the run length of 300, minus 3, in varint-SU form. FIG. 23 shows an example of storing 300 ones in the RV format. The right most byte represents the marker byte 2310 and the 2<sup>nd</sup> and 3<sup>ld</sup> bytes to the left 2320 represent the quantity 297 in varint-SU format. </p><p id="p0344" num="0344">[0164] As discussed above, the various embodiments can be implemented in a wide variety of operating environments, which in some cases can include one or more user computers, computing devices, or processing devices which can be used to operate any of a number of applications. User or client devices can include any of a number of general purpose personal computers, such as desktop or laptop computers running a standard operating system, as well as cellular, wireless, and handheld devices running mobile software and capable of supporting a number of networking and messaging protocols. Such a system also can include a number of workstations running any of a variety of commercially-available operating systems and other known applications for purposes such as development and database management. These devices also can include other electronic devices, such as dummy terminals, thin-clients, gaining systems, and other devices capable of communicating via a network. </p><p id="p0345" num="0345">[0165] Various aspects also can be implemented as part of at least one service or Web service, such as may be part of a service-oriented architecture. Services such as Web services can communicate using any appropriate type of messaging, such as by using messages in extensible markup language (XML) format and exchanged using an appropriate protocol such as SOAP (derived from the "Simple Object Access Protocol"). Processes provided or executed by such services can be written in any appropriate language, such as the Web Services Description Language (WSDL). Using a language such as WSDL allows for functionality such as the automated generation of client-side code in v arious SOAP frameworks. </p><p id="p0346" num="0346">[0166] Most embodiments utilize at least one network that would be familiar to those skilled in the art for supporting communications using any of a variety of commercially-available 
<!-- EPO <DP n="46"/>-->
 protocols, such as TCP/IP, OSI, FTP, UPnP, NFS, CIFS, and AppleTalk. The network can be, for example, a local area network, a wide-area network, a virtual private network, the Internet, an intranet, an extranet, a public switched telephone network, an infrared network, a wireless network, and any combination thereof. </p><p id="p0347" num="0347">[0167] In embodiments utilizing a Web server, the Web server can run any of a variety of server or mid-tier applications, including HTTP servers, FTP servers, CGI servers, data servers, Java servers, and business application servers. The server(s) also may be capable of executing programs or scripts in response requests from user devices, such as by executing one or more Web applications that may be implemented as one or more scripts or programs written in any programming language, such as Java®, C, C# or C++, or any scripting language, such as Perl, Python, or TCL, as well as combinations thereof. The server(s) may also include database servers, including without limitation those commercially available from Oracle<sup>®</sup>, Microsoft<sup>®</sup>, Sybase®, and IBM<sup>®</sup>. </p><p id="p0348" num="0348">[0168] The environment can include a variety of data stores and other memory and storage media as discussed above. These can reside in a variety of locations, such as on a storage medium local to (and/or resident in) one or more of the computers or remote from any or all of the computers across the network. In a particular set of embodiments, the information may reside in a storage-area network ("SAN") familiar to those skilled in the art. Similarly, any necessary files for performing the functions attributed to the computers, servers, or other network devices may be stored locally and/or remotely, as appropriate. Where a system includes computerized devices, each such device can include hardware elements that may be electrically coupled via a bus, the elements including, for example, at least one central processing unit (CPU), at least one input device (e.g., a mouse, keyboard, controller, touch screen, or keypad), and at least one output device (e.g., a display device, printer, or speaker). Such a system may also include one or more storage devices, such as disk drives, optical storage devices, and solid- state storage devices such as random access memory ("RAM") or read-only memory ("ROM"), as well as removable media devices, memory cards, flash cards, etc. </p><p id="p0349" num="0349">[0169] Such devices also can include a computer-readable storage media reader, a </p><p id="p0350" num="0350">communications device (e.g., a modem, a network card (wireless or wired), an infrared communication device, etc.), and working memory as described above. The computer- readabl e 
<!-- EPO <DP n="47"/>-->
 storage media reader can be connected with, or configured to receive, a computer-readable storage medium, representing remote, local, fixed, and/or removable storage devices as well as storage media for temporarily and/or more permanently containing, storing, transmitting, and retrieving computer-readable information. The system and various devices also typically will include a number of software applications, modules, services, or other elements located within at least one working memory device, including an operating system and application programs, such as a client application or Web browser. It should be appreciated that alternate embodiments may have numerous variations from that described above. For example, customized hardware might also be used and/or particular elements might be implemented in hardware, software (including portable software, such as applets), or both. Further, connection to other computing devices such as network input/output devices may be employed. </p><p id="p0351" num="0351"> [0170] Storage media and computer readable media for containing code, or portions of code, can include any appropriate media known or used in the art, including storage media and communication media, such as but not limited to volatile and non- volatile, removable and nonremovable media implemented in any method or technology for storage and/or transmission of information such as computer readable instructions, data structures, program modules, or other data, including RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disk (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by the a system device. Based on the disclosure and teachings provided herein, a person of ordinary skill in the art will appreciate other ways and/or methods to implement the various embodiments. </p><p id="p0352" num="0352"> [0171 ] The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. It will, however, be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims. </p><p id="p0353" num="0353">Clauses: </p><p id="p0354" num="0354">Clause 1. A computer-implemented method for decoding encoded document identification numbers differences in a search engine posting list comprising: 
<!-- EPO <DP n="48"/>-->
 under control of one or more computer systems configured with executable instructions, reading one or more descriptors, each descriptor including information regarding a plurality of size information regarding a group of encoded document identification number differences; </p><p id="p0355" num="0355"> reading a plurality of data representing the group of encoded document identification number differences linked with the one or more descriptors; </p><p id="p0356" num="0356"> identifying one or more shuffle sequences linked with the one or more descriptors from a lookup table; </p><p id="p0357" num="0357"> performing one or more parallel shuffle operations on the plurality of data representing the group of encoded document identification number differences using the identified shuffle sequences, wherein the one or more parallel shuffle operations includes inserting one or more sequences of zeros into the plurality of data; </p><p id="p0358" num="0358"> determining a plurality of decoded document identification number differences from the shuffled plurality of data representing the group of encoded document identification number differences. </p><p id="p0359" num="0359">Clause 2. The computer-implemented method for decoding encoded document identification numbers in a search engine posting list of Clause 1 wherein the encoded document identification number differences are encoded with a group unary format. </p><p id="p0360" num="0360">Clause 3. A computer-implemented method for decoding variable-length data comprising: </p><p id="p0361" num="0361"> under control of one or more computer systems configured with executable instructions, reading one or more blocks of data, each block of data including a plurality of encoded variable-length data; </p><p id="p0362" num="0362"> reading one or more descriptors linked with the one or more blocks of data; </p><p id="p0363" num="0363"> identifying one or more shuffle sequences linked with the one or more descriptors from a lookup table; </p><p id="p0364" num="0364"> performing one or more shuffle operations on the one or more blocks of data using the one or more identified shuffle sequences; and </p><p id="p0365" num="0365"> determining a plurality of decoded variable-length data from the shuffled one or more blocks of data. 
<!-- EPO <DP n="49"/>-->
 Clause 4. The computer-implemented method for decoding variable-length data of Clause 3 wherein performing the one or more shuffle operations further comprises inserting one or more sequences of zeros into the shuffled one or more blocks of data to represent one or more portions of the one or more blocks of data in a standard format. </p><p id="p0366" num="0366">Clause 5. The computer-implemented method for decoding variable-length data of Clause 3 wherein the one or more data blocks represent a plurality of variable-length integers. </p><p id="p0367" num="0367">Clause 6. The computer-implemented method for decoding variable-length data of Clause 3 wherein determining the plurality of decoded variable-length data from the shuffled one or more blocks of data further comprises: </p><p id="p0368" num="0368"> determining a partial result from the shuffled one or more blocks of data, wherein a remaining portion associated with the partial result is determined from another block of data. </p><p id="p0369" num="0369">Clause 7. The computer-implemented method for decoding variable-length data of Clause 3 wherein the one or more shuffle operations comprises one or more parallel shuffle instructions from a single instruction multiple data (SIMD) processor instruction set. </p><p id="p0370" num="0370">Clause 8. The computer-implemented method for decoding variable-length data of Clause 3 further comprising: </p><p id="p0371" num="0371"> identifying one or more offsets linked with the one or more descriptors. </p><p id="p0372" num="0372">Clause 9. The computer-implemented method for decoding variable-length data of Clause 8 wherein the one or more offsets linked with the one or more descriptors comprise an input offset with a fixed size and an output offset of a variable size. </p><p id="p0373" num="0373">Clause 10. The computer-implemented method for decoding variable-length data of Clause 8 wherein the one or more offsets linked with the one or more descriptors comprise an input offset with a variable size. </p><p id="p0374" num="0374">Clause 1 1. A system for decoding variable-length data comprising. </p><p id="p0375" num="0375">comprising: 
<!-- EPO <DP n="50"/>-->
 a processor; and </p><p id="p0376" num="0376"> a memory device including instructions that, when executed by the processor, cause the system to: </p><p id="p0377" num="0377"> read one or more blocks of data, each block of data including a plurality of encoded variable-length data; </p><p id="p0378" num="0378"> read one or more descriptors linked with the one or more blocks of data; identify one or more shuffle sequences linked with the one or more descriptors from a lookup table; </p><p id="p0379" num="0379"> perform one or more shuffle operations on the one or more blocks of data using the one or more identified shuffle sequences; and </p><p id="p0380" num="0380"> determine a plurality of decoded variable-length data from the shuffled one or more blocks of data. </p><p id="p0381" num="0381">Clause 12. The system for decoding variable-length data of Clause 11 wherein performing the one or more shuffle operations further comprises inserting one or more sequences of zeros into the shuffled one or more blocks of data to represent one or more portions of the one or more blocks of data in a standard format. </p><p id="p0382" num="0382">Clause 13. The system for decoding variable-length data of Clause 1 1 wherein the one or more data blocks represent a plurality of variable-length integers. </p><p id="p0383" num="0383">Clause 14. The system for decoding variable-length data of Clause 11 wherein determining a plurality of decoded variable-length data from the shuffled one or more blocks of data further comprises: </p><p id="p0384" num="0384"> determining a partial result from the shuffled one or more blocks of data, wherein a remaining portion associated with the partial result is determined from another block of data. </p><p id="p0385" num="0385">Clause 15. The system for decoding variable-length data of Clause 11 wherein the one or more shuffle operations comprises one or more parallel shuffle instructions from a single instruction multiple data (SIMD) processor instruction set. </p><p id="p0386" num="0386">Clause 16. The system for decoding variable-length data of Clause 11 further comprising: 
<!-- EPO <DP n="51"/>-->
 identifying one or more offsets linked with the one or more descriptors. </p><p id="p0387" num="0387">Clause 17. The system for decoding variable-length data of Clause 16 wherein the one or more offsets linked with the one or more descriptors includes an input offset with a fixed size and an output offset of variable size. </p><p id="p0388" num="0388">Clause 18. The system for decoding variable-length data of Clause 16 wherein the one or more offsets linked with the one or more blocks of data comprise an input offset with a variable size. </p><p id="p0389" num="0389">Clause 19. A non-transitory computer readable storage medium storing instructions for decoding variable-length data comprising, the instructions when executed by a processor causing the processor to: </p><p id="p0390" num="0390"> read one or more blocks of data, each block of data including a plurality of encoded variable-length data; </p><p id="p0391" num="0391"> read one or more descriptors linked with the one or more blocks of data; </p><p id="p0392" num="0392"> identify one or more shuffle sequences linked with the one or more descriptors from a lookup table; </p><p id="p0393" num="0393"> perform one or more shuffle operations on the one or more blocks of data using the one or more identified shuffle sequences; and </p><p id="p0394" num="0394"> determine a plurality of decoded variable-length data from the shuffled one or more blocks of data. </p><p id="p0395" num="0395">Clause 20. The non-transitory computer readable storage medium of Clause 19 wherein performing the one or more shuffle operations further comprises inserting one or more sequences of zeros into the shuffled one or more block of data to represent one or more portions of the one or more blocks of data in a standard format. </p><p id="p0396" num="0396">Clause 21. The non-transitory computer readable storage medium of Clause 19 wherein the one or more data blocks represent a plurality of variable-length integers. 
<!-- EPO <DP n="52"/>-->
 Clause 22. The non-transitory computer readable storage medium of Clause 19 wherein determining a plurality of decoded variable-length data from the shuffled one or more blocks of data further comprises: </p><p id="p0397" num="0397"> determining a partial result from the shuffled one or more blocks of data, wherein a remaining portion associated with the partial result is determined from another block of data. </p><p id="p0398" num="0398">Clause 23. The non-transitory computer readable storage medium of Clause 19 wherein the one or more shuffle operations comprises one or more parallel shuffle instructions from a single instruction multiple data (SIMD) processor instruction set. </p><p id="p0399" num="0399">Clause 24. The non- transitory computer readable storage medium of Clause 19 further comprising: </p><p id="p0400" num="0400"> identifying one or more offsets linked with the one or more descriptors, wherein the one or more offsets linked with the one or more descriptors comprise an input offset with a fixed size and an output offset with a variable size. </p><p id="p0401" num="0401">Clause 25. The non-transitory computer readable storage medium of Clause 19 further comprising: </p><p id="p0402" num="0402"> identifying one or more offsets linked with the one or more descriptors, wherein the one or more offsets linked with the one or more descriptors comprise an input offset with a variable size. </p><p id="p0403" num="0403">Clause 26. A computer-implemented method for encoding document identification numbers for a search engine posting list comprising: </p><p id="p0404" num="0404"> under control of one or more computer systems configured with executable instructions, determine a block size for data storage; </p><p id="p0405" num="0405"> receiving a plurality of document identification numbers for the search engine posting list; </p><p id="p0406" num="0406"> determining differences between adjacent document identification numbers: determine an encoded representation of each document identification number difference, wherein the encoded representations of the document identification number differences uses variable-length representations; 
<!-- EPO <DP n="53"/>-->
 identifying a sequential subset of the plurality of encoded representations of the document identification number differences, wherein a sum of respective sizes of the encoded representation of each document identification number difference of the sequential subset being less than or equal to the determined block size for data storage; </p><p id="p0407" num="0407"> generating one or more descriptors, the descriptors providing information regarding the number of encoded representations of document identification number differences in the subset of encoded representations of document identification number differences and the size of each respective encoded representation of a respective document identification number difference in the sequential subset; and </p><p id="p0408" num="0408"> storing the one or more descriptors and the subset of encoded representations of the document identification differences, wherein the sequential subset of encoded representations of document identification number differences is stored as a group and the one or more descriptors are stored contiguous with the group of encoded representations of document identification number differences. </p><p id="p0409" num="0409">Clause 27. The computer-implemented method for encoding document identification numbers for the search engine posting list of Clause 26 , wherein the one or more descriptors represents the size of each respective encoded representation of a respective document identification number difference of the sequential subset with a unary representation of each respective size. </p><p id="p0410" num="0410">Clause 28. A computer-implemented method for encoding data using variable-length representations comprising: </p><p id="p0411" num="0411"> under control of one or more computer systems configured with executable instructions, determining a block size for data storage; </p><p id="p0412" num="0412"> identifying a plurality of data items; </p><p id="p0413" num="0413"> determining an encoded representation of each data item, wherein the encoded representations of the data items uses variable-length representations; </p><p id="p0414" num="0414"> identifying a first subset of the plurality of encoded representations of the data items, wherein a sum of respective sizes of the encoded representations o the data items from the first subset of the plurality of encoded representations of data items is less than or equal to the determined block size for data storage; 
<!-- EPO <DP n="54"/>-->
 generating a first descriptor, the first descriptor representing the respective sizes of the encoded representations of the data items of the first subset of the plurality of encoded representations of the data items; </p><p id="p0415" num="0415"> storing the encoded representations of the data items from the first subset of the plurality of encoded representations of the data items as a first stored group; and </p><p id="p0416" num="0416"> storing the first descriptor. </p><p id="p0417" num="0417">Clause 29. The computer-implemented method of encoding data using variable-length representations of Clause 28, wherein storing the first descriptor comprises storing the first descriptor contiguous with the first stored grouped. </p><p id="p0418" num="0418">Clause 30. The computer-implemented method of encoding data using variable-length representations of Clause 28, wherein storing the first descriptor comprises storing the first descriptor non-contiguous with the first stored grouped. </p><p id="p0419" num="0419">Clause 31. The computer-implemented method of encoding data using variable-length representations of Clause 28, wherein generating the first descriptor includes representing the size of each respective encoded representation for each data item in a unary format. </p><p id="p0420" num="0420">Clause 32. The computer-implemented method of encoding data using variable-length representations of Clause 31 , wherein representing the size of each respective encoded representation for each data item in the unary format includes generating the unary format that describes the respective size of each encoded representation for each data item as a unary size minus one and separates the representation of each respective size by a zero. </p><p id="p0421" num="0421">Clause 34. The computer-implemented method of encoding data using variable-length representations of Clause 31, wherein generating the first descriptor includes inserting padding information into the first descriptor representing a difference in size between the first subset and the block size of data. </p><p id="p0422" num="0422">Clause 34. The computer-implemented method of encoding data using variable-length representations of Clause 28, further comprising: </p><p id="p0423" num="0423"> identifying an additional encoded representation of a respective data item from the plurality of encoded representations of the data items; 
<!-- EPO <DP n="55"/>-->
 storing at least at least a first portion of the additional encoded representation of the respective data item as part of the first stored grouped; and </p><p id="p0424" num="0424"> storing at least a second portion of the additional encoded representation of the respective data item as part of a second stored group. </p><p id="p0425" num="0425">Clause 35. The computer-implemented method of encoding data using variable-length representations of Clause 34, further comprising: </p><p id="p0426" num="0426"> generating a second descriptor, the second descriptor representing in part the length of at least the second portion of the additional encoded representation for the respective data item as part of the second stored group. </p><p id="p0427" num="0427">Clause 36. The computer- implemented method of encoding data using variable-length representations of Clause 28, wherein the data items are delta-gaps. </p><p id="p0428" num="0428">Clause 37. A system for encoding data using variable-length representations, comprising: </p><p id="p0429" num="0429"> a processor; and </p><p id="p0430" num="0430"> a memory device including instructions that, when executed by the processor, cause the system to: </p><p id="p0431" num="0431"> determine a block size for data storage; </p><p id="p0432" num="0432"> identify a plurality of data items; </p><p id="p0433" num="0433"> determine an encoded representation of each data item, wherein the encoded representations of the data items uses variable-length representations; </p><p id="p0434" num="0434"> identify a first subset of the plurality of encoded representations of the data items, wherein a sum of respective sizes of the encoded representations of the data items from the first subset of the plurality of encoded representations of data items is less than or equal to the determined block size for data storage; </p><p id="p0435" num="0435"> generate a first descriptor, the first descriptor representing the respective sizes of the encoded representations of the data items of the first subset of the plurality of encoded representations of the data items; </p><p id="p0436" num="0436"> store the encoded representations of the data items from the first subset of the plurality of encoded representations of the data items as a first stored group; and </p><p id="p0437" num="0437"> store the first descriptor. 
<!-- EPO <DP n="56"/>-->
 Clause 38. The system for encoding data using variable-length representations of Clause 37, wherein storing the first descriptor comprises storing the first descriptor contiguous with the first stored group. </p><p id="p0438" num="0438">Clause 39. The system for encoding data using variable-length representations of Clause 37, wherein storing the first descriptor comprises storing the first descriptor noncontiguous with the first stored group. </p><p id="p0439" num="0439">Clause 40. The system for encoding data using variable-length representations of Clause 37, wherein generating the first descriptor includes representing the size of each respective encoded representation for each data item in a unary format. </p><p id="p0440" num="0440">Clause 41. The system for encoding data using variable-length representations of Clause 40, wherein representing the size of each respective encoded representation for each data item in the unary format includes generating the unary format that describes the respective size of each encoded representation of a respective data item as the unary size minus one and separates the representation of each respective size by a zero. </p><p id="p0441" num="0441">Clause 42. The system for encoding data using variable-length representations of Clause 37, wherein generating the first descriptor includes inserting padding information into the first descriptor representing a difference in size between the first subset and the block size of data. </p><p id="p0442" num="0442">Clause 43. The system for encoding data using variable-length representations of Clause 37, further comprising: </p><p id="p0443" num="0443"> identifying an additional encoded representation of a respective data item from the plurality of encoded representations of the data items; </p><p id="p0444" num="0444"> storing at least at least a first portion of the additional encoded representation of the respective data item as part of the first stored group; and </p><p id="p0445" num="0445"> storing at least a second portion of the additional encoded representation of the respective data item as part of a second stored group. </p><p id="p0446" num="0446">Clause 44. The system for encoding data using variable-length representations of Clause 43, further comprising: 
<!-- EPO <DP n="57"/>-->
 generating a second descriptor, the second descriptor representing in part the length of at least the second portion of the additional encoded representation of the respective data item as part of the second stored group. </p><p id="p0447" num="0447">Clause 45. A non-transitory computer readable storage medium storing instructions for encoding data using variable-length representations, the instructions when executed by a processor causing the processor to: </p><p id="p0448" num="0448"> determine a block size for data storage; </p><p id="p0449" num="0449"> identify a plurality of variable-length data; </p><p id="p0450" num="0450"> determine an encoded representation of each data item, wherein the encoded representations of the data items uses variable-length representations; </p><p id="p0451" num="0451"> identify a first subset of the plurality of encoded representations of the data items, wherein a sum of respective sizes of the encoded representations of the data items from the first subset of the plurality of encoded representations of data items is less than or equal to the determined block size for data storage; </p><p id="p0452" num="0452"> generate a first descriptor, the first descriptor representing the respective sizes of the encoded representations of the data i tems of the first subset of the plurality of encoded representations of the data items; </p><p id="p0453" num="0453"> store the encoded representations of the data items from the first subset of the plurality of encoded representations of the data items as a first stored group; and </p><p id="p0454" num="0454"> store the first descriptor. </p><p id="p0455" num="0455">Clause 46. The non-transitory computer readable storage medium of Clause 45, wherein storing the first descriptor comprises storing the first descriptor contiguous with the first stored group. </p><p id="p0456" num="0456">Clause 47. The non-transitory computer readable storage medium of Clause 45, wherein storing the first descriptor comprises storing the first descriptor non-contiguous with the first stored group. </p><p id="p0457" num="0457">Clause 48. The non-transitory computer readable storage medium of Clause 45, wherein generating the first descriptor includes representing the size of each respective encoded representation for each data item in a unary format. 
<!-- EPO <DP n="58"/>-->
 Clause 49. The non-transitory computer readable storage medium of Clause 48, wherein representing the size of each respective encoded representation for each data item in the unary format includes generating the unary format that describes the respective size of each encoded representation for each data item as the unary size minus one and separates the representation of each respective size by a zero. </p><p id="p0458" num="0458">Clause 50. The non-transitory computer readable storage medium of Clause 45, further comprising: </p><p id="p0459" num="0459"> identifying an additional encoded representation of a respective data item from the plurality of encoded representations of the data items; </p><p id="p0460" num="0460"> storing at least at least a first portion of the additional encoded representation of the respective data item as part of the first stored grouped; and </p><p id="p0461" num="0461"> storing at least a second portion of the additional encoded representation of the respective data item as part of a second stored group. </p><p id="p0462" num="0462">Clause 51. The non-transitory computer readable storage medium of Clause 50, further comprising: </p><p id="p0463" num="0463"> generating a second descriptor, the second descriptor representing in part the length of at least the second portion of the additional encoded representation of the respective data item as part of the second stored group. 
</p></description><claims mxw-id="PCLM44725895" ref-ucid="WO-2012116086-A1" lang="EN" load-source="patent-office"><claim id="clm-0001" num="1"><!-- EPO <DP n="59"/>--><claim-text/><claim-text>WHAT IS CLAIMED IS: L A system for decoding variable-length data comprising, comprising: </claim-text><claim-text> a processor; and </claim-text><claim-text> a memory device including instructions that, when executed by the processor, cause the system to: </claim-text><claim-text> read one or more blocks of data, each block of data including a plurality of encoded variable-length data; </claim-text><claim-text> read one or more descriptors linked with the one or more blocks of data; identify one or more shuffle sequences linked with the one or more descriptors from a lookup table; </claim-text><claim-text> perform one or more shuffle operations on the one or more blocks of data using the one or more identified shuffle sequences; and </claim-text><claim-text> determine a plurality of decoded variable-length data from the shuffled one or more blocks of data. </claim-text></claim><claim id="clm-0002" num="2"><claim-text>2. The system for decoding variable-length data of claim 1 wherein performing the one or more shuffle operations further comprises inserting one or more sequences of zeros into the shuffled one or more blocks of data to represent one or more portions of the one or more blocks of data in a standard format. </claim-text></claim><claim id="clm-0003" num="3"><claim-text>3. The system for decoding variable-length data of claim 1 wherein the one or more data blocks represent a plurality of variable-length integers. </claim-text></claim><claim id="clm-0004" num="4"><claim-text>4. The system for decoding variable-length data of claim 1 wherein determining a plurality of decoded variable-length data from the shuffled one or more blocks of data further comprises: </claim-text><claim-text> determining a partial result from the shuffled one or more blocks of data, wherein a remaining portion associated with the partial result is determined from another block of data. </claim-text></claim><claim id="clm-0005" num="5"><claim-text>5. The system for decoding variable-length data of claim 1 wherein the one or more shuffle operations comprises one or more parallel shuffle instructions from a single instruction multiple data (SIMD) processor instruction set. <!-- EPO <DP n="60"/>--> </claim-text></claim><claim id="clm-0006" num="6"><claim-text>6. The system for decoding variable-length data of claim 1 further comprising: </claim-text><claim-text> identifying one or more offsets linked with the one or more descriptors. </claim-text></claim><claim id="clm-0007" num="7"><claim-text>7. The system for decoding variable-length data of claim 6 wherein the one or more offsets linked with the one or more descriptors includes an input offset with a fixed size and an output offset of variable size. </claim-text></claim><claim id="clm-0008" num="8"><claim-text>8. The system for decoding variable-length data of claim 6 wherein the one or more offsets linked with the one or more blocks of data comprise an input offset with a variable size. </claim-text></claim><claim id="clm-0009" num="9"><claim-text>9. A computer-implemented method for encoding data using variable-length representations comprising: </claim-text><claim-text> under control of one or more computer systems configured with executable instructions, determining a block size for data storage; </claim-text><claim-text> identifying a plurality of data items; </claim-text><claim-text> determining an encoded representation of each data item, wherein the encoded representations of the data items uses variable-length representations; </claim-text><claim-text> identifying a first subset of the plurality of encoded representations of the data items, wherein a sum of respective sizes of the encoded representations of the data items from the first subset of the plurality of encoded representations of data items is less than or equal to the determined block size for data storage; </claim-text><claim-text> generating a first descriptor, the first descriptor representing the respective sizes of the encoded representations of the data items of the first subset of the plurality of encoded representations of the data items; </claim-text><claim-text> storing the encoded representations of the data items from the first subset o the plurality of encoded representations of the data items as a first stored group; and </claim-text><claim-text> storing the first descriptor. </claim-text></claim><claim id="clm-0010" num="10"><claim-text>10. The computer-implemented method of encoding data using variable- length representations of claim 9, wherein storing the first descriptor comprises storing the first descriptor contiguous with the first stored grouped. <!-- EPO <DP n="61"/>--> </claim-text></claim><claim id="clm-0011" num="11"><claim-text>11. The computer-implemented method of encoding data using variable- length representations of claim 9, wherein storing the first descriptor comprises storing the first descriptor non-contiguous with the first stored grouped. </claim-text></claim><claim id="clm-0012" num="12"><claim-text>12. The computer-implemented method of encoding data using variable- length representations of claim 9, wherein generating the first descriptor includes representing the size of each respective encoded representation for each data item in a unary format. </claim-text></claim><claim id="clm-0013" num="13"><claim-text>13. The computer-implemented method of encoding data using variable- length representations of claim 12, wherein representing the size of each respective encoded representation for each data item in the unary format includes generating the unary format that describes the respective size of each encoded representation for each data item as a unary size minus one and separates the representation of each respective size by a zero. </claim-text></claim><claim id="clm-0014" num="14"><claim-text>14. The computer-implemented method of encoding data using variable- length representations of claim 12, wherein generating the first descriptor includes inserting padding information into the first descriptor representing a difference in size between the first subset and the block size of data. </claim-text></claim><claim id="clm-0015" num="15"><claim-text>15. The computer-implemented method of encoding data using variable- length representations of claim 9, further comprising: </claim-text><claim-text> identifying an additional encoded representation of a respective data item from the plurality of encoded representations of the data items; </claim-text><claim-text> storing at least at least a first portion of the additional encoded representation of the respective data item as part of the first stored grouped; and </claim-text><claim-text> storing at least a second portion of the additional encoded representation of the respective data item as part of a second stored group. </claim-text></claim></claims><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
