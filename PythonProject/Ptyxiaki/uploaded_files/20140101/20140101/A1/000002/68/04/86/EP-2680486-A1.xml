<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2680486-A1" country="EP" doc-number="2680486" kind="A1" date="20140101" family-id="46514279" file-reference-id="204583" date-produced="20180824" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146549202" ucid="EP-2680486-A1"><document-id><country>EP</country><doc-number>2680486</doc-number><kind>A1</kind><date>20140101</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-12305788-A" is-representative="YES"><document-id mxw-id="PAPP154823125" load-source="docdb" format="epo"><country>EP</country><doc-number>12305788</doc-number><kind>A</kind><date>20120629</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140452404" ucid="EP-12305788-A" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>12305788</doc-number><kind>A</kind><date>20120629</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1988108412" load-source="ipcr">H04L   9/30        20060101ALI20121023BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1988112436" load-source="ipcr">H04L   9/08        20060101AFI20121023BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL1988099428" load-source="docdb" scheme="CPC">H04L2209/76        20130101 LA20131024BHEP        </classification-cpc><classification-cpc mxw-id="PCL1988108053" load-source="docdb" scheme="CPC">H04L2209/60        20130101 LA20131015BHEP        </classification-cpc><classification-cpc mxw-id="PCL1988110077" load-source="docdb" scheme="CPC">H04L   9/0894      20130101 LI20131025BHEP        </classification-cpc><classification-cpc mxw-id="PCL1988922617" load-source="docdb" scheme="CPC">H04L   9/08        20130101 FI20140103BHEP        </classification-cpc><classification-cpc mxw-id="PCL1988925825" load-source="docdb" scheme="CPC">H04L   9/30        20130101 LI20140103BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132180090" lang="DE" load-source="patent-office">Schlüsselverwaltung</invention-title><invention-title mxw-id="PT132180091" lang="EN" load-source="patent-office">Key management</invention-title><invention-title mxw-id="PT132180092" lang="FR" load-source="patent-office">Gestion de clé</invention-title><citations><non-patent-citations><nplcit><text>ACM TRANSACTIONS ON INFORMATION AND SYSTEM SECURITY vol. 9, no. 1, February 2006, pages 1 - 30</text><sources><source mxw-id="PNPL45130846" load-source="docdb" name="APP"/></sources></nplcit><nplcit><text>BENOIT LIBERT; DAMIEN VERGNAUD: 'Public Key Cryptography', vol. 4939, 2008, SPRINGER article 'Unidirectional chosen-ciphertext secure proxy re-encryption', pages 360 - 379</text><sources><source mxw-id="PNPL45130847" load-source="docdb" name="APP"/></sources></nplcit><nplcit><text>CHUNBO MA ET AL: "Group-Based Proxy Re-encryption Scheme", 16 September 2009 (2009-09-16), EMERGING INTELLIGENT COMPUTING TECHNOLOGY AND APPLICATIONS, SPRINGER BERLIN HEIDELBERG, BERLIN, HEIDELBERG, PAGE(S) 1025 - 1034, XP019140602, ISBN: 978-3-642-04069-6 * the whole document *</text><sources><source mxw-id="PNPL45130848" load-source="docdb" name="SEA" category="I"/></sources></nplcit><nplcit><text>QIANG TANG ET AL: "Inter-domain Identity-Based Proxy Re-encryption", 14 December 2008 (2008-12-14), INFORMATION SECURITY AND CRYPTOLOGY, SPRINGER BERLIN HEIDELBERG, BERLIN, HEIDELBERG, PAGE(S) 332 - 347, XP019117004, ISBN: 978-3-642-01439-0 * the whole document *</text><sources><source mxw-id="PNPL45130849" load-source="docdb" name="SEA" category="I"/></sources></nplcit><nplcit><text>XIAOHUI LIANG ET AL:  "Attribute Based Proxy Re-encryption with Delegating Capabilities", ACM, 2 PENN PLAZA, SUITE 701 - NEW YORK USA, 12 March 2009 (2009-03-12), XP040465600, Sydney</text><sources><source mxw-id="PNPL45130850" load-source="docdb" name="SEA" category="I"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR918173449" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>ORANGE</last-name><address><country>FR</country></address></addressbook></applicant><applicant mxw-id="PPAR918137549" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>ORANGE</last-name></addressbook></applicant><applicant mxw-id="PPAR918985535" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Orange</last-name><iid>101394618</iid><address><street>78, rue Olivier de Serres</street><city>75015 Paris</city><country>FR</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR918140751" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>CANARD SEBASTIEN</last-name><address><country>FR</country></address></addressbook></inventor><inventor mxw-id="PPAR918141942" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>CANARD, SEBASTIEN</last-name></addressbook></inventor><inventor mxw-id="PPAR918992102" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>CANARD, Sébastien</last-name><address><street>15, rue Alexandre Bigot</street><city>14000 Caen</city><country>FR</country></address></addressbook></inventor><inventor mxw-id="PPAR918151687" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>AHMED TANSIR</last-name><address><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR918134569" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>Ahmed, Tansir</last-name></addressbook></inventor><inventor mxw-id="PPAR918988975" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>Ahmed, Tansir</last-name><address><street>Flat 2, Acorn Court 6 Oaks Lane</street><city>IG2 7PL Ilford</city><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR918160851" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>CHAZALET BORIS</last-name><address><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR918157008" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>CHAZALET, BORIS</last-name></addressbook></inventor><inventor mxw-id="PPAR918989659" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>CHAZALET, BORIS</last-name><address><street>81 Stanlake Road Shepherds Bush</street><city>W12 7HQ London</city><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR918152368" load-source="docdb" sequence="4" format="epo"><addressbook><last-name>DEVIGNE JULIEN</last-name><address><country>FR</country></address></addressbook></inventor><inventor mxw-id="PPAR918166229" load-source="docdb" sequence="4" format="intermediate"><addressbook><last-name>Devigne, Julien</last-name></addressbook></inventor><inventor mxw-id="PPAR918983988" load-source="patent-office" sequence="4" format="original"><addressbook><last-name>Devigne, Julien</last-name><address><street>166B, rue de Bayeux</street><city>14000 Caen</city><country>FR</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR918982648" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Cabinet Plasseraud</last-name><iid>100784233</iid><address><street>52, rue de la Victoire</street><city>75440 Paris Cedex 09</city><country>FR</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS548803319" load-source="docdb">AL</country><country mxw-id="DS548848895" load-source="docdb">AT</country><country mxw-id="DS548803321" load-source="docdb">BE</country><country mxw-id="DS548855002" load-source="docdb">BG</country><country mxw-id="DS548801875" load-source="docdb">CH</country><country mxw-id="DS548848961" load-source="docdb">CY</country><country mxw-id="DS548848896" load-source="docdb">CZ</country><country mxw-id="DS548803326" load-source="docdb">DE</country><country mxw-id="DS548848962" load-source="docdb">DK</country><country mxw-id="DS548848963" load-source="docdb">EE</country><country mxw-id="DS548854615" load-source="docdb">ES</country><country mxw-id="DS548855003" load-source="docdb">FI</country><country mxw-id="DS548855004" load-source="docdb">FR</country><country mxw-id="DS548803327" load-source="docdb">GB</country><country mxw-id="DS548848964" load-source="docdb">GR</country><country mxw-id="DS548803328" load-source="docdb">HR</country><country mxw-id="DS548848897" load-source="docdb">HU</country><country mxw-id="DS548801876" load-source="docdb">IE</country><country mxw-id="DS548848965" load-source="docdb">IS</country><country mxw-id="DS548855005" load-source="docdb">IT</country><country mxw-id="DS548848966" load-source="docdb">LI</country><country mxw-id="DS548871976" load-source="docdb">LT</country><country mxw-id="DS548837486" load-source="docdb">LU</country><country mxw-id="DS548871977" load-source="docdb">LV</country><country mxw-id="DS548871982" load-source="docdb">MC</country><country mxw-id="DS548837487" load-source="docdb">MK</country><country mxw-id="DS548837488" load-source="docdb">MT</country><country mxw-id="DS548854616" load-source="docdb">NL</country><country mxw-id="DS548848898" load-source="docdb">NO</country><country mxw-id="DS548837489" load-source="docdb">PL</country><country mxw-id="DS548848967" load-source="docdb">PT</country><country mxw-id="DS548854617" load-source="docdb">RO</country><country mxw-id="DS548848968" load-source="docdb">RS</country><country mxw-id="DS548837490" load-source="docdb">SE</country><country mxw-id="DS548803329" load-source="docdb">SI</country><country mxw-id="DS548848899" load-source="docdb">SK</country><country mxw-id="DS548837491" load-source="docdb">SM</country><country mxw-id="DS548801877" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA128669872" lang="EN" load-source="patent-office"><p id="pa01" num="0001">The application relates in particular to a system comprising electronic devices connectable to a network. Said electronic devices are associated with respective key pairs. Each key pair comprises a private key and a related public key. The system is adapted to cipher data with a public key of a key pair of an electronic device of the system, to store thus ciphered data in the network and to share said ciphered data through the network with an electronic device of the system. The set of key pairs associated with said electronic devices of the system is partitioned into at least two subsets such that for each subset having more than one key pair there is a mutual trust between all key pairs of such subset. The system is arranged to define, for each key pair of each such subset, a bidirectional transition key between said key pair and another key pair of such subset. The system is further arranged to define a unidirectional transition key between a key pair of a subset and a key pair of another subset.</p><p id="pa02" num="0002">The application also relates to a corresponding method, computer program, and storage device.
<img id="iaf01" file="imgaf001.tif" wi="121" he="84" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA128499245" lang="EN" source="EPO" load-source="docdb"><p>The application relates in particular to a system comprising electronic devices connectable to a network. Said electronic devices are associated with respective key pairs. Each key pair comprises a private key and a related public key. The system is adapted to cipher data with a public key of a key pair of an electronic device of the system, to store thus ciphered data in the network and to share said ciphered data through the network with an electronic device of the system. The set of key pairs associated with said electronic devices of the system is partitioned into at least two subsets such that for each subset having more than one key pair there is a mutual trust between all key pairs of such subset. The system is arranged to define, for each key pair of each such subset, a bidirectional transition key between said key pair and another key pair of such subset. The system is further arranged to define a unidirectional transition key between a key pair of a subset and a key pair of another subset.  The application also relates to a corresponding method, computer program, and storage device.</p></abstract><description mxw-id="PDES63955302" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><p id="p0001" num="0001">The invention relates to cryptographic systems operating networks such as clouds. Cloud computing consists in using remote servers to store or process data traditionally located on local servers or on personal computers. Such remote servers are a main component of a cloud. Accessing services hosted in a cloud typically takes place through a standard application such as a web browser.</p><p id="p0002" num="0002">Cloud users are no longer in charge of their servers, which simplifies their work as they don't have to manage an often complex and expensive dedicated infrastructure, which is replaced by a shared infrastructure managed by a third party. However, applications and data not being under direct control of users anymore (e.g. in a local computer or in a server supervised par the user), they are potentially accessible to third parties (cloud administrators for example). This may cause major confidentiality issues.</p><p id="p0003" num="0003">In particular, a user may want to use a cloud for storing personal or confidential data. In order to ensure privacy or confidentiality, several systems have been proposed in order to allow a cloud (or more generally an entity such as a remote server) to store data in ciphered form such that the cloud is unable to decipher the ciphered data it stores. However, it is sometimes desired to share stored ciphered data with other parties (list of authorized users). A user having a key pair in a PKI (Public Key Infrastructure) may store his own data, ciphered with his public key, but may also want to allow certain persons (for example family members) to access to certain stored data (for example family pictures), without having to disclose his private key (which may be used to decipher any data he ciphered with his public key, which could include medical files or fiscal matters for example).</p><p id="p0004" num="0004">To this end, it is known to use an entity called a proxy (which may be hosted in the cloud) which both stores users' encrypted data and allows access to such data by authorized users, in such a way that the proxy is not able to obtain any information about the stored data. This is described for example in <nplcit id="ncit0001" npl-type="s"><text>« Improved Proxy Re-encryption Schemes with Applications to Secure Distributed Storage », Giuseppe Ateniese (The Johns Hopkins University) Kevin Fu (University of Massachusetts, Amherst), Matthew Green (The Johns Hopkins University) and Susan Hohenberger (Massachusetts Institute of Technology), published in ACM Transactions on Information and System Security, volume 9, number 1, February 2006, pages 1-30</text></nplcit>.</p><p id="p0005" num="0005">In such systems, the cloud manages several distinct accounts. It is possible to register several devices with each account. Each time a device is registered with a given account, a transition key KT (a.k.a re-encryption key) is generated for each possible pair of devices that are registered with this account. For example, if an account A comprises two devices '2' and '3', and if a third device '1' is registered with the account, two transition keys are created, KT12 from '1' to '2' and KT13 from '1' to '3'. When device '1' wants to store data in the cloud and share such data with all members of account A, '1' may encrypt such data with its public key PK1 and store the result in the cloud. Device '1' can later retrieve such ciphered data for its own use and decrypt it with its private key SK1 (corresponding to<!-- EPO <DP n="2"> --> PK1). If device '2' or '3' wants to access such data, the proxy may use the transition key from device '1' to the device in question (KT12 for device '2' and KT13 for device '3') in order to translate such data (ciphered by PK1) into data decipherable by SK2 (or SK3 respectively).</p><p id="p0006" num="0006">An Ateniese-Fu-Green-Hohenberger system enables the use of a single encryption key, each transition key being computed from the corresponding private key of the applicable target device, processed by a one way function (the private key should not be recoverable from a transition key).</p><p id="p0007" num="0007">A Tysowski-Anwarul system adapts the previous system (described for servers in general) to a context comprising cloud storage.</p><p id="p0008" num="0008">There are different kinds of proxy re-encryption schemes. A proxy re-encryption scheme (as well as a proxy re-encryption key) is said to be bidirectional if the proxy can translate encrypted data from one device (e.g. device '1') to another device (e.g. device '2') and vice versa with the same re-encryption key (either KT12 = KT21, or there is a public relation between KT12 and KT21 such that one is easily derived from the other). Such a proxy re-encryption scheme requires a mutual trust between devices. This may be problematic as device '1' may trust device '2' without device '2' trusting device '1'.</p><p id="p0009" num="0009">A proxy re-encryption scheme (as well as a proxy re-encryption key) is said to be unidirectional if the proxy requires different re-encryption keys to translate encrypted data from one device (e.g. device '1') to another device (e.g. device '2') and to translate encrypted data from the other device ('2') to the first device (`1'), i.e. KT12 is different from KT21, in the sense not only that KT12 is not strictly equal to KT21, but also that there is no feasible (public) way to compute KT12 from KT21, or to compute KT21 from KT12.</p><p id="p0010" num="0010">A proxy re-encryption scheme is said to be single-hop if it is only possible to re-encrypt once, and is said to be multi-hop if it is possible to re-encrypt several times (which may be advantageous).</p><p id="p0011" num="0011">Known unidirectional proxy re-encryption schemes are single-hop. Known bidirectional proxy re-encryption schemes are multi-hop (with a few exceptions that are not considered relevant in the present context). Therefore, those skilled in the art currently have to either use a bidirectional scheme which poses problems (such as privacy or confidentiality issues due to a forced mutual trust which in fact should have been a one-way trust), or to use a unidirectional scheme, which also poses problems (due in particular to the fact that it is not possible to re-encrypt already re-encrypted data).</p><p id="p0012" num="0012">It is recalled that a secret key, a.k.a symmetric key (used in a symmetric cryptosystems) is a key that is used both for encryption and decryption, wherein sharing data ciphered with a secret key typically requires sharing the secret key (so that the ciphered data be decipherable). A key pair (used in asymmetric cryptosystems) comprises a private key typically assigned to a single entity and not shared, and a corresponding public key, which can be shared. When there is no ambiguity, the expressions "secret key" and "private key" are sometimes used interchangeably.</p><p id="p0013" num="0013">It is an aim of the invention to improve the situation.<!-- EPO <DP n="3"> --></p><p id="p0014" num="0014">The invention relates to a system comprising electronic devices connectable to a network, said electronic devices being associated with respective key pairs,<br/>
each key pair comprising a private key and a related public key,<br/>
the system being adapted to cipher data with a public key of a key pair of an electronic device of the system, to store thus ciphered data in the network and to share said ciphered data through the network with an electronic device of the system,<br/>
the set of key pairs associated with said electronic devices of the system being partitioned into at least two subsets such that for each subset having more than one key pair there is a mutual trust between all key pairs of such set,<br/>
the system being arranged to define, for each key pair of each such subset, a bidirectional transition key between said key pair and another key pair of such subset,<br/>
the system being further arranged to define a unidirectional transition key between a key pair of a subset and a key pair of another subset.</p><p id="p0015" num="0015">This system is advantageous in particular in that it does not force a mutual trust between all key pairs (full mutual trust not necessarily being the norm in practice) and at the same time it enables a multi-hop scheme between all key pairs that mutually trust each other (enabling in particular an easier addition/deletion of key pairs).</p><p id="p0016" num="0016">The invention also relates to a method for securing a system comprising electronic devices connectable to a network, wherein said electronic devices are associated with respective key pairs,<br/>
each key pair comprising a private key and a related public key,<br/>
the system being adapted to cipher data with a public key of a key pair of an electronic device of the system, to store thus ciphered data in the network and to share said ciphered data through the network with an electronic device of the system, the method comprising:
<ul><li>/a/ defining a partition of the set of key pairs associated with said electronic devices of the system into at least two subsets such that, for each subset having more than one key pair, there be a mutual trust between all key pairs of such subset;</li><li>/b/ defining for each key pair of each such subset a bidirectional transition key between said key pair and another key pair of such subset;</li><li>/c/ defining a unidirectional transition key between a key pair of a subset and a key pair of another subset.</li></ul></p><p id="p0017" num="0017">This method is advantageous in particular in that it does not force a mutual trust between all key pairs (full mutual trust not necessarily being the norm in practice) and at the same time it enables a multi-hop scheme between all key pairs that mutually trust each other (enabling in particular an easier addition/deletion of key pairs).</p><p id="p0018" num="0018">Other aspects and advantages of the invention will become readily apparent in the following description of certain embodiments.<!-- EPO <DP n="4"> --></p><p id="p0019" num="0019">The invention will also be better understood by referring to the drawings, in which:
<ul><li><figref idrefs="f0001">Figure 1</figref> shows a system according to a possible embodiment ;</li><li><figref idrefs="f0002">Figure 2</figref> shows a recovery of encrypted data in a system according to <figref idrefs="f0001">Figure 1</figref> ;</li><li><figref idrefs="f0003">Figure 3</figref> illustrates the loss of a device in a system according to <figref idrefs="f0001">Figure 1</figref> ;</li><li><figref idrefs="f0004">Figure 4</figref> illustrates the loss of another device in a system according to <figref idrefs="f0001">Figure 1</figref> ;</li><li><figref idrefs="f0005">Figure 5</figref> illustrates a system with multiple proxies ;</li><li><figref idrefs="f0006">Figure 6</figref> illustrates the loss of a device in a system according to <figref idrefs="f0005">Figure 5</figref>.</li></ul></p><p id="p0020" num="0020"><figref idrefs="f0001">Figure 1</figref> shows a system in which a first user (Alice) has three devices (laptop computer, desktop computer and PDA) respectively storing a key pair KP1, KP2 and KP3 (the three of which constitute a first subset of key pairs). A second user (Bob) has two devices (desktop computer and tablet computer) respectively storing a key pair KP4 and KP5 (the two of which constitute a second subset of key pairs). Alice and Bob's five devices are connected to a proxy PROX storing multi-hop bidirectional transition keys KT12 (between KP1 and KP2) and KT23 (between KP2 and KP3) for Alice, and multi-hop bidirectional transition key KT45 (between KP4 and KP5) for Bob. The proxy PROX also stores a single-hop unidirectional transition key KT34 (from KP3 to KP4).</p><p id="p0021" num="0021"><figref idrefs="f0002">Figure 2</figref> shows how, in a system according to <figref idrefs="f0001">Figure 1</figref>, a document D_KP1 (ciphered with the public key of KP1) stored in the cloud is converted into a document D_KP2 (decipherable with the private key of KP2) thanks to the multi-hop bidirectional transition key KT12. <figref idrefs="f0002">Figure 2</figref> also shows how the same a document D_KP1 (ciphered with the public key of KP1) is converted into a document D_KP5 (decipherable with the private key of KP5) thanks to the single-hop unidirectional transition key KT15 obtained by the multi-hop bidirectional transition KT12, followed by the multi-hop bidirectional transition key KT23, followed by the single-hop unidirectional transition key KT34, followed by the multi-hop bidirectional transition key KT45.</p><p id="p0022" num="0022"><figref idrefs="f0003">Figure 3</figref> illustrate the loss of the laptop computer of Alice in the system according to <figref idrefs="f0001">Figure 1</figref>. Due to this loss, the key pair KP1 (stored in the laptop) is lost as well and it is no longer possible to directly decrypt the document D_KP1. The proxy PROX converts the document D_KP1 into a document D_KP2 (decipherable with the private key of KP2) thanks to the multi-hop bidirectional transition key KT12. The document D_KP1 as well as the transition key TK12 can then be deleted.</p><p id="p0023" num="0023"><figref idrefs="f0004">Figure 4</figref> illustrate the loss of the desktop computer of Bob in the system according to <figref idrefs="f0001">Figure 1</figref>. Due to this loss, the key pair KP4 (stored in the desktop computer) is lost as well and the transition key KT34 becomes useless. The transition key KT34 is merged with the transition key KT45 in order to form a new transition key KT35, and the old transition keys KT34 and KT45 are deleted.<!-- EPO <DP n="5"> --></p><p id="p0024" num="0024"><figref idrefs="f0005">Figure 5</figref> illustrates a system according to <figref idrefs="f0001">Figure 1</figref> modified so as to rely on two different proxies PROX_A and PROX_B instead of a single one (PROX), wherein the transition keys for Alice are stored and managed by a proxy dedicated to Alice (PROX_A), and the transition keys for Bob are stored and managed by a proxy dedicated to Bob (PROX_B).</p><p id="p0025" num="0025"><figref idrefs="f0006">Figure 6</figref> illustrate the loss of the desktop computer of Bob in the system according to <figref idrefs="f0005">Figure 5</figref>. Due to this loss, the key pair KP4 (stored in the desktop) is lost as well. A new unidirectional single-hop transition key KT25 (from key pair KP2 to key pair KP5) is created. Transition keys KT34 and KT45 are then deleted from PROX_A and PROX_B respectively. PROX_B no longer stores a transition key.</p><p id="p0026" num="0026">According to a possible embodiment, a system comprises electronic devices (for example smart phones, cell phones, portable computer, PCs, smart cards, security tokens, etc.) connectable to a network (for example a cloud, or simply a network comprising conventional servers, or a cellular network). The electronic devices are associated with respective key pairs. Each electronic device therefore has at least one key pair. According to a possible embodiment, there is a one to one relationship between a key pair and an electronic device. However, it is also possible, for example, to have several (and unique) key pairs in a same electronic device. This can be the case if a given user has several key pairs (for example a key pair for personal use and a key pair for professional use, or several professional key pairs each attached to different services), and stores several of his key pairs in the same device (for example in the SIM card of his smart phone).</p><p id="p0027" num="0027">Each key pair comprises a private key and a related public key.</p><p id="p0028" num="0028">The system is adapted to cipher data with a public key of a key pair of an electronic device of the system, to store thus ciphered data in the network and to share said ciphered data through the network with an electronic device of the system (the same electronic device or another one). For example, the system may enable a user of an electronic device of the system to cipher data stored on his electronic device (e.g. a smart phone), to store such ciphered data in a cloud, and then to later retrieve such ciphered data for himself into his electronic device, or to share it with another user's electronic device, or to transfer it to another electronic device belonging to himself.</p><p id="p0029" num="0029">The set of key pairs associated with said electronic devices of the system (i.e. the set comprising any key pair stored on any one of the electronic devices of the system) is partitioned into at least two subsets such that for each subset having more than one key pair there is a mutual trust between all key pairs of such subset. By definition, mutual trust between two key pairs means that any holder of any of the two key pairs accepts that any data ciphered with the public key of his key pair be decipherable by a private key of the other key pair. In a possible embodiment, the decryption first needs to involve a proper bidirectional transition key, to be applied to the ciphered data. In a possible trust model, each subset corresponds to a person, and contains all key pairs of such person. The person is accordingly assumed to trust herself whatever the key pair concerned (since all key pairs in question all belong to the same person). However, in another trust model, a same person may have several key pairs not necessarily<!-- EPO <DP n="6"> --> trusting each other, for example a military officer working on top secret matter may have access to secret material that he should not be able to decrypt at home with his personal key pair. Conversely, there can be trust relationships between different persons, therefore in possible embodiments a given subset may contain key pairs belonging to different persons.</p><p id="p0030" num="0030">The system is arranged to define, for each key pair of each such subset, a bidirectional transition key between said key pair and another key pair of such subset. Accordingly, if N is an integer designating the number of key pairs in a subset, at least N-1 bidirectional transition keys are defined (there may also be more than N-1 bidirectional transition keys). Accordingly, bidirectional keys being multi-hop keys, a private key of any key pair of a subset can decipher data ciphered by a public key of any other key pair of the subset, by first using at least one and at most N-1 bidirectional transition keys. For example in a subset comprising key pairs KP1, KP2 and KP3, and associated with bidirectional transition keys KT12 and KT13, only KT12 is needed to enable the decryption of a document D_KP1 ciphered with the public key of KP1 by the private key of KP2. However, both KT12 and KT13 are needed to enable the decryption of a document D_KP2 ciphered with the public key of KP2 by the private key of KP3. It is in fact possible to compute less than N-1 transition keys, however this may cause deficiencies in the system, which deficiencies may lead the system for example to request from one of the devices to decipher (to the extent possible) and re-cipher stored data in order to overcome the deficiency.</p><p id="p0031" num="0031">The system is further arranged to define a unidirectional transition key between a key pair of a subset and a key pair of another subset. Accordingly, it is possible to share information between such key pairs in one direction (a key pair of a subset may trust a key pair of another subset without the converse being true). According to a possible embodiment, each subset corresponds to a person, and unidirectional transition keys are used between different persons.</p><p id="p0032" num="0032">In a possible embodiment, different key pairs of a subset are necessarily stored on different electronic devices. This embodiment is advantageous, because if any electronic device is lost, and if a key pair of the electronic device belonged to a subset, then any other device which stores another key pair belonging to the same subset can recover data ciphered with the public key of said key pair of the lost electronic device. In this context, if an electronic device comprises several key pairs, then only data ciphered with a public key of a key pair of the electronic device that belongs to a subset with at least two key pairs can be recovered. The expression "loss of the electronic device" may refer to the electronic device being destroyed, accidentally left behind, stolen, or having otherwise failed (e.g. hardware or software failure) or being disposed of (when replaced by newer equipment). It is typically not possible (or at least very difficult) to retrieve key material from the electronic device.</p><p id="p0033" num="0033">More particularly, each subset may correspond to a person, and each key pair of the subset may correspond to a different electronic device of the person (e.g. his cell phone, his tablet, his PC, his laptop). If the person loses his tablet, the ciphered contents (which are in the cloud) may accordingly be decipherable from another one of the electronic devices of that person. In such a scheme, unidirectional transition keys may correspond to unidirectional trust between two devices, each belonging to a different person.<!-- EPO <DP n="7"> --></p><p id="p0034" num="0034">In another embodiment, a same electronic device may comprise several key pairs belonging to a same subset. This may be advantageous as it may offer protection against accidental destruction of one of such key pairs in an electronic device without the electronic device itself being lost (e.g. if the user of an electronic device is given the possibility to delete key pairs and deletes one by mistake), without involving other electronic devices, as long as another key pair of the subset is already stored in the same electronic device. This may also help in dealing with key pair revocation (e.g. when a key pair has been compromised and needs to be revoked) or key pair renewal (a key pair typically has a validity period, for example two years, after which it needs to be replaced). But this does not necessarily protect against the loss of the electronic device, since data ciphered with a public key of a key pair of such electronic device cannot always be deciphered by another key pair. If at least one of the key pairs of the set is not stored in the lost electronic device, then a recovery for material ciphered with that key pair that was in the lost electronic device is possible.</p><p id="p0035" num="0035">According to a possible embodiment, the set composed of the electronic devices of the system is partitioned into at least two subsets of electronic devices such that for each subset having more than one electronic device there is a mutual trust between a key pair of any electronic device of such subset of electronic devices and a key pair of any other electronic device of such subset of electronic devices. The system is arranged to define, for each electronic device of each such subset of electronic devices, a bidirectional transition key between a key pair of said electronic device and a key pair of another electronic device of the subset, the system being further arranged to define a unidirectional transition key between a key pair of an electronic device of a subset of electronic devices and a key pair of an electronic device of another subset of electronic devices.</p><p id="p0036" num="0036">According to a possible embodiment, the system comprises a cryptographic proxy storing the transition keys. The system could also work without dedicated proxies, e.g. in carrying out transition key operations in another component (e.g. server) of the cloud or other type of network in which the system operates. The proxy is advantageous as it defines a security perimeter within which transition key operations may be performed more securely than in a general purpose component of a network.</p><p id="p0037" num="0037">According to another embodiment, the system comprises cryptographic proxies, each cryptographic proxy being associated with a subset of key pairs of the system and storing the transition keys defined for the key pairs of the subset. Each proxy may for example serve a certain number of holders of key pairs, for example in a corporate environment, two corporations could each operate their own (single) proxy for all of their respective employees, i.e. proxy X for all employees of company X and proxy Y for all employees of company Y.</p><p id="p0038" num="0038">According to a possible embodiment, a system is configured so as upon loss of a private key of a key pair of an electronic device of the system, a transition key being defined for the key pair, the system is arranged to convert any ciphered data stored in the network and ciphered with the public key of said<!-- EPO <DP n="8"> --> key pair, the ciphered data being converted with the transition key into data decipherable by a private key of another key pair of an electronic device of the system.</p><p id="p0039" num="0039">The loss of the private key may occur through the loss of an electronic device storing the private key, or through unintentional destruction (or intentional revocation or renewal) of this private key within an electronic device that has not been lost.</p><p id="p0040" num="0040">According to a possible embodiment, upon loss of such private key (e.g. after having received a notification from a user indicating that the private key is lost), and after conversion of ciphered data, transition keys involving the lost key are destroyed (this may require re-computing other transition keys if needed).</p><p id="p0041" num="0041">According to a possible embodiment, a method is arranged to secure a system comprising electronic devices connectable to a network. Said electronic devices are associated with respective key pairs.</p><p id="p0042" num="0042">Each key pair comprises a private key and a related public key,</p><p id="p0043" num="0043">The system is adapted to cipher data with a public key of a key pair of an electronic device of the system, to store thus ciphered data in the network and to share said ciphered data through the network with an electronic device of the system. The method comprises:
<ul><li>/a/ defining a partition of the set of key pairs associated with said electronic devices of the system into at least two subsets such that, for each subset having more than one key pair, there be a mutual trust between all key pairs of such subset;</li><li>/b/ defining for each key pair of each such subset a bidirectional transition key between said key pair and another key pair of such subset;</li><li>/c/ defining a unidirectional transition key between a key pair of a subset and a key pair of another subset.</li></ul></p><p id="p0044" num="0044">The method may be carried out by software components (which may be developed for example in C language, assembly language, Java, or any other suitable programming language) which may be run by processors of respective elements (electronic devices and proxies) of the system. Accordingly, electronic devices and/or proxies may comprise a processor associated with a memory storing the respective software component and possibly other components (such as a crypto-processor). Alternatively, electronic devices and/or proxies may comprise dedicated circuits, carrying out the method electronically (without a conventional processor, but for example with hardwired logic).</p><p id="p0045" num="0045">According to a possible embodiment, a computer program product is arranged to carry out a method as described above when executed by a processor.</p><p id="p0046" num="0046">According to a possible embodiment, a non transitory computer readable storage medium (such as a USB key, a memory chip embedded in an electronic device or proxy, a smart card chip, etc.) stores a computer program according to the previous paragraph.<!-- EPO <DP n="9"> --></p><p id="p0047" num="0047">More detailed possible embodiments will now be described.</p><p id="p0048" num="0048">The embodiments are based on the proxy re-encryption system proposed by <nplcit id="ncit0002" npl-type="b"><text>Benoît Libert and Damien Vergnaud, in "Unidirectional chosen-ciphertext secure proxy re-encryption", in Ronald Cramer, editor, Public Key Cryptography, volume 4939 of Lecture Notes in Computer Science,pages 360-379. Springer, 2008</text></nplcit>.</p><p id="p0049" num="0049">The following unidirectional single-hop proxy re-encryption scheme is proposed:
<ul><li>GENERATION OF PUBLIC PARAMETERS Choose a prime p and two groups G and G<i><sub>t</sub></i> of prime order p such that there exists a bilinear pairing <i>e</i> : G × G → G<i><sub>T</sub></i>. Let. <i>g,u,v</i> be three generators of G and <i>S</i> = (KEYCEN,SlCN,VERIF) be a strongly unforgeable one-time signature scheme such that verification keys are in Zp<sup>*</sup> (see [1] for more details).<br/>
The global parameters are <i>P</i> = (<i>p,G,G<sub>T</sub>,e,g,u,v,S</i>).</li><li>KEY GENERATION. On input the global parameters, each user is able to generate her own private key <maths id="math0001" num=""><math display="inline"><mi>x</mi><mo>⁢</mo><mover><mo>←</mo><mi>$</mi></mover><mo>⁢</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>p</mi><mo>*</mo></msubsup></math><img id="ib0001" file="imgb0001.tif" wi="14" he="8" img-content="math" img-format="tif" inline="yes"/></maths> and the corresponding public, key <i>X</i> = <i>g<sup>x</sup></i>.<br/>
The re-encryption key between a user <i>i</i>. and a user <i>j</i> is generated by using the private key <i>x<sub>i</sub></i> of <i>i</i> and the public key <i>X<sub>j</sub></i> of <i>j</i>. Such key is computed as <maths id="math0002" num=""><math display="inline"><msub><mi>R</mi><mrow><mi>i</mi><mo>→</mo><mi>j</mi></mrow></msub><mo>=</mo><msubsup><mi>X</mi><mi>j</mi><mrow><mn>1</mn><mo>/</mo><msub><mi>x</mi><mi>i</mi></msub></mrow></msubsup><mn>.</mn></math><img id="ib0002" file="imgb0002.tif" wi="26" he="10" img-content="math" img-format="tif" inline="yes"/></maths></li><li>FIRST LEVEL ENCRYPTION. On input the public parameters, a message <i>m</i> ∈ <i>G<sub>T</sub></i> and a public key <i>X<sub>i</sub></i>, this algorithm creates a first level ciphertext <i>C'</i> as follows:
<ol><li>1. Run the key generation procedure of the strongly unforgeable one-time signature scheme (<i>ssk,svk</i>) = <i>S</i>.KEYGEN() and denote <i>C</i><sub>1</sub> = <i>svk</i>.</li><li>2. Pick <maths id="math0003" num=""><math display="inline"><mi>r</mi><mo>,</mo><mi>t</mi><mo>∈</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>p</mi><mo>*</mo></msubsup><mn>.</mn></math><img id="ib0003" file="imgb0003.tif" wi="19" he="7" img-content="math" img-format="tif" inline="yes"/></maths></li><li>3. Compute <maths id="math0004" num=""><math display="inline"><msubsup><mi>C</mi><mn>2</mn><mi>ʹ</mi></msubsup><mo>=</mo><msubsup><mi>X</mi><mi>i</mi><mi>t</mi></msubsup><mo>,</mo><msubsup><mi>C</mi><mn>2</mn><mi>ʺ</mi></msubsup><mo>=</mo><msup><mi>g</mi><mrow><mn>1</mn><mo>/</mo><mi>t</mi></mrow></msup><mo>,</mo><msubsup><mi>C</mi><mn>2</mn><mi>ʹʺ</mi></msubsup><mo>=</mo><msubsup><mi>X</mi><mi>i</mi><mi mathvariant="italic">rt</mi></msubsup><mo>,</mo><msub><mi>C</mi><mn>3</mn></msub><mo>=</mo><mi>e</mi><mo>⁢</mo><msup><mfenced separators=""><mi>g</mi><mo>⁢</mo><mi>g</mi></mfenced><mi>r</mi></msup><mo>⋅</mo><mi>m</mi></math><img id="ib0004" file="imgb0004.tif" wi="82" he="7" img-content="math" img-format="tif" inline="yes"/></maths>and <i>C</i><sub>4</sub> = (<i>u<sup>svk</sup></i> · <i>v</i>)<i><sup>r</sup></i>.</li><li>4. Run the signature of the strongly unforgeable one-time signature scheme σ = <i>S.</i>SIGN(<i>ssk,C</i><sub>3</sub>||<i>C</i><sub>4</sub>).</li></ol>
The first level ciphertext of the message <i>m</i> is <maths id="math0005" num=""><math display="inline"><msup><mi>C</mi><mi>ʹ</mi></msup><mo>=</mo><mfenced separators=""><msub><mi>C</mi><mn>1</mn></msub><mo>,</mo><msubsup><mi>C</mi><mn>2</mn><mi>ʹ</mi></msubsup><mo>⁢</mo><msubsup><mi>C</mi><mn>2</mn><mi>ʺ</mi></msubsup><mo>,</mo><msubsup><mi>C</mi><mn>2</mn><mi>ʹʺ</mi></msubsup><mo>,</mo><msub><mi>C</mi><mn>3</mn></msub><mo>,</mo><msub><mi>C</mi><mn>4</mn></msub><mo>,</mo><mi>σ</mi></mfenced><mn>.</mn></math><img id="ib0005" file="imgb0005.tif" wi="51" he="9" img-content="math" img-format="tif" inline="yes"/></maths></li><li>SECOND LEVEL. ENCRYPTION. On input the public parameters, a message <i>m</i> ∈ G<i><sub>T</sub></i> and a public key <i>X<sub>i</sub></i>, this algorithm creates a second level ciphertext <i>C</i> as follows:
<ol><li>1. Run the key generation procedure of the strongly unforgeable one-time signature scheme (<i>ssk,svk</i>) <i>= S</i>.KEYGEN() and note <i>C</i><sub>1</sub> = <i>svk</i>.</li><li>2. Pick <maths id="math0006" num=""><math display="inline"><mi>r</mi><mo>∈</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>p</mi><mo>*</mo></msubsup><mn>.</mn></math><img id="ib0006" file="imgb0006.tif" wi="14" he="8" img-content="math" img-format="tif" inline="yes"/></maths></li><li>3. Compute <maths id="math0007" num=""><math display="inline"><msub><mi>C</mi><mn>2</mn></msub><mo>=</mo><msubsup><mi>X</mi><mi>i</mi><mi>r</mi></msubsup><mo>,</mo><msub><mi>C</mi><mn>3</mn></msub><mo>=</mo><mi>e</mi><mo>⁢</mo><msup><mfenced separators=""><mi>g</mi><mo>⁢</mo><mi>g</mi></mfenced><mi>r</mi></msup><mo>⋅</mo><mi>m</mi></math><img id="ib0007" file="imgb0007.tif" wi="45" he="7" img-content="math" img-format="tif" inline="yes"/></maths> and <i>C</i><sub>4</sub> = (<i>u<sup>svk</sup></i> · <i>v</i>)<i><sup>r</sup></i>.</li><li>4. Run the signature of the strongly unforgeable on-time signature scheme σ = <i>S</i>.SIGN(<i>ssk</i>,<i>C</i><sub>3</sub>∥<i>C</i><sub>4</sub>). The second level ciphertext of the message <i>m</i> is <i>C</i> = (<i>C</i><sub>1</sub>,<i>C</i><sub>2</sub>,<i>C</i><sub>3</sub>,<i>C</i><sub>4</sub>,σ).</li></ol><!-- EPO <DP n="10"> --></li><li>UNIDIRECTIONAL RE-ENCRYPTION. On input the public parameters, a second level elphertext <i>C</i> and a re-encryption key <i>R<sub>i→j</sub></i> from <i>i</i> to <i>j</i>. The re-encryption algorithm, proceeds as follows:
<ol><li>1. Validity of the second level ciphertext <i>C<sub>i</sub></i> intended to <i>i</i>: check if <i>e</i>(<i>C</i><sub>2</sub>,<i>u</i><sup><i>C</i><sup2>1</sup2></sup> · <i>v</i>) = <i>e</i>(<i>X<sub>i</sub>,C<sub>4</sub></i>) and if <i>S.</i>VERIF(<i>C</i><sub>1</sub>,σ,<i>C</i><sub>3</sub>∥<i>C</i><sub>4</sub>) = 1.</li><li>2. Pick <maths id="math0008" num=""><math display="inline"><mi>t</mi><mo>∈</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>p</mi><mo>*</mo></msubsup><mn>.</mn></math><img id="ib0008" file="imgb0008.tif" wi="14" he="8" img-content="math" img-format="tif" inline="yes"/></maths></li><li>3. Compute <maths id="math0009" num=""><math display="inline"><msubsup><mi>C</mi><mn>2</mn><mi>ʹ</mi></msubsup><mo>=</mo><msubsup><mi>X</mi><mi>i</mi><mi>t</mi></msubsup><mo>,</mo><msubsup><mi>C</mi><mn>2</mn><mi>ʺ</mi></msubsup><mo>=</mo><msup><msub><mi>R</mi><mrow><mi>i</mi><mo>→</mo><mi>j</mi></mrow></msub><mrow><mn>1</mn><mo>/</mo><mi>t</mi></mrow></msup></math><img id="ib0009" file="imgb0009.tif" wi="40" he="8" img-content="math" img-format="tif" inline="yes"/></maths> and <maths id="math0010" num=""><math display="inline"><msubsup><mi>C</mi><mn>2</mn><mi>ʹʺ</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mn>2</mn><mi>t</mi></msubsup><mn>.</mn></math><img id="ib0010" file="imgb0010.tif" wi="20" he="8" img-content="math" img-format="tif" inline="yes"/></maths></li></ol>
The re-encryption of the second level ciphertexts is <i>C</i> is <maths id="math0011" num=""><math display="inline"><msup><mi>C</mi><mi>ʹ</mi></msup><mo>=</mo><mfenced separators=""><msub><mi>C</mi><mn>1</mn></msub><mo>,</mo><msubsup><mi>C</mi><mn>2</mn><mi>ʹ</mi></msubsup><mo>⁢</mo><msubsup><mi>C</mi><mn>2</mn><mi>ʺ</mi></msubsup><mo>,</mo><msubsup><mi>C</mi><mn>2</mn><mi>ʹʺ</mi></msubsup><mo>,</mo><msub><mi>C</mi><mn>3</mn></msub><mo>,</mo><msub><mi>C</mi><mn>4</mn></msub><mo>,</mo><mi>σ</mi></mfenced><mn>.</mn></math><img id="ib0011" file="imgb0011.tif" wi="55" he="10" img-content="math" img-format="tif" inline="yes"/></maths></li><li>FIRST LEVEL DECRYPTION. On input the public parameters, a first level elphertext <i>C'</i> and a private key <i>x<sub>i</sub>,</i> the message <i>m</i> can be recovered as follows:
<ol><li>1. Validity of the ciphertext intended to <i>i</i>: check if <maths id="math0012" num=""><math display="inline"><mi>e</mi><mfenced separators=""><msubsup><mi>C</mi><mn>2</mn><mi>ʹ</mi></msubsup><mo>⁢</mo><msubsup><mi>C</mi><mn>2</mn><mi>ʺ</mi></msubsup></mfenced><mo>=</mo><mi>e</mi><mfenced separators=""><msub><mi>X</mi><mi>i</mi></msub><mo>⁢</mo><mi>g</mi></mfenced><mo>,</mo></math><img id="ib0012" file="imgb0012.tif" wi="36" he="12" img-content="math" img-format="tif" inline="yes"/></maths> if <maths id="math0013" num=""><math display="inline"><mi>e</mi><mfenced separators=""><msubsup><mi>C</mi><mn>2</mn><mi>ʺʹ</mi></msubsup><mo>,</mo><msup><mi>u</mi><msub><mi>C</mi><mn>1</mn></msub></msup><mo>⋅</mo><mi>υ</mi></mfenced><mo>=</mo></math><img id="ib0013" file="imgb0013.tif" wi="30" he="9" img-content="math" img-format="tif" inline="yes"/></maths><maths id="math0014" num=""><math display="block"><mrow><mi>e</mi><mfenced separators=""><msubsup><mrow><mi>C</mi></mrow><mrow><mn>2</mn></mrow><mrow><mo>′</mo></mrow></msubsup><mo>⁢</mo><msub><mrow><mi>C</mi></mrow><mrow><mn>4</mn></mrow></msub></mfenced></mrow></math><img id="ib0014" file="imgb0014.tif" wi="18" he="7" img-content="math" img-format="tif"/></maths> and if <i>S</i>.VERIF(<i>C</i><sub>1</sub>,σ,<i>C</i><sub>3</sub>||<i>C</i><sub>4</sub>) = 1.</li><li>2. Compute <maths id="math0015" num=""><math display="inline"><mi>m</mi><mo>=</mo><msub><mi>C</mi><mn>3</mn></msub><mo>/</mo><mi>e</mi><mo>⁢</mo><msup><mfenced separators=""><msubsup><mi>C</mi><mn>2</mn><mi>ʺ</mi></msubsup><mo>⁢</mo><msubsup><mi>C</mi><mn>2</mn><mi>ʺʹ</mi></msubsup></mfenced><mrow><mn>1</mn><mo>/</mo><msub><mi>x</mi><mi>i</mi></msub></mrow></msup><mn>.</mn></math><img id="ib0015" file="imgb0015.tif" wi="40" he="8" img-content="math" img-format="tif" inline="yes"/></maths></li></ol></li><li>SECOND LEVEL DECRYPTION. On input the public parameter, a second level ciphertext <i>C</i> and a private key <i>x<sub>i</sub></i>, the message m can be recovered as follows:
<ol><li>1. Validity of the second level ciphertext <i>C<sub>i</sub></i> intended to i: cheek if <i>e</i>(<i>C</i><sub>2</sub>,u<sup><i>C</i><sub2>1</sub2></sup> · <i>v</i>) = e(<i>X<sub>i</sub>,C</i><sub>4</sub><i>)</i> and if <i>S</i>.VERIF(<i>C</i><sub>1</sub>,σ,<i>C</i><sub>3</sub>∥<i>C</i><sub>4</sub>) = 1.</li><li>2. Compute <i>m</i> = <i>C</i><sub>3</sub>/<i>e</i>(<i>C</i><sub>2</sub><i>,g</i>)<sup><i>1</i>/</sup><i><sup>x<sub2>i</sub2></sup>.</i></li></ol></li></ul></p><p id="p0050" num="0050">The following bidirectional multi-hop proxy re-encryption scheme is proposed:
<ul><li>GENERATION OF PUBLIC PARAMETERS Choose a prime p and two groups G and G<sub>t</sub> of prime order p such that there exists a bilinear pairing e : G×G → G<i><sub>T</sub></i>. Let <i>g,u,v</i> be three generators of G and <i>S</i> = (KEYGEN,SIGN,VERIF) be a strongly unforgeable one-time signature scheme such that verification keys are in <maths id="math0016" num=""><math display="inline"><msubsup><mi mathvariant="double-struck">Z</mi><mi>p</mi><mo>*</mo></msubsup></math><img id="ib0016" file="imgb0016.tif" wi="8" he="8" img-content="math" img-format="tif" inline="yes"/></maths><br/>
The global parameters are <i>P</i> = (<i>p</i>,G,G<i><sub>T</sub></i>,<i>e,g,u,v</i>,<i>S</i>).</li><li>KEY GENERATION. On input the global parameters, each user is able to generate her own private key <maths id="math0017" num=""><math display="inline"><mi>x</mi><mo>⁢</mo><mover><mo>←</mo><mi>$</mi></mover><mo>⁢</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>p</mi><mo>*</mo></msubsup></math><img id="ib0017" file="imgb0017.tif" wi="14" he="8" img-content="math" img-format="tif" inline="yes"/></maths> and the corresponding public key <i>X</i> = <i>g<sup>x</sup></i>.<br/>
The re-encryption key between a user <i>i</i> and a user <i>j</i> is generated by using both private keys <i>x<sub>i</sub></i> of <i>i</i> and x<i><sub>j</sub></i> of <i>j</i>. A such key is computed as R<i><sub>i↔j</sub></i> = x<i><sub>j</sub></i>/x<i><sub>i</sub></i>. The re-encryption key between <i>i</i> and <i>j</i> is also <i>R</i><sub><i>i</i>↔</sub><i><sub>j</sub>.</i></li><li><i>R</i><sub><i>i</i>↔<i>j</i></sub> will denote <i>x<sub>i</sub></i>/<i>x<sub>j</sub></i>, the inverse of it will be denoted R<i><sub>j↔i</sub></i> and is also computable from the first</li></ul></p><heading id="h0001">SECOND LEVEL ENCRYPTION.</heading><p id="p0051" num="0051">In the case of a bidirectional multi-hop proxy re-encryption, there is one single level of ciphertext. But, regarding the above unidirectional single-hop scheme, we keep the terminology of "second level" ciphertext.</p><p id="p0052" num="0052">On input the public parameters, a message <i>m</i> ∈ G<i><sub>T</sub></i> and a public key <i>X<sub>i</sub>,</i> this algorithm creates a second level ciphertexts <i>C<sub>i</sub></i> as follows:
<ol><li>1. Run the key generation algorithm of the strongly unforgeable one-time signature scheme (<i>ssk,svk</i>) <i>= S</i>.KEYGEN() and note <i>C</i><sub>1</sub> = <i>svk.</i></li><li>2. Pick <maths id="math0018" num=""><math display="inline"><mi>r</mi><mo>∈</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>p</mi><mo>*</mo></msubsup><mn>.</mn></math><img id="ib0018" file="imgb0018.tif" wi="15" he="8" img-content="math" img-format="tif" inline="yes"/></maths></li><li>3. Compute <maths id="math0019" num=""><math display="inline"><msub><mi>C</mi><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow></msub><mo>=</mo><msubsup><mi>X</mi><mi>i</mi><mi>r</mi></msubsup><mo>,</mo><msub><mi>C</mi><mn>3</mn></msub><mo>=</mo><mi>e</mi><mo>⁢</mo><msup><mfenced separators=""><mi>g</mi><mo>⁢</mo><mi>g</mi></mfenced><mi>r</mi></msup><mo>⋅</mo><mi>m</mi></math><img id="ib0019" file="imgb0019.tif" wi="50" he="8" img-content="math" img-format="tif" inline="yes"/></maths> and <i>C</i><sub>4</sub> = (<i>u<sup>svk</sup></i> · <i>v</i>)<i><sup>r</sup></i>.<!-- EPO <DP n="11"> --></li><li>4. Run the signature of the strongly unforgeable one-time signature scheme σ = <i>S.</i>SIGN(<i>ssk,C</i><sub>3</sub>∥<i>C</i><sub>4</sub>)<i>.</i> The second level ciphertext of the message m is <i>C<sub>i</sub></i> = (<i>C</i><sub>1</sub>,<i>C<sub>i</sub></i>,<sub>2</sub>,<i>C</i><sub>3</sub>,<i>C</i><sub>4</sub>,σ).</li></ol></p><p id="p0053" num="0053">BIDIRECTIONAL RE-ENCRYPTION. On input the public parameters, a second level ciphertext <i>C<sub>i</sub></i> and a re-encryption key <i>R<sub>i↔j</sub></i> from <i>i</i> to <i>j</i>. The re-encryption algorithm proceeds as follows:
<ol><li>1. Validity of the second level ciphertext <i>C<sub>i</sub></i> intended to i: check if <i>e</i>(<i>C</i><sub><i>i</i>,2</sub>,<i>u</i><sup><i>C</i><sub2>1</sub2></sup> · <i>v</i>) = <i>e</i>(<i>X<sub>i</sub></i>,<i>C</i><sub>4</sub>) and if <i>S</i>.VERIF(<i>C</i><sub>1</sub>,σ,<i>C</i><sub>3</sub>||<i>C</i><sub>4</sub>) = 1.</li><li>2. Compute <maths id="math0020" num=""><math display="inline"><msub><mi>C</mi><mrow><mi>j</mi><mo>,</mo><mn>2</mn></mrow></msub><mo>=</mo><msubsup><mi>C</mi><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow><msub><mi>R</mi><mrow><mi>i</mi><mo>↔</mo><mi>j</mi></mrow></msub></msubsup><mo>,</mo></math><img id="ib0020" file="imgb0020.tif" wi="29" he="8" img-content="math" img-format="tif" inline="yes"/></maths></li></ol></p><p id="p0054" num="0054">The re-encryption of the second level ciphertext is <i>C<sub>j</sub></i> is <i>C<sub>j</sub> =</i> (<i>C</i><sub>1</sub><i>,C</i><sub><i>j,</i>2</sub><i><sub>,</sub>C</i><sub>3</sub><i>,C</i><sub>4</sub><i>,</i>σ)<i>.</i></p><p id="p0055" num="0055">SECOND LEVEL DECRYPTION. On input the public parameters, a second level ciphertext <i>C<sub>i</sub></i> and a private key <i>x<sub>i</sub>,</i> the message m can be recovered as follows:
<ol><li>1. Validity of the second level ciphertext <i>C<sub>i</sub></i> intended to i: check if <i>e</i>(<i>C</i><sub><i>i</i>,2</sub>,<i>u</i><sup><i>C</i><sub2>1</sub2></sup> · <i>v</i>) = <i>e</i>(<i>X<sub>i</sub>,C</i><sub>4</sub>) and if <i>S</i>.VERIF(<i>C</i><sub>1</sub>,σ,<i>C</i><sub>3</sub>||<i>C</i><sub>4</sub>) = 1.</li><li>2. Compute <i>m</i> = <i>C</i><sub>3</sub>/<i>e</i>(<i>C</i><sub><i>i,</i>2<i>,g</i></sub>)<sup><i>1</i>/x<i><sub>i</sub></i></sup>.</li></ol></p><p id="p0056" num="0056">The key point is that the level 2 ciphertext of this scheme is exactly the same as the level 2 ciphertext of the unidirectional single-hop scheme described above.</p><p id="p0057" num="0057">The above can be applied as follows to distributed secure storage with management of lost device.</p><p id="p0058" num="0058">Both schemes can be used to construct a distributed secure storage system based on proxy re-encryption. One has to consider that there is a mutual trust between key pairs of a given subset. In the following examples, each electronic device stores a unique key pair (therefore key pairs and corresponding electronic devices are interchangeable in the sense that they correspond to a same logical entity). In the following, each subset is formed by all electronic devices of a given user (of course, as discussed earlier, other kinds of subsets could be defined, and the same mathematical method described below could be used).</p><p id="p0059" num="0059">In the following examples, we can use a bidirectional re-encryption between those devices that belong to a same user, whereas we do not want to have this kind of trust between devices of different users. A first user Alice (A) may want to share her data with a second user Bob (B), but Bob may want to not share his data with Alice, so that we use in this case a unidirectional type scheme.</p><p id="p0060" num="0060">An example of such a distributed secure storage system between two users is showed below, in which A has devices A1, A2, A3 and A4 and a B which has devices B1, B2 and B3.</p><heading id="h0002">Keys generation</heading><p id="p0061" num="0061">A computes the minimum of bidirectional re-encryption keys between her devices such that it allows the proxy to compute all bidirectional re-encryption keys from any A's device to any other A's device, for example: <i>R</i><sub><i>A</i><sub2>1</sub2>↔<i>A</i>2</sub>, <i>R</i><sub><i>A</i><sub2>1</sub2>↔<i>A</i><sub2>3</sub2></sub> and <i>R</i><sub><i>A</i><sub2>2</sub2>↔<i>A</i><sub2>4</sub2></sub>.</p><p id="p0062" num="0062">In practice, each time a user adds a new device to the cloud, she may compute a bidirectional re-encryption between her new device and one of her already existing devices. The user B do the<!-- EPO <DP n="12"> --> same for her devices. All these bidirectional re-encryption keys are given to the proxy. To finish, A computes at least one unidirectional re-encryption key from one of her devices to one of <i>B</i>'s devices, for example <i>R</i><sub><i>A</i><sub2>3</sub2>→<i>B</i><sub2>2</sub2></sub> and gives it to the proxy.</p><heading id="h0003"><i>Remark</i> Regarding key generation</heading><p id="p0063" num="0063"><ul><li>With such configuration, there are enough re-encryption keys for A's devices. For example with <i>R</i><sub><i>A</i><sub2>1</sub2>↔<i>A</i><sub2>2</sub2></sub> and <i>R</i><sub><i>A</i><sub2>1</sub2>↔<i>A</i><sub2>3</sub2>,</sub> one can compute <i>R</i><sub><i>A</i><sub2>2</sub2>↔<i>A</i><sub2>3</sub2></sub> = <i>R</i><sub><i>A</i><sub2>1</sub2>↔<i>A</i><sub2>3</sub2></sub>/<i>R</i><sub><i>A</i><sub2>1</sub2>↔<i>A</i><sub2>2</sub2></sub>.</li><li>Similarly, we can easily compute all re-encryptions keys from any A's devices to any B's devices. Indeed <maths id="math0021" num=""><math display="inline"><msub><mi>R</mi><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>↔</mo><msub><mi>B</mi><mn>2</mn></msub></mrow></msub><mo>=</mo><msubsup><mi>R</mi><mrow><msub><mi>A</mi><mn>3</mn></msub><mo>↔</mo><msub><mi>B</mi><mn>1</mn></msub></mrow><msub><mi>R</mi><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>↔</mo><msub><mi>A</mi><mn>3</mn></msub><mn>.</mn><msub><mi>R</mi><mrow><msub><mi>B</mi><mn>1</mn></msub><mo>↔</mo><msub><mi>B</mi><mn>2</mn></msub></mrow></msub></mrow></msub></msubsup></math><img id="ib0021" file="imgb0021.tif" wi="46" he="10" img-content="math" img-format="tif" inline="yes"/></maths></li></ul></p><heading id="h0004">Distributed secure storage</heading><p id="p0064" num="0064">Suppose A wants to store a message m in her cloud, so that B can access it. She selects one of her devices, <i>e.g.</i> A<sub>3</sub>, and encrypts the data m under the public key of this selected device (with the second level encryption algorithm), she obtains <i>C</i><sub>A<sub2>3</sub2></sub> = <i>Encrypt</i><sub>2</sub>(<i>m,pk</i><sub><i>A</i><sub2>3</sub2></sub>) and sends it to the cloud. A can recovers her data from any of her devices as follows:
<ul><li>If she wants to recover it from her device <i>A</i><sub>3</sub>, the proxy sends her <i>C</i><sub><i>A</i><sub2>3</sub2></sub> and, as it is a ciphertext intended to the public key of <i>A</i><sub>3</sub>, <i>A</i> can easily decrypt it with the device <i>A</i><sub>3</sub>.</li><li>If she wants to recover it from another device, <i>e.g</i>. <i>A</i><sub>1</sub>, the proxy can obtain from all available bidirectional re-encryption keys, the re-encryption key from <i>A</i><sub>3</sub> to <i>A</i><sub>1</sub>. With this latter, the proxy can next compute the ciphertext <i>C</i><sub><i>A</i><sub2>1</sub2></sub> = <i>Bidirectícmal.ReEncrypt</i>(<i>C</i><sub><i>A</i><sub2>3</sub2></sub><i>,R</i><sub><i>A</i><sub2>3</sub2><i>↔A</i><sub2>1</sub2></sub>) intended to <i>A</i><sub>1</sub>. <i>A</i><sub>1</sub> can finally decrypt it, using the level 2 decryption procedure of the bidirectional multi-hop type scheme.</li></ul></p><p id="p0065" num="0065">Suppose now that <i>B</i> wants to recover the message <i>m</i>. As <i>A</i> delegates to <i>B</i> her decryption rights, <i>B</i> mays recover her data from any of her devices. Indeed, let <i>i</i> ∈ [1,4]. As already explained, the proxy can compute the re-encryption key from <i>A</i><sub>3</sub> to <i>B<sub>i</sub></i> (related to the unidirectional single-hop scheme): <i>R</i><sub><i>A</i><sub2>3</sub2></sub>→<i><sub>B<sub2>i</sub2></sub></i>. It can also re-encrypts C<i><sub>A<sub2>3</sub2></sub></i> into a level 1 ciphertext<maths id="math0022" num=""><math display="block"><msubsup><mi>C</mi><msub><mi>B</mi><mi>i</mi></msub><mo>′</mo></msubsup><mo>=</mo><mi mathvariant="italic">Unidirectional</mi><mn mathvariant="italic">.</mn><mi mathvariant="italic">ReEncrypt</mi><mfenced separators=""><msub><mi>C</mi><msub><mi>A</mi><mi>s</mi></msub></msub><mo>⁢</mo><msub><mi>R</mi><mrow><msub><mi>A</mi><mi>s</mi></msub><mo>→</mo><msub><mi>B</mi><mi>i</mi></msub></mrow></msub></mfenced></math><img id="ib0022" file="imgb0022.tif" wi="81" he="7" img-content="math" img-format="tif"/></maths> intended to <i>B<sub>i</sub></i> and related to the unidirectional single-hop proxy re-encryption scheme.</p><p id="p0066" num="0066">Lost devices may be managed according to the following (different situations are considered).
<ul><li><i>A</i> has still at least one device: the proxy re-encrypts all ciphertexts intended to the lost device, say <i>A</i><sub>2</sub>, into ciphertexts intended to a remaining device of <i>A</i>. This is possible as the proxy can compute all re-encryptions keys between A's devices. Then it stores all new ciphertexts and deletes ciphertexts intended for this lost device. Moreover, to prevent the lost device to access to data via a re-encryption, the proxy also deletes all unidirectional and bidirectional re-encryption keys involving the key of the lost device. Before doing this, the proxy has to be careful since it is necessary for it to keep a set of minimum re-encryption keys to recover all re-encryption keys between remaining devices. For example if the only link to compute the re-encryption key between <i>A</i><sub>1</sub> and <i>A</i><sub>3</sub> is <i>R</i><sub><i>A</i><sub2>1</sub2>↔<i>A</i><sub2>2</sub2></sub> and <i>R</i><sub><i>A</i><sub2>2</sub2>↔<i>A</i><sub2>3</sub2></sub>, then the proxy has first to compute <i>R<sub>A<sub2>1</sub2></sub>↔</i><sub><i>A</i><sub2>3</sub2></sub>and to store it before deleting <i>R</i><sub><i>A</i>1↔<i>A</i><sub2>2</sub2></sub> and <i>R</i><sub><i>A</i><sub2>2</sub2>↔<i>A</i><sub2>3</sub2></sub>.</li><li>A has no more device: the proxy does as described previously, except that the target device is one device of <i>B</i>. Next, the proxy can delete all re-encryption keys involving the lost device, as they are not useful anymore.</li></ul></p><p id="p0067" num="0067"><i>Remark</i> . If the lost device of <i>A</i> is his only one, and if <i>A</i> has no delegates, then it seems that there is no solution. It is thus important to motivate users to have more than one device in such system.</p><p id="p0068" num="0068">The advantage of this solution is that it is not necessary to ask the user to use one of his device in order to decrypt a ciphertext, so as to encrypt it for another key. Moreover, this solution also manages the addition of new devices into the system. For this purpose, it is simply necessary to give to the proxy the new related re-encryption keys.<!-- EPO <DP n="13"> --></p><p id="p0069" num="0069">According to a possible embodiment, each user may be provided with his own proxy.</p><p id="p0070" num="0070">In the case each user has his own personal proxy and does not necessarily trust the other proxies, then some modifications are proposed in the above construction. The first modification is in the re-encryption key management. In fact, the bidirectional re-encryption keys of one user (and the unidirectional re-encryption keys from this user to other users) are only given to her proxy</p><p id="p0071" num="0071">The storage of data is not modified: when a user <i>A</i> wants to store a data (and want to share it with a user <i>B</i>), she encrypts it under the public key of one of her device and stores the obtained ciphertext in her cloud.</p><p id="p0072" num="0072">The main difference is when <i>B</i> wants to recover such stored data. Either all the re-encryption keys are generated and stored by the first proxy and there is no more problem. In case the re-encryption key from the key used to encrypt the cipher to the one related to the device <i>B</i> which is used to obtain the data does not exist,<br/>
the proxy first obtains a ciphertext intended to one device of <i>B</i> (using the keys it has stored and the bidirectional multi-hop type scheme). In a second step, the proxy of <i>A</i> sends the result to the proxy of <i>B</i> which can next use the appropriate key and the unidirectional single-hop type scheme to obtain a ciphertext for the requesting device of <i>B.</i></p><p id="p0073" num="0073">In fact, our above scheme is not complete since in the above case, the ciphertext which is send from proxy <i>A</i> to proxy <i>B</i> corresponds to a level 1 ciphertext: it seems not possible to be re-encrypted again for another device of <i>B.</i> We need thus to add the following procedure which permits such re-encryption.</p><p id="p0074" num="0074">BIDIRECTIONAL RE-ENCRYPTION'. On input the public parameters, a first level ciphertext <maths id="math0023" num=""><math display="inline"><msubsup><mi>C</mi><mi>i</mi><mi>ʹ</mi></msubsup></math><img id="ib0023" file="imgb0023.tif" wi="5" he="8" img-content="math" img-format="tif" inline="yes"/></maths> and a re-encryption key <i>R<sub>i↔j</sub></i> from <i>i</i> to <i>j.</i> The re-encryption algorithm proceeds as follows:
<ol><li>1. Validity of the ciphertext intended to i: check if <maths id="math0024" num=""><math display="inline"><mi>e</mi><mfenced separators=""><msubsup><mi>C</mi><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow><mi>ʹ</mi></msubsup><mo>⁢</mo><msubsup><mi>C</mi><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow><mi>ʺ</mi></msubsup></mfenced><mo>=</mo><mi>e</mi><mfenced separators=""><msub><mi>X</mi><mi>i</mi></msub><mo>⁢</mo><mi>g</mi></mfenced><mo>,</mo></math><img id="ib0024" file="imgb0024.tif" wi="40" he="10" img-content="math" img-format="tif" inline="yes"/></maths> if <maths id="math0025" num=""><math display="inline"><mi>e</mi><mfenced separators=""><msubsup><mi>C</mi><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow><mi>ʹʺ</mi></msubsup><mo>,</mo><msup><mi>u</mi><msub><mi>C</mi><mn>1</mn></msub></msup><mo>⋅</mo><mi>υ</mi></mfenced><mo>=</mo></math><img id="ib0025" file="imgb0025.tif" wi="30" he="8" img-content="math" img-format="tif" inline="yes"/></maths> and if <i>S.VERIF</i>(<i>C</i><sub>1</sub><i>,</i>σ<i>,C</i><sub>3</sub>||<i>C</i><sub>4</sub>) <i>=</i> 1.</li><li>2. Compute <maths id="math0026" num=""><math display="inline"><msubsup><mi>C</mi><mrow><mi>j</mi><mo>,</mo><mn>2</mn></mrow><mi>ʹ</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow><msup><mi>ʹ</mi><msub><mi>R</mi><mrow><mi>i</mi><mo>↔</mo><mi>j</mi></mrow></msub></msup></msubsup><mo>,</mo><msubsup><mi>C</mi><mrow><mi>j</mi><mo>,</mo><mn>2</mn></mrow><mi>ʺ</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow><msup><mi>ʺ</mi><msub><mi>R</mi><mrow><mi>i</mi><mo>↔</mo><mi>j</mi></mrow></msub></msup></msubsup></math><img id="ib0026" file="imgb0026.tif" wi="51" he="8" img-content="math" img-format="tif" inline="yes"/></maths> and <maths id="math0027" num=""><math display="inline"><msubsup><mi>C</mi><mrow><mi>j</mi><mo>,</mo><mn>2</mn></mrow><mi>ʹʺ</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow><msup><mi>ʹʺ</mi><msub><mi>R</mi><mrow><mi>i</mi><mo>↔</mo><mi>j</mi></mrow></msub></msup></msubsup><mn>.</mn></math><img id="ib0027" file="imgb0027.tif" wi="30" he="8" img-content="math" img-format="tif" inline="yes"/></maths></li></ol></p><p id="p0075" num="0075">The re-encryption of the first level ciphertext is <maths id="math0028" num=""><math display="inline"><msubsup><mi>C</mi><mi>j</mi><mi>ʹ</mi></msubsup></math><img id="ib0028" file="imgb0028.tif" wi="5" he="7" img-content="math" img-format="tif" inline="yes"/></maths> is <maths id="math0029" num=""><math display="inline"><msubsup><mi>C</mi><mi>j</mi><mi>ʹ</mi></msubsup><mo>=</mo><mfenced separators=""><msub><mi>C</mi><mn>1</mn></msub><mo>⁢</mo><msubsup><mi>C</mi><mrow><mi>j</mi><mo>,</mo><mn>2</mn></mrow><mi>ʹ</mi></msubsup><mo>⁢</mo><msubsup><mi>C</mi><mrow><mi>j</mi><mo>,</mo><mn>2</mn></mrow><mi>ʺ</mi></msubsup><mo>⁢</mo><msubsup><mi>C</mi><mrow><mi>j</mi><mo>,</mo><mn>2</mn></mrow><mi>ʹʺ</mi></msubsup><mo>⁢</mo><msub><mi>C</mi><mn>3</mn></msub><mo>⁢</mo><msub><mi>C</mi><mn>4</mn></msub><mo>⁢</mo><mi>σ</mi></mfenced><mn>.</mn></math><img id="ib0029" file="imgb0029.tif" wi="58" he="8" img-content="math" img-format="tif" inline="yes"/></maths>.</p><p id="p0076" num="0076"><i>Lost device.</i> In case one user loose one device, we can apply the above technique, except that some new unidirectional re-encryptions keys have to be send to some proxies. For example, if <i>A</i>'s proxy has the unidirectional re-encryption key from <i>A</i><sub>2</sub> to <i>B</i><sub>3</sub> and <i>B</i> lost her device B<sub>3</sub>, then <i>A</i>'s proxy has to delete the re-encryption key from <i>A</i><sub>2</sub> to <i>B</i><sub>3</sub>. <i>B</i> will not be able to recover data before <i>A</i> will give a new unidirectional re-encryption key to her proxy (to prevent that case, <i>A</i> can compute some unidirectional re-encryption keys for different devices of B and give it to her proxy before the lost of a device).</p></description><claims mxw-id="PCLM56976218" lang="EN" load-source="patent-office"><!-- EPO <DP n="14"> --><claim id="c-en-0001" num="0001"><claim-text>A system comprising electronic devices connectable to a network, said electronic devices being associated with respective key pairs,<br/>
each key pair comprising a private key and a related public key,<br/>
the system being adapted to cipher data with a public key of a key pair of an electronic device of the system, to store thus ciphered data in the network and to share said ciphered data through the network with an electronic device of the system,<br/>
the set of key pairs associated with said electronic devices of the system being partitioned into at least two subsets such that for each subset having more than one key pair there is a mutual trust between all key pairs of such subset,<br/>
the system being arranged to define, for each key pair of each such subset, a bidirectional transition key between said key pair and another key pair of such subset,<br/>
the system being further arranged to define a unidirectional transition key between a key pair of a subset and a key pair of another subset.</claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The system according to claim 1, wherein the system comprises a cryptographic proxy storing the transition keys.</claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The system according to claim 1, wherein the system comprises cryptographic proxies, each cryptographic proxy being associated with a subset of key pairs of the system and storing the transition keys defined for the key pairs of the subset.</claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The system according to claim 1, wherein, upon loss of a private key of a key pair of an electronic device of the system, a transition key being defined for the key pair, the system is arranged to convert any ciphered data stored in the network and ciphered with the public key of said key pair, the ciphered data being converted with the transition key into data decipherable by a private key of another key pair of an electronic device of the system.</claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>A method for securing a system comprising electronic devices connectable to a network, wherein said electronic devices are associated with respective key pairs,<br/>
each key pair comprising a private key and a related public key,<br/>
the system being adapted to cipher data with a public key of a key pair of an electronic device of the system, to store thus ciphered data in the network and to share said ciphered data through the network with an electronic device of the system, the method comprising:<!-- EPO <DP n="15"> -->
<claim-text>/a/ defining a partition of the set of key pairs associated with said electronic devices of the system into at least two subsets such that, for each subset having more than one key pair, there be a mutual trust between all key pairs of such subset;</claim-text>
<claim-text>/b/ defining for each key pair of each such subset a bidirectional transition key between said key pair and another key pair of such subset;</claim-text>
<claim-text>/c/ defining a unidirectional transition key between a key pair of a subset and a key pair of another subset.</claim-text></claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The method according to claim 5, wherein the system comprises a cryptographic proxy, the method comprising storing the transition keys in the cryptographic proxy.</claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>The method according to claim 5, wherein the system comprises cryptographic proxies, each cryptographic proxy being associated with a set of electronic devices of the system, the method comprising storing the transition keys defined for the electronic devices of the set in the associated cryptographic proxy.</claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>The method according to claim 5, wherein, upon loss of a private key of a key pair of an electronic device of the system, a transition key being defined for the key pair, the method comprises converting any ciphered data stored in the network and ciphered with the public key of said key pair, the ciphered data being converted with the transition key into data decipherable by a private key of another key pair of an electronic device of the system.</claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>A computer program product arranged to carry out a method according to claim 5 when executed by a processor.</claim-text></claim><claim id="c-en-0010" num="0010"><claim-text>A non transitory computer readable storage medium storing a computer program according to claim 9.</claim-text></claim></claims><drawings mxw-id="PDW16667000" load-source="patent-office"><!-- EPO <DP n="16"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="165" he="231" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="17"> --><figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="164" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="18"> --><figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="165" he="226" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="19"> --><figure id="f0004" num="4"><img id="if0004" file="imgf0004.tif" wi="165" he="216" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="20"> --><figure id="f0005" num="5"><img id="if0005" file="imgf0005.tif" wi="162" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="21"> --><figure id="f0006" num="6"><img id="if0006" file="imgf0006.tif" wi="165" he="225" img-content="drawing" img-format="tif"/></figure></drawings><search-report-data><doc-page id="srep0001" file="srep0001.tif" wi="156" he="233" type="tif"/></search-report-data><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
