<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2680580-A1" country="EP" doc-number="2680580" kind="A1" date="20140101" family-id="46384242" file-reference-id="318307" date-produced="20180824" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146549108" ucid="EP-2680580-A1"><document-id><country>EP</country><doc-number>2680580</doc-number><kind>A1</kind><date>20140101</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-12174016-A" is-representative="YES"><document-id mxw-id="PAPP154823031" load-source="docdb" format="epo"><country>EP</country><doc-number>12174016</doc-number><kind>A</kind><date>20120628</date><lang>EN</lang></document-id><document-id mxw-id="PAPP176177387" load-source="docdb" format="original"><country>EP</country><doc-number>12174016.1</doc-number><date>20120628</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140454203" ucid="EP-12174016-A" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>12174016</doc-number><kind>A</kind><date>20120628</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1992697148" load-source="docdb">H04N  19/93        20140101ALI20151127BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-1992701688" load-source="docdb">H04N  19/18        20140101ALI20151127BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-1992701855" load-source="docdb">H04N  19/13        20140101AFI20151127BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-1992703617" load-source="docdb">H04N  19/91        20140101ALI20151127BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-2137526537" load-source="docdb" scheme="CPC">H04N  19/93        20141101 LI20141108BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2137526559" load-source="docdb" scheme="CPC">H04N  19/91        20141101 LI20141108BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2137531115" load-source="docdb" scheme="CPC">H04N  19/18        20141101 LI20141108BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2137532044" load-source="docdb" scheme="CPC">H04N  19/13        20141101 FI20141107BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132179808" lang="DE" load-source="patent-office">Kontextcodierte Zwischenspeicher mit reduziertem Grenzfall bei der Videokompression mit Paritätsverdeckung</invention-title><invention-title mxw-id="PT132179809" lang="EN" load-source="patent-office">Reduced worst-case context-coded bins in video compression with parity hiding</invention-title><invention-title mxw-id="PT132179810" lang="FR" load-source="patent-office">Corbeilles codées avec contexte le plus défavorable réduit dans la compression vidéo avec masquage de parité</invention-title><citations><patent-citations><patcit mxw-id="PCIT377485539" load-source="docdb" ucid="US-201213354465-A" dnum-type="application"><document-id format="epo"><country>US</country><doc-number>201213354465</doc-number><kind>A</kind><date>20120120</date></document-id><sources><source name="APP" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT377497083" load-source="docdb" ucid="US-201213524117-A" dnum-type="application"><document-id format="epo"><country>US</country><doc-number>201213524117</doc-number><kind>A</kind><date>20120615</date></document-id><sources><source name="APP" created-by-npl="N"/></sources></patcit></patent-citations><non-patent-citations><nplcit><text>NGUYEN N ET AL: "Adaptive Thresholds for Greater-than-1 and Greater-than-2 Flags", 9. JCT-VC MEETING; 100. MPEG MEETING; 27-4-2012 - 7-5-2012; GENEVA; (JOINT COLLABORATIVE TEAM ON VIDEO CODING OF ISO/IEC JTC1/SC29/WG11 AND ITU-T SG.16 ); URL: HTTP://WFTP3.ITU.INT/AV-ARCH/JCTVC-SITE/,, no. JCTVC-I0281, 17 April 2012 (2012-04-17), XP030112044</text><sources><source mxw-id="PNPL54962235" load-source="docdb" name="SEA" category="A"/></sources></nplcit><nplcit><text>SOLE J ET AL: "Sign data hiding simplification and enhancement", 9. JCT-VC MEETING; 100. MPEG MEETING; 27-4-2012 - 7-5-2012; GENEVA; (JOINT COLLABORATIVE TEAM ON VIDEO CODING OF ISO/IEC JTC1/SC29/WG11 AND ITU-T SG.16 ); URL: HTTP://WFTP3.ITU.INT/AV-ARCH/JCTVC-SITE/,, no. JCTVC-I0326, 17 April 2012 (2012-04-17), XP030112089</text><sources><source mxw-id="PNPL54962236" load-source="docdb" name="SEA" category="A"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR918137488" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>BLACKBERRY LTD</last-name><address><country>CA</country></address></addressbook></applicant><applicant mxw-id="PPAR918142927" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>BLACKBERRY LIMITED</last-name></addressbook></applicant><applicant mxw-id="PPAR918979985" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>BlackBerry Limited</last-name><iid>101413722</iid><address><street>2200 University Avenue East</street><city>Waterloo, ON N2K 0A7</city><country>CA</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR918144736" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>HE DAKE</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918171500" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>HE, DAKE</last-name></addressbook></inventor><inventor mxw-id="PPAR918991993" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>HE, DAKE</last-name><address><street>c/o Research In Motion Limited 295 Phillip Street Extension 78760</street><city>Waterloo, Ontario N2L 3W8</city><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918169960" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>WANG JING</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918153808" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>WANG, JING</last-name></addressbook></inventor><inventor mxw-id="PPAR918984435" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>WANG, JING</last-name><address><street>c/o Research In Motion Limited 295 Phillip Street Extension 75923</street><city>Waterloo, Ontario N2L 3W8</city><country>CA</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR918990400" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Patel, Binesh</last-name><iid>101089551</iid><address><street>Barker Brettell LLP 100 Hagley Road</street><city>Edgbaston Birmingham B16 8QQ</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS548835728" load-source="docdb">AL</country><country mxw-id="DS548842465" load-source="docdb">AT</country><country mxw-id="DS548835730" load-source="docdb">BE</country><country mxw-id="DS548801335" load-source="docdb">BG</country><country mxw-id="DS548846101" load-source="docdb">CH</country><country mxw-id="DS548802194" load-source="docdb">CY</country><country mxw-id="DS548802195" load-source="docdb">CZ</country><country mxw-id="DS548843061" load-source="docdb">DE</country><country mxw-id="DS548835731" load-source="docdb">DK</country><country mxw-id="DS548835732" load-source="docdb">EE</country><country mxw-id="DS548845076" load-source="docdb">ES</country><country mxw-id="DS548801336" load-source="docdb">FI</country><country mxw-id="DS548801337" load-source="docdb">FR</country><country mxw-id="DS548843062" load-source="docdb">GB</country><country mxw-id="DS548835733" load-source="docdb">GR</country><country mxw-id="DS548843063" load-source="docdb">HR</country><country mxw-id="DS548802196" load-source="docdb">HU</country><country mxw-id="DS548846102" load-source="docdb">IE</country><country mxw-id="DS548835734" load-source="docdb">IS</country><country mxw-id="DS548801342" load-source="docdb">IT</country><country mxw-id="DS548835735" load-source="docdb">LI</country><country mxw-id="DS548843064" load-source="docdb">LT</country><country mxw-id="DS548842466" load-source="docdb">LU</country><country mxw-id="DS548843065" load-source="docdb">LV</country><country mxw-id="DS548843066" load-source="docdb">MC</country><country mxw-id="DS548842467" load-source="docdb">MK</country><country mxw-id="DS548842468" load-source="docdb">MT</country><country mxw-id="DS548801343" load-source="docdb">NL</country><country mxw-id="DS548846103" load-source="docdb">NO</country><country mxw-id="DS548801344" load-source="docdb">PL</country><country mxw-id="DS548845077" load-source="docdb">PT</country><country mxw-id="DS548801345" load-source="docdb">RO</country><country mxw-id="DS548845082" load-source="docdb">RS</country><country mxw-id="DS548801350" load-source="docdb">SE</country><country mxw-id="DS548842964" load-source="docdb">SI</country><country mxw-id="DS548846104" load-source="docdb">SK</country><country mxw-id="DS548846105" load-source="docdb">SM</country><country mxw-id="DS548835736" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA128669779" lang="EN" load-source="patent-office"><p id="pa01" num="0001">Methods and devices for reconstructing coefficient levels from a bitstream of encoded video data for a coefficient group in a transform unit. Parity hiding is used to signal the parity of the upper left coefficient of the coefficient group. Based on the parity, either the significant coefficient flag or the greater-than-one flag is encoded/decoded for that coefficient, but not both. The greater-than-one flag is encoded/decoded irrespective of whether a maximum number of greater-than-one flags have been encoded/decoded with respect to the other coefficients in the coefficient group.
<img id="iaf01" file="imgaf001.tif" wi="80" he="103" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA128499152" lang="EN" source="EPO" load-source="docdb"><p>Methods and devices for reconstructing coefficient levels from a bitstream of encoded video data for a coefficient group in a transform unit. Parity hiding is used to signal the parity of the upper left coefficient of the coefficient group. Based on the parity, either the significant coefficient flag or the greater-than-one flag is encoded/decoded for that coefficient, but not both. The greater-than-one flag is encoded/decoded irrespective of whether a maximum number of greater-than-one flags have been encoded/decoded with respect to the other coefficients in the coefficient group.</p></abstract><description mxw-id="PDES63955209" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><b>COPYRIGHT NOTICE</b></heading><p id="p0001" num="0001">A portion of the disclosure of this document and accompanying materials contains material to which a claim for copyright is made. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office files or records, but reserves all other copyright rights whatsoever.</p><heading id="h0002"><b>FIELD</b></heading><p id="p0002" num="0002">The present application generally relates to data compression and, in particular, to methods and devices for encoding and decoding transform coefficients, specifically in the case of video coding.</p><heading id="h0003"><b>BACKGROUND</b></heading><p id="p0003" num="0003">Data compression occurs in a number of contexts. It is very commonly used in communications and computer networking to store, transmit, and reproduce information efficiently. It finds particular application in the encoding of images, audio and video. Video presents a significant challenge to data compression because of the large amount of data required for each video frame and the speed with which encoding and decoding often needs to occur. The current state-of-the-art for video encoding is the ITU-T H.264/AVC video coding standard. It defines a number of different profiles for different applications, including the Main profile, Baseline profile and others. A next-generation video encoding standard is currently under development through a joint initiative of MPEG-ITU termed High Efficiency Video Coding (HEVC). The initiative may eventually result in a video-coding standard that will form part of a suite of standards referred to as MPEG-H.</p><p id="p0004" num="0004">There are a number of standards for encoding/decoding images and videos, including H.264, that use block-based coding processes. In these processes, the image or<!-- EPO <DP n="2"> --> frame is divided into blocks, typically 4x4 or 8x8, and the blocks are spectrally transformed into coefficients, quantized, and entropy encoded. In many cases, the data being transformed is not the actual pixel data, but is residual data following a prediction operation. Predictions can be intra-frame, <i>i.e.</i> block-to-block within the frame/image, or inter-frame, <i>i.e.</i> between frames (also called motion prediction). It is expected that HEVC will also have these features.</p><p id="p0005" num="0005">When spectrally transforming residual data, many of these standards prescribe the use of a discrete cosine transform (DCT) or some variant thereon. The resulting DCT coefficients are then quantized using a quantizer to produce quantized transform domain coefficients, or indices.</p><p id="p0006" num="0006">The block or matrix of quantized transform domain coefficients (sometimes referred to as a "transform unit") is then entropy encoded using a particular context model. In H.264/AVC and in the current development work for HEVC, the quantized transform coefficients are encoded by (a) encoding a last significant coefficient position indicating the location of the last non-zero coefficient in the transform unit, (b) encoding a significance map indicating the positions in the transform unit (other than the last significant coefficient position) that contain non-zero coefficients, (c) encoding the magnitudes of the non-zero coefficients, and (d) encoding the signs of the non-zero coefficients. This encoding of the quantized transform coefficients often occupies 30-80% of the encoded data in the bitstream.</p><heading id="h0004"><b>BRIEF DESCRIPTION OF THE DRAWINGS</b></heading><p id="p0007" num="0007">Reference will now be made, by way of example, to the accompanying drawings which show example embodiments of the present application, and in which:</p><p id="p0008" num="0008"><figref idrefs="f0001">Figure 1</figref> shows, in block diagram form, an encoder for encoding video;</p><p id="p0009" num="0009"><figref idrefs="f0002">Figure 2</figref> shows, in block diagram form, a decoder for decoding video;</p><p id="p0010" num="0010"><figref idrefs="f0003">Figure 3</figref> shows, in flowchart form, an example process for decoding encoded video with parity hiding;</p><p id="p0011" num="0011"><figref idrefs="f0004">Figure 4</figref> shows a simplified block diagram of an example embodiment of an encoder; and<!-- EPO <DP n="3"> --></p><p id="p0012" num="0012"><figref idrefs="f0005">Figure 5</figref> shows a simplified block diagram of an example embodiment of a decoder.</p><p id="p0013" num="0013">Similar reference numerals may have been used in different figures to denote similar components.</p><heading id="h0005"><b>DESCRIPTION OF EXAMPLE EMBODIMENTS</b></heading><p id="p0014" num="0014">The present application describes methods and encoders/decoders for encoding and decoding residual video data. In particular, the present application discloses methods and devices for reconstructing coefficient levels from a bitstream of encoded video data for a coefficient group in a transform unit. Parity is used to hide information regarding the upper left coefficient, which is the last coefficient in the coefficient group processed in the scan order. The decoding of a significant-coefficient flag for the upper left coefficient and the decoding of a greater-than-one flag for the upper left coefficient are conditional upon the parity of the upper left coefficient, and irrespective of whether a threshold number of greater-than-one flags were decoded for the other coefficients of the coefficient group.</p><p id="p0015" num="0015">In a first aspect, the present application describes method of decoding a bitstream of encoded video to reconstruct coefficients of a coefficient group in a video decoder, the coefficient group including an upper left coefficient. The method includes decoding flags for reconstructing the coefficients of the coefficient group other than the upper left coefficient, wherein decoding includes, for each non-zero coefficient, decoding a greater-than-one flag if the number of previously decoded greater-than-one flags for the coefficient group is less than a predetermined threshold number; determining a parity of the upper left coefficient; decoding a significant-coefficient flag for the upper left coefficient only if the parity is even; and decoding a greater-than-one flag for the upper left coefficient only if the parity is odd and irrespective of the predetermined threshold number.</p><p id="p0016" num="0016">The present application further discloses a method of encoding video in a video encoder to output a bitstream of encoded data, the video including a coefficient group including an upper left coefficient. The method includes encoding a parity of the upper left<!-- EPO <DP n="4"> --> coefficient; encoding flags for the coefficients of the coefficient group other than the upper left coefficient, wherein encoding includes, for each non-zero coefficient other than the upper left coefficient, encoding a greater-than-one flag if the number of previously encoded greater-than-one flags for the coefficient group is less than a predetermined threshold number; encoding a significant-coefficient flag for the upper left coefficient only if the parity is even; and encoding a greater-than-one flag for the upper left coefficient only if the parity is odd and irrespective of the predetermined threshold number.</p><p id="p0017" num="0017">In a further aspect, the present application describes encoders and decoders configured to implement such methods of encoding and decoding.</p><p id="p0018" num="0018">In yet a further aspect, the present application describes non-transitory computer-readable media storing computer-executable program instructions which, when executed, configured a processor to perform the described methods of encoding and/or decoding.</p><p id="p0019" num="0019">Other aspects and features of the present application will be understood by those of ordinary skill in the art from a review of the following description of examples in conjunction with the accompanying figures.</p><p id="p0020" num="0020">In the description that follows, some example embodiments are described with reference to the H.264 standard for video coding and/or the developing HEVC standard. Those ordinarily skilled in the art will understand that the present application is not limited to H.264/AVC or HEVC but may be applicable to other video coding/decoding standards, including possible future standards, multi-view coding standards, scalable video coding standards, and reconfigurable video coding standards.</p><p id="p0021" num="0021">In the description that follows, when referring to video or images the terms frame, picture, slice, tile and rectangular slice group may be used somewhat interchangeably. Those of skill in the art will appreciate that, in the case of the H.264 standard, a frame may contain one or more slices. The term "frame" may be replaced with "picture" in HEVC. Other terms may be used in other video coding standards. It will also be appreciated that certain encoding/decoding operations might be performed on a frame-by-frame basis, some are performed on a slice-by-slice basis, some picture-by-picture, some tile-by-tile, and some by rectangular slice group, depending on the particular requirements or terminology of the<!-- EPO <DP n="5"> --> applicable image or video coding standard. In any particular embodiment, the applicable image or video coding standard may determine whether the operations described below are performed in connection with frames and/or slices and/or pictures and/or tiles and/or rectangular slice groups, as the case may be. Accordingly, those ordinarily skilled in the art will understand, in light of the present disclosure, whether particular operations or processes described herein and particular references to frames, slices, pictures, tiles, rectangular slice groups are applicable to frames, slices, pictures, tiles, rectangular slice groups, or some or all of those for a given embodiment. This also applies to transform units, coding units, groups of coding units, etc., as will become apparent in light of the description below.</p><p id="p0022" num="0022">Reference is now made to <figref idrefs="f0001">Figure 1</figref>, which shows, in block diagram form, an encoder 10 for encoding video. Reference is also made to <figref idrefs="f0002">Figure 2</figref>, which shows a block diagram of a decoder 50 for decoding video. It will be appreciated that the encoder 10 and decoder 50 described herein may each be implemented on an application-specific or general purpose computing device, containing one or more processing elements and memory. The operations performed by the encoder 10 or decoder 50, as the case may be, may be implemented by way of application-specific integrated circuit, for example, or by way of stored program instructions executable by a general purpose processor. The device may include additional software, including, for example, an operating system for controlling basic device functions. The range of devices and platforms within which the encoder 10 or decoder 50 may be implemented will be appreciated by those ordinarily skilled in the art having regard to the following description.</p><p id="p0023" num="0023">The encoder 10 receives a video source 12 and produces an encoded bitstream 14. The decoder 50 receives the encoded bitstream 14 and outputs a decoded video frame 16. The encoder 10 and decoder 50 may be configured to operate in conformance with a number of video compression standards. For example, the encoder 10 and decoder 50 may be H.264/AVC compliant. In other embodiments, the encoder 10 and decoder 50 may conform to other video compression standards, including evolutions of the H.264/AVC standard, like HEVC.</p><p id="p0024" num="0024">The encoder 10 includes a spatial predictor 21, a coding mode selector 20, transform processor 22, quantizer 24, and entropy encoder 26. As will be appreciated by those ordinarily skilled in the art, the coding mode selector 20 determines the appropriate<!-- EPO <DP n="6"> --> coding mode for the video source, for example whether the subject frame/slice is of I, P, or B type, and whether particular coding units (e.g. macroblocks, coding units, etc.) within the frame/slice are inter or intra coded. The transform processor 22 performs a transform upon the spatial domain data. In particular, the transform processor 22 applies a block-based transform to convert spatial domain data to spectral components. For example, in many embodiments a discrete cosine transform (DCT) is used. Other transforms, such as a discrete sine transform or others may be used in some instances. The block-based transform is performed on a coding unit, macroblock or sub-block basis, depending on the size of the macroblocks or coding units. In the H.264 standard, for example, a typical 16x16 macroblock contains sixteen 4x4 transform blocks and the DCT process is performed on the 4x4 blocks. In some cases, the transform blocks may be 8x8, meaning there are four transform blocks per macroblock. In yet other cases, the transform blocks may be other sizes. In some cases, a 16x16 macroblock may include a non-overlapping combination of 4x4 and 8x8 transform blocks.</p><p id="p0025" num="0025">Applying the block-based transform to a block of pixel data results in a set of transform domain coefficients. A "set" in this context is an ordered set in which the coefficients have coefficient positions. In some instances the set of transform domain coefficients may be considered as a "block" or matrix of coefficients. In the description herein the phrases a "set of transform domain coefficients" or a "block of transform domain coefficients" are used interchangeably and are meant to indicate an ordered set of transform domain coefficients.</p><p id="p0026" num="0026">The set of transform domain coefficients is quantized by the quantizer 24. The quantized coefficients and associated information are then encoded by the entropy encoder 26.</p><p id="p0027" num="0027">The block or matrix of quantized transform domain coefficients may be referred to herein as a "transform unit" (TU). In some cases, the TU may be non-square, e.g. a non-square quadrature transform (NSQT).</p><p id="p0028" num="0028">Intra-coded frames/slices (<i>i.e</i>. type I) are encoded without reference to other frames/slices. In other words, they do not employ temporal prediction. However intra-coded frames do rely upon spatial prediction within the frame/slice, as illustrated in <figref idrefs="f0001">Figure 1</figref> by the spatial predictor 21. That is, when encoding a particular block the data in the block may be compared to the data of nearby pixels within blocks already encoded for that frame/slice.<!-- EPO <DP n="7"> --> Using a prediction algorithm, the source data of the block may be converted to residual data. The transform processor 22 then encodes the residual data. H.264, for example, prescribes nine spatial prediction modes for 4x4 transform blocks. In some embodiments, each of the nine modes may be used to independently process a block, and then rate-distortion optimization is used to select the best mode.</p><p id="p0029" num="0029">The H.264 standard also prescribes the use of motion prediction/compensation to take advantage of temporal prediction. Accordingly, the encoder 10 has a feedback loop that includes a de-quantizer 28, inverse transform processor 30, and deblocking processor 32. The deblocking processor 32 may include a deblocking processor and a filtering processor. These elements mirror the decoding process implemented by the decoder 50 to reproduce the frame/slice. A frame store 34 is used to store the reproduced frames. In this manner, the motion prediction is based on what will be the reconstructed frames at the decoder 50 and not on the original frames, which may differ from the reconstructed frames due to the lossy compression involved in encoding/decoding. A motion predictor 36 uses the frames/slices stored in the frame store 34 as source frames/slices for comparison to a current frame for the purpose of identifying similar blocks. Accordingly, for macroblocks or coding units to which motion prediction is applied, the "source data" which the transform processor 22 encodes is the residual data that comes out of the motion prediction process. For example, it may include information regarding the reference frame, a spatial displacement or "motion vector", and residual pixel data that represents the differences (if any) between the reference block and the current block. Information regarding the reference frame and/or motion vector may not be processed by the transform processor 22 and/or quantizer 24, but instead may be supplied to the entropy encoder 26 for encoding as part of the bitstream along with the quantized coefficients.</p><p id="p0030" num="0030">Those ordinarily skilled in the art will appreciate the details and possible variations for implementing video encoders.</p><p id="p0031" num="0031">The decoder 50 includes an entropy decoder 52, dequantizer 54, inverse transform processor 56, spatial compensator 57, and deblocking processor 60. The deblocking processor 60 may include deblocking and filtering processors. A frame buffer 58 supplies reconstructed frames for use by a motion compensator 62 in applying motion<!-- EPO <DP n="8"> --> compensation. The spatial compensator 57 represents the operation of recovering the video data for a particular intra-coded block from a previously decoded block.</p><p id="p0032" num="0032">The bitstream 14 is received and decoded by the entropy decoder 52 to recover the quantized coefficients. Side information may also be recovered during the entropy decoding process, some of which may be supplied to the motion compensation loop for use in motion compensation, if applicable. For example, the entropy decoder 52 may recover motion vectors and/or reference frame information for inter-coded macroblocks.</p><p id="p0033" num="0033">The quantized coefficients are then dequantized by the dequantizer 54 to produce the transform domain coefficients, which are then subjected to an inverse transform by the inverse transform processor 56 to recreate the "video data". It will be appreciated that, in some cases, such as with an intra-coded macroblock or coding unit, the recreated "video data" is the residual data for use in spatial compensation relative to a previously decoded block within the frame. The spatial compensator 57 generates the video data from the residual data and pixel data from a previously decoded block. In other cases, such as inter-coded macroblocks or coding units, the recreated "video data" from the inverse transform processor 56 is the residual data for use in motion compensation relative to a reference block from a different frame. Both spatial and motion compensation may be referred to herein as "prediction operations".</p><p id="p0034" num="0034">The motion compensator 62 locates a reference block within the frame buffer 58 specified for a particular inter-coded macroblock or coding unit. It does so based on the reference frame information and motion vector specified for the inter-coded macroblock or coding unit. It then supplies the reference block pixel data for combination with the residual data to arrive at the reconstructed video data for that coding unit/macroblock.</p><p id="p0035" num="0035">A deblocking/filtering process may then be applied to a reconstructed frame/slice, as indicated by the deblocking processor 60. After deblocking/filtering, the frame/slice is output as the decoded video frame 16, for example for display on a display device. It will be understood that the video playback machine, such as a computer, set-top box, DVD or Blu-Ray player, and/or mobile handheld device, may buffer decoded frames in a memory prior to display on an output device.<!-- EPO <DP n="9"> --></p><p id="p0036" num="0036">It is expected that HEVC-compliant encoders and decoders will have many of these same or similar features.</p><heading id="h0006"><b><i>Quantized Transform Domain Coefficient Encoding and Decoding</i></b></heading><p id="p0037" num="0037">The present application describes example processes and devices for encoding and decoding transform coefficients of a transform unit. The non-zero coefficients are identified by a significance map. A significance map is a block, matrix, group, or set of flags that maps to, or corresponds to, a transform unit or a defined unit of coefficients (e.g. several transform units, a portion of a transform unit, or a coding unit). Each flag indicates whether the corresponding position in the transform unit or the specified unit contains a non-zero coefficient or not. In existing standards, these flags may be referred to as significant-coefficient flags. In existing standards, there is one flag per coefficient from the DC coefficient to the last significant coefficient in a scan order, and the flag is a bit that is zero if the corresponding coefficient is zero and is set to one if the corresponding coefficient is non-zero. The term "significance map" as used herein is intended to refer to a matrix or ordered set of significant-coefficient flags for a transform unit, as will be understood from the description below, or a defined unit of coefficients, which will be clear from the context of the applications.</p><p id="p0038" num="0038">The significance map may be converted to a vector in accordance with the scan order (which may be vertical, horizontal, diagonal, zig-zag, or any other scan order permitted under the applicable standard). The scan is typically done in "reverse" order, <i>i.e</i>. starting with the last significant coefficient and working back through the significant map in reverse direction until the significant-coefficient flag in the upper-left corner at [0,0] is reached. In the present description, the term "scan order" is intended to mean the order in which flags, coefficients, or groups, as the case may be, are processed and may include orders that are referred to colloquially as "reverse scan order".</p><p id="p0039" num="0039">Each significant-coefficient flag is then entropy encoded using the applicable context-adaptive coding scheme. For example, in many applications a context-adaptive binary arithmetic coding (CABAC) scheme may be used.<!-- EPO <DP n="10"> --></p><p id="p0040" num="0040">The magnitudes for those non-zero coefficients may then be encoded. In some standards, magnitudes (<i>i.e</i>. levels) are encoded by encoding one or more level flags. If additional information is required to signal the magnitude of a quantized transform domain coefficient, then remaining-level data may be encoded. In one example implementation, the levels may be encoded by first encoding a map of greater-than-one flags indicating which non-zero coefficients having an absolute value level greater than one. Greater-than-two flags may then be encoded to indicate which non-zero coefficients have a level greater than two. Remaining level data may then be encoded for any of the coefficients having an absolute value greater than two. The value encoded in the remaining-level integer may be the actual value minus three. The sign of each of the non-zero coefficients is also encoded. Each non-zero coefficient has a sign bit indicating whether the level of that non-zero coefficient is negative or positive.</p><p id="p0041" num="0041">In some implementations a transform unit may be partitioned into contiguous and non-overlapping coefficient groups. The coefficients within each coefficient group may be processed in a scan order, e.g. diagonal, before processing the next coefficient group in a group-scan order (which may also be diagonal, or any other selected order). Coefficient groups may be square, e.g. 4x4, or non-square, e.g. 2x8, 8x2, <i>etc.</i> In some cases, coefficient groups may vary in size and may be oriented/aligned with a scan order, e.g. diagonally.</p><p id="p0042" num="0042">Coefficient groups sometimes may be used to implement multi-level coding, such as through the use of significant-coefficient group flags. A significant-coefficient group flag indicates whether the associated coefficient group should be presumed to have non-zero coefficients or whether all coefficients may be presumed to be zero (and thus no further data need be encoded/decoded for that coefficient group).</p><p id="p0043" num="0043">Some prior work has focused on sign bit hiding. <patcit id="pcit0001" dnum="US13354465B"><text>US patent application 13/354,465 was filed January 20, 2012</text></patcit>, and is entitled "Multiple Sign Bit Hiding within a Transform Unit". The earlier work focused on dividing coefficients into non-overlapping sets and hiding one bit per set. The sign of one of the coefficients in the set is hidden in the parity of the sum of the absolute value of the coefficients in the set. Accordingly, at the encoder if the parity of the sum does not match the sign, then the value of one of the coefficients in the set is adjusted up or down to force the party to correspond to the sign. In one example, the coefficients are divided into non-overlapping sets of sixteen corresponding to the coefficient<!-- EPO <DP n="11"> --> groups into which a transform unit is divided. The contents of <patcit id="pcit0002" dnum="US13354465B"><text>US application 13/354,465</text></patcit> are hereby incorporated by reference.</p><p id="p0044" num="0044"><patcit id="pcit0003" dnum="US13524117B"><text>US patent application 13/524,117 was filed June 15, 2012</text></patcit>, and is entitled "Multi-bit Information Hiding using Overlapping Subsets". This application describes the hiding of multiple sign bits in a single coefficient group based on parity values determined using overlapping subsets of coefficients. The application also discloses a number of example conditions for enabling information hiding using parity. The contents of <patcit id="pcit0004" dnum="US13524117B"><text>US application 13/524,117</text></patcit> are hereby incorporated by reference.</p><p id="p0045" num="0045">In accordance with one aspect of the present application, parity of the upper left coefficient is a condition for determining whether to encode/decode a significant-coefficient flag for the upper left coefficient and/or a greater-than-one flag for the upper left coefficient. The parity of the upper left coefficient may be signaled by the parity of the sum of absolute values of the other coefficients in the coefficient group (e.g. coefficients 1 to 15). Various conditions may be applied to determine whether parity hiding is enabled for a particular coefficient group.</p><p id="p0046" num="0046">With the maximum number of greater-than-one flags set at eight, parity hiding for the upper left coefficient still results in a worst-case number of context-coded bins of 25. Worst-case situations are typically assessed on the basis of the maximum number of context-coded bins required to encode a coefficient group. Using this measure, the worst case is sixteen significant-coefficient flags, eight greater-than-one flags, and one greater-than-two flag: 16+8+1 = 25.</p><p id="p0047" num="0047">In accordance with one aspect of the present application, parity hiding may be leveraged to improve the worst-case scenario without sacrificing compression efficiency. In one aspect, the threshold maximum number of greater-than-one flags is applied to the coefficients of the coefficient group other than the upper left coefficient (e.g. the DC coefficient). This allows us to reduce the threshold maximum. In one example, the maximum number of greater-than-one flags is reduced from eight to seven, although other maximums may be used in other embodiments. Parity hiding is used to code the flags of the upper left coefficient. In particular, if the parity of the upper left coefficient is even, then the greater-than-one flag of the upper left coefficient is <u>not</u> encoded/decoded. If the parity of the upper left coefficient is odd, then the significant-coefficient flag of the upper left coefficient is <u>not</u><!-- EPO <DP n="12"> --> encoded/decoded. Notably, the greater-than-one flag is encoded/decoded when the parity is odd irrespective of whether the maximum number of greater-than-one flags has been reached with respect to the other coefficients of the coefficient group. That is, the greater-than-one flag of the upper left coefficient, if encoded/decoded, is not counted against the maximum number of greater-than-one flags for the coefficient group.</p><p id="p0048" num="0048">This scheme results in a worst-case throughput of 24. When parity hiding is enabled and the upper left coefficient is even, the worst case is sixteen significant coefficient flags, seven greater-than-one flags, and one greater-than-two flag: 16+7+1 = 24. When parity hiding is enabled and the upper left coefficient is odd, the worst case is fifteen significant coefficient flags, eight greater-than-one flags (one for the upper left coefficient and a maximum of seven in the remainder of the coefficient group), and one greater-than-two flag: 15+(7+1)+1 = 24.</p><p id="p0049" num="0049">Reference is now made to <figref idrefs="f0003">Figure 3</figref>, which shows in flowchart form an example process 100 for decoding a bitstream of encoded data to reconstruct quantized transform domain coefficients. The process 100 may be carried out by a video decoder, which may be implemented by a computing device, including a general purpose computing devices (for example, a tablet, laptop, desktop, mobile communications device, or set-top box) executing a video decoding application.</p><p id="p0050" num="0050">The process 100 is executed to decode a bitstream of encoded data. The bitstream may be obtained through a network connection, for example. In another exmape, the bitstream may be obtained from a stored computer-readable media (e.g. a memory element, such as a disc, flash drive, memory card, RAM, ROM, or other memory).</p><p id="p0051" num="0051">In this example, the process 100 is applied to reconstruct the coefficients of a 4x4 coefficient group containing sixteen coefficients processed in a scan order from the lower right coefficient to the upper left coefficient. The scan order may be diagonal in some cases (or horizontal, vertical, zig zag, or other such scan orders). Processing of coefficients from bottom right to upper left is sometimes referred to colloquially as "reverse" scan order.</p><p id="p0052" num="0052">The process 100 includes decoding the significant coefficient flags for the first fifteen coefficients in scan order, <i>i.e</i>. coefficients x<sub>15</sub>, x<sub>14</sub>, x<sub>13</sub>, ..., x<sub>1</sub>, in operation 102. This excludes the upper left coefficient, x<sub>0</sub>. In operation 104, greater-than-one flags for any non-zero<!-- EPO <DP n="13"> --> coefficients amongst the first fifteen coefficients, x<sub>15</sub> to x<sub>1</sub>, are decoded subject to a threshold maximum number of greater-than-one flags. In this example, the threshold may be a maximum of seven greater-than-one flags for the coefficients x<sub>15</sub> to x<sub>1</sub> per coefficient group. Operation 106 involves decoding greater-than-two flags for any coefficients in coefficients x<sub>15</sub> to x<sub>1</sub> that are greater-than-one, subject to a threshold maximum number of greater-than-two flags, which in this case may be set to 1. Operation 108 involves decoding remaining level data for coefficients x<sub>15</sub> to x<sub>1</sub>. The decoding of significant-coefficient flags, greater-than-one flags, greater-than-two flags, and remaining level data for coefficients x<sub>15</sub> to x<sub>1</sub> provides the decoder with the magnitudes of each of the first fifteen coefficients of the coefficient group.</p><p id="p0053" num="0053">In operation 110, the decoder obtains a parity value for the upper left coefficient, x<sub>0</sub>. In some embodiments the parity value is a hidden parity based on the previously decoded/reconstructed coefficients of the coefficient group. The parity may be hidden in the parity of the sum of the absolute value of coefficients x<sub>15</sub> to x<sub>1</sub>, for example. The parity may be hidden in other ways and using fewer than all of coefficients x<sub>15</sub> to x<sub>1</sub>. In one case that will be described later below, the parity is signaled in the bitstream by a flag that the decoder decodes. In this example, however, it is presumed that the decoder obtains the parity value from the parity of the sum of absolute values of coefficients x<sub>15</sub> to x<sub>1</sub>.</p><p id="p0054" num="0054">In operation 112, the decoder assesses whether the parity value of the upper left coefficient is odd or even. In other words, the decoder determines whether the upper left coefficient has an odd magnitude or an even magnitude. If odd, then the decoder knows that the upper left coefficient cannot be 0, so a significant-coefficient flag would have been redundant, and the decoder knows that a significant-coefficient flag is not coded in the bitstream. Accordingly, the decoder decodes a greater-than-one flag in operation 114. The greater-than-one flag indicates whether the upper left coefficient is 1 or whether it is 3 or higher. Note that a greater-than-two flag does not need to be coded in this instance either, since if the greater-than-one flag equals 1, then the upper left coefficient is necessarily greater-than-two. Also note that the greater-than-one flag for the upper left coefficient is decoded irrespective of whether the maximum number of greater-than-one flags has already been reached with respect to the decoding of those flags for coefficients x<sub>15</sub> to x<sub>1</sub> in operation<!-- EPO <DP n="14"> --> 104. That is, the greater-than-one flag for the upper left coefficient is always encoded/decoded when parity hiding is enabled and the parity value is odd.</p><p id="p0055" num="0055">Once the greater-than-one flag is decoded in operation 114, then the decoder decodes remaining level data, if necessary, in operation 120. The remaining level data may code the magnitude of the coefficient minus three (since it is known that the value is at least three). In some cases, because the coefficient is known to be odd, the remaining level data decoded in operation 120 may be the remaining-level-minus-three mod 2. Other mechanisms for signaling the remaining level data will be appreciated.</p><p id="p0056" num="0056">If, in operation 112, it is determined that the parity of the upper left coefficient is even, then in operation 116 the decoder decodes a significant-coefficient flag for the upper left coefficient. In operation 118, if the significant coefficient flags is 1, the decoder decodes a greater-than-two flag subject to the maximum threshold number of greater-than-two flags. It will be appreciated that if the significant-coefficient flag is 1, then the upper left coefficient is known to be 2 or 4 (or higher). Accordingly, a greater-than-one flag is not necessary. The greater-than-two flag (if encoded) signals whether the magnitude of the upper left coefficient is 2 or whether it is 4 or higher. After operation 118 the decoder decodes remaining level data for the upper left coefficient (if any) in operation 120. As noted above, the remaining level data may be encoded in a manner that takes into account the fact that the coefficient is known to be even.</p><p id="p0057" num="0057">It will be understood that some of the foregoing described operations may be split into separate operations in another example embodiment, and some of the separate operations may be combined or reordered in some embodiments.</p><p id="p0058" num="0058">The described process 100 imposes a threshold maximum number of greater-than-one flags upon the first fifteen coefficients x<sub>15</sub> to x<sub>1</sub>, and then requires decoding of a greater-than-one flag for the upper left coefficient irrespective of whether the maximum number was reached if the upper left coefficient is known to be odd from the parity determination. In some example embodiments, the number of coefficients in the set or group being decoded may be more or less than sixteen, and the process may be adapted accordingly.</p><p id="p0059" num="0059">The process at the encoder is largely similar to the process at the decoder, except that the encoder knows whether the upper left coefficient is even or odd and may need<!-- EPO <DP n="15"> --> to adjust one of the other coefficients in the coefficient group (<i>i.e.</i> one of x<sub>15</sub> to x<sub>1</sub>), in order for the parity value to match the parity of the upper left coefficient. Various rate-distortion optimization techniques may be used to determine which coefficient to adjust. The encoder encodes the flags and remaining level data for coefficients x<sub>15</sub> to x<sub>1</sub>, subject to the maximum threshold number of particular flags. The encoder then encodes either a significant-coefficient flag or a greater-than-one flag for the upper left coefficient, depending on its parity. A greater-than-two flag, if applicable, may then be encoded (if the parity is even and the significant coefficient flag equals 1), and remaining level data (if any) may be encoded.</p><heading id="h0007"><b><i>Context coding of upper left greater-than-one flag</i></b></heading><p id="p0060" num="0060">In the above-described encoding and decoding process, the coding of the greater-than-one flags is context-based. The greater-than-one flags for coefficients x<sub>15</sub> to x<sub>1</sub> indicate whether that coefficient is 1 or greater than or equal to 2. For the upper left coefficient, however, the greater-than-one flag indicates whether the upper left coefficient is 1 or greater than or equal to 3. Accordingly, the probability distribution with respect to this flag may be different than the regular greater-than-one flags.</p><p id="p0061" num="0061">As a result, in some embodiments, an additional set of contexts may be defined for coding the greater-than-one flag of the upper left coefficient. The context may be based on the position of the coefficient in the transform unit, in some embodiments. For example, the context (ctxInc) for coding the greater-than-one flag for the upper left coefficient in a coefficient group may be determined as follows:
<pre listing-type="program-listing">                    If posX + posY == 0
                           ctxInc = Context 1
                    Else
                           ctxInc = Context 2</pre></p><p id="p0062" num="0062">In this example, posX and posY indicate the x, y position of the upper left coefficient relative to the upper left corner of the transform unit (which may contain multiple coefficient groups, depending on its size). These two additional contexts may be used for both luma and chroma. In another example, a separate set of two contexts may be defined for luma and for chroma, <i>i.e</i>. four new contexts.<!-- EPO <DP n="16"> --></p><p id="p0063" num="0063">In another example, the context for coding the greater-than-one flag for the upper left coefficient in a coefficient group is determined as follows:
<pre listing-type="program-listing">             If parity hiding is enabled, and the upper left coefficient is odd:
                    If posX + posY == 0
                           ctxInc = Context 1
                    Else
                           ctxInc = Context 2
             Else
                    If posX + posY == 0
                           ctxInc = Context 3
                    Else
                           ctxInc = Context 4</pre></p><p id="p0064" num="0064">Note that in this example, context 1 is used for coding the greater-than-one flag of the upper left coefficient when parity hiding and when in position [0, 0] of the TU. If not in position [0, 0], then context 2 is used. If parity hiding is not used, then context 3 is used for coding the greater-than-one flag of the upper left coefficient when in position [0, 0], and context 4 otherwise.</p><p id="p0065" num="0065">In yet another example, if parity hiding is not used then the greater-than-one flag of the upper left coefficient is coded as per usual using the context set otherwise used for coding greater-than-one flags, as indicated by the following pseudo-code:
<pre listing-type="program-listing">             If parity hiding is enabled, and the upper left coefficient is odd:
                    If posX + posY == 0
                           ctxInc = Context 1
                    Else
                           ctxInc = Context 2
             Else
                    Use normal contexts</pre></p><p id="p0066" num="0066">In yet another example, if parity hiding is not used or there is at least one coefficient that is greater than one in the first fifteen coefficients then the greater-than-one flag of the upper left coefficient is coded as per usual using the context set otherwise used for coding greater-than-one flags, as indicated by the following pseudo-code:
<pre listing-type="program-listing">             If parity hiding is enabled, and the upper left coefficient is odd, and none of the
             first fifteen coefficients are greater than one:
                    If posX + posY == 0
                           ctxInc = Context 1
                    Else
                           ctxInc = Context 2<!-- EPO <DP n="17"> -->
             Else
                    Use normal contexts</pre></p><p id="p0067" num="0067">Other processes may be employed by the encoder/decoder for determining context for encoding/decoding the greater-than-one flags in some other embodiments.</p><heading id="h0008"><b><i>Coded parity value</i></b></heading><p id="p0068" num="0068">As described above, in many embodiments the parity of the upper left coefficient may be determined based upon a parity value calculation involving one or more of the other coefficients in the coefficient group. However, in another embodiment the parity of the upper left coefficient is explicitly signaled in the bitstream. That is, the parity is encoded as a separate syntax element. Example pseudo-code illustrating one embodiment of such a process is as follows:
<pre listing-type="program-listing">                Decode( parity(x) == 0 ) // parity of x (0: even, 1: odd)
                If( parity(x) == 0 )
               {
                  Decode( |x| &gt; 0 ) // significance flag of x
                  If(|x|&gt; 0)
                  {
                    Decode( |x| &gt; 2 ) // greaterTwo flag of |x|
                    Decode( sign(x) ) // sign of x
                    If(|x|&gt; 2)
                    {
                       Decode( (|x| - 4)/2 ) // remaining level of |x|
                    }
                  }
               }
               else
               {
                 Decode( |x| &gt; 1) // greaterOne flag of |x|
                 Decode( sign(x) ) // sign of x
                 If(|x| &gt; 1 )
                 {
                   Decode( (|x| - 3)/2 ) // remaining level of |x|
                  }
               }</pre><!-- EPO <DP n="18"> --></p><p id="p0069" num="0069">From a binarization point of view, the parity decoding process set out above describes a more balanced Huffman tree, which is more efficient if the probability distribution of the coefficient values is biased towards large numbers. This may be the case, for example, with the DC coefficient. The following exemplary criterion may be used to identify coefficient groups with such probability distributions so that the parity decoding process may be applied:
<pre listing-type="program-listing">                    If the current CG is the first CG in the TU and the total number of non-
                    zero coefficients &gt;= 2
                           Apply parity decoding
                    Else
                           Apply regular coefficient decoding</pre></p><p id="p0070" num="0070">In some embodiments, the parity decoding process may also be unified with sign bit hiding. Example pseudo-code illustrating one embodiment of such unification is as follows:
<pre listing-type="program-listing">                    If the current CG is the first CG in the TU and the total number of non-
                    zero coefficients &gt;= 2
                           Apply parity decoding
                    Else if (the current CG is the last CG in the TU and lastNZPosInCG -
                    firstNZPosInCG &gt;= 4) or (the current CG is not the last CG in the TU
                    and the total number of non-zero coefficients &gt;= 2)
                           Apply sign bit hiding
                    Else
                           Regular coefficient decoding</pre></p><p id="p0071" num="0071">The following pseudo-code illustrates one example implementation of parity hiding in a video decoding process. In this example, the parity of the first coefficient is hidden per coefficient group. That hidden parity is then used to determine whether the decoder decodes a significant coefficient flag or a greater-than-one flag. The decoding of greater-than-one flags with respect to the first fifteen coefficients is subject to maximum of seven, as indicated by "if( numSigCoeff&lt;7)...".
<tables id="tabl0001" num="0001"><img id="ib0001" file="imgb0001.tif" wi="162" he="34" img-content="table" img-format="tif"/></tables><!-- EPO <DP n="19"> -->
<tables id="tabl0002" num="0002"><img id="ib0002" file="imgb0002.tif" wi="161" he="233" img-content="table" img-format="tif"/></tables><!-- EPO <DP n="20"> -->
<tables id="tabl0003" num="0003"><img id="ib0003" file="imgb0003.tif" wi="162" he="57" img-content="table" img-format="tif"/></tables></p><p id="p0072" num="0072">It will be understood that the foregoing pseudo-code is but one example implementation. In this example, the significant coefficient flags, greater-than-one flags, greater-than-two flag, and sign bits are decoded for positions 15 to 1 in the coefficient group (excluding the upper left position). Then, in the for-loop detailed above, the remaining level data for positions 15 to 0 is decoded, if any, and within that loop for the upper left position (n = 0) the decoder (conditionally) decodes its significant-coefficient flag, greater-than-one flag, and greater-than-two flag, depending on the parity test. Its sign is also decoded. When it comes to decoding the greater-than-one flag for the upper left coefficient, it is conditional upon parity hiding being enabled and the parity being odd. It is <u>not</u> conditional upon whether the maximum number of greater-than-one flags was already reached in the decoding of positions x<sub>15</sub> to x<sub>1</sub>.</p><p id="p0073" num="0073">In one further example, it is observed that when the parity of the coefficient at the first position in a coefficient group or a transform unit is inferred, it might be advantageous to use a different (smaller) quantization step size at that position than the quantization step size used when the parity of the first coefficient is not inferred. In AVC or HEVC, for example, the following quantization scheme might be used:
<ul><li>when the parity of the coefficient at the first position in a coefficient group or a transform unit is not inferred, the quantization step size might be determined by a quantization parameter Qp; and</li><li>when the parity of the coefficient at the first position in the coefficient group or the transform unit is inferred, the quantization step size might be<!-- EPO <DP n="21"> --> determined by max(Qp-k, 0), where k is a non-negative integer. When k is equal to 6, the quantization step size is half that determined by Qp when the parity is not inferred.</li></ul></p><p id="p0074" num="0074">In the case of scalable video coding, any of the foregoing embodiments may be applied to the base layer encoding/decoding, the enhancement layer encoding/decoding, or both layers.</p><p id="p0075" num="0075">Reference is now made to Figure 10, which shows a simplified block diagram of an example embodiment of an encoder 900. The encoder 900 includes a processor 902, memory 904, and an encoding application 906. The encoding application 906 may include a computer program or application stored in memory 904 and containing instructions for configuring the processor 902 to perform operations such as those described herein. For example, the encoding application 906 may encode and output bitstreams encoded in accordance with the processes described herein. It will be understood that the encoding application 906 may be stored in on a computer readable medium, such as a compact disc, flash memory device, random access memory, hard drive, etc.</p><p id="p0076" num="0076">Reference is now also made to Figure 11, which shows a simplified block diagram of an example embodiment of a decoder 1000. The decoder 1000 includes a processor 1002, a memory 1004, and a decoding application 1006. The decoding application 1006 may include a computer program or application stored in memory 1004 and containing instructions for configuring the processor 1002 to perform operations such as those described herein. It will be understood that the decoding application 1006 may be stored in on a computer readable medium, such as a compact disc, flash memory device, random access memory, hard drive, etc.</p><p id="p0077" num="0077">It will be appreciated that the decoder and/or encoder according to the present application may be implemented in a number of computing devices, including, without limitation, servers, suitably-programmed general purpose computers, audio/video encoding and playback devices, set-top television boxes, television broadcast equipment, and mobile devices. The decoder or encoder may be implemented by way of software containing instructions for configuring a processor to carry out the functions described herein. The software instructions may be stored on any suitable non-transitory computer-readable memory, including CDs, RAM, ROM, Flash memory, etc.<!-- EPO <DP n="22"> --></p><p id="p0078" num="0078">It will be understood that the encoder described herein and the module, routine, process, thread, or other software component implementing the described method/process for configuring the encoder may be realized using standard computer programming techniques and languages. The present application is not limited to particular processors, computer languages, computer programming conventions, data structures, other such implementation details. Those skilled in the art will recognize that the described processes may be implemented as a part of computer-executable code stored in volatile or non-volatile memory, as part of an application-specific integrated chip (ASIC), etc.</p><p id="p0079" num="0079">Certain adaptations and modifications of the described embodiments can be made. Therefore, the above discussed embodiments are considered to be illustrative and not restrictive.</p></description><claims mxw-id="PCLM56976122" lang="EN" load-source="patent-office"><!-- EPO <DP n="23"> --><claim id="c-en-0001" num="0001"><claim-text>A method of decoding a bitstream of encoded video to reconstruct coefficients of a coefficient group in a video decoder, the coefficient group including an upper left coefficient, the method comprising:
<claim-text>decoding flags for reconstructing the coefficients of the coefficient group other than the upper left coefficient, wherein decoding includes, for each non-zero coefficient, decoding a greater-than-one flag if the number of previously decoded greater-than-one flags for the coefficient group is less than a predetermined threshold number;</claim-text>
<claim-text>determining a parity of the upper left coefficient;</claim-text>
<claim-text>decoding a significant-coefficient flag for the upper left coefficient only if the parity is even; and</claim-text>
<claim-text>decoding a greater-than-one flag for the upper left coefficient only if the parity is odd and irrespective of the predetermined threshold number.</claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The method claimed in claim 1, wherein the predetermined threshold number is 7.</claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The method claimed in claim 1 or claim 2, wherein determining a parity comprises decoding a parity flag from the bitstream.</claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The method claimed in claim 1 or claim 2, wherein determining a parity is based upon a set of the coefficients of the coefficient group other than the upper left coefficient.</claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The method claimed in claim 1 or claim 2, wherein determining a parity is based upon the parity of a sum of the magnitudes of the coefficients of the coefficient group other than the upper left coefficient.</claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The method claimed in any one of claims 1 to 5, further comprising decoding a greater-than-two flag for the upper left coefficient only if:
<claim-text>the parity is even;</claim-text>
<claim-text>the significant-coefficient flag is equal to 1; and<!-- EPO <DP n="24"> --></claim-text>
<claim-text>a maximum number of greater-than-two flags has not been decoded when decoding flags for reconstruction the coefficients of the coefficient group other than the upper left coefficient.</claim-text></claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>The method claimed in any one of claims 1 to 6, wherein decoding flags for reconstructing the coefficients of the coefficient group other than the upper left coefficient further comprises:
<claim-text>decoding significant-coefficient flags;</claim-text>
<claim-text>decoding a greater-than-two flag if at least one greater-than-one flag associated with the coefficients of the coefficient group, other than the upper left coefficient, equals 1; and</claim-text>
<claim-text>decoding remaining level data, if any.</claim-text></claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>A method of encoding video in a video encoder to output a bitstream of encoded data, the video including a coefficient group including an upper left coefficient, the method comprising:
<claim-text>encoding a parity of the upper left coefficient;</claim-text>
<claim-text>encoding flags for the coefficients of the coefficient group other than the upper left coefficient, wherein encoding includes, for each non-zero coefficient other than the upper left coefficient, encoding a greater-than-one flag if the number of previously encoded greater-than-one flags for the coefficient group is less than a predetermined threshold number;</claim-text>
<claim-text>encoding a significant-coefficient flag for the upper left coefficient only if the parity is even; and</claim-text>
<claim-text>encoding a greater-than-one flag for the upper left coefficient only if the parity is odd and irrespective of the predetermined threshold number.</claim-text></claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>The method claimed in claim 8, wherein the predetermined threshold number is 7.</claim-text></claim><claim id="c-en-0010" num="0010"><claim-text>The method claimed in claim 8 or claim 9, wherein encoding a parity comprises encoding a parity flag that indicates whether the parity is even or odd.<!-- EPO <DP n="25"> --></claim-text></claim><claim id="c-en-0011" num="0011"><claim-text>The method claimed in claim 8 or claim 9, wherein encoding a parity comprises determining whether the parity matches a parity value determined based upon a set of the coefficients of the coefficient group other than the upper left coefficient and, if not, adjusting at least one of the coefficients to match the parity value to the parity.</claim-text></claim><claim id="c-en-0012" num="0012"><claim-text>The method claimed in claim 11, wherein the parity value is based upon the parity of a sum of the magnitudes of the coefficients of the coefficient group other than the upper left coefficient.</claim-text></claim><claim id="c-en-0013" num="0013"><claim-text>The method claimed in any one of claims 8 to 12, further comprising encoding a greater-than-two flag for the upper left coefficient only if:
<claim-text>the parity is even;</claim-text>
<claim-text>the significant-coefficient flag is equal to 1; and</claim-text>
<claim-text>a maximum number of greater-than-two flags has not been encoded when encoding flags for the coefficients of the coefficient group other than the upper left coefficient.</claim-text></claim-text></claim><claim id="c-en-0014" num="0014"><claim-text>A decoder for decoding a bitstream of encoded video to reconstruct coefficients of a coefficient group in a video decoder, the coefficient group including an upper left coefficient, the decoder comprising:
<claim-text>a processor;</claim-text>
<claim-text>a memory; and</claim-text>
<claim-text>a decoding application stored in memory and containing instructions for configuring the processor to perform the method claimed in any one of claims 1 to 7.</claim-text></claim-text></claim><claim id="c-en-0015" num="0015"><claim-text>An encoder for encoding video in a video encoder to output a bitstream of encoded data, the video including a coefficient group including an upper left coefficient, the encoder comprising:
<claim-text>a processor;</claim-text>
<claim-text>a memory; and</claim-text>
<claim-text>an encoding application stored in memory and containing instructions for configuring the processor to perform the method claimed in any one of claims 8 to 13.</claim-text><!-- EPO <DP n="26"> --></claim-text></claim><claim id="c-en-0016" num="0016"><claim-text>A non-transitory processor-readable medium storing processor-executable instructions which, when executed, configures one or more processors to perform the method claimed in any one of claims 1 to 13.</claim-text></claim></claims><drawings mxw-id="PDW16666907" load-source="patent-office"><!-- EPO <DP n="27"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="165" he="201" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="28"> --><figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="165" he="147" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="29"> --><figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="165" he="209" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="30"> --><figure id="f0004" num="4"><img id="if0004" file="imgf0004.tif" wi="165" he="209" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="31"> --><figure id="f0005" num="5"><img id="if0005" file="imgf0005.tif" wi="150" he="205" img-content="drawing" img-format="tif"/></figure></drawings><search-report-data><doc-page id="srep0001" file="srep0001.tif" wi="157" he="233" type="tif"/></search-report-data><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
