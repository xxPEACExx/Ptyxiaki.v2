<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2680579-A1" country="EP" doc-number="2680579" kind="A1" date="20140101" family-id="46506177" file-reference-id="318307" date-produced="20180824" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146549109" ucid="EP-2680579-A1"><document-id><country>EP</country><doc-number>2680579</doc-number><kind>A1</kind><date>20140101</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-12173938-A" is-representative="YES"><document-id mxw-id="PAPP154823032" load-source="docdb" format="epo"><country>EP</country><doc-number>12173938</doc-number><kind>A</kind><date>20120627</date><lang>EN</lang></document-id><document-id mxw-id="PAPP187510436" load-source="docdb" format="original"><country>EP</country><doc-number>12173938.7</doc-number><date>20120627</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140447442" ucid="US-201213533337-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201213533337</doc-number><kind>A</kind><date>20120626</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1848629444" load-source="docdb">H04N  19/176       20140101AFI20170131BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-1848632506" load-source="docdb">H04N  19/157       20140101ALI20170131BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-1848634245" load-source="docdb">H04N  19/136       20140101ALI20170131BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-1848635009" load-source="docdb">H04N  19/122       20140101ALI20170131BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-2137520175" load-source="docdb" scheme="CPC">H04N  19/176       20130101 LI20141108BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2137524333" load-source="docdb" scheme="CPC">H04N  19/122       20141101 LI20141108BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2137530049" load-source="docdb" scheme="CPC">H04N  19/157       20141101 FI20141108BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2137531806" load-source="docdb" scheme="CPC">H04N  19/136       20141101 LI20141108BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132179811" lang="DE" load-source="patent-office">Modifizierte Codierung zum transformen Überlesen</invention-title><invention-title mxw-id="PT132179812" lang="EN" load-source="patent-office">Modified coding for transform skipping</invention-title><invention-title mxw-id="PT132179813" lang="FR" load-source="patent-office">Codage modifié pour sauter des blocs de transformation</invention-title><citations><non-patent-citations><nplcit><text>LAN (XIDIAN UNIV) C ET AL: "Intra and inter coding tools for screen contents", 20110310, no. JCTVC-E145, 10 March 2011 (2011-03-10), XP030008651, ISSN: 0000-0007</text><sources><source mxw-id="PNPL52439235" load-source="docdb" name="SEA" category="A"/></sources></nplcit><nplcit><text>MARTA MRAK ET AL: "Transform skip mode", 7. JCT-VC MEETING; 98. MPEG MEETING; 21-11-2011 - 30-11-2011; GENEVA; (JOINT COLLABORATIVE TEAM ON VIDEO CODING OF ISO/IEC JTC1/SC29/WG11 AND ITU-T SG.16 ); URL: HTTP://WFTP3.ITU.INT/AV-ARCH/JCTVC-SITE/,, no. JCTVC-G575, 8 November 2011 (2011-11-08), XP030110559</text><sources><source mxw-id="PNPL52439236" load-source="docdb" name="SEA" category="A"/></sources></nplcit><nplcit><text>None</text><sources><source mxw-id="PNPL45130731" load-source="docdb" name="APP"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR918173618" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>BLACKBERRY LTD</last-name><address><country>CA</country></address></addressbook></applicant><applicant mxw-id="PPAR918145800" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>BLACKBERRY LIMITED</last-name></addressbook></applicant><applicant mxw-id="PPAR918990944" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>BlackBerry Limited</last-name><iid>101413722</iid><address><street>2200 University Avenue East</street><city>Waterloo, ON N2K 0A7</city><country>CA</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR918166390" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>HE DAKE</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918137142" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>HE, DAKE</last-name></addressbook></inventor><inventor mxw-id="PPAR918984292" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>HE, DAKE</last-name><address><street>c/o Research In Motion Limited 295 Phillip Street Extension 78760</street><city>Waterloo, Ontario N2L 3W8</city><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918150082" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>WANG JING</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918157509" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>WANG, JING</last-name></addressbook></inventor><inventor mxw-id="PPAR918991956" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>WANG, JING</last-name><address><street>c/o Research In Motion Limited 295 Phillip Street Extension 75923</street><city>Waterloo, Ontario N2L 3W8</city><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918147220" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>MARTIN-COCHER GAELLE CHRISTINE</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR918157251" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>MARTIN-COCHER, GAELLE CHRISTINE</last-name></addressbook></inventor><inventor mxw-id="PPAR918980252" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>Martin-Cocher, Gaëlle Christine</last-name><address><street>c/o Research In Motion Limited 4701 Tahoe Blvd. Extension 14591</street><city>Mississauga, Ontario L4W 0B5</city><country>CA</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR918990271" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Patel, Binesh</last-name><iid>101089551</iid><address><street>Barker Brettell LLP 100 Hagley Road</street><city>Edgbaston Birmingham B16 8QQ</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS548842965" load-source="docdb">AL</country><country mxw-id="DS548846106" load-source="docdb">AT</country><country mxw-id="DS548801351" load-source="docdb">BE</country><country mxw-id="DS548845083" load-source="docdb">BG</country><country mxw-id="DS548802197" load-source="docdb">CH</country><country mxw-id="DS548801352" load-source="docdb">CY</country><country mxw-id="DS548846107" load-source="docdb">CZ</country><country mxw-id="DS548842967" load-source="docdb">DE</country><country mxw-id="DS548801353" load-source="docdb">DK</country><country mxw-id="DS548801358" load-source="docdb">EE</country><country mxw-id="DS548842469" load-source="docdb">ES</country><country mxw-id="DS548845084" load-source="docdb">FI</country><country mxw-id="DS548802198" load-source="docdb">FR</country><country mxw-id="DS548842968" load-source="docdb">GB</country><country mxw-id="DS548801359" load-source="docdb">GR</country><country mxw-id="DS548842969" load-source="docdb">HR</country><country mxw-id="DS548846108" load-source="docdb">HU</country><country mxw-id="DS548802199" load-source="docdb">IE</country><country mxw-id="DS548801360" load-source="docdb">IS</country><country mxw-id="DS548845085" load-source="docdb">IT</country><country mxw-id="DS548801361" load-source="docdb">LI</country><country mxw-id="DS548845414" load-source="docdb">LT</country><country mxw-id="DS548835737" load-source="docdb">LU</country><country mxw-id="DS548845415" load-source="docdb">LV</country><country mxw-id="DS548845416" load-source="docdb">MC</country><country mxw-id="DS548835738" load-source="docdb">MK</country><country mxw-id="DS548835739" load-source="docdb">MT</country><country mxw-id="DS548835740" load-source="docdb">NL</country><country mxw-id="DS548802200" load-source="docdb">NO</country><country mxw-id="DS548835741" load-source="docdb">PL</country><country mxw-id="DS548842470" load-source="docdb">PT</country><country mxw-id="DS548843068" load-source="docdb">RO</country><country mxw-id="DS548842471" load-source="docdb">RS</country><country mxw-id="DS548835742" load-source="docdb">SE</country><country mxw-id="DS548842971" load-source="docdb">SI</country><country mxw-id="DS548802201" load-source="docdb">SK</country><country mxw-id="DS548802202" load-source="docdb">SM</country><country mxw-id="DS548801366" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA128669780" lang="EN" load-source="patent-office"><p id="pa01" num="0001">Methods and devices for modified coding of blocks of residuals in the case of transform skipping. To better align the data with assumptions upon which the entropy coding scheme is based, the block of residual data is permuted at the encoder prior to entropy coding. The block of reconstructed data is then inverse permuted at the decoder to recover the reconstructed block of residuals. The permutation may include 180 rotation of the block, which may be of particular benefit in the case of intra-coded residuals.
<img id="iaf01" file="imgaf001.tif" wi="85" he="97" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA128499153" lang="EN" source="EPO" load-source="docdb"><p>Methods and devices for modified coding of blocks of residuals in the case of transform skipping. To better align the data with assumptions upon which the entropy coding scheme is based, the block of residual data is permuted at the encoder prior to entropy coding. The block of reconstructed data is then inverse permuted at the decoder to recover the reconstructed block of residuals. The permutation may include 180 rotation of the block, which may be of particular benefit in the case of intra-coded residuals.</p></abstract><description mxw-id="PDES63955210" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><b>COPYRIGHT NOTICE</b></heading><p id="p0001" num="0001">A portion of the disclosure of this document and accompanying materials contains material to which a claim for copyright is made. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office files or records, but reserves all other copyright rights whatsoever.</p><heading id="h0002"><b>FIELD</b></heading><p id="p0002" num="0002">The present application generally relates to data compression and, in particular, to methods and devices for video coding that apply transform skipping to some blocks of residuals, and to an improved coding and decoding process to improve performance when transform skipping is enabled.</p><heading id="h0003"><b>BACKGROUND</b></heading><p id="p0003" num="0003">Data compression occurs in a number of contexts. It is very commonly used in communications and computer networking to store, transmit, and reproduce information efficiently. It finds particular application in the encoding of images, audio and video. Video presents a significant challenge to data compression because of the large amount of data required for each video frame and the speed with which encoding and decoding often needs to occur. The current state-of-the-art for video encoding is the ITU-T H.264/AVC video coding standard. It defines a number of different profiles for different applications, including the Main profile, Baseline profile and others. A next-generation video encoding standard is currently under development through a joint initiative of MPEG-ITU termed High Efficiency Video Coding (HEVC). The initiative may eventually result in a video-coding standard that will form part of a suite of standards referred to as MPEG-H.</p><p id="p0004" num="0004">There are a number of standards for encoding/decoding images and videos, including H.264, that use block-based coding processes. In these processes, the image or<!-- EPO <DP n="2"> --> frame is divided into blocks, typically 4x4 or 8x8, and the blocks are spectrally transformed into coefficients, quantized, and entropy encoded. In many cases, the data being transformed is not the actual pixel data, but is residual data following a prediction operation. Predictions can be intra-frame, <i>i.e.</i> block-to-block within the frame/image, or inter-frame, <i>i.e.</i> between frames (also called motion prediction). It is expected that HEVC will also have these features.</p><p id="p0005" num="0005">When spectrally transforming residual data, many of these standards prescribe the use of a discrete cosine transform (DCT) or some variant thereon. The resulting DCT coefficients are then quantized using a quantizer to produce quantized transform domain coefficients, or indices.</p><p id="p0006" num="0006">The block or matrix of quantized transform domain coefficients (sometimes referred to as a "transform unit") is then entropy encoded using a particular context model. In H.264/AVC and in the current development work for HEVC, the quantized transform coefficients are encoded by (a) encoding a last significant coefficient position indicating the location of the last non-zero coefficient in the transform unit, (b) encoding a significance map indicating the positions in the transform unit (other than the last significant coefficient position) that contain non-zero coefficients, (c) encoding the magnitudes of the non-zero coefficients, and (d) encoding the signs of the non-zero coefficients. This encoding of the quantized transform coefficients often occupies 30-80% of the encoded data in the bitstream.</p><p id="p0007" num="0007">The developing HEVC standard may provide for transform skipping in the case of intra-coded blocks. Transform skipping may be selectively applied in some cases. For example, it may be used in an attempt to improve rate-distortion performance in the case of mixed (screen) content video. In some cases, transform skipping may be applied to all intra-coded blocks/slices/frames/pictures. In some cases, it may be applied to certain categories of video data, such as only 4x4 intra-coded blocks.</p><p id="p0008" num="0008">When the transform step is skipped, the residual data left after the prediction operation is directly quantized and entropy encoded. In other words, the encoder and decoder do not deal with quantized transform domain coefficients, but rather with quantized spatial domain data (i.e. quantized residuals).<!-- EPO <DP n="3"> --></p><heading id="h0004"><b>BRIEF SUMMARY</b></heading><p id="p0009" num="0009">The present application describes methods and encoders/decoders for encoding and decoding residual video data.</p><p id="p0010" num="0010">In a first aspect, the present application describes a method of decoding a bitstream of encoded video in a video decoder to reconstruct a block of residuals. The method includes determining that transform skipping is enabled for the block of residuals; entropy decoding a part of the bitstream to reconstruct a permuted block of quantized residual data; and based on the determination that transform skipping is enabled, reconstructing the block of residuals by dequantizing and inverse permuting the permuted block of quantized residual data.</p><p id="p0011" num="0011">In another aspect, the present application discloses a method of encoding video in a video encoder to output a bitstream of encoded data, the video including a block of residuals. The method includes determining that transform skipping is enabled for the block of residuals; based on the determination that transform skipping is enabled, permuting the block of residual data to produce a permuted block of residual data; quantizing the permuted block of residual data to produce a permuted block of quantized residual data; and entropy encoding the permuted block of quantized residual data to generate part of the bitstream of encoded data.</p><p id="p0012" num="0012">In a further aspect, the present application describes encoders and decoders configured to implement such methods of encoding and decoding.</p><p id="p0013" num="0013">In yet a further aspect, the present application describes non-transitory computer-readable media storing computer-executable program instructions which, when executed, configured a processor to perform the described methods of encoding and/or decoding.</p><p id="p0014" num="0014">Other aspects and features of the present application will be understood by those of ordinary skill in the art from a review of the following description of examples in conjunction with the accompanying figures.<!-- EPO <DP n="4"> --></p><heading id="h0005"><b>BRIEF DESCRIPTION OF THE DRAWINGS</b></heading><p id="p0015" num="0015">Reference will now be made, by way of example, to the accompanying drawings which show example embodiments of the present application, and in which:</p><p id="p0016" num="0016"><figref idrefs="f0001">Figure 1</figref> shows, in block diagram form, an encoder for encoding video;</p><p id="p0017" num="0017"><figref idrefs="f0002">Figure 2</figref> shows, in block diagram form, a decoder for decoding video;</p><p id="p0018" num="0018"><figref idrefs="f0003">Figure 3</figref> shows a flowchart illustrating a process of encoding a block of residuals for which transform skipping is enabled;</p><p id="p0019" num="0019"><figref idrefs="f0004">Figure 4</figref> shows a flowchart illustrating a process for decoding a block of residuals for which transform skipping is enabled;</p><p id="p0020" num="0020"><figref idrefs="f0005">Figure 5</figref> shows an example permutation of a block of residuals;</p><p id="p0021" num="0021"><figref idrefs="f0006">Figure 6</figref> shows a simplified block diagram of an example embodiment of an encoder; and</p><p id="p0022" num="0022"><figref idrefs="f0007">Figure 7</figref> shows a simplified block diagram of an example embodiment of a decoder.</p><p id="p0023" num="0023">Similar reference numerals may have been used in different figures to denote similar components.</p><heading id="h0006"><b>DESCRIPTION OF EXAMPLE EMBODIMENTS</b></heading><p id="p0024" num="0024">In the description that follows, some example embodiments are described with reference to the H.264 standard for video coding and/or the developing HEVC standard. Those ordinarily skilled in the art will understand that the present application is not limited to H.264/AVC or HEVC but may be applicable to other video coding/decoding standards, including possible future standards, multi-view coding standards, scalable video coding standards, and reconfigurable video coding standards.</p><p id="p0025" num="0025">In the description that follows, when referring to video or images the terms frame, picture, slice, tile and rectangular slice group may be used somewhat interchangeably.<!-- EPO <DP n="5"> --> Those of skill in the art will appreciate that, in the case of the H.264 standard, a frame may contain one or more slices. The term "frame" may be replaced with "picture" in HEVC. Other terms may be used in other video coding standards. It will also be appreciated that certain encoding/decoding operations might be performed on a frame-by-frame basis, some are performed on a slice-by-slice basis, some picture-by-picture, some tile-by-tile, and some by rectangular slice group, depending on the particular requirements or terminology of the applicable image or video coding standard. In any particular embodiment, the applicable image or video coding standard may determine whether the operations described below are performed in connection with frames and/or slices and/or pictures and/or tiles and/or rectangular slice groups, as the case may be. Accordingly, those ordinarily skilled in the art will understand, in light of the present disclosure, whether particular operations or processes described herein and particular references to frames, slices, pictures, tiles, rectangular slice groups are applicable to frames, slices, pictures, tiles, rectangular slice groups, or some or all of those for a given embodiment. This also applies to transform units, coding units, groups of coding units, etc., as will become apparent in light of the description below.</p><p id="p0026" num="0026">Reference is now made to <figref idrefs="f0001">Figure 1</figref>, which shows, in block diagram form, an encoder 10 for encoding video. Reference is also made to <figref idrefs="f0002">Figure 2</figref>, which shows a block diagram of a decoder 50 for decoding video. It will be appreciated that the encoder 10 and decoder 50 described herein may each be implemented on an application-specific or general purpose computing device, containing one or more processing elements and memory. The operations performed by the encoder 10 or decoder 50, as the case may be, may be implemented by way of application-specific integrated circuit, for example, or by way of stored program instructions executable by a general purpose processor. The device may include additional software, including, for example, an operating system for controlling basic device functions. The range of devices and platforms within which the encoder 10 or decoder 50 may be implemented will be appreciated by those ordinarily skilled in the art having regard to the following description.</p><p id="p0027" num="0027">The encoder 10 receives a video source 12 and produces an encoded bitstream 14. The decoder 50 receives the encoded bitstream 14 and outputs a decoded video frame 16. The encoder 10 and decoder 50 may be configured to operate in conformance with a number of video compression standards. For example, the encoder 10 and decoder 50 may be<!-- EPO <DP n="6"> --> H.264/AVC compliant. In other embodiments, the encoder 10 and decoder 50 may conform to other video compression standards, including evolutions of the H.264/AVC standard, like HEVC.</p><p id="p0028" num="0028">The encoder 10 includes a spatial predictor 21, a coding mode selector 20, transform processor 22, quantizer 24, and entropy encoder 26. As will be appreciated by those ordinarily skilled in the art, the coding mode selector 20 determines the appropriate coding mode for the video source, for example whether the subject frame/slice is of I, P, or B type, and whether particular coding units (e.g. macroblocks, coding units, etc.) within the frame/slice are inter or intra coded. The transform processor 22 performs a transform upon the spatial domain data. In particular, the transform processor 22 applies a block-based transform to convert spatial domain data to spectral components. For example, in many embodiments a discrete cosine transform (DCT) is used. Other transforms, such as a discrete sine transform or others may be used in some instances. The block-based transform is performed on a coding unit, macroblock or sub-block basis, depending on the size of the macroblocks or coding units. In the H.264 standard, for example, a typical 16x16 macroblock contains sixteen 4x4 transform blocks and the DCT process is performed on the 4x4 blocks. In some cases, the transform blocks may be 8x8, meaning there are four transform blocks per macroblock. In yet other cases, the transform blocks may be other sizes. In some cases, a 16x16 macroblock may include a non-overlapping combination of 4x4 and 8x8 transform blocks.</p><p id="p0029" num="0029">Applying the block-based transform to a block of pixel data results in a set of transform domain coefficients. A "set" in this context is an ordered set in which the coefficients have coefficient positions. In some instances the set of transform domain coefficients may be considered as a "block" or matrix of coefficients. In the description herein the phrases a "set of transform domain coefficients" or a "block of transform domain coefficients" are used interchangeably and are meant to indicate an ordered set of transform domain coefficients.</p><p id="p0030" num="0030">The set of transform domain coefficients is quantized by the quantizer 24. The quantized coefficients and associated information are then encoded by the entropy encoder 26.<!-- EPO <DP n="7"> --></p><p id="p0031" num="0031">The block or matrix of quantized transform domain coefficients may be referred to herein as a "transform unit" (TU). In some cases, the TU may be non-square, e.g. a non-square quadrature transform (NSQT).</p><p id="p0032" num="0032">Intra-coded frames/slices (i.e. type I) are encoded without reference to other frames/slices. In other words, they do not employ temporal prediction. However intra-coded frames do rely upon spatial prediction within the frame/slice, as illustrated in <figref idrefs="f0001">Figure 1</figref> by the spatial predictor 21. That is, when encoding a particular block the data in the block may be compared to the data of nearby pixels within blocks already encoded for that frame/slice. Using a prediction algorithm, the source data of the block may be converted to residual data. The transform processor 22 then encodes the residual data. H.264, for example, prescribes nine spatial prediction modes for 4x4 transform blocks. In some embodiments, each of the nine modes may be used to independently process a block, and then rate-distortion optimization is used to select the best mode.</p><p id="p0033" num="0033">The H.264 standard also prescribes the use of motion prediction/compensation to take advantage of temporal prediction. Accordingly, the encoder 10 has a feedback loop that includes a de-quantizer 28, inverse transform processor 30, and deblocking processor 32. The deblocking processor 32 may include a deblocking processor and a filtering processor. These elements mirror the decoding process implemented by the decoder 50 to reproduce the frame/slice. A frame store 34 is used to store the reproduced frames. In this manner, the motion prediction is based on what will be the reconstructed frames at the decoder 50 and not on the original frames, which may differ from the reconstructed frames due to the lossy compression involved in encoding/decoding. A motion predictor 36 uses the frames/slices stored in the frame store 34 as source frames/slices for comparison to a current frame for the purpose of identifying similar blocks. Accordingly, for macroblocks or coding units to which motion prediction is applied, the "source data" which the transform processor 22 encodes is the residual data that comes out of the motion prediction process. For example, it may include information regarding the reference frame, a spatial displacement or "motion vector", and residual pixel data that represents the differences (if any) between the reference block and the current block. Information regarding the reference frame and/or motion vector may not be processed by the transform processor 22 and/or quantizer 24, but instead may be supplied to<!-- EPO <DP n="8"> --> the entropy encoder 26 for encoding as part of the bitstream along with the quantized coefficients.</p><p id="p0034" num="0034">Those ordinarily skilled in the art will appreciate the details and possible variations for implementing video encoders.</p><p id="p0035" num="0035">The decoder 50 includes an entropy decoder 52, dequantizer 54, inverse transform processor 56, spatial compensator 57, and deblocking processor 60. The deblocking processor 60 may include deblocking and filtering processors. A frame buffer 58 supplies reconstructed frames for use by a motion compensator 62 in applying motion compensation. The spatial compensator 57 represents the operation of recovering the video data for a particular intra-coded block from a previously decoded block.</p><p id="p0036" num="0036">The bitstream 14 is received and decoded by the entropy decoder 52 to recover the quantized coefficients. Side information may also be recovered during the entropy decoding process, some of which may be supplied to the motion compensation loop for use in motion compensation, if applicable. For example, the entropy decoder 52 may recover motion vectors and/or reference frame information for inter-coded macroblocks.</p><p id="p0037" num="0037">The quantized coefficients are then dequantized by the dequantizer 54 to produce the transform domain coefficients, which are then subjected to an inverse transform by the inverse transform processor 56 to recreate the "video data". It will be appreciated that, in some cases, such as with an intra-coded macroblock or coding unit, the recreated "video data" is the residual data for use in spatial compensation relative to a previously decoded block within the frame. The spatial compensator 57 generates the video data from the residual data and pixel data from a previously decoded block. In other cases, such as inter-coded macroblocks or coding units, the recreated "video data" from the inverse transform processor 56 is the residual data for use in motion compensation relative to a reference block from a different frame. Both spatial and motion compensation may be referred to herein as "prediction operations".</p><p id="p0038" num="0038">The motion compensator 62 locates a reference block within the frame buffer 58 specified for a particular inter-coded macroblock or coding unit. It does so based on the reference frame information and motion vector specified for the inter-coded macroblock or coding unit. It then supplies the reference block pixel data for combination with the residual data to arrive at the reconstructed video data for that coding unit/macroblock.<!-- EPO <DP n="9"> --></p><p id="p0039" num="0039">A deblocking/filtering process may then be applied to a reconstructed frame/slice, as indicated by the deblocking processor 60. After deblocking/filtering, the frame/slice is output as the decoded video frame 16, for example for display on a display device. It will be understood that the video playback machine, such as a computer, set-top box, DVD or Blu-Ray player, and/or mobile handheld device, may buffer decoded frames in a memory prior to display on an output device.</p><p id="p0040" num="0040">It is expected that HEVC-compliant encoders and decoders will have many of these same or similar features.</p><p id="p0041" num="0041">One feature that HEVC may include is transform skipping. Other video coding standards may also provide for the possibility of transform skipping, at least with respect to some blocks of residual data. In HEVC, transform skipping is currently considered in the case of intra-coded 4x4 blocks, although in other standards or in modification of HEVC it is possible that transform skipping may be applied to intra-coded blocks of other size, or even to inter-coded blocks. Transform skipping may also occur in HEVC in lossless mode, which is signaled by the "transquantbypass" flag. In lossless mode, both the transform and the quantization are skipped (in some implementations the quantization operation is still performed but it is flat quantization).</p><p id="p0042" num="0042">Transform skipping is a coding technique in which residual data is not subjected to a spectral transform, like DCT, that converts the residual data to transform coefficients. Instead, the residual data is directly quantized and entropy encoded (except in lossless mode, in which case the quantization is skipped too). At the decoder, if transform skipping is enabled for a block (which may be signaled by a flag in a header), then the decoder entropy decodes the quantized residuals and dequantized them to produce reconstructed residual data. The encoding and decoding processes and models are unchanged from those used with quantized transform coefficients. That is, the encoder and decoder still code the coefficients/residuals using significance flags, greater-than-one flags, greater-than-two flags, remaining-level data, and sign bits, including techniques like parity hiding and sign bit hiding, where applicable and enabled.</p><p id="p0043" num="0043">Transform skipping has been enabled with respect to intra-coded 4x4 blocks in HEVC specifically because it may improve the BD-rate by 3-7% in certain sequences, like Class F sequences mixing screen content and natural video.<!-- EPO <DP n="10"> --></p><p id="p0044" num="0044">A problem noted by the present inventors is that transform skipping results in statistically different data distribution within a block than is the case with transform coefficients. This means that some of the assumptions upon which the entropy coding is based are no longer valid, which may negatively impact the efficiency of the entropy coding. In particular, in conventional video coding the effect of the spectral transform is to concentrate non-zero data in the upper left corner of the block. The higher frequency coefficients are concentrated in the right and lower portions of the block and statistically are less common, meaning that these portions of the block tend contain zero in many cases. The entropy coding is designed to take advantage of this by using a scan order that starts with the lower right corner and works back towards the upper left corner of the block (whether diagonal, zig zag, horizontal, or vertical). This means that the scan typically involves a large number of zeros at the beginning, followed by a concentration of non-zero data at the end, with the most likely non-zero position being the last position in the scan order. Many encoding techniques, including sign bit hiding and parity hiding, are based around this feature of current video coding.</p><p id="p0045" num="0045">In contrast, with transform skipping and intra-coded blocks, the statistics are different. With intra-coding, the predicted pixels are usually (depending on the mode) based on the pixels immediately above or to the left of the block being predicted. Thus, they are correlated most closely with the pixels along the upper row or leftmost column of the block. In other words, the most likely zero residuals are concentrated towards the upper end and left side of the block, whereas the most likely non-zero residuals are concentrated towards the bottom and right side of the block. This is not the statistical expectation upon which the entropy coding process is based.</p><p id="p0046" num="0046">One option to address this issue is to change the entropy coding process when transform skipping is enabled. For example, in one embodiment the encoder and decoder may have a second (alternative) scan order predefined that is the reverse of the scan order normally used. The second scan order may process residuals from the upper left corner towards the lower right corner, and may otherwise use the entropy coding techniques of regular transform coefficient coding. This would address the issue of the statistically different distribution of data in the case of transform skipping.<!-- EPO <DP n="11"> --></p><p id="p0047" num="0047">Another option to address this issue is to permute a block of residual data prior to quantization and entropy coding, if transform skipping is enabled for the block. A suitably chosen permutation of the block to produce a permuted block of residual data may result in a permuted block that has a data distribution that better matches the assumptions underlying the design of the entropy coding process. At the decoder, the encoded data is decoded to recover a permuted block of quantized residual data. The decoder may then inverse permute the permuted block and dequantize the data to produce a block of reconstructed residual data. Advantageously, this approach avoids making any changes to the entropy coding process and uses the same scan pattern and coding procedure that would otherwise be used for encoding quantized transform domain coefficients.</p><p id="p0048" num="0048">It will be appreciated that the quantization (if uniform step size is used through the block) may be applied before or after permutation depending on the implementation. If the quantization varies based on position within the block, then the quantization may be applied after permutation to better match with expectations of statistical data distribution that may be built into the quantizer design. Likewise, in such a case the decoder dequantizes prior to inverse permutation.</p><p id="p0049" num="0049">Reference is now made to <figref idrefs="f0003">Figure 3</figref>, which shows, in flowchart form, an example process 100 for encoding video data. The example process presumes that a prediction operation has occurred and that the video data has thus been reduced to blocks of residuals. This particular process 100 may be applied on a block-by-block basis (by transform unit, coefficient group, coding unit, or other block-basis). Note that the examples herein may make reference to square blocks but the present application is also applicable to non-square blocks, such as, for example, 2x8 or 8x2 transform units (although the specific permutation operation may be different than would be applied to a 4x4 block).</p><p id="p0050" num="0050">The process 100 includes the operation 102 of determining whether transform skipping is applied to this block. Transform skipping may only be enabled for certain types of blocks in some embodiments, such as intra-coded 4x4 blocks. The decision to transform skip may be made for an individual block using RD optimization, in some cases. The decision may be based on an overall setting for the video/picture/slice, in some cases. Irrespective of how it is determines whether to transform skip, in operation 102 the encoder routes the process 100 based on that determination. If transform skipping is not enabled, then<!-- EPO <DP n="12"> --> the process 100 moves to operation 103 where the transform is applied. Then in operation 106 the transform coefficients are quantized. It will be understood that the transform and quantization operations may be implemented in a single operation in some implementations, but they are illustrated separately in this flowchart for clarity.</p><p id="p0051" num="0051">If transform skipping is enabled, then the encoder performs operation 104, which involves permuting the block of residuals to produce a permuted block of residuals. The permutation is a one-to-one reordering of the residuals within the block. Each residual in the block is mapped to a respective position (the same position or a different position) in the permuted block. Examples of permutations include vertical inversion, where the rows of the block are rearranged such that the block's contents are flipped vertically, and horizontal inversion, where the columns of the block are rearranged such that the block's contents are flipped horizontally. Other examples include cyclic permutations, in which positions are adjusted in an ordered cycle. Yet another example permutation is rotation, where the block's contents are rotated by 90 degrees, 180 degrees or 270 degrees.</p><p id="p0052" num="0052">The permutation may be selected based on the extent to which the permutation tends to align the data distribution with the expected data distribution upon which the encoding process is based. In the case of transform skipping, the data distribution of the residuals results in concentration of non-zero values towards the bottom and/or right side of the block, whereas the coding model is based upon a concentration of non-zero values towards the upper and/or left side of the block. Accordingly, in one embodiment the permutation applied is a 180 degree rotation of the contents of the block.</p><p id="p0053" num="0053">The block of residuals may be a matrix an nW x nH matrix x[i, j], where nW is the width of the block, nH is the height of the block, and where 0 ≤ i &lt; nW and 0 ≤ j &lt; nH. The permuted matrix y[i,j] may be populated (generated) with the values of the x matrix in accordance with the following relation: <maths id="math0001" num=""><math display="block"><mi mathvariant="normal">y</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">i</mi><mo>⁢</mo><mi mathvariant="normal">j</mi></mfenced><mo>=</mo><mi mathvariant="normal">x</mi><mo>⁢</mo><mfenced open="[" close="]" separators=""><mi>nW</mi><mo>-</mo><mn mathvariant="normal">1</mn><mo>-</mo><mi mathvariant="normal">i</mi><mo>,</mo><mi>nH</mi><mo>-</mo><mn mathvariant="normal">1</mn><mo>-</mo><mi mathvariant="normal">j</mi></mfenced><mo>,</mo><mspace width="1em"/><mi>where</mi><mspace width="1em"/><mn mathvariant="normal">0</mn><mo>≤</mo><mi mathvariant="normal">i</mi><mo>&lt;</mo><mi>nW and</mi><mspace width="1em"/><mn mathvariant="normal">0</mn><mo>≤</mo><mi mathvariant="normal">j</mi><mo>&lt;</mo><mi>nH</mi></math><img id="ib0001" file="imgb0001.tif" wi="119" he="12" img-content="math" img-format="tif"/></maths></p><p id="p0054" num="0054"><figref idrefs="f0005">Figure 5</figref> illustrates application of this permutation (a 180 degree rotation) to a 4x4 block. The numbering within the block of residuals, x, is an arbitrary horizontal numbering of residual positions. After permutation, the permuted block y shows the change in the positions of those residuals from the block x.<!-- EPO <DP n="13"> --></p><p id="p0055" num="0055">Referring still to <figref idrefs="f0003">Figure 3</figref>, after permutation the permuted block of residuals y may be quantized (as noted above, in some implementations the quantization may occur before permutation) in operation 106. The quantized data is then entropy coded in operation 108.</p><p id="p0056" num="0056">Reference is now made to <figref idrefs="f0004">Figure 4</figref>, which shows a process 200 for decoding encoded video data. Various operations in the process 200 are not illustrated in <figref idrefs="f0004">Figure 4</figref> for clarity and readability. The process 200 includes entropy decoding 202 the bitstream of encoded data to reconstruct quantized residuals/coefficients. It will be understood that the entropy decoding 202 involves decoding of various flags and additional information in a scan order in order to reconstruct the signed values of the residuals/coefficient in various positions within a block, such as a coefficient group, transform unit, coding unit, <i>etc.</i> That scan order (in this example embodiment) may be diagonal, horizontal, vertical or zig zag and generally begins with the lower-right position in the block and proceeds in its order until it reaches the upper left position in the block.</p><p id="p0057" num="0057">In operation 204, the reconstructed data is dequantized. The decoder determines, in operation 206, whether transform skipping is enabled for the current block. It may determine whether transform skipping is enabled based upon a flag decoded from the bitstream. The flag may be in a header, such as the picture header, slice header, coding unit header, or other headers applicable to the current block. The determination may take into account the nature of the current block and whether transform skipping is permitted based on the type of block. For example, transform skipping may be restricted to intra-coded blocks in some implementations. In other implementations, transform skipping may be restricted to intra-coded blocks of a particular size, such as 4x4 blocks.</p><p id="p0058" num="0058">If transform skipping is not enabled, then the decoder proceeds to perform the inverse transform in operation 210 to convert the block of reconstructed transform coefficients into a block of reconstructed residual data. It will be appreciated that the inverse transform operation 210 and the dequantization operation 204 are shown separately in this example for clarity although in some implementations these operations may be combined in a single mathematical operation upon the data.</p><p id="p0059" num="0059">If transform skipping is determined to be enabled in operation 206, then the decoder performs an inverse permutation upon the reconstructed residual data in operation<!-- EPO <DP n="14"> --> 208. The inverse permutation reverses the permutation performed at the encoder. For example, if the encoder applies a 90 degree clockwise rotation, then the decoder applies a 90 degree counter-clockwise rotation. In another example, if the encoder applies a 180 degree rotation, then the decoder applies a 180 degree rotation. Thus the reconstructed residuals of the permuted block are rearranged to be put back into the positions they were in prior to permutation at the encoder. The decoder thereby produces a block of reconstructed residuals.</p><p id="p0060" num="0060">In one example, the 180 degree rotation is implemented by mapping the reconstructed residuals of the permuted block to new positions to produce the inverse permuted block. For example, where the permuted block has height nH and width nW, the inverse permutation includes mapping each (i, j)-th residual of the permuted block, for 0 ≤ i &lt; nW and 0 ≤ j &lt; nH, to the (nW-1-i, nH-1-j)-th residual of the inverse permuted block.</p><p id="p0061" num="0061">In one embodiment, the inverse permutation performed in operation 206 depends on the scan order or the prediction mode. For example, with intra-prediction most prediction modes (horizontally from the left, diagonally from the upper-left, or vertically from above) result in data likely to be best aligned through a 180 degree rotation of the block. However, if the prediction mode is at least partly based on reference pixels to the upper right of the block (e.g. modes 3 and 7 in H.264/AVC), then the residual data may be most likely to be zero in the upper right corner of the block, and most likely to be non-zero in the lower left corner of the block. This situation may be better served though a permutation that is a 90 degree clockwise rotation and an inverse permutation that is a 90 degree counter-clockwise rotation.</p><p id="p0062" num="0062">Whether through inverse transform in operation 210 or inverse permutation in operation 210, the decoder generates a block of reconstructed residuals. In operation 212 those residuals are used to reconstruct the block of pixel data, such as through combining the reconstructed residuals with a predicted block obtained from intra-prediction or inter-prediction.</p><p id="p0063" num="0063">In some cases, the encoder and decoder may have a built-in scaling and descaling operation (in some cases, as part of a rounding process) into which the permutation may be added. For example, if transform skipping is enabled for a block, the residual sample value r<sub>ij</sub> with i=0..(nW)-1, j=0..(nH)-1 may be derived as follows:</p><p id="p0064" num="0064">If shift is greater than 0:<!-- EPO <DP n="15"> --> <maths id="math0002" num=""><math display="block"><msub><mi mathvariant="normal">r</mi><mrow><mfenced separators=""><mi>nW</mi><mo>-</mo><mn mathvariant="normal">1</mn><mo>-</mo><mi mathvariant="normal">i</mi></mfenced><mo>,</mo><mfenced separators=""><mi>nH</mi><mo>-</mo><mn mathvariant="normal">1</mn><mo>-</mo><mi mathvariant="normal">j</mi></mfenced></mrow></msub><mo>=</mo><mfenced separators=""><msub><mi mathvariant="normal">d</mi><mi>ij</mi></msub><mo>+</mo><mfenced separators=""><mn mathvariant="normal">1</mn><mo>&lt;</mo><mo>&lt;</mo><mfenced separators=""><mi>shift</mi><mo>-</mo><mn mathvariant="normal">1</mn></mfenced></mfenced></mfenced><mo>&gt;</mo><mo>&gt;</mo><mi>shift</mi></math><img id="ib0002" file="imgb0002.tif" wi="95" he="13" img-content="math" img-format="tif"/></maths></p><p id="p0065" num="0065">Otherwise: <maths id="math0003" num=""><math display="block"><msub><mi mathvariant="normal">r</mi><mrow><mfenced separators=""><mi>nW</mi><mo>-</mo><mn mathvariant="normal">1</mn><mo>-</mo><mi mathvariant="normal">i</mi></mfenced><mo>,</mo><mfenced separators=""><mi>nH</mi><mo>-</mo><mn mathvariant="normal">1</mn><mo>-</mo><mi mathvariant="normal">j</mi></mfenced></mrow></msub><mo>=</mo><msub><mi mathvariant="normal">d</mi><mi>ij</mi></msub><mo>&lt;</mo><mo>&lt;</mo><mfenced separators=""><mo>-</mo><mi>shift</mi></mfenced></math><img id="ib0003" file="imgb0003.tif" wi="70" he="14" img-content="math" img-format="tif"/></maths></p><p id="p0066" num="0066">In these expressions d<sub>ij</sub> is a scaled dequantized reconstructed residual. The scaling is applied at the encoder and the decoder applies a descaling operation. The shift variable may be dependent upon text type (<i>i.e</i>. whether the values being reconstructed are luma or chroma). It will be noted that in both expressions above the scaled dequantized reconstructed residual are inverse permuted when the residual sample value is realized through the descaling/rounding operations.</p><p id="p0067" num="0067">In another embodiment, it might be preferred to perform the inverse permutation after entropy decoding and before inverse quantization, if applicable, at the video decoder. Correspondingly, the permutation might happen after quantization, if applicable, and before entropy coding at the video encoder.</p><p id="p0068" num="0068">In a further embodiment, the permutation and inverse permutation process can be used to reduce the number of scan orders used in the coding process at the encoder and the parsing process at the decoder, respectively. For example, if one block is to be horizontally (or vertically) scanned, and the diagonal scan is prescribed to be used in the coding and parsing process, one could permute the block so that the diagonal scan produces the same one dimensional sequence from the permuted block as the horizontal (or vertical) scan does from the block before permutation. In this way, the number of bins (binary symbols) to be coded or parsed for the concerned block in the case where only diagonal scan is used and permutation and inverse permutation are performed would be same as in the case where horizontal (or vertical) scan is used instead. At the decoder, after the permuted block is parsed (according to the prescribed diagonal scan), an inverse permutation is then applied to produce the reconstructed block that would be the same as if horizontal (or vertical) scan is used instead in the coding and parsing process. In another example, the permutation may be defined as the transpose so that either horizontal or vertical scan might be saved in the coding and parsing processes.</p><p id="p0069" num="0069">In order to improve compression performance when permutation and inverse permutation are used to reduce the number of scan orders, the contexts used to code and<!-- EPO <DP n="16"> --> decode syntax elements related to a block (with or without transform/quantization) like significant-coefficient flags, significant-coefficient-group flags, and last significant coefficient positions, might depend upon the original scan order before permutation at the encoder, or equivalently after inverse permutation at the decoder.</p><p id="p0070" num="0070">In order to simplify the encoder or the decoder when permutation and inverse permutation are used to reduce the number of scan orders, permutation or inverse permutation might be performed as part of transform or inverse transform, respectively, or, in another implementation, the permutation or inverse permutation might be performed as part of scaling or inverse scaling processes, respectively.</p><p id="p0071" num="0071">The above-described processes employ a predetermined permutation and corresponding inverse permutation to better align the residual data with the expected data distribution upon which the entropy coding scheme has been based. This technique for aligning the residual data of a block with assumed data distributions can be generalized beyond a fixed permutation. For example, in one embodiment, a confidence level may be obtained either online during the coding process or offline by training for each position in a transform unit: the higher the confidence level is, the more likely the prediction is accurate. For example, in intra prediction the positions closer to the samples used for prediction (e.g. near the top-left boundary) have higher confidence levels than the positions farther away. Such confidence levels for a transform unit are collectively called the prediction confidence map for the transform unit. One way to derive such a confidence map is to use the minimum L1 or L2 distance between the position to be predicted and to the positions of the samples used for prediction. Another way to derive such a confidence map in inter prediction is to use the energy of the residuals in the (neighboring) prediction or transform units that have already been parsed, or statistics learned from the previously reconstructed slices of the same slice type. Other techniques may also be used to assess the confidence level of a prediction and build a prediction confidence map.</p><p id="p0072" num="0072">With the prediction confidence map and a prescribed scanning/coding order (e.g. zig-zag, horizontal, vertical, or diagonal), a reordering may then be generated or selected that attempts to place the positions with higher confidence level closer to the beginning of the scanning/coding order than the positions with lower confidence level. This dynamic<!-- EPO <DP n="17"> --> generation of a custom reordering may be used in intra and inter coding, including in non-square blocks.</p><p id="p0073" num="0073">In some cases, a lossless mode can be achieved by skipping the transform and using flat quantization. The reordering of the coefficients may be performed in such a lossless mode. In one example embodiment, the reordering operation may be conditional on the usage of a flat quantization; that is, the reordering could be performed only in the case of lossless coding (<i>i.e.</i> skip transform and flat quantization). Alternatively, the reordering may be performed only in lossy coding (i.e. skip transform and non-flat quantization). In another embodiment, the reordering may be applied whenever the transform operation is skipped, irrespective of whether the quantization is flat or non-flat.</p><p id="p0074" num="0074">In another embodiment, setting the QP to a particular value (e.g. to zero) may correspond to performing a skip of the transform and the quantization steps. The reordering of the coefficients may be performed based on the QP value being set to that particular value.</p><p id="p0075" num="0075">In another case, the lossless mode is achieved by skipping both the transform and the quantization steps. The reordering of the coefficients may be implemented conditional on a flag that signals this lossless mode, whether it is applied at the frame, slice, CU level or at any other suitable level. For example, if lossless mode is enabled for a block, the residual sample values r<sub>ij</sub> with i=0..(nW)-1, j=0..(nH)-1 of the (nW)x(nH) array r may be derived from the (nW)x(nH) array of transform coefficients transCoeffLevel[ xT ][ yT ][ cIdx ] as follows: <maths id="math0004" num=""><math display="block"><msub><mi mathvariant="normal">r</mi><mi>ij</mi></msub><mo>=</mo><mi>transCoeffLevel</mi><mfenced open="[" close="]"><mi>xT</mi></mfenced><mo>⁢</mo><mfenced open="[" close="]"><mi>yT</mi></mfenced><mo>⁢</mo><mfenced open="[" close="]"><mi>cIdx</mi></mfenced><mo>⁢</mo><mfenced open="[" close="]" separators=""><mfenced><mi>nW</mi></mfenced><mo>-</mo><mn mathvariant="normal">1</mn><mo>-</mo><mi mathvariant="normal">i</mi></mfenced><mo>⁢</mo><mfenced open="[" close="]" separators=""><mfenced><mi>nH</mi></mfenced><mo>-</mo><mn mathvariant="normal">1</mn><mo>-</mo><mi mathvariant="normal">j</mi></mfenced></math><img id="ib0004" file="imgb0004.tif" wi="115" he="14" img-content="math" img-format="tif"/></maths></p><p id="p0076" num="0076">In some scenarios, a frame can be divided in two areas, for instance one being used for screen content and the other for natural video. This may sometimes be called a split screen. Similarly, in a multiview codec, could utilize one view for screen content and the other for natural video. Alternatively, a bitstream could be composed of at least two substreams one making use of a transform skip or lossless mode, while the other would not. In any of these example situations, it will be understood that the coefficient reordering may be applied in the encoding/decoding of one of the views/areas/streams that is using either the transform skip, the transform skip with flat quantization or a skip of the transform and quantization steps while the other area/view/stream may not have coefficient reordering applied to its encoding/decoding.<!-- EPO <DP n="18"> --></p><p id="p0077" num="0077">In the case of scalable video coding, any of the foregoing embodiments may be applied to the base layer encoding/decoding, the enhancement layer encoding/decoding, or both layers. In the case of 3D or multi-view video coding, any of the forgoing embodiments may be applied to one of the view encoding/decoding, to the other view(s) encoding/decoding or to both/all views.</p><p id="p0078" num="0078">Reference is now made to Figure 10, which shows a simplified block diagram of an example embodiment of an encoder 900. The encoder 900 includes a processor 902, memory 904, and an encoding application 906. The encoding application 906 may include a computer program or application stored in memory 904 and containing instructions for configuring the processor 902 to perform operations such as those described herein. For example, the encoding application 906 may encode and output bitstreams encoded in accordance with the processes described herein. It will be understood that the encoding application 906 may be stored in on a computer readable medium, such as a compact disc, flash memory device, random access memory, hard drive, etc.</p><p id="p0079" num="0079">Reference is now also made to Figure 11, which shows a simplified block diagram of an example embodiment of a decoder 1000. The decoder 1000 includes a processor 1002, a memory 1004, and a decoding application 1006. The decoding application 1006 may include a computer program or application stored in memory 1004 and containing instructions for configuring the processor 1002 to perform operations such as those described herein. It will be understood that the decoding application 1006 may be stored in on a computer readable medium, such as a compact disc, flash memory device, random access memory, hard drive, etc.</p><p id="p0080" num="0080">It will be appreciated that the decoder and/or encoder according to the present application may be implemented in a number of computing devices, including, without limitation, servers, suitably-programmed general purpose computers, audio/video encoding and playback devices, set-top television boxes, television broadcast equipment, and mobile devices. The decoder or encoder may be implemented by way of software containing instructions for configuring a processor to carry out the functions described herein. The software instructions may be stored on any suitable non-transitory computer-readable memory, including CDs, RAM, ROM, Flash memory, etc.<!-- EPO <DP n="19"> --></p><p id="p0081" num="0081">It will be understood that the encoder described herein and the module, routine, process, thread, or other software component implementing the described method/process for configuring the encoder may be realized using standard computer programming techniques and languages. The present application is not limited to particular processors, computer languages, computer programming conventions, data structures, other such implementation details. Those skilled in the art will recognize that the described processes may be implemented as a part of computer-executable code stored in volatile or non-volatile memory, as part of an application-specific integrated chip (ASIC), etc.</p><p id="p0082" num="0082">Certain adaptations and modifications of the described embodiments can be made. Therefore, the above discussed embodiments are considered to be illustrative and not restrictive.</p></description><claims mxw-id="PCLM56976123" lang="EN" load-source="patent-office"><!-- EPO <DP n="20"> --><claim id="c-en-0001" num="0001"><claim-text>A method of decoding a bitstream of encoded video in a video decoder to reconstruct a block of residuals, the method comprising:
<claim-text>determining that transform skipping is enabled for the block of residuals;</claim-text>
<claim-text>entropy decoding a part of the bitstream to reconstruct a permuted block of<br/>
quantized residual data; and</claim-text>
<claim-text>based on the determination that transform skipping is enabled, reconstructing<br/>
the block of residuals by dequantizing and inverse permuting the permuted block of quantized residual data.</claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The method claimed in claim 1, wherein inverse permuting includes rotating the permuted block.</claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The method claimed in claim 2, wherein rotating the permuted block comprises rotating that permuted block by 180 degrees.</claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The method claimed in claim 3, wherein the permuted block has height nH and width nW, and wherein rotating comprises mapping each (i, j)-th residual of the permuted block, for 0 ≤ i &lt; nW and 0 ≤ <u>j</u> &lt; nH, to the (nW-1-i, nH-1-j)-th residual of the inverse permuted block.</claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The method claimed in any one of claims 1 to 4, wherein the permuted block is a 4x4 intra-coded block.</claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The method claimed in any one of claims 1 to 5, wherein determining includes determining that the block of residuals is intra-coded.</claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>The method claimed in any one of claims 1 to 6, wherein determining includes decoding a transform skipping flag from a header in the bitstream.</claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>The method claimed in any one of claims 1 to 7, wherein reconstructing includes dequantizing the reconstructed permuted block of quantized residual data to produce a<!-- EPO <DP n="21"> --> reconstructed permuted block of residual data and inverse permuting the reconstructed permuted block of residual data to produce the reconstructed block of residuals.</claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>The method claimed in any one of claims 1 to 6, wherein the determining that transform skipping is enabled comprises parsing a flag indicative of a lossless mode.</claim-text></claim><claim id="c-en-0010" num="0010"><claim-text>The method claimed in any one of claims 1 to 9, wherein the decoding of a part of the bitstream includes decoding at least two areas, wherein one area comprises blocks of residuals for which transform skipping is enabled and wherein the other area comprises blocks of residuals for which transform skipping is not enabled, and wherein the inverse permuting is applied to blocks in the area for which transform skipping is enabled and not to blocks in the other area.</claim-text></claim><claim id="c-en-0011" num="0011"><claim-text>A method of encoding video in a video encoder to output a bitstream of encoded data, the video including a block of residuals, the method comprising:
<claim-text>determining that transform skipping is enabled for the block of residuals;</claim-text>
<claim-text>based on the determination that transform skipping is enabled, permuting the block<br/>
of residual data to produce a permuted block of residual data;</claim-text>
<claim-text>quantizing the permuted block of residual data to produce a permuted block of<br/>
quantized residual data; and</claim-text>
<claim-text>entropy encoding the permuted block of quantized residual data to generate part of<br/>
the bitstream of encoded data.</claim-text></claim-text></claim><claim id="c-en-0012" num="0012"><claim-text>The method claimed in claim 11, wherein permuting includes rotating the block of residual data, and wherein rotating the block of residual data comprises rotating that block by 180 degrees.</claim-text></claim><claim id="c-en-0013" num="0013"><claim-text>The method claim in claim 12, wherein the block of residuals has height nH and width nW, and wherein rotating comprises mapping each (i, j)-th residual of the block of residuals, for 0 ≤ i &lt; nW and 0 ≤ j &lt; nH, to the (nW-1-i, nH-1-j)-th residual of the permuted block.</claim-text></claim><claim id="c-en-0014" num="0014"><claim-text>A decoder for decoding a bitstream of encoded video to reconstruct a block of residuals, the decoder comprising:
<claim-text>a processor;<!-- EPO <DP n="22"> --></claim-text>
<claim-text>a memory; and</claim-text>
<claim-text>a decoding application stored in memory and containing instructions for configuring<br/>
the processor to perform the method claimed in any one of claims 1 to 10.</claim-text></claim-text></claim><claim id="c-en-0015" num="0015"><claim-text>An encoder for encoding video to output a bitstream of encoded data, the video including a block of residuals, the decoder comprising:
<claim-text>a processor;</claim-text>
<claim-text>a memory; and</claim-text>
<claim-text>an encoding application stored in memory and containing instructions for configuring<br/>
the processor to perform the method claimed in any one of claims 11 to 13.</claim-text></claim-text></claim><claim id="c-en-0016" num="0016"><claim-text>A non-transitory processor-readable medium storing processor-executable instructions which, when executed, configures one or more processors to perform the method claimed in any of claims 1 to 13.</claim-text></claim></claims><drawings mxw-id="PDW16666908" load-source="patent-office"><!-- EPO <DP n="23"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="165" he="188" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="24"> --><figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="165" he="141" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="25"> --><figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="165" he="186" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="26"> --><figure id="f0004" num="4"><img id="if0004" file="imgf0004.tif" wi="165" he="169" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="27"> --><figure id="f0005" num="5"><img id="if0005" file="imgf0005.tif" wi="165" he="114" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="28"> --><figure id="f0006" num="6"><img id="if0006" file="imgf0006.tif" wi="153" he="210" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="29"> --><figure id="f0007" num="7"><img id="if0007" file="imgf0007.tif" wi="153" he="210" img-content="drawing" img-format="tif"/></figure></drawings><search-report-data><doc-page id="srep0001" file="srep0001.tif" wi="158" he="233" type="tif"/></search-report-data><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
