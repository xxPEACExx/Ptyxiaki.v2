<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2441049-B1" country="EP" doc-number="2441049" kind="B1" date="20140101" family-id="41426930" file-reference-id="318281" date-produced="20180823" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146552403" ucid="EP-2441049-B1"><document-id><country>EP</country><doc-number>2441049</doc-number><kind>B1</kind><date>20140101</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-10725092-A" is-representative="NO"><document-id mxw-id="PAPP154826326" load-source="docdb" format="epo"><country>EP</country><doc-number>10725092</doc-number><kind>A</kind><date>20100609</date><lang>EN</lang></document-id><document-id mxw-id="PAPP174949852" load-source="docdb" format="original"><country>EP</country><doc-number>10725092.0</doc-number><date>20100609</date></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140454515" ucid="EP-09305527-A" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>09305527</doc-number><kind>A</kind><date>20090610</date></document-id></priority-claim><priority-claim mxw-id="PPC140445736" ucid="EP-10725092-A" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>10725092</doc-number><kind>A</kind><date>20100609</date></document-id></priority-claim><priority-claim mxw-id="PPC140452906" ucid="EP-2010058111-W" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>2010058111</doc-number><kind>W</kind><date>20100609</date></document-id></priority-claim></priority-claims><dates-of-public-availability><intention-to-grant-date><date>20130723</date></intention-to-grant-date></dates-of-public-availability><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1988104393" load-source="docdb">G06T   9/00        20060101AFI20101230BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-2051743058" load-source="docdb" scheme="CPC">G06T   9/004       20130101 LI20150519BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2051746442" load-source="docdb" scheme="CPC">G06T   9/001       20130101 FI20150519BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132189693" lang="DE" load-source="patent-office">Verfahren zur Kodierung/Dekodierung eines dreidimensionalen Maschenmodells, das eine oder mehrere Komponenten umfasst</invention-title><invention-title mxw-id="PT132189694" lang="EN" load-source="patent-office">METHOD FOR ENCODING/DECODING A 3D MESH MODEL THAT COMPRISES ONE OR MORE COMPONENTS</invention-title><invention-title mxw-id="PT132189695" lang="FR" load-source="patent-office">Procédé de codage/décodage d'un modèle de maillage 3D qui comporte un ou plusieurs composants</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR918157611" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>THOMSON LICENSING</last-name><address><country>FR</country></address></addressbook></applicant><applicant mxw-id="PPAR918137308" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>THOMSON LICENSING</last-name></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR918143416" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>CAI KANGYING</last-name><address><country>CN</country></address></addressbook></inventor><inventor mxw-id="PPAR918145733" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>CAI, KANGYING</last-name></addressbook></inventor><inventor mxw-id="PPAR918994970" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>CAI, KANGYING</last-name><address><street>8F, Bld. A Technology Fortune Center No. 8 Xue Qing Road Hai Dian District</street><city>Beijing 100085</city><country>CN</country></address></addressbook></inventor><inventor mxw-id="PPAR918137731" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>CHEN QU QING</last-name><address><country>CN</country></address></addressbook></inventor><inventor mxw-id="PPAR918164599" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>CHEN, QU QING</last-name></addressbook></inventor><inventor mxw-id="PPAR918994967" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>CHEN, QU QING</last-name><address><street>8F, Bld. A Technology Fortune Center No. 8, Xue Qing Road Hai Dian District</street><city>Beijing 100085</city><country>CN</country></address></addressbook></inventor><inventor mxw-id="PPAR918170477" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>TENG JUN</last-name><address><country>CN</country></address></addressbook></inventor><inventor mxw-id="PPAR918153172" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>TENG, Jun</last-name></addressbook></inventor><inventor mxw-id="PPAR918994968" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>TENG, Jun</last-name><address><street>8/F, Building A Technology Fortune Center No. 8 Xue Qing Road Hai Dian District</street><city>Beijing 100085</city><country>CN</country></address></addressbook></inventor></inventors><assignees><assignee mxw-id="PPAR918994971" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Thomson Licensing</last-name><iid>101157220</iid><address><street>1-5, rue Jeanne d'Arc</street><city>92130 Issy-Les-Moulineaux</city><country>FR</country></address></addressbook></assignee></assignees><agents><agent mxw-id="PPAR918994969" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Rittner, Karsten</last-name><suffix>et al</suffix><iid>100044783</iid><address><street>Deutsche Thomson OHG European Patent Operations Karl-Wiechert-Allee 74</street><city>30625 Hannover</city><country>DE</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="EP-2010058111-W"><document-id><country>EP</country><doc-number>2010058111</doc-number><kind>W</kind><date>20100609</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2010142743-A2"><document-id><country>WO</country><doc-number>2010142743</doc-number><kind>A2</kind><date>20101216</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS548948679" load-source="docdb">AL</country><country mxw-id="DS548822220" load-source="docdb">AT</country><country mxw-id="DS548948680" load-source="docdb">BE</country><country mxw-id="DS548958587" load-source="docdb">BG</country><country mxw-id="DS548847179" load-source="docdb">CH</country><country mxw-id="DS548947411" load-source="docdb">CY</country><country mxw-id="DS548822221" load-source="docdb">CZ</country><country mxw-id="DS548948681" load-source="docdb">DE</country><country mxw-id="DS548947412" load-source="docdb">DK</country><country mxw-id="DS548947413" load-source="docdb">EE</country><country mxw-id="DS548959531" load-source="docdb">ES</country><country mxw-id="DS548958588" load-source="docdb">FI</country><country mxw-id="DS548958589" load-source="docdb">FR</country><country mxw-id="DS548948690" load-source="docdb">GB</country><country mxw-id="DS548947414" load-source="docdb">GR</country><country mxw-id="DS548948691" load-source="docdb">HR</country><country mxw-id="DS548822222" load-source="docdb">HU</country><country mxw-id="DS548847180" load-source="docdb">IE</country><country mxw-id="DS548947415" load-source="docdb">IS</country><country mxw-id="DS548958590" load-source="docdb">IT</country><country mxw-id="DS548947416" load-source="docdb">LI</country><country mxw-id="DS548953646" load-source="docdb">LT</country><country mxw-id="DS548822223" load-source="docdb">LU</country><country mxw-id="DS548953647" load-source="docdb">LV</country><country mxw-id="DS548953648" load-source="docdb">MC</country><country mxw-id="DS548875198" load-source="docdb">MK</country><country mxw-id="DS548875199" load-source="docdb">MT</country><country mxw-id="DS548959532" load-source="docdb">NL</country><country mxw-id="DS548958591" load-source="docdb">NO</country><country mxw-id="DS548875200" load-source="docdb">PL</country><country mxw-id="DS548847181" load-source="docdb">PT</country><country mxw-id="DS548959533" load-source="docdb">RO</country><country mxw-id="DS548875201" load-source="docdb">SE</country><country mxw-id="DS548847182" load-source="docdb">SI</country><country mxw-id="DS548958592" load-source="docdb">SK</country><country mxw-id="DS548875206" load-source="docdb">SM</country><country mxw-id="DS548947417" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><description mxw-id="PDES63956818" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><u>Field of the invention</u></heading><p id="p0001" num="0001">This invention relates to encoding and decoding of 3D mesh models that comprise one or more components, corresponding encoders and decoders, and resulting data sets.</p><heading id="h0002"><u>Background</u></heading><p id="p0002" num="0002">Three-dimensional (3D) meshes have been widely used in various applications for representing 3D objects. Their raw representation usually requires a huge amount of data, especially with the rapid growth of 3D scanners. However, most applications demand compact representation of 3D meshes for storage and transmission. Various algorithms have been proposed to compress 3D meshes efficiently from the early 1990s. Assumingly, this kind of technique will receive even more attention from both academe and industry with the rapid growth of internet based 3D applications.</p><p id="p0003" num="0003">The surface of a 3D object is a triangle mesh, i.e. it is composed of triangles. Two triangles that share an edge are <i>neighbours.</i> A sequence of neighbouring triangles is a <i>path,</i> and a set of triangles is called a <i>connected component</i> if a path between any two of its triangles exists. Flat surface areas that are in the shape of a parallelogram require only two triangles to be correctly described, while flat areas that are not in the shape of a parallelogram require more triangles. Typically, 3D meshes are represented by three types of data: connectivity data, geometry data and property data. Connectivity data describe the adjacency relationship between vertices, geometry data specify vertex locations in<!-- EPO <DP n="2"> --> 3D space, and property data specify attributes such as the normal vector, material reflectance and texture coordinates. Most widely-used 3D compression algorithms compress connectivity data and geometry data separately. The coding order of geometry data is determined by the underlying connectivity coding. 3D mesh property data are usually compressed by a method similar to geometry compression.</p><p id="p0004" num="0004">Geometry data are usually compressed by exploiting high correlation between the positions of adjacent vertices along the coding order, which are also spatially adjacent in most cases. Most geometry compression schemes follow a three-step procedure: pre-quantization of vertex positions, prediction of quantized positions, and entropy coding of prediction residuals.</p><p id="p0005" num="0005">Uncompressed geometry data typically specify each coordinate component with a 32-bit floating-point number. However, this precision is beyond human eyes' perception capability and is far more than needed for common applications. Thus, quantization can be used for reducing the data amount without serious impairment on visual quality. Quantization techniques can be classified to be uniform on non-uniform. Each quantization cell is of the same length in a uniform scalar quantizer while cells have different lengths in a non-uniform scalar quantizer. A known method is to partition a mesh into several regions according to local curvature and triangle sizes, and then adaptively choose different quantization resolutions for different regions. Within each region, the vertex coordinates are uniformly quantized. Compared with non-uniform quantization, uniform quantization is simple and computationally efficient, but it is not optimal in terms of rate-distortion (R-D) performance.<!-- EPO <DP n="3"> --></p><p id="p0006" num="0006">Another important issue of geometry data compression is the coordinate system used to express vertex positions. Commonly a (usually cartesian) world coordinate system (WCS) for the complete model and/or a local coordinate system (LCS) for a single triangle are used, as shown in <figref idrefs="f0001"><b>Fig.1 a)</b></figref><b>.</b></p><p id="p0007" num="0007">A compression algorithm for 3D mesh models using Principal Component Analysis was proposed by <nplcit id="ncit0001" npl-type="b"><text>Amjoun, Sondershaus and Straßer in "Compression of Complex Animated Meshes", Advances in Computer Graphics, Lecture Notes in Computer Science, Springer, Volume 4035, 2006, pp 606-613</text></nplcit>.</p><heading id="h0003"><u>Summary of the Invention</u></heading><p id="p0008" num="0008">The present invention provides methods and means for improving the accuracy of encoded 3D mesh models, and particularly the accuracy of encoded 3D mesh models that comprise one or more distinct components.</p><p id="p0009" num="0009">A method for encoding a 3D mesh model that is composed of one or more components is disclosed in claim 1. A geometry encoder for encoding a 3D mesh model that is composed of one or more components is disclosed in claim 4.</p><p id="p0010" num="0010">Advantageous embodiments of the invention are disclosed in the dependent claims, the following description and the figures.</p><heading id="h0004"><u>Brief description of the drawings</u></heading><p id="p0011" num="0011">Exemplary embodiments of the invention are described with reference to the accompanying drawings, which show in<!-- EPO <DP n="4"> --><!-- EPO <DP n="5"> -->
<dl id="dl0001" compact="compact"><dt>Fig.1 a)</dt><dd>the world coordinate system and a local coordinate system for usage with a 3D mesh model;</dd><dt>Fig.1 b)</dt><dd>a component coordinate system for usage with a component of a 3D mesh model;</dd><dt>Fig.2</dt><dd>an exemplary 3D mesh model as a wireframe model;</dd><dt>Fig.3 a)-c)</dt><dd>details of an uncompressed 3D mesh model;</dd><dt>Fig.3 d)-f)</dt><dd>details of a conventionally quantized and de-quantized 3D mesh model with artifacts;</dd><dt>Fig.3 g)-i)</dt><dd>details of an improved quantized and de-quantized 3D mesh model according to the invention;</dd><dt>Fig.4</dt><dd>a block diagram of an entropy encoder for 3D mesh models;</dd><dt>Fig.5</dt><dd>a block diagram of an entropy decoder for 3D mesh models; and</dd><dt>Fig.6</dt><dd>a flow chart of a method for encoding 3D mesh models.</dd></dl></p><heading id="h0005"><u>Detailed description of the invention</u></heading><p id="p0012" num="0012"><figref idrefs="f0001">Fig.1</figref> shows a portion of a 3D mesh model with respective cartesian coordinate systems. The world coordinate system WCS with its three orthonormal axes X<sub>w</sub>, Y<sub>w</sub>, Z<sub>w</sub> is valid for the whole model. A spanning triangle T<sub>sp</sub> (uvr) is described relative to a reference triangle T<sub>ref</sub> (uvw). A local coordinate system LCS (with three orthonormal axes X,Y,Z) is usually defined at each reference triangle. The common side <o><i>uv</i></o> of T<sub>ref</sub> and T<sub>sp</sub>, which is called "active gate", defines the local x-axis X. The middle point <i>O</i> of <o><i>uv</i></o> is assumed to be the origin. The local z-axis Z is the normal of the reference triangle T<sub>ref</sub>. The local <i>y</i>-axis Y is then obtained by computing the cross product of the local z and x axes, and is therefore orthogonal to the xz plane. The local coordinate system LCS needs to be re-calculated for each current front vertex<!-- EPO <DP n="6"> --> (r in <figref idrefs="f0001">Fig.1</figref>). Since the range of the local coordinate values is not predefined, quantization in the local coordinate system is a two-pass process. One initial pass is necessary to find the range of local coordinates. Compared with quantization in the world coordinate system WCS, quantization in local coordinate system LCS is more complex and needs much more computational effort.</p><p id="p0013" num="0013">When compressing a 3D model (i.e. vertices and connection data), quantization is used, resulting in quantization errors. Quantization is a lossy procedure, since it represents a large or infinite set of values with a smaller set. Typical mesh geometry coding schemes uniformly quantize each coordinate at 8-bit to 12-bit quantization resolutions. For models with smooth surface and uniformly distributed vertices, the quality loss can hardly be noticed for human eyes. However, this approximation often fails to accurately reproduce flat surfaces that are not orthogonal to any coordinate axes, adding an important amount of distortion even for a simple geometry. E.g. if a model comprises a large flat area, the quantization error may conventionally have the effect that the triangles that belong to an originally flat partial area are not flat any longer, i.e. they do not make a flat surface after de-quantization. It has been found that this problem results partly from the position of the component, relative to the world coordinate system WCS. The present invention solves this problem by defining a separate component coordinate system CCS for each component.</p><p id="p0014" num="0014">According to one aspect of the invention, a 3D mesh model that is de-composed into components can be quantized better and more accurately when each component is encoded relative to its own individual component coordinate system CCS, as shown in <figref idrefs="f0001">Fig.1 b)</figref>. In the encoder, the component coordinate<!-- EPO <DP n="7"> --> system CCS is used to normalize the component for quantization, so that the quantization is done in the world coordinate system WCS. This reduces quantization errors. In the encoded 3D model, data defining the component coordinate system CCS are included. In the decoder, the data defining the component coordinate system CCS are extracted, the component is de-quantized in the world coordinate system WCS and then transformed back into its original position, using the extracted component coordinate system CCS.</p><p id="p0015" num="0015">In the following, the encoding and decoding processes are explained in more detail. Generally, the vertex positions of a current component are {v<sub>i</sub> | i = 0,...,n}. Suppose a current connected component has m triangles. For any triangle <i>T<sub>i</sub></i> of the current connected component, we denote its area as <i>S<sub>i</sub></i> and its three vertices of as <i>v<sub>i0</sub>, v<sub>i1</sub></i> and <i>v<sub>i2</sub></i>. The triangles of the current component are {(i0, i1, i2) | i = 0,...,m}. The complete surface area of the current component is S.</p><p id="p0016" num="0016">In one embodiment, the following steps are performed during encoding:
<ol><li>1. Calculate the mean point of the component v<sub>mean</sub> and the covariance matrix C as follows. <maths id="math0001" num="(1)"><math display="block"><mi>S</mi><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover></mstyle><msub><mi>S</mi><mi>i</mi></msub></math><img id="ib0001" file="imgb0001.tif" wi="111" he="12" img-content="math" img-format="tif"/></maths> <maths id="math0002" num="(2)"><math display="block"><msub><mi>v</mi><mi mathvariant="italic">mean</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>3</mn><mo>⁢</mo><mi mathvariant="italic">mS</mi></mrow></mfrac><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover></mstyle><msub><mi>S</mi><mi>i</mi></msub><mo>⁢</mo><mfenced separators=""><msub><mi>v</mi><mrow><mi>i</mi><mo>⁢</mo><mn>0</mn></mrow></msub><mo>+</mo><msub><mi>v</mi><mrow><mi>i</mi><mo>⁢</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>v</mi><mrow><mi>i</mi><mo>⁢</mo><mn>2</mn></mrow></msub></mfenced></math><img id="ib0002" file="imgb0002.tif" wi="111" he="12" img-content="math" img-format="tif"/></maths> <maths id="math0003" num="(3)"><math display="block"><mi>C</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>3</mn><mo>⁢</mo><mi mathvariant="italic">mS</mi></mrow></mfrac><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover></mstyle><msub><mi>S</mi><mi>i</mi></msub><mo>⁢</mo><mfenced separators=""><msub><mi>v</mi><mrow><mi>i</mi><mo>⁢</mo><mn>0</mn></mrow></msub><mo>⁢</mo><msup><msub><mi>v</mi><mrow><mi>i</mi><mo>⁢</mo><mn>0</mn></mrow></msub><mi>T</mi></msup><mo>+</mo><msub><mi>v</mi><mrow><mi>i</mi><mo>⁢</mo><mn>1</mn></mrow></msub><mo>⁢</mo><msup><msub><mi>v</mi><mrow><mi>i</mi><mo>⁢</mo><mn>1</mn></mrow></msub><mi>T</mi></msup><mo>+</mo><msub><mi>v</mi><mrow><mi>i</mi><mo>⁢</mo><mn>2</mn></mrow></msub><mo>⁢</mo><msup><msub><mi>v</mi><mrow><mi>i</mi><mo>⁢</mo><mn>2</mn></mrow></msub><mi>T</mi></msup></mfenced><mo>-</mo><msub><mi>v</mi><mi mathvariant="italic">mean</mi></msub><mo>⁢</mo><msup><msub><mi>v</mi><mi mathvariant="italic">mean</mi></msub><mi>T</mi></msup></math><img id="ib0003" file="imgb0003.tif" wi="123" he="12" img-content="math" img-format="tif"/></maths></li><li>2. Calculate the eigenvectors and corresponding eigenvalues of C: E0, E1 and E2 are the eigenvectors (e.g. sorted in increasing order of eigenvalues).<!-- EPO <DP n="8"> --></li><li>3. Translate vertices by -v<sub>mean</sub>. Then the mean point of all vertices will be the origin.</li><li>4. Rotate vertices to make E0, E1 and E2 align with X, Y and Z axis.</li><li>5. Translate vertices by v<sub>mean</sub>.</li><li>6. Compress the rotated geometry data, e.g. by the classical three-step procedure: pre-quantization of vertex positions, prediction of quantized positions, and entropy coding of prediction residuals.</li><li>7. Besides the encoded prediction residuals, record E0 and E1 in the compressed component data.</li></ol></p><p id="p0017" num="0017">The following steps are performed during decoding:
<ol><li>1. Decode the prediction residuals, calculate the quantized positions and de-quantize positions.</li><li>2. Calculate the mean point v<sub>mean</sub> (or center) using the de-quantized float positions of each vertex as follows. <maths id="math0004" num="(4)"><math display="block"><mi>S</mi><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover></mstyle><msub><mi>S</mi><mi>i</mi></msub></math><img id="ib0004" file="imgb0004.tif" wi="98" he="12" img-content="math" img-format="tif"/></maths> <maths id="math0005" num="(5)"><math display="block"><msub><mi>v</mi><mi mathvariant="italic">mean</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>3</mn><mo>⁢</mo><mi mathvariant="italic">mS</mi></mrow></mfrac><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover></mstyle><msub><mi>S</mi><mi>i</mi></msub><mo>⁢</mo><mfenced separators=""><msub><mi>v</mi><mrow><mi>i</mi><mo>⁢</mo><mn>0</mn></mrow></msub><mo>+</mo><msub><mi>v</mi><mrow><mi>i</mi><mo>⁢</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>v</mi><mrow><mi>i</mi><mo>⁢</mo><mn>2</mn></mrow></msub></mfenced></math><img id="ib0005" file="imgb0005.tif" wi="98" he="12" img-content="math" img-format="tif"/></maths></li><li>3. Translate vertices by -v<sub>mean</sub>.</li><li>4. Read the eigenvectors E0 and E1 from the compressed mesh data, and calculate E2 = E0 * E1</li><li>5. Rotate vertices to make X, Y and Z axis align with E0, E1 and E2.</li><li>6. Translate vertices by v<sub>mean</sub>.</li></ol></p><p id="p0018" num="0018">In other words, the component is translated such that its center moves from its original position to the center of the coordinate system, rotated according to the rotation matrix<!-- EPO <DP n="9"> --> as defined by the eigenvectors E0,E1,E2 and translated back to its original position.</p><p id="p0019" num="0019">As both the encoder and decoder only do rigid operation on components, the mean points calculated by the two sides have the same position. The area of a triangle is usually a float number, calculated from the float number positions of its three vertices. Generally, the weight of each vertex of a triangle is calculated from the positions of all the vertices of all the triangles to which it belongs, since these positions define the eccentricity and shape of the component, and thus the importance of the respective vertex. In one embodiment, the area of each triangle is added to the weight of all its three vertices. The weight of a vertex (for calculating the component mean) is the sum of the areas of all its adjacent triangles in this embodiment.</p><p id="p0020" num="0020"><figref idrefs="f0001">Fig.2</figref> is an exemplary original 3D model of a personal digital assistant (PDA) located on a seat. The model is made by 3D software<sup>1</sup>. The model is composed of thirteen connected components with totally 12822 vertices and 24696 triangles. <figref idrefs="f0002">Fig.3 a)</figref> shows the same model, with <figref idrefs="f0002">Fig.3 b) and c) </figref>showing details of edges of a flat front region of the model. Many vertices/triangles are required to define the round corner regions (not visible in <figref idrefs="f0002">Fig.3 a)-c)). Fig.3 d)</figref> is the same model quantized with 12-bits. There is a significant visual quality loss on the flat surfaces on the quantized model, especially on the area with high vertex density, i.e. the round corner regions. To show the difference clearly, the close-ups of the original and quantized models are shown in <figref idrefs="f0002">Fig.3 b),c) and e),f)</figref> respectively. While in the original model a)-c) the triangles of the flat region are coplanar,<!-- EPO <DP n="10"> --> this is not the case after conventional quantization d)-f). However, encoding and decoding according to the present invention yields improved quality of the 3D model, as shown in <figref idrefs="f0002">Fig.3 g)-i)</figref>. Compared with the decoded model shown in <figref idrefs="f0002">Fig.3 a)</figref>, the geometry compression technique proposed herein significantly improves the quality of the decoded model while using the same quantization resolution.<br/>
<sup>1</sup> 3DsMax</p><p id="p0021" num="0021">This invention provides an efficient geometry compression method, especially for 3D meshes with highly non-uniform vertex distribution and large scale flat surfaces that are not orthogonal to any coordinate axes, such as 3D engineering models. Most 3D engineering models have many connected components, which each have a different object space.</p><p id="p0022" num="0022">A geometry encoder according to one aspect of the invention compresses each connected component in its own object coordinate system, where the large scale feature of the connected component (e.g. flat surfaces) is orthogonal to one of the coordinate axes, and can be much better reserved at conventional or even less quantization resolution. Encoding can be based on prediction and residuals. As the large scale feature has been normalized, the entropy of the residual of a predicted position is also decreased, which helps increase the compression ratio of geometry encoding. Both the quality of the decoded model and the compression ratio can be improved at the same time.</p><p id="p0023" num="0023">In one embodiment, the encoder first computes an orthonormal basis in 3D-space that describes the eccentricities of a current connected component by a simple and computational efficient technique, which is Principal Component Analysis (PCA) based. This basis is used as a pure rotation matrix to bring the corresponding connected component to a normalized<!-- EPO <DP n="11"> --> (or canonical) orientation mesh. The rotated geometry data is then quantized, predicted and entropy encoded. The orthonormal basis is also recorded in the compressed mesh data, so that the decoder can restore the original geometry of each connected component and assemble them together after decoding the component geometry.</p><p id="p0024" num="0024"><figref idrefs="f0003">Fig.4</figref> shows a block diagram of a geometry encoder according to one aspect of the invention. The geometry encoder 50 comprises a component recognition block 51 that recognizes connected components, an object space calculation block 52 that calculates the object space (i.e. the individual orthonormal basis in 3D space) of each connected component, as described above, an orientation normalization block 53, a quantizer 54 for quantizing vertex positions and a differential encoding block 55 for predicting the quantized vertex positions and generating residuals. The object space calculation block 52 outputs object coordinate system information 56, i.e. data defining the calculated object space, to an entropy encoder 58. The differential encoding block 55 outputs the residual information 57 also to the entropy encoder 58.</p><p id="p0025" num="0025">The entropy encoder 58 generates a signal that represents an entropy encoded 3D model, and that comprises at least one group of encoded vertex data, representing a connected component, and the object coordinate system information relating to said component. The object coordinate system information can be used to define a transformation between a component coordinate system (CCS) and the world coordinate system (WCS).</p><p id="p0026" num="0026"><figref idrefs="f0003">Fig.5</figref> shows a block diagram of a corresponding geometry decoder, which is suitable for decoding the above-described signal that<!-- EPO <DP n="12"> --> represents an entropy encoded 3D model. The geometry decoder 60 has an entropy decoder 61, which decodes an input signal and extracts prediction residual information 62, i.e. the actual vertex and connectivity data, and the object coordinate system information 63. In the geometry decoder comprises a decoder 64 for decoding the quantized vertex positions, a de-quantizer 65 for de-quantizing the vertex positions, an orientation restoration block 66 for restoring the orientation of each connected component, and an assemble block 67 for assembling the connected component, and for assembling the 3D model from the connected components. The orientation restoration block 66 receives and processes the object coordinate system information 63, so as to obtain a transform matrix (e.g. rotation matrix). In one example, the processing comprises calculating an eigenvector E2 that is orthogonal to two received eigenvectors E0, E1, as described above.</p><p id="p0027" num="0027"><figref idrefs="f0004">Fig.6</figref> shows a flow-chart of an exemplary encoding process. First a component is selected or determined 71, which may happen implicitly. Then, an orthonormal basis in 3D space is determined for the component 72. While the object coordinate system information is used to normalize the object orientation 74, it is also encoded 73. Then the vertex positions are quantized 75 and encoded 76. Finally, the encoded quantized vertex positions and the encoded object coordinate system information may be transmitted 77, stored etc.</p><p id="p0028" num="0028">The invention is advantageous to minimize the visual artifacts of the quantized 3D mesh models. It is especially good for those 3D meshes with large scale flat surfaces that are not orthogonal to any coordinate axe and yield a highly non-uniform vertex distribution, e.g. 3D engineering models, without sacrificing the simplicity and compression ratio of<!-- EPO <DP n="13"> --> geometry encoder/decoder. The invention provides an efficient geometry compression strategy designed especially for models with large scale flat surfaces and highly non-uniform vertex distribution.</p><p id="p0029" num="0029">Another approach for removing the visual artifacts would be to increase the quantization resolution. However, it leads to a significant decrease in the efficiency of the geometry encoder. Therefore it is not used here. Non-uniform quantization needs to divide the mesh into many pieces during encoding and merge the pieces together during decoding which needs much more computation efforts and makes the encoder/ decoder more complex. Local coordinate systems depend on the connectivity compression method used and the flat surfaces can not be guaranteed to be orthogonal to any local coordinate axis either.</p><p id="p0030" num="0030">While it may be generally known to use used PCA based techniques to normalize the orientation of connected components, the present invention uses a weighting scheme for assigning weights to the vertices during computation of the covariance matrix. This kind of weighting scheme is particularly reasonable when considering the dramatically changed triangle size of 3D models made by recent software applications.</p><p id="p0031" num="0031">A bit-stream provided by the encoder is similar to a conventional bit-stream, but is only modified at geometry level, i.e. in the header of a group of vertex data of each connected component. The new bit-stream records the object coordinate system information, which includes:
<ul><li>one bit to indicate whether the orientation of the current connected component needs to be normalized. E.g. "1" means the orientation normalization operation is<!-- EPO <DP n="14"> --> employed, while "0" means the operation is not employed; and</li><li>some bits to indicate the coordinate axes of the object coordinate system of the corresponding connected component if the previous bit equals to "1". As each axis is normalized, two floats are enough to record one axis. Two axes are enough to describe the coordinate system. Thus, four floating point values, i.e. 16 bytes, are necessary for the object coordinate system of one connected component.</li></ul></p><p id="p0032" num="0032">Exemplarily, a range encoder<sup>2</sup> can be used as entropy coder, which is similar to the arithmetic coder or Huffman coder. The geometry encoder's performance with and without component orientation normalization are listed in Table 1. By using the geometry encoder with component orientation normalization proposed in this invention, we save <b><i>(1527 - 1419.6)</i></b> / <b><i>1527 = 7.2%</i></b> storage, since the prediction residual is also greatly reduced after the connected components become orientation meshes. So the proposed geometry compression not only improves the visual quality of the decoded model at a given quantization resolution, but as another advantage may also increase the compression ratio.
<tables id="tabl0001" num="0001"><table frame="all"><title>Tab.1: Performance comparison of geometry encoders with and without component orientation normalization when compressing 'PDA' model</title><tgroup cols="5"><colspec colnum="1" colname="col1" colwidth="34mm"/><colspec colnum="2" colname="col2" colwidth="33mm"/><colspec colnum="3" colname="col3" colwidth="33mm"/><colspec colnum="4" colname="col4" colwidth="33mm"/><colspec colnum="5" colname="col5" colwidth="35mm"/><thead><row><entry morerows="1" valign="top">Org. Geo.(byte)</entry><entry namest="col2" nameend="col3" align="center" valign="top">Geometry encoder without component orientation normalization</entry><entry namest="col4" nameend="col5" align="center" valign="top">Geometry encoder with component orientation normalization</entry></row><row><entry valign="top">Comp. Geo.(byte)</entry><entry valign="top">Comp. Ratio</entry><entry valign="top">Comp. Geo.(byte)</entry><entry valign="top">Comp. Ratio</entry></row></thead><tbody><row><entry>153864</entry><entry align="right">1527</entry><entry align="right">28.9%</entry><entry align="right">1207+209.6 = 1416.6</entry><entry align="right">22.9%</entry></row></tbody></tgroup></table></tables>
<sup>2</sup>G.N.N. Martin. Range encoding: an algorithm for removing redundancy from digitized message. March 1979, Video &amp; Data Recording Conference, Southampton, UK<!-- EPO <DP n="15"> --></p><p id="p0033" num="0033">In one embodiment, a geometry encoder for encoding a 3D mesh model, wherein the 3D mesh model comprises one or more components, comprises<br/>
determining means (52) for determining an orthonormal basis in 3D space for each of the one or more components, wherein Principal Component Analysis based on the vertices of a component is used and wherein each vertex belongs to one or more triangles, and wherein, for said Principal Component Analysis, each vertex of the component is assigned a weight which is determined from the areas of the triangles to which the vertex belongs,<br/>
encoder (56) for encoding object coordinate system information of the component,<br/>
normalizer means (53) for normalizing the orientation of each of the one or more components relative to a world coordinate system (WCS), wherein a transformation means is comprises that performs for each of said one or more components a transformation that is obtained from the determined orthonormal basis of the component,<br/>
quantizer (54) for quantizing the normalized vertex positions, and<br/>
encoder (55,57) for encoding the quantized vertex positions.</p><p id="p0034" num="0034">In one embodiment of the geometry encoder, the determining means (52) for determining an orthonormal basis comprises calculating means for calculating a component mean for each component, wherein for the calculating said weight of a vertex<!-- EPO <DP n="16"> --> is the sum of the areas of the triangles to which the vertex belongs.</p><p id="p0035" num="0035">A geometry decoder for decoding a 3D mesh model comprising one or more components comprises decoding means(64) for decoding quantized vertex positions; de-quantizing means (65) for de-quantizing the decoded vertex positions;<br/>
determining means for determining de-quantized vertices that belong to a component of the one or more components; receiving means (63) for receiving object coordinate system information that relates to said component, the object coordinate system information defining a transformation between a component coordinate system (CCS) and the world coordinate system (WCS); and<br/>
restoring means (66) for restoring the orientation of said component relative to the world coordinate system (WCS), based on the received object coordinate system information.</p><p id="p0036" num="0036">The decoder further comprises assembling means (67) for assembling the 3D mesh model from a plurality of components, wherein for each component individual object coordinate system information is received (63) and for each component the orientation is individually restored (66).</p><p id="p0037" num="0037">The restoring means for restoring the orientation of said component comprises<br/>
calculating means for calculating the mean point of the component using the de-quantized float positions of each vertex of the component, translating means for translating (e.g. shifting) the component, wherein the mean point is translated (e.g. shifted) to the center of the coordinate system, rotating means for rotating the component, and<br/>
<!-- EPO <DP n="17"> -->translating means (may be the same as above) for translating the rotated component, wherein the mean point is translated to its former position.</p><p id="p0038" num="0038">In one example of the decoder, the receiving means performs steps of extracting two eigenvectors E0, E1 of a covariance matrix, calculating a third eigenvector E2 and using the eigenvectors as object coordinate system information for determining an orthonormal basis in 3D space for the component.</p><p id="p0039" num="0039">It will be understood that the present invention has been described purely by way of example, and modifications of detail can be made without departing from the scope of the invention, as<!-- EPO <DP n="18"> --> defined in the claims. Reference numerals appearing in the claims are by way of illustration only and shall have no limiting effect on the scope of the claims.</p></description><claims mxw-id="PCLM56977943" lang="DE" load-source="patent-office"><!-- EPO <DP n="22"> --><claim id="c-de-01-0001" num="0001"><claim-text>Verfahren zum Codieren eines 3D-Flächennetzmodells, wobei das 3D-Flächennetzmodell eine oder mehrere Komponenten umfasst, wobei das Verfahren die folgenden Schritte umfasst:
<claim-text>- Bestimmen (52) einer Orthonormalbasis im 3D-Raum für jede der einen oder mehreren Komponenten, wobei eine Hauptkomponentenanalyse auf der Grundlage der Scheitelpunkte einer Komponente verwendet wird und wobei jeder Scheitelpunkt zu einem oder zu mehreren Dreiecken gehört;</claim-text>
<claim-text>- Codieren (56) von Objektkoordinatensystem-Informationen der Komponente, wobei die Objektkoordinatensystem-Informationen aus der Orthonormalbasis hergeleitet werden;</claim-text>
<claim-text>- Normieren (53) der Orientierung jeder der einen oder mehreren Komponenten, wobei für jede der einen oder mehreren Komponenten eine Transformation zwischen einem Komponentenkoordinatensystem (CCS) und einem Weltkoordinatensystem (WCS) verwendet wird, die aus der bestimmten Orthonormalbasis der Komponente erhalten wird, und wobei die Objektkoordinatensystem-Informationen die Transformation definieren; und</claim-text>
<claim-text>- Quantisieren (54) der normierten Scheitelpunktpositionen;</claim-text>
<b>gekennzeichnet durch</b>
<claim-text>- Zuweisen einer Gewichtung zu jedem Scheitelpunkt der Komponente für die Hauptkomponentenanalyse, wobei die Gewichtung aus den Flächen der Dreiecke bestimmt wird, zu denen der Scheitelpunkt gehört; und<!-- EPO <DP n="23"> --></claim-text>
<claim-text>- differentielles Codieren (55, 57) der quantisierten Scheitelpunktpositionen auf der Grundlage eines aufspannenden Dreiecks (ST), wobei für jedes aufspannende Dreieck (ST) ein lokales Koordinatensystem (LCS) verwendet wird.</claim-text></claim-text></claim><claim id="c-de-01-0002" num="0002"><claim-text>Verfahren nach Anspruch 1, wobei der Schritt des Bestimmens (52) einer Orthonormalbasis das Berechnen eines Komponentenmittelwerts für jede Komponente umfasst, wobei für das Berechnen die Gewichtung eines Scheitelpunkts die Summe der Flächen der Dreiecke, zu denen der Scheitelpunkt gehört, ist.</claim-text></claim><claim id="c-de-01-0003" num="0003"><claim-text>Verfahren nach Anspruch 1 oder 2, wobei der Schritt des Codierens (56) der Objektkoordinatensystem-Informationen das Codieren zweier Eigenvektoren E0, E1 der Kovarianzmatrix der Komponente, jedoch nicht eines dritten Eigenvektors E2 umfasst.</claim-text></claim><claim id="c-de-01-0004" num="0004"><claim-text>Geometriecodierungseinrichtung zum Codieren eines 3D-Flächennetzmodells, wobei das 3D-Flächennetzmodell eine oder mehrere Komponenten umfasst, wobei die Geometriecodierungseinrichtung umfasst:
<claim-text>- ein Bestimmungsmittel (52) zum Bestimmen einer Orthonormalbasis im 3D-Raum für jede der einen oder mehreren Komponenten, wobei eine Hauptkomponentenanalyse auf der Grundlage der Scheitelpunkte einer Komponente verwendet wird und wobei jeder Scheitelpunkt zu einem oder zu mehreren Dreiecken gehört;</claim-text>
<claim-text>- einen Codierer (56) zum Codieren von Objektkoordinatensystem-Informationen der Komponente, wobei die Objektkoordinatensystem-Informationen<!-- EPO <DP n="24"> --> aus der Orthonormalbasis hergeleitet werden;</claim-text>
<claim-text>- ein Normierungsmittel (53) zum Normieren der Orientierung jeder der einen oder mehreren Komponenten in Bezug zu einem Weltkoordinatensystem (WCS), wobei das Normierungsmittel ein Transformationsmittel umfasst, das für jede der einen oder mehreren Komponenten eine Transformation zwischen einem Komponentenkoordinatensystem (CCS) und einem Weltkoordinatensystem (WCS) ausführt, die aus der bestimmten Orthonormalbasis der Komponente erhalten wird und die durch die Objektkoordinatensystem-Informationen definiert ist; und</claim-text>
<claim-text>- einen Quantisierer (54) zum Quantisieren der normierten Scheitelpunktpositionen;</claim-text>
<b>dadurch gekennzeichnet, dass</b>
<claim-text>- für die Hauptkomponentenanalyse jedem Scheitelpunkt der Komponente eine Gewichtung zugewiesen wird, die aus den Flächen der Dreiecke bestimmt wird, zu denen der Scheitelpunkt gehört; und</claim-text>
<claim-text>- der Geometriecodierer einen Codierer (55, 57) zum differentiellen Codieren der quantisierten Scheitelpunktpositionen auf der Grundlage eines aufspannenden Dreiecks (ST) umfasst, wobei für jedes aufspannende Dreieck (ST) ein lokales Koordinatensystem (LCS) verwendet wird.</claim-text></claim-text></claim><claim id="c-de-01-0005" num="0005"><claim-text>Geometriecodierer nach Anspruch 4, wobei das Bestimmungsmittel (52) ein Berechnungsmittel zum Berechnen eines Komponentenmittelwerts für jede Komponente umfasst, wobei für das Berechnen die Gewichtung eines Scheitelpunkts die<!-- EPO <DP n="25"> --> Summe der Flächen der Dreiecke, zu denen der Scheitelpunkt gehört, ist.</claim-text></claim><claim id="c-de-01-0006" num="0006"><claim-text>Geometriecodierer nach Anspruch 4 oder 5, wobei der Codierer (56) zum Codieren von Objektkoordinatensystem-Informationen der Komponente zwei Eigenvektoren E0, E1 einer Kovarianzmatrix, jedoch nicht einen dritten Eigenvektor E2 codiert.</claim-text></claim></claims><claims mxw-id="PCLM56977944" lang="EN" load-source="patent-office"><!-- EPO <DP n="19"> --><claim id="c-en-01-0001" num="0001"><claim-text>A method for encoding a 3D mesh model, wherein the 3D mesh model comprises one or more components, comprising the steps of
<claim-text>- determining (52) an orthonormal basis in 3D space for each of the one or more components, wherein Principal Component Analysis based on the vertices of a component is used and wherein each vertex belongs to one or more triangles;</claim-text>
<claim-text>- encoding (56) object coordinate system information of the component, wherein the object coordinate system information is derived from said orthonormal basis;</claim-text>
<claim-text>- normalizing (53) the orientation of each of the one or more components, wherein for each of said one or more components a transformation between a component coordinate system (CCS) and a world coordinate system (WCS) is used that is obtained from the determined orthonormal basis of the component, and wherein the object coordinate system information defines said transformation; and</claim-text>
<claim-text>- quantizing (54) the normalized vertex positions;</claim-text>
<b>characterised by</b>
<claim-text>- assigning, for said Principal Component Analysis, a weight to each vertex of the component, wherein said weight is determined from the areas of the triangles to which the vertex belongs; and</claim-text>
<claim-text>- differentially encoding (55,57) the quantized vertex positions based on a spanning triangle (ST), wherein a local coordinate system (LCS) is used for each spanning triangle (ST).</claim-text><!-- EPO <DP n="20"> --></claim-text></claim><claim id="c-en-01-0002" num="0002"><claim-text>Method according to claim 1, wherein the step of determining (52) an orthonormal basis comprises calculating a component mean for each component, wherein for the calculating said weight of a vertex is the sum of the areas of the triangles to which the vertex belongs.</claim-text></claim><claim id="c-en-01-0003" num="0003"><claim-text>Method according to claim 1 or 2, wherein the step of encoding (56) the object coordinate system information comprises encoding two eigenvec-tors E0,E1 of the covariance matrix of the component, but not a third eigenvector E2.</claim-text></claim><claim id="c-en-01-0004" num="0004"><claim-text>Geometry encoder for encoding a 3D mesh model, the 3D mesh model comprising one or more components, the geometry encoder comprising
<claim-text>- determining means (52) for determining an orthonormal basis in 3D space for each of the one or more components, wherein Principal Component Analysis based on the vertices of a component is used and wherein each vertex belongs to one or more triangles;</claim-text>
<claim-text>- encoder (56) for encoding object coordinate system information of the component, wherein the object coordinate system information is derived from said orthonormal basis;</claim-text>
<claim-text>- normalizer means (53) for normalizing the orientation of each of the one or more components relative to a world coordinate system (WCS), wherein the normalizer means comprises transformation means that performs for each of said one or more components<!-- EPO <DP n="21"> --> a transformation between a component coordinate system (CCS) and a world coordinate system (WCS) that is obtained from the determined orthonormal basis of the component, and that is defined by the object coordinate system information; and</claim-text>
<claim-text>- quantizer (54) for quantizing the normalized vertex positions; <b>characterised in that</b> - for said Principal Component Analysis, each vertex of the component is assigned a weight which is determined from the areas of the triangles to which the vertex belongs; and</claim-text>
<claim-text>- the geometry encoder comprises an encoder (55,57) for differentially encoding the quantized vertex positions based on a spanning triangle (ST), wherein a local coordinate system (LCS) is used for each spanning triangle (ST).</claim-text></claim-text></claim><claim id="c-en-01-0005" num="0005"><claim-text>Geometry encoder according to claim 4, wherein the determining means (52) comprises calculating means for calculating a component mean for each component, wherein for the calculating said weight of a vertex is the sum of the areas of the triangles to which the vertex belongs.</claim-text></claim><claim id="c-en-01-0006" num="0006"><claim-text>Geometry encoder-according to claim 4 or 5, wherein the encoder (56) for encoding object coordinate system information of the component encodes two Eigenvectors E0, E1 of a covariance matrix, but not a third Eigenvector E2.</claim-text></claim></claims><claims mxw-id="PCLM56977945" lang="FR" load-source="patent-office"><!-- EPO <DP n="26"> --><claim id="c-fr-01-0001" num="0001"><claim-text>Un procédé pour le codage d'un modèle de maillage 3D, dans lequel le modèle de maillage 3D comprend un ou plusieurs composants, comprenant les étapes de
<claim-text>- détermination (52) d'une base orthonormale dans un espace 3D pour le composant ou chacun des composants, dans lequel l'analyse du composant principal basée sur les sommets d'un composant est utilisée et dans lequel chaque sommet appartient à un ou plusieurs triangle(s),</claim-text>
<claim-text>- codage (56) des informations du système de coordonnées d'un objet du composant, dans lequel les nformations des coordonnées d'un objet sont dérivées de ladite base orthonormale;</claim-text>
<claim-text>- normalisation (53) de l'orientation du composant ou de chacun des composants, dans lequel pour le composant ou chacun des composants une transformation entre un système de coordonnées du composant (CCS) et un système de coordonnées universel (WCS) est utilisé, obtenu à partir de la base orthonormale déterminée du composant, et dans lequel les informations du système de coordonnées d'un objet définissent ladite transformation; et</claim-text>
<claim-text>- quantification (54) des positions de sommet normalisées; <b>caractérisées par</b></claim-text>
<claim-text>- l'attribution, pour ladite analyse du composant principal, d'un poids pour chaque sommet du composant, dans lequel ledit poids est déterminé à partir des parties des triangles auxquelles le sommet appartient; et<!-- EPO <DP n="27"> --></claim-text>
<claim-text>- le codage différentiel (55,57) des positions de sommet quantifiées basées sur un triangle (ST), dans lequel un système de coordonnées local (LCS) est utilisé pour chaque triangle maximal (ST).</claim-text></claim-text></claim><claim id="c-fr-01-0002" num="0002"><claim-text>Procédé selon la revendication 1, dans lequel l'étape de détermination (52) d'une base orthonormale comprend le calcul d'un moyen de composant pour chaque composant, dans lequel pour le calcul, ledit poids d'un sommet équivaut à la somme des parties des triangles auxquelles le sommet appartient.</claim-text></claim><claim id="c-fr-01-0003" num="0003"><claim-text>Procédé selon la revendication 1 ou 2, dans lequel l'étape de codage (56) des informations du système de coordonnées d'un objet comprend le codage de deux vecteurs propres E0, E1 de la matrice de covariance du composant mais pas un troisième vecteur propre E2.</claim-text></claim><claim id="c-fr-01-0004" num="0004"><claim-text>Un codeur géométrique pour le codage d'un modèle de maillage 3D, le modèle de maillage 3D comprenant un ou plusieurs composants, le codeur géométrique comprenant
<claim-text>- un moyen de détermination (52) pour la détermination d'une base orthonormale dans un espace 3D pour le composant ou chacun des composants, dans lequel est utilisée l'analyse du composant principal basée sur les sommets d'un composant et dans lequel chaque sommet appartient à un ou plusieurs triangles;</claim-text>
<claim-text>- un codeur (56) pour le codage des informations du système de coordonnées d'un objet du composant dans lequel les informations du système de coordonnées de l'objet sont dérivées de ladite base orthonormale;<!-- EPO <DP n="28"> --></claim-text>
<claim-text>- un moyen normalisateur (53) pour la normalisation du composant ou de chacun des composants relatif(s) à un système de coordonnées universel (WCS), dans lequel le moyen normalisateur comprend un moyen de transformation qui effectue pour le composant ou chacun des composants une transformation entre un système de coordonnées de composants (CCS) et un système de coordonnées universel (WCS) qui est obtenu à partir de la base orthonormale du composant, et qui est défini par les informations du système de coordonnées de l'objet; et</claim-text>
<claim-text>- quantificateur (54) pour quantifier les positions normalisées du sommet ; <b>caractérisé en ce que</b></claim-text>
<claim-text>- pour ladite analyse de composant principal, un poids est attribué à chaque sommet mis à part le composant, déterminé à partir des zones des triangles auxquelles appartient le sommet; et</claim-text>
<claim-text>- le codeur géométrique comprend un codeur (55,57) pour le codage différentiel des positions de sommet quantifiées basé sur un triangle maximal (ST), dans lequel un système de coordonnées local (LCS)est utilisé pour chaque triangle maximal (ST).</claim-text></claim-text></claim><claim id="c-fr-01-0005" num="0005"><claim-text>Codeur géométrique selon la revendication 4, dans lequel l'étape de détermination (52) comprend un moyen de calcul pour calculer un moyen de composant pour chaque composant, dans lequel pour le calcul ledit poids d'un sommet est la somme des parties des triangles auxquelles le sommet appartient.</claim-text></claim><claim id="c-fr-01-0006" num="0006"><claim-text>Codeur géométrique selon l'une des revendications 4 ou 5, dans lequel le codeur (56) pour le codage des<!-- EPO <DP n="29"> --> informations du système de coordonnées de l'objet du composant code deux vecteurs propres E0, E1 d'une matrice de covariance, mais pas un troisième vecteur propre E2.</claim-text></claim></claims><drawings mxw-id="PDW16668435" load-source="patent-office"><!-- EPO <DP n="30"> --><figure id="f0001" num="1a,1b,2"><img id="if0001" file="imgf0001.tif" wi="165" he="208" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="31"> --><figure id="f0002" num="3a,3b,3c,3d,3e,3f,3g,3h,3i"><img id="if0002" file="imgf0002.tif" wi="164" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="32"> --><figure id="f0003" num="4,5"><img id="if0003" file="imgf0003.tif" wi="159" he="201" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="33"> --><figure id="f0004" num="6"><img id="if0004" file="imgf0004.tif" wi="165" he="154" img-content="drawing" img-format="tif"/></figure></drawings><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
