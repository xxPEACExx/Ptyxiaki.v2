<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2006770-B1" country="EP" doc-number="2006770" kind="B1" date="20140101" family-id="38657663" file-reference-id="318250" date-produced="20180822" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146554289" ucid="EP-2006770-B1"><document-id><country>EP</country><doc-number>2006770</doc-number><kind>B1</kind><date>20140101</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-07290793-A" is-representative="YES"><document-id mxw-id="PAPP154828212" load-source="docdb" format="epo"><country>EP</country><doc-number>07290793</doc-number><kind>A</kind><date>20070619</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140453699" ucid="EP-07290793-A" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>07290793</doc-number><kind>A</kind><date>20070619</date></document-id></priority-claim></priority-claims><dates-of-public-availability><intention-to-grant-date><date>20121030</date></intention-to-grant-date></dates-of-public-availability><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1988127677" load-source="ipcr">G06F   9/50        20060101AFI20071115BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL1988137390" load-source="docdb" scheme="CPC">G06F   9/5088      20130101 FI20130101BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132195351" lang="DE" load-source="patent-office">Lastenbalancierung</invention-title><invention-title mxw-id="PT132195352" lang="EN" load-source="patent-office">Load balancing</invention-title><invention-title mxw-id="PT132195353" lang="FR" load-source="patent-office">Equilibrage de charge</invention-title></technical-data><related-documents><relation type="division-into"><child-doc ucid="EP-12005831.8"><document-id load-source="patent-office" format="epo"><country>EP</country><doc-number>12005831.8</doc-number><date>20120810</date></document-id></child-doc><parent-doc ucid="EP-07290793-A"><document-id load-source="patent-office" format="epo"><country>EP</country><doc-number>07290793</doc-number><kind>A</kind><date>20070619</date></document-id><parent-grant-document ucid="EP-2006770-B1"><document-id><country>EP</country><doc-number>2006770</doc-number><kind>B1</kind><date>20140101</date></document-id></parent-grant-document></parent-doc></relation></related-documents><parties><applicants><applicant mxw-id="PPAR918153001" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>VIRTUALLOGIX SA</last-name><address><country>FR</country></address></addressbook></applicant><applicant mxw-id="PPAR918150315" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>VIRTUALLOGIX SA</last-name></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR918172914" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>GROUZDEV VLADIMIR</last-name><address><country>FR</country></address></addressbook></inventor><inventor mxw-id="PPAR918132512" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>GROUZDEV VLADIMIR</last-name></addressbook></inventor><inventor mxw-id="PPAR918999312" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>GROUZDEV VLADIMIR</last-name><address><street>129 bis, Boulevard Murat</street><city>75016 Paris</city><country>FR</country></address></addressbook></inventor></inventors><assignees><assignee mxw-id="PPAR918999314" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>VirtualLogix SA</last-name><iid>100832619</iid><address><street>6, avenue Gustave Eiffel</street><city>78180 Montigny-Le-Bretonneux</city><country>FR</country></address></addressbook></assignee></assignees><agents><agent mxw-id="PPAR918999313" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Rummler, Felix</last-name><suffix>et al</suffix><iid>100045869</iid><address><street>R.G.C. Jenkins &amp; Co 26 Caxton Street</street><city>London SW1H 0RJ</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS548888118" load-source="docdb">AT</country><country mxw-id="DS548876280" load-source="docdb">BE</country><country mxw-id="DS548987671" load-source="docdb">BG</country><country mxw-id="DS548832737" load-source="docdb">CH</country><country mxw-id="DS548986221" load-source="docdb">CY</country><country mxw-id="DS548986222" load-source="docdb">CZ</country><country mxw-id="DS548989265" load-source="docdb">DE</country><country mxw-id="DS548876281" load-source="docdb">DK</country><country mxw-id="DS548876282" load-source="docdb">EE</country><country mxw-id="DS548991855" load-source="docdb">ES</country><country mxw-id="DS548987672" load-source="docdb">FI</country><country mxw-id="DS548987673" load-source="docdb">FR</country><country mxw-id="DS548989266" load-source="docdb">GB</country><country mxw-id="DS548876283" load-source="docdb">GR</country><country mxw-id="DS548986223" load-source="docdb">HU</country><country mxw-id="DS548832738" load-source="docdb">IE</country><country mxw-id="DS548876284" load-source="docdb">IS</country><country mxw-id="DS548987674" load-source="docdb">IT</country><country mxw-id="DS548876285" load-source="docdb">LI</country><country mxw-id="DS548989267" load-source="docdb">LT</country><country mxw-id="DS548888119" load-source="docdb">LU</country><country mxw-id="DS548987675" load-source="docdb">LV</country><country mxw-id="DS548989268" load-source="docdb">MC</country><country mxw-id="DS548888120" load-source="docdb">MT</country><country mxw-id="DS548888121" load-source="docdb">NL</country><country mxw-id="DS548888122" load-source="docdb">PL</country><country mxw-id="DS548991856" load-source="docdb">PT</country><country mxw-id="DS548993064" load-source="docdb">RO</country><country mxw-id="DS548888123" load-source="docdb">SE</country><country mxw-id="DS548989269" load-source="docdb">SI</country><country mxw-id="DS548832739" load-source="docdb">SK</country><country mxw-id="DS548876286" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data></bibliographic-data><description mxw-id="PDES63957707" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><b>Background</b></heading><p id="p0001" num="0001">A virtual machine is a self-contained execution environment that behaves as if it is a separate computer and which can run its own operating system. Virtual machines provide Virtual CPUs (VCPUs) to clients or "guests", and each VCPU runs on a dedicated physical CPU. A VCPU is a representation of a physical processor within a Virtual Machine. In conventional systems, the mapping between virtual and physical CPUs is static.</p><p id="p0002" num="0002">If multiple CPUs are available to a client or "guest", the guest tasks are spread between the CPUs. This is preferably done such that the available resources are used in the most efficient way and computing time is decreased. This process is generally referred to as "load balancing".</p><p id="p0003" num="0003">Conventional load balancing algorithms may be insufficient. Let us consider, for example, the sharing of a plurality of physical CPUs between dedicated real-time software and generic server software. Let us assume an UP (uniprocessor) execution environment (e.g. LINUX) running the real-time software on CPU 0, and an SMP (symmetric multiprocessing) execution environment (LINUX) running a server software on CPUs 0-3. In this example, CPU 0 is shared between the the real-time software and the server software. The dedicated real-time has a higher scheduling priority. In this example, the SMP load balancer does not take into account the real-time activity on CPU 0. This may skew the SMP load balancing.<!-- EPO <DP n="2"> --></p><p id="p0004" num="0004">The present invention aims to address this and other problems of conventional load balancing. In particular, but not exclusively, the present invention is concerned with better balancing the load of physical CPUs in a computer system comprising physical and virtual CPUs.</p><p id="p0005" num="0005"><nplcit id="ncit0001" npl-type="b"><text>JACOB J C ET AL: "A spanning tree based recursive refinement algorithm for fast task mapping" PROCEEDINGS OF THE FOURTH IEEE INTERNATIONAL SYMPOSIUM ON HIGH PERFORMANCE DISTRIBUTED COMPUTING (CAT. NO.95TB8075) IEEE COMPUT. SOC. PRESS LOS ALAMITOS, CA, USA, 1995, pages 58-65, XP002458251 ISBN: 0-8186-7088-6</text></nplcit>, and <nplcit id="ncit0002" npl-type="s"><text>E. PIEL, P. MARQUET, J. SOULA, AND J.-L. DEKEYSER: "LOAD-BALANCING FOR A REAL-TIME SYSTEM BASED ON ASYMMETRIC MULTI-PROCESSING" 16TH EUROMICRO CONFERENCE ON REAL-TIME SYSTEMS, WIP SESSION, June 2004 (2004-06), XP002458252 Catania, Italy</text></nplcit>, describe methods pertaining to the features of the preamble of claim 1.</p><heading id="h0002"><b>Summary of the Invention</b></heading><p id="p0006" num="0006">The invention is recited by independent claims 1, 4 and 5. Preferred features are recited by the dependent claims.</p><heading id="h0003"><b>Brief Description of the Drawings</b></heading><p id="p0007" num="0007"><ul><li><figref idrefs="f0001">Fig. 1</figref> illustrates schematically the architecture of a system to which the present invention can be applied; and</li><li><figref idrefs="f0002 f0003 f0004 f0005">Figs. 2 to 5</figref> illustrate screen shots showing CPU usage statistics with and without load balancing in accordance with an embodiment of the invention.</li></ul></p><heading id="h0004"><b>Description of Exemplary Embodiments of the Invention</b></heading><heading id="h0005"><b>Introduction</b></heading><p id="p0008" num="0008"><figref idrefs="f0001">Fig. 1</figref> illustrates schematically the architecture of a system comprising physical CPUs, virtual CPUs, and client (guest) applications, to which the present invention can be applied.</p><p id="p0009" num="0009">The present invention is based on the realisation that the overall performance of a system as shown in <figref idrefs="f0001">Fig. 1</figref> can be improved by automatically balancing the load on physical CPUs attributed to the same SMP guest. In particular, the idea is to balance the physical CPUs load by migrating a virtual CPU (VCPU) from one physical CPU<!-- EPO <DP n="3"> --> to another. Although this affects a statical VCPU to CPU assignment for a UP guest, the VCPUs to CPUs mapping within a fixed set of CPUs is transparent for SMP guests such that a scheduler which implements the present invention can decide which VCPU is to run on which physical CPU within the fixed CPU set. In other words, if an SMP guest is running on two physical CPUs (a &amp; b), the scheduler creates two VCPUs (x &amp; y) and maps them to the physical CPUs. In this example, two equivalent mappings are possible:
<ol><li>(1) VCPU<sub>x</sub> → CPU<sub>a</sub> and VCPU<sub>y</sub> → CPU<sub>b</sub></li><li>(2) VCPU<sub>x</sub> → CPU<sub>b</sub> and VCPU<sub>y</sub> → CPU<sub>a</sub></li></ol></p><p id="p0010" num="0010">The scheduler is able to dynamically choose one of these mappings depending on CPU loads. The mapping switch results in a "swapping" ofVCPUs, i.e. in two VCPUs migrating from one physical CPU to another. Such an operation is fully transparent for the guest and does not change a fixed physical set of CPUs assigned to the guest.</p><p id="p0011" num="0011">By implementing such a load balancing mechanism, it is possible to at least partially resolve the above described SMP load balancing skewing problem by migrating a server VCPU running on CPU<sub>0</sub>, for example, to another CPU when the real-time activity is high and this VCPU is loaded. In order to improve the overall performance by such a migration, an underloaded CPU<sub>n</sub> (n &gt; 0, in this example) must be found and VCPU running on CPU<sub>n</sub> must migrate to CPU<sub>0</sub>.<!-- EPO <DP n="4"> --></p><p id="p0012" num="0012">This solution is partial only in that it does not work when the system is heavily loaded, i.e. when all physical CPUs are fully loaded. However, as such a situation is rare in practice, it is acceptable.</p><heading id="h0006"><b>Migration criteria</b></heading><p id="p0013" num="0013">Regularly, at a given time period, the scheduler calculates the load of each physical CPU (LOAD<sub>n</sub>, n=0..N) and all VCPUs running on each physical CPU (VLOAD<sub>n,m</sub>, m=0..M). More particularly, two loads are calculated for each VCPU: a "positive" load and a "negative" load.</p><p id="p0014" num="0014">The positive load for a given VCPU<sub>n,m</sub> is equal to the actual VCPU load: <maths id="math0001" num=""><math display="block"><msub><mi>VPLOAD</mi><mrow><mi mathvariant="normal">n</mi><mo>,</mo><mi mathvariant="normal">m</mi></mrow></msub><mo>=</mo><msub><mi>VLOAD</mi><mrow><mi mathvariant="normal">n</mi><mo>,</mo><mi mathvariant="normal">m</mi></mrow></msub></math><img id="ib0001" file="imgb0001.tif" wi="56" he="10" img-content="math" img-format="tif"/></maths></p><p id="p0015" num="0015">The negative load for a given VCPU<sub>n,m</sub> is equal to a sum of the loads of all other VCPUs running on the same physical CPU: <maths id="math0002" num=""><math display="block"><msub><mi>VNLOAD</mi><mrow><mi mathvariant="normal">n</mi><mo>,</mo><mi mathvariant="normal">m</mi></mrow></msub><mo>=</mo><mstyle displaystyle="false"><munder><mo>∑</mo><mspace width="1em"/></munder><mo>⁢</mo><msub><mi>VLOAD</mi><mrow><mi mathvariant="normal">n</mi><mo>,</mo><mi mathvariant="normal">i</mi></mrow></msub></mstyle><mspace width="2em"/><mi mathvariant="normal">i</mi><mo>=</mo><mn mathvariant="normal">0..</mn><mo>⁢</mo><mi mathvariant="normal">M</mi><mo>,</mo><mi mathvariant="normal">i</mi><mo>≠</mo><mi mathvariant="normal">m</mi></math><img id="ib0002" file="imgb0002.tif" wi="86" he="15" img-content="math" img-format="tif"/></maths></p><p id="p0016" num="0016">A physical CPU is considered overloaded if its load is above a predetermined threshold: <maths id="math0003" num=""><math display="block"><msub><mi>LOAD</mi><mi mathvariant="normal">n</mi></msub><mo>≥</mo><msub><mi>LOAD</mi><mi>over</mi></msub></math><img id="ib0003" file="imgb0003.tif" wi="45" he="11" img-content="math" img-format="tif"/></maths><!-- EPO <DP n="5"> --></p><p id="p0017" num="0017">A physical CPU is considered underloaded if its load is below a predetermined threshold: <maths id="math0004" num=""><math display="block"><msub><mi>LOAD</mi><mi mathvariant="normal">n</mi></msub><mo>≥</mo><msub><mi>LOAD</mi><mi>under</mi></msub></math><img id="ib0004" file="imgb0004.tif" wi="43" he="11" img-content="math" img-format="tif"/></maths></p><p id="p0018" num="0018">Load balancing is only applied to a pair of CPUs in which one CPU is overloaded and other CPU is underloaded: <maths id="math0005" num=""><math display="block"><msub><mi>CPU</mi><mi mathvariant="normal">i</mi></msub><mo>↔</mo><msub><mi>CPU</mi><mi mathvariant="normal">j</mi></msub></math><img id="ib0005" file="imgb0005.tif" wi="30" he="10" img-content="math" img-format="tif"/></maths><br/>
where <maths id="math0006" num=""><math display="block"><msub><mi>CPU</mi><mi mathvariant="normal">i</mi></msub><mo>≥</mo><msub><mi>LOAD</mi><mi>over</mi></msub><mo>⁢</mo><msub><mrow><mspace width="1em"/><mi>and CPU</mi></mrow><mi mathvariant="normal">j</mi></msub><mo>≤</mo><msub><mi>LOAD</mi><mi>under</mi></msub></math><img id="ib0006" file="imgb0006.tif" wi="84" he="12" img-content="math" img-format="tif"/></maths></p><p id="p0019" num="0019">The load balancing comprises finding two unbalanced VCPUs of the same SMP guest running on CPU<sub>i</sub> and CPU<sub>j</sub> such that: <maths id="math0007" num=""><math display="block"><msub><mi>VPLOAD</mi><mrow><mi mathvariant="normal">i</mi><mo>,</mo><mi mathvariant="normal">k</mi></mrow></msub><mo>=</mo><msub><mi>VPLOAD</mi><mrow><mi mathvariant="normal">j</mi><mo>,</mo><mi mathvariant="normal">l</mi></mrow></msub></math><img id="ib0007" file="imgb0007.tif" wi="54" he="13" img-content="math" img-format="tif"/></maths> and swapping these VCPUs across physical CPUs.</p><p id="p0020" num="0020">Because a VCPU migration, in terms of processing power, is a quite expensive operation, the migration criteria is adjusted by introducing a positive migration threshold:<!-- EPO <DP n="6"> --> <maths id="math0008" num=""><math display="block"><msub><mi>VPLOAD</mi><mrow><mi mathvariant="normal">i</mi><mo>,</mo><mi mathvariant="normal">k</mi></mrow></msub><mo>-</mo><msub><mi>VPLOAD</mi><mrow><mi mathvariant="normal">j</mi><mo>,</mo><mi mathvariant="normal">l</mi></mrow></msub><mo>≥</mo><mi mathvariant="italic">MIGR_POS_WTMARK</mi></math><img id="ib0008" file="imgb0008.tif" wi="96" he="11" img-content="math" img-format="tif"/></maths></p><p id="p0021" num="0021">In addition, the migration criteria takes into account the negative load of the overloaded emigrant: <maths id="math0009" num=""><math display="block"><msub><mi>VNLOAD</mi><mrow><mi mathvariant="normal">i</mi><mo>,</mo><mi mathvariant="normal">k</mi></mrow></msub><mo>≥</mo><mi mathvariant="italic">MIGR_NEG_WTMARK</mi></math><img id="ib0009" file="imgb0009.tif" wi="76" he="10" img-content="math" img-format="tif"/></maths></p><p id="p0022" num="0022">The negative load water mark avoids unnecessary migrations when the CPU overloading is not caused by a simultaneous activity of multiple guests, but rather by a single guest monopolizing the physical CPU.</p><heading id="h0007">Specific Implementation</heading><p id="p0023" num="0023"><i>A mymips</i> program has been used to demonstrate skewing in the SMP load balancing of a guest operating system. The <i>mymips</i> program permanently calculates the program execution speed (MIPS) and prints out the calculation results on console.<br/>
<i>mymips</i> provides the following result when running on a SMP Linux guest with a dedicated single physical CPU:
<ul><li>min/max/ave: 258/258/258</li></ul></p><p id="p0024" num="0024">The results above and below were obtained on a DELL D820 Dual Core 1.8 MHz Laptop.<!-- EPO <DP n="7"> --></p><p id="p0025" num="0025">Two <i>mymips</i> programs provide the following result when running on an SMP Linux with two dedicated CPUs:
<ul><li>min/max/ave: 257/259/258</li><li>min/max/ave: 258/259/258</li></ul></p><p id="p0026" num="0026">A basic configuration which can be used to implement the load balancing mechanism in accordance with an embodiment of the invention comprises two SMP Linux guests sharing two physical CPUs. In order to obtain an unbalanced load on such a configuration, guests have been running on a conventional system without load balancing mechanism. Two <i>mymips</i> programs running simultaneously on each guest provide the following results:
<ul><li>min/max/ave: 101/258/190</li><li>min/max/ave: 92/257/190</li></ul></p><p id="p0027" num="0027">This shows about 25% of performance hit comparing to a single SMP Linux which performs a load balancing (at OS level) across multiple CPUs. The performance hit is due to sporadic <i>mymips</i> migrations from one CPU to another. Such a migration randomly runs <i>mymips</i> on the same processor.</p><p id="p0028" num="0028">This practical result is fully in line with a theoretical determination. Because of a random nature of migrations, the probability of running both <i>mymips</i> on the same CPU is 0.5. Thus, an expected performance hit is 0.25 because when running two programs on the same CPU, only a half of the CPU power is available.<!-- EPO <DP n="8"> --></p><p id="p0029" num="0029"><figref idrefs="f0002">Figs. 2</figref> illustrates a screen shot showing CPU usage statistics without load balancing in accordance with an embodiment of the invention. The screen shot represents the scenario described above.</p><p id="p0030" num="0030">When running the same load with load balancing enabled, the performance is close to a single SMP Linux.
<ul><li>min/max/ave: 254/257/256</li><li>min/max/ave: 250/256/255</li></ul></p><p id="p0031" num="0031">The load balancing compensates sporadic migrations of <i>mymips</i> (from one VCPU to another) caused by the Linux SMP scheduler. In other words, the scheduler tries to execute heavy loaded VCPUs on different physical CPUs.</p><p id="p0032" num="0032"><figref idrefs="f0003">Figs. 3</figref> illustrates a screen shot showing CPU usage statistics with load balancing in accordance with an embodiment of the invention. The screen shot represents the scenario described above.</p><p id="p0033" num="0033">In order to confirm the above theoretical conclusion, a Linux kernel compilation was used as a variable load. Two compilations were running in parallel on two Linux guests in the following three configurations:
<ol><li>(1) Two Linux guests each running on a dedicated CPU</li><li>(2) Two Linux guests sharing two CPUs without load balancing<!-- EPO <DP n="9"> --></li><li>(3) Two Linux guests sharing two CPUs with load balancing</li></ol></p><p id="p0034" num="0034">Each time, the duration of compilation was measured. Results corresponding to different Linux kernel compilations are shown below.
<ul><li>(1.1) 11m21.046s</li><li>(1.2) 8m34.204s</li><li>(2.1) 16m4.272s</li><li>(2.2) 12m20.575s</li><li>(3.1) 13m51.974s</li><li>(3.2) 10m32.467s</li></ul></p><p id="p0035" num="0035">The performance hit on the system without load balancing (2) is about 40%, while the performance hit on the system with load balancing (3) is about 20%. Accordingly, the load balancing improves a performance degradation caused by a transparent CPU sharing among multiple SMP guests.</p><p id="p0036" num="0036"><figref idrefs="f0004">Figs. 4</figref> and <figref idrefs="f0005">5</figref> illustrate screen shots showing CPU usage statistics with and without load balancing in accordance with an embodiment of the invention. The screen shots represent the scenarios described above.<!-- EPO <DP n="10"> --></p><p id="p0037" num="0037">The above results were obtained using the following load balancing parameters:
<ul><li><i>PERIOD =</i> 10 milliseconds</li><li>LOAD<sub>under</sub> = 80%</li><li>LOAD<sub>over</sub> = 100%</li><li><i>MIGR_POS_ WTMARK= 5 %</i></li><li><i>MIGR_NEG</i>_<i>WTMARK = 5</i>%</li></ul></p><p id="p0038" num="0038">It may be possible to achieve even better result on a variable load by modifying these parameters.</p><heading id="h0008"><b>Other aspects and embodiments</b></heading><p id="p0039" num="0039">It will be clear from the forgoing that the above-described embodiments are only examples, and that other embodiments are possible.</p></description><claims mxw-id="PCLM56980610" lang="DE" load-source="patent-office"><!-- EPO <DP n="13"> --><claim id="c-de-01-0001" num="0001"><claim-text>Verfahren zur Lastenbalancierung in einem Datenverarbeitungssystem, das eine Mehrzahl von physikalischen CPUs und eine Mehrzahl von virtuellen CPUs umfasst, wobei das Verfahren umfasst:
<claim-text>Ausführen einer Multiprozessoroperation, die mindestens zwei physikalische CPUs einbezieht; und</claim-text>
<claim-text>Zuweisen von mindestens zwei virtuellen CPUs zur Multiprozessoroperation zum Ausführen der Multiprozessoroperation;</claim-text>
<claim-text>Zuordnen der mindestens zwei virtuellen CPUs jeweils zu den mindestens zwei physikalischen CPUs; und</claim-text>
<claim-text>Bestimmen der Last einer jeden der mindestens zwei virtuellen CPUs und der Last einer jeden der mindestens zwei physikalischen CPUs;</claim-text>
<claim-text><b>gekennzeichnet durch</b>:
<claim-text>Bestimmen für eine gegebene virtuelle CPU einer negativen Last, welche die Last aller anderen virtuellen CPUs anzeigt, die der gleichen physikalischen CPU zugeteilt sind wie die gegebene virtuelle CPU;</claim-text><claim-text>Austauschen der Zuordnung der beiden virtuellen CPUs, wenn die folgenden Bedingungen erfüllt werden:
<claim-text>(i) die Last einer der beiden physikalischen CPUs ist über einer ersten Schwelle;</claim-text>
<claim-text>(ii) die Last der anderen der beiden physikalischen CPUs ist unter einer zweiten Schwelle;</claim-text>
<claim-text>(iii) die Last einer virtuellen CPU, die der physikalischen CPU zugeordnet ist, deren Last über der ersten Schwelle ist, ist höher als die Last einer virtuellen CPU, die der physikalischen CPU zugeordnet ist, deren Last unter der zweiten Schwelle ist; und</claim-text>
<claim-text>(iv) die negative Last ist über einer vorbestimmten Schwelle.</claim-text></claim-text></claim-text></claim-text></claim><claim id="c-de-01-0002" num="0002"><claim-text>Verfahren nach Anspruch 1, umfassend:
<claim-text>Austauschen der Zuordnung der beiden virtuellen CPUs als Reaktion auf eine Änderung der Last mindestens einer der beiden physikalischen CPUs.</claim-text></claim-text></claim><claim id="c-de-01-0003" num="0003"><claim-text>Verfahren nach Anspruch 4, umfassend:<!-- EPO <DP n="14"> -->
<claim-text>Austauschen der Zuordnung nur dann, wenn der Unterschied von Lasten der beiden virtuellen CPUs über einer vorbestimmten Schwelle ist.</claim-text></claim-text></claim><claim id="c-de-01-0004" num="0004"><claim-text>Computersystem, das so ausgelegt ist, dass es das Verfahren nach einem der vorhergehenden Ansprüche ausführt.</claim-text></claim><claim id="c-de-01-0005" num="0005"><claim-text>Computerprogrammprodukt, umfassend maschinenlesbaren Code, welcher bei Ausführung durch eine Datenverarbeitungsvorrichtung das Verfahren nach einem der Ansprüche 1 bis 3 ausführt.</claim-text></claim><!-- EPO <DP n="15"> --><!-- EPO <DP n="16"> --><!-- EPO <DP n="17"> --><!-- EPO <DP n="18"> --></claims><claims mxw-id="PCLM56980611" lang="EN" load-source="patent-office"><!-- EPO <DP n="11"> --><claim id="c-en-01-0001" num="0001"><claim-text>A method of load balancing in a data processing system comprising a plurality of physical CPUs and a plurality of virtual CPUs, the method comprising:
<claim-text>running a multiprocessor operation involving at least two physical CPUs; and</claim-text>
<claim-text>assigning at least two virtual CPUs to said multiprocessor operation, for executing said multiprocessor operation;</claim-text>
<claim-text>mapping the at least two virtual CPUs to said at least two physical CPUs, respectively, wherein the mapping depends on the load of said at least two physical CPUs; and</claim-text>
<claim-text>determining the load of each of said at least two virtual CPUs and the load of each of said at least two physical CPUs;</claim-text>
<claim-text><b>characterised by</b></claim-text>
<claim-text>determining, for a given virtual CPU, a negative load indicative of the load of all other virtual CPUs that are allocated to the same physical CPU as the given virtual CPU;</claim-text>
<claim-text>swapping the mapping of the two virtual CPUs if the following conditions are met:
<claim-text>(i) the load of one of the two physical CPUs is above a first threshold,</claim-text>
<claim-text>(ii) the load of the other one of the two physical CPUs is below a second threshold,</claim-text>
<claim-text>(iii) the load of a virtual CPU mapped to the physical CPU whose load is above said first threshold is higher than the load of a virtual CPU mapped to the physical CPU whose load is below said second threshold; and</claim-text>
<claim-text>(iv) the negative load is above a predetermined threshold.</claim-text></claim-text></claim-text></claim><claim id="c-en-01-0002" num="0002"><claim-text>The method of claim 1, comprising:
<claim-text>swapping the mapping of the two virtual CPUs in response to a change of load of at least one of the two physical CPUs.</claim-text></claim-text></claim><claim id="c-en-01-0003" num="0003"><claim-text>The method of claim 4, comprising:
<claim-text>swapping the mapping only if the difference of loads of said two virtual CPUs is above a predetermined threshold.</claim-text><!-- EPO <DP n="12"> --></claim-text></claim><claim id="c-en-01-0004" num="0004"><claim-text>Computer system, arranged to perform the method of any preceding claim.</claim-text></claim><claim id="c-en-01-0005" num="0005"><claim-text>Computer program product, comprising machine-readable code which, when executed by a data processing device, executes the method of any of claims 1 to 3.</claim-text></claim></claims><claims mxw-id="PCLM56980612" lang="FR" load-source="patent-office"><!-- EPO <DP n="19"> --><claim id="c-fr-01-0001" num="0001"><claim-text>Procédé d'équilibrage de charge dans un système de traitement de données comprenant une pluralité de CPU physiques et une pluralité de CPU virtuelles, le procédé comprenant :
<claim-text>l'exécution d'une opération à multiprocesseur impliquant au moins deux CPU physiques ; et</claim-text>
<claim-text>l'assignation d'au moins deux CPU virtuelles à ladite opération à multiprocesseur, pour exécuter ladite opération à multiprocesseur ;</claim-text>
<claim-text>le mappage des au moins deux CPU virtuelles respectivement sur chacune desdites deux CPU physiques, dans lequel le mappage dépend de la charges desdites aux moins deux CPU physiques ; et</claim-text>
<claim-text>la détermination de la charge de chacune desdites au moins deux CPU virtuelles et de la charge de chacune desdites au moins deux CPU physiques ;</claim-text>
<claim-text><b>caractérisé par</b></claim-text>
<claim-text>la détermination, pour une CPU virtuelle donnée, d'une charge négative indicative de la charge de toutes les autres CPU virtuelles qui sont allouées à la même CPU physique en tant que la CPU virtuelle donnée ; et</claim-text>
<claim-text>l'échange du mappage des deux CPU virtuelles si les conditions suivantes sont remplies :
<claim-text>(i) la charge de l'une des deux CPU physiques est supérieure à un premier seuil,</claim-text>
<claim-text>(ii) la charge de l'autre des deux CPU physiques est inférieure à un deuxième seuil,</claim-text>
<claim-text>(iii) la charge d'une CPU virtuelle mappée sur la CPU physique dont la charge est supérieure au dit premier seuil est supérieure à la charge d'une CPU virtuelle mappée sur la CPU physique dont la charge est inférieure au dit deuxième seuil ; et</claim-text>
<claim-text>(iv) la charge négative est supérieure à un seuil prédéterminé.</claim-text></claim-text></claim-text></claim><claim id="c-fr-01-0002" num="0002"><claim-text>Procédé selon la revendication 1, comprenant :
<claim-text>l'échange du mappage des deux CPU virtuelles en réponse à un changement de charge de l'au moins une des deux CPU physiques.</claim-text><!-- EPO <DP n="20"> --></claim-text></claim><claim id="c-fr-01-0003" num="0003"><claim-text>Procédé selon la revendication 1, comprenant :
<claim-text>l'échange du mappage uniquement si la différence de charges desdites deux CPU virtuelles est supérieure à un seuil prédéterminé.</claim-text></claim-text></claim><claim id="c-fr-01-0004" num="0004"><claim-text>Système informatique agencé pour effectuer le procédé selon l'une quelconque des revendications précédentes.</claim-text></claim><claim id="c-fr-01-0005" num="0005"><claim-text>Produit de programme informatique comprenant un code lisible par machine qui, lorsqu'il est exécuté par un dispositif de traitement de données, exécute le procédé selon l'une quelconque des revendications 1 à 3.</claim-text></claim></claims><drawings mxw-id="PDW16669213" load-source="patent-office"><!-- EPO <DP n="21"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="162" he="191" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="22"> --><figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="165" he="218" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="23"> --><figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="165" he="221" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="24"> --><figure id="f0004" num="4"><img id="if0004" file="imgf0004.tif" wi="165" he="225" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="25"> --><figure id="f0005" num="5"><img id="if0005" file="imgf0005.tif" wi="165" he="220" img-content="drawing" img-format="tif"/></figure></drawings><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
