<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-1958051-B1" country="EP" doc-number="1958051" kind="B1" date="20140101" family-id="38040311" file-reference-id="299946" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146553539" ucid="EP-1958051-B1"><document-id><country>EP</country><doc-number>1958051</doc-number><kind>B1</kind><date>20140101</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-06820057-A" is-representative="NO"><document-id mxw-id="PAPP154827462" load-source="docdb" format="epo"><country>EP</country><doc-number>06820057</doc-number><kind>A</kind><date>20061115</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140449072" ucid="FI-2006000376-W" load-source="docdb"><document-id format="epo"><country>FI</country><doc-number>2006000376</doc-number><kind>W</kind><date>20061115</date></document-id></priority-claim><priority-claim mxw-id="PPC140452083" ucid="US-27286705-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>27286705</doc-number><kind>A</kind><date>20051115</date></document-id></priority-claim></priority-claims><dates-of-public-availability><intention-to-grant-date><date>20130618</date></intention-to-grant-date><search-report-dispatch-date><date>20110822</date></search-report-dispatch-date></dates-of-public-availability><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1988107251" load-source="ipcr">G06T   1/60        20060101AFI20130502BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL1988099256" load-source="docdb" scheme="CPC">G06T   1/60        20130101 FI20130101BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132193101" lang="DE" load-source="patent-office">PUFFERVERWALTUNG IN VEKTORGRAFIK-HARDWARE</invention-title><invention-title mxw-id="PT132193102" lang="EN" load-source="patent-office">BUFFER MANAGEMENT IN VECTOR GRAPHICS HARDWARE</invention-title><invention-title mxw-id="PT132193103" lang="FR" load-source="patent-office">GESTION DE MEMOIRE TAMPON DANS UN MATERIEL DE DESSIN VECTORIEL</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR918161541" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>ADVANCED MICRO DEVICES INC</last-name><address><country>US</country></address></addressbook></applicant><applicant mxw-id="PPAR918164670" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>ADVANCED MICRO DEVICES, INC.</last-name></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR918135223" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>TUOMI MIKA</last-name><address><country>FI</country></address></addressbook></inventor><inventor mxw-id="PPAR918136069" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>TUOMI, MIKA</last-name></addressbook></inventor><inventor mxw-id="PPAR918997138" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>TUOMI, MIKA</last-name><address><street>Kissanmäentie 15</street><city>FI-29600 Noormarkku</city><country>FI</country></address></addressbook></inventor></inventors><assignees><assignee mxw-id="PPAR918997140" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Advanced Micro Devices, Inc.</last-name><iid>101174764</iid><address><street>1 AMD Place</street><city>Sunnyvale, CA 94008</city><country>US</country></address></addressbook></assignee></assignees><agents><agent mxw-id="PPAR918997139" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Maury, Richard Philip</last-name><iid>100025539</iid><address><street>Marks &amp; Clerk LLP 90 Long Acre</street><city>London WC2E 9RA</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="FI-2006000376-W"><document-id><country>FI</country><doc-number>2006000376</doc-number><kind>W</kind><date>20061115</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2007057507-A2"><document-id><country>WO</country><doc-number>2007057507</doc-number><kind>A2</kind><date>20070524</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS548829081" load-source="docdb">AT</country><country mxw-id="DS548978074" load-source="docdb">BE</country><country mxw-id="DS548978631" load-source="docdb">BG</country><country mxw-id="DS548863403" load-source="docdb">CH</country><country mxw-id="DS548973503" load-source="docdb">CY</country><country mxw-id="DS548829082" load-source="docdb">CZ</country><country mxw-id="DS548978075" load-source="docdb">DE</country><country mxw-id="DS548973504" load-source="docdb">DK</country><country mxw-id="DS548973505" load-source="docdb">EE</country><country mxw-id="DS548987854" load-source="docdb">ES</country><country mxw-id="DS548978632" load-source="docdb">FI</country><country mxw-id="DS548978633" load-source="docdb">FR</country><country mxw-id="DS548978076" load-source="docdb">GB</country><country mxw-id="DS548973506" load-source="docdb">GR</country><country mxw-id="DS548829083" load-source="docdb">HU</country><country mxw-id="DS548863404" load-source="docdb">IE</country><country mxw-id="DS548973507" load-source="docdb">IS</country><country mxw-id="DS548978634" load-source="docdb">IT</country><country mxw-id="DS548973508" load-source="docdb">LI</country><country mxw-id="DS548976269" load-source="docdb">LT</country><country mxw-id="DS548884119" load-source="docdb">LU</country><country mxw-id="DS548976274" load-source="docdb">LV</country><country mxw-id="DS548976275" load-source="docdb">MC</country><country mxw-id="DS548987855" load-source="docdb">NL</country><country mxw-id="DS548884120" load-source="docdb">PL</country><country mxw-id="DS548863405" load-source="docdb">PT</country><country mxw-id="DS548987856" load-source="docdb">RO</country><country mxw-id="DS548884121" load-source="docdb">SE</country><country mxw-id="DS548978077" load-source="docdb">SI</country><country mxw-id="DS548978635" load-source="docdb">SK</country><country mxw-id="DS548973509" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><description mxw-id="PDES63957260" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001">Field of the Invention</heading><p id="p0001" num="0001">The present invention generally relates to buffer management, and more particularly to buffer management in vector graphics hardware.</p><heading id="h0002">Discussion of the Background</heading><p id="p0002" num="0002">In recent years, vector graphics systems and algorithms have been developed for achieving robust and exact visualization, and have been employed in demanding software applications, such as in computer aided design, graphics applications, and the like. The benefit of the employing vector graphics, include scalability without the loss of graphics quality. The vector in a drawing or a plan typically includes a starting point, a direction, and a length or an ending point. Thus, a line can be represented using vector graphics with reduced information, as compared to having to indicate each pixel of the line, as with other methods. Furthermore, the vector need not be a direct line, as curves, and the like, also can be employed, and including additional information, for example, for defining a curve. The corresponding format employed during the execution of a corresponding graphical application, the file format for storing the corresponding graphical information, the fundamentals of vector graphics and the corresponding software applications employed, and the like, are well known and will not be described in detail herein.<br/>
<!-- EPO <DP n="2"> -->The Open VG 1.0 standard provides an interface for a set of functions that can be implemented by hardware and/or software drivers for rasterization, filling of polygons, and the like. In the standard, two different fill rules, a non-zero and an odd/even rule, are implemented, and are described at page 72 of the standard. The basic principle of such filling technique employs the fact that each edge of a polygon has a direction, such that when the filling procedure arrives at the edge from the left, the filling procedure detects if the edge is going up or down. If the edge is going upwards, a counter is increased, and if the edge is going downwards, the counter is decreased. The value of the counter is stored in a buffer for each pixel on the screen. However, the pixels are further divided into sub-pixels, wherein the counter values must be stored for each line of each sub-pixel, requiring even larger buffers.<br/>
The above technique presents a problem for compact hardware implementations, and the like, and which may limit the buffer size, for example, due to manufacturing considerations, cost considerations, and the like. For example, if a mobile device has a display resolution of 176x208 pixels, and each pixel is divided into 16x16 sub-pixels, and an 8-bit counter is employed for each line, a buffer of 585728 bytes is needed. However, a buffer of such size may not be practical for integration on a graphics hardware accelerator of such a mobile device. Furthermore, merely adding more memory to the graphics hardware accelerator may not be practical, for example, due to the common evolvement in manufacturing processes, a need for bigger graphics resolutions, and the like.<!-- EPO <DP n="3"> --></p><p id="p0003" num="0003">One solution is to use the main memory of the device for implementing the above-noted buffer. However, such a solution results in increased traffic on limited bandwidth buses between the graphics accelerator and the main memory.</p><p id="p0004" num="0004"><patcit id="pcit0001" dnum="WO9429812A"><text>WO94/29812A</text></patcit> discloses a processor unit for processing vector graphics primitives, the processor unit comprising counters configured to store a value indicating a current state of a fill rule for each of the sub-pixel sampling point for a pixel; a bus for receiving instructions and data; a first internal buffer configured to store at least one indicator bit value for each pixel; and determination logic configured to determine whether or not to retrieve and to retrieve the counter value from a memory based on the indicator bit values.</p><p id="p0005" num="0005"><patcit id="pcit0002" dnum="WO0180183A"><text>WO01/80183A</text></patcit> discloses bits indicating that a value has not changed. SUMMARY OF THE INVENTION</p><p id="p0006" num="0006">Therefore, there is a need for decreasing traffic on buses between a main memory, and a graphics accelerator, as described above. The above and other problems are addressed by the exemplary embodiments of the present invention, which provide an exemplary hardware implemented vector graphics solution. The exemplary embodiments can be employed with various graphical applications, including computer graphics applications, and the like, and in particular handheld device applications, low computing capacity device applications, memory limited device applications, and the like.</p><p id="p0007" num="0007">Accordingly, in exemplary embodiments of the present invention there are provided a graphics processor, a graphics processing unit, a functional block for a graphics processor, a graphics device, and the like, for processing vector graphics primitives, and the like. The exemplary embodiments can include counters for storing a value indicating a current state of a fill rule for each of a sub-pixel sampling point. The counter values are stored in a memory that can be an interval memory of the graphics processor or an external memory, for example, a conventional memory of a device. The exemplary embodiments further can include a bus for receiving instructions and primitives. If the memory is an internal memory, the bus is unidirectional, and if the memory is external, the bus is bi-directional for transmitting requests to the memory. Accordingly, the memory is used for storing the values of each of the counters.</p><p id="p0008" num="0008">The exemplary embodiments further can include a first internal buffer arranged to store at least one indicator bit value for each pixel. Typically, the internal buffer has values having a length of one or two bits. However, different bit lengths can be employed, as needed. The exemplary embodiments further can include determination logic arranged to determine whether or not to retrieve a counter value<!-- EPO <DP n="4"> --> from the memory based on the indicator bit values. The indicator bits of the first buffer include a value for indicating that a value of a counter has not changed. Furthermore, the indicator bits of the first buffer include a value for indicating that a value of a counter has to be retrieved from the memory, which can be internal or external, depending on a given implementation, as described above.<br/>
The exemplary embodiments can include a second internal buffer arranged to store limited values for each counter, and the determination logic can be further arranged to determine whether or not to retrieve the counter value from the second buffer. The indicator bits of the first buffer further can include values for indicating a range of the second buffer from which the limited value of each counter can be retrieved.<br/>
In an exemplary embodiment, polygons can be processed in tiles, wherein, advantageously, the internal memories employed need not be allocated for the whole screen, but rather a portion thereof. The tile size can be, for example, 32x32 pixels. In further exemplary embodiments such a size can be chosen depending on a given implementation, and various other hardware architectures can be employed for the internal memory, the internal buffers, and the like, as will be appreciated by those skilled in the hardware art(s).<br/>
Advantageously, the exemplary embodiments can be employed to reduce traffic in a bus between a graphics accelerator and an external main memory, by employing the internal memory in the graphics processor, and which is<!-- EPO <DP n="5"> --> faster than the external main memory that is addressed over the bus. As the exemplary embodiments include the counter information in the first or the second buffers internal to the graphics processor, advantageously, the main memory need not be addressed for every pixel, resulting in a solution that is beneficial and faster than conventional approaches to solving the above-noted problem. Furthermore, with the exemplary embodiments, the first buffer and the second buffer can be reduced in size, advantageously, allowing integration thereof in a graphics processor, and resulting in minimizing of manufacturing costs.<br/>
Still other aspects, features, and advantages of the present invention are readily apparent from the following detailed description, by illustrating a number of exemplary embodiments and implementations, including the best mode contemplated for carrying out the present invention. The present invention is also capable of other and different embodiments, and its several details can be modified in various respects, all without departing from the scope of the present invention as defined by the independent claims. Accordingly, the drawings and descriptions are to be regarded as illustrative in nature, and not as restrictive.</p><heading id="h0003"><b>BRIEF DESCRIPTION OF THE DRAWINGS</b></heading><p id="p0009" num="0009">The embodiments of the present invention are illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:
<ul><li><figref idrefs="f0001">FIG. 1</figref> illustrates an exemplary graphical device, according to the present invention; and</li><li><figref idrefs="f0002">FIG. 2</figref> illustrates a further exemplary graphical device, according to the present invention.</li></ul><!-- EPO <DP n="6"> --></p><heading id="h0004"><b>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</b></heading><p id="p0010" num="0010">Referring now to the drawings, wherein like reference numerals designate identical or corresponding parts throughout the several views, and more particularly to <figref idrefs="f0001">FIGs. 1</figref> and <figref idrefs="f0002">2</figref> thereof, there are illustrated exemplary graphical devices, according to exemplary embodiments. As will be appreciated by those skilled in the hardware art(s), the bit values and data type lengths employed in the exemplary embodiments are for exemplary purposes, and in further exemplary embodiments can be selected, for example, depending on the overall design of the corresponding graphics module, and the like. In an exemplary embodiment, the exemplary graphics module can be part of a graphics processor unit, which can be a part of a graphics card, and the like. In further exemplary embodiments, for example, such in embedded system applications, and the like, the graphics processor unit can include further functionality for producing graphics, and the like. Thus, a graphics processor unit according to further exemplary embodiments can include further functionality in addition to the functionality of the exemplary embodiments.</p><p id="p0011" num="0011">In <figref idrefs="f0001">FIG. 1</figref>, the exemplary graphical device 10 can include, for example, a mobile telephone, a video graphics card, and the like, and, thus, can include further components that need not be described with respect to the exemplary embodiments, but which can be employed for a given application. The exemplary embodiments, for example, can be implemented in a graphics processor unit 11, and the like, and which can include other functionality 15 that need not be described with respect to the exemplary embodiments, but which can be configured for a given application. The exemplary embodiments can be implemented via logic 12 (e.g., configured to determine whether or not to retrieve and to retrieve counter value from a memory based on indicator<!-- EPO <DP n="7"> --> bit values), and internal buffers 13 and 14. Furthermore, an external memory 16 connected via a bus 17 can be employed, as shown in <figref idrefs="f0001">FIG. 1</figref>. However, the external memory 16 need not be employed, for example, if the exemplary embodiments are implemented in an internal memory of a graphics processor. If the external memory 16 is employed, a bi-directional bus 17 can be provided, as shown in <figref idrefs="f0001">FIG. 1</figref>. Otherwise, a unidirectional bus can be employed. In addition, other components in the graphics processing unit 11 may employ a bi-directional bus or unidirectional bus, as needed.</p><p id="p0012" num="0012">The exemplary embodiments are based on an exemplary architecture, which can include three different memory areas that are employed for storing the information for producing a graphical image. The first memory area, which is referred to as an edge buffer 25, can include the complete information for the previously described filling operation. Each pixel includes sub-pixels that typically have a sampling point on each sub-pixel line. Thus, the allocated memory depends on the chosen resolution for each corresponding parameter. For example, for an actual screen resolution of 176x208 pixels, as is common for current mobile phone applications, and the like, each pixel is divided into 16x16 sub-pixels, with each sub-pixel line employing a corresponding 8-bit counter, resulting in a memory allocation of 585,728 bytes for the corresponding counters. The counters are used in the above-noted filling technique, and are employed because the complete information may not be available. The corresponding 585,728 bytes of memory can be configured as an internal or an external memory. However, it may not possible to manufacture such a memory as an internal memory, for example, because of manufacturing costs, and the like, and in which case an external memory can be employed and accessed with a bi-directional bus for requesting a value<!-- EPO <DP n="8"> --> for each counter value when necessary, as shown in <figref idrefs="f0001">FIG. 1</figref>.</p><p id="p0013" num="0013">The two other memories according to the exemplary embodiments include internal buffers 13 and 14, wherein the first internal buffer 13 can be configured as a type buffer 23, and the second internal buffer 14 can be configured as a limited edge buffer 24, for example, when there are no changes in filling rules for each pixel or sub-pixel. Thus, with the exemplary embodiments, advantageously, requests to the external memory can be avoided, minimized, and the like.</p><p id="p0014" num="0014">In an exemplary embodiment, the first internal buffer 13 can be configured to have a resolution of two bits for each pixel. Thus, the corresponding memory allocation employed is 176x208/4 bytes, which equals 9,152 bytes, and which is considerably less than that needed for implementing a complete edge buffer 25. The exemplary values for the type buffer 23 can include and indicate, for example:
<ul><li>00 = No information</li><li>01 = Limited edge buffer, range -1..2</li><li>10 = Limited edge buffer, range -2..1</li><li>11 = edge buffer in the external memory</li></ul></p><p id="p0015" num="0015">The exemplary values indicate from where the filling information for each pixel can be retrieved. For example, a value of 00 can indicate that there is no information available for the current pixels, which means that the state of the filling rule does not change on a current pixel. Thus, no further processing need be performed, as all of the counters have the same values as in the previous pixel. Values 01 and 10 can be used to indicate that information is stored in the second internal buffer 14, which can be a limited edge buffer 24. The significance of the corresponding ranges is<!-- EPO <DP n="9"> --> further described below with respect to the second internal buffer 14. The value 11 indicates that the counter value cannot be stored in the limited edge buffer 24, but rather can be retrieved from the complete edge buffer 25. According to the exemplary embodiments, the first internal buffer 13 is processed first. Thus, to clear the buffers, each value in the first internal buffer 13 can be set to 00. While computing the edge information, the first internal buffer 13 can be modified, for example, only when information is to be stored to the other buffers. Thus, outdated information stored into other buffers is not accessed, when the value of the type buffer 23 is set to 00.</p><p id="p0016" num="0016">As the counters are assigned for each line of sub-pixels, the second internal buffer 14 includes more information, because there are 16 counters for each pixel. In an exemplary embodiment, the information in the second internal buffer 14 also has a length of two bits, but it is assigned for each sub-pixel sampling point. Thus, each pixel has 32-bits of information, for an implementation employing a 16x16 resolution. Advantageously, a 32-bit length can be covered with a single double word. However, in further exemplary embodiments, any suitable length, for example, depending on a given application can be employed, as will be appreciated by those skilled in the hardware art(s). In the current example, the second internal buffer 14 employs 146,432 bytes, and which is considerably less than that needed for the complete information.</p><p id="p0017" num="0017">With the exemplary embodiments, as two bits of information can be employed for the values 01 and 10, four different numbers can be represented. In addition, as the information can be signed, the possibilities for the values 01 and 10 can include -1..+2, and -2..+1, respectively. The selection of such a range can be indicated in the type buffer 23, wherein in most cases, such a range is sufficient for covering the changes<!-- EPO <DP n="10"> --> within one pixel, advantageously, reducing accesses to the complete edge buffer 25. In an exemplary embodiment, the range can be different for different pixels, but within one pixel a single range can be applied. Thus, if either of the ranges is not acceptable, the type buffer 23 can be set to a value indicating that the counter value can be retrieved from the complete edge buffer 25.</p><p id="p0018" num="0018">According to the exemplary embodiments, data lengths can vary depending on a given application. However, if the type buffer 23, which is the first internal buffer 13, has a data length of one bit, such implementation need not employ the second internal buffer 14. In this case, the type buffer 23 need only indicate if the counter value has to be retrieved from an edge buffer that is stored in the external memory 16. Such implementation is possible, but is not as efficient as the implementation of the example described above. However, such implementation may be employed and may be desirable, for example, if it is not possible to provide sufficient internal memory. In addition, the memory demand for the one-bit type buffer 23 implementation is one half that of the two-bit implementation.</p><p id="p0019" num="0019">In <figref idrefs="f0002">FIG. 2</figref>, the exemplary graphics device 20 can include a graphics processing unit 21. In an exemplary embodiment, the screen can be processed in tiles, wherein, advantageously, the corresponding memory and internal buffers need not be allocated for the whole screen resolution. If the memory is an external memory, it can be allocated for the whole screen. Advantageously, with the tiled implementation, the corresponding memory can be an internal memory, due to a reduced need for memory size. Such an internal memory can be used for storing the complete edge buffer 25 for the whole tile. For example, if a 32x32 pixel tile is used, there can be employed 16,384 bytes for the complete edge buffer 25. If the type buffer 23, which is the first internal buffer 13, has 2-bit values, there can be<!-- EPO <DP n="11"> --> employed 256 bytes for the type buffer 23. If the limited edge buffer 24, which is the second internal buffer 14, is employed and has 2-bit values for each sub-pixel line, there can be employed 4,096 bytes for the limited edge buffer 24. If the limited edge buffer 24 is not employed and the type buffer 23 has 1-bit values, the type buffer 23 need only employ 128 bytes. Advantageously, the memory employed can be adjusted by choosing the tile size without losing the resolution of the values in the buffers. When the type buffer 23, the edge buffer 25, and possibly the limited edge buffer 24 are stored internal to the graphics processing unit 21, the bus 27 can be configured as a unidirectional bus. The bus 27 can configured for receiving instructions and data from other components 28, such as, CPU, main memory, and the like. The logic 22 and the other functionality 26 can function as in the exemplary embodiments of <figref idrefs="f0001">FIG. 1</figref>. In addition to tiles, in further exemplary embodiments, the screen can be divided into parts or in other ways, can by processed by scan lines, and the like, as will be appreciated by those skilled in the hardware art(s).</p><p id="p0020" num="0020">Although the exemplary embodiments are described in terms of implementation as part of a graphics processor unit, the exemplary embodiments can be implemented as a graphics block included in any suitable processor unit, and the like, as will be appreciated by those skilled in the hardware art(s). The novel aspects of the exemplary embodiments include the logic 22, the type buffer 23, and the edge buffer 25, but may further include the limited edge buffer 24, and the like. The remaining components, for example, such as the bus 27, and the like, can depend on the needs of a given host processor. Advantageously, the exemplary embodiments need not employ a bi-directional bus, even though busses typically are bi-directional in general-purpose processors, graphics processors, and the like.<!-- EPO <DP n="12"> --></p><p id="p0021" num="0021">In the tiled exemplary embodiment, the processor unit or graphics block 21 can be configured to process the screen tile by tile. Once a tile is processed, it need not be further employed and can be discarded. Advantageously, the respective tile memory can be re-used by clearing the type buffer 23. As only the data related to the currently processed tile is known, in an exemplary embodiment, appropriate rules can be employed, for example, for controlling the information related to adjacent tiles, and the like. For example, in a typical drawing process, operating from left to right, a currently processed tile can employ information from the left neighbor tile, and may pass information to the right neighbor tile.</p><p id="p0022" num="0022">In an exemplary embodiment, the processing of the complete image can be started from the left. Thus, the first case to be handled is a situation wherein a polygon is not completely in view, but rather is partially out on the left side. In this situation, the portion of the edge exceeding the left border is forced to the left border. If the whole edge is outside the leftmost tile, the complete edge can be forced to the left border of the tile. When the edge is forced to the left border, each of the counters can be changed to produce an image rendered correctly in the visible part of the polygon. Without such forcing, some of the counters would not be changed and this would cause a situation, wherein a part of the pixel would be interpreted as being within the polygon, while another part of the pixel would be interpreted as being outside the polygon. Since the fill rule works cumulatively, all of the counter values in the same horizontal line before the currently processed counter value may need to be known. Thus, the values outside the image can be computed in the left border. The leftmost border can be computed in a similar manner, even if the tiled embodiment is not employed.<!-- EPO <DP n="13"> --></p><p id="p0023" num="0023">When the first tile has been processed, the data affecting the second tile can be transferred to the second tile, in various different ways, as will be appreciated by those skilled in the hardware art(s). For example, counters can be employed for passing the values of the sub-pixel counters to the next tile. However, if an edge crosses a sub-pixel so that it is not considered to be within the pixel, the result will not be correct in the next pixel, if this is not taken into account. Thus, when the tile is not the leftmost tile, the edges also can be computed one pixel to the left from the tile currently being processed. In this case, the edges are not forced on the left border, as with the leftmost tile.</p><p id="p0024" num="0024">Similarly, the corresponding information is transferred to the next tile, until the rightmost tile is reached. In the rightmost tile, the information needs to be received from the previous tile, as previously described. However, such information need not be transferred further, as the rest of the edges are out of view. When the rightmost tile has been processed, the rendering moves to the next tile line, and starts from the leftmost tile, as described above. This process can be repeated until the rightmost tile of the last tile line has been processed. At this stage, the current polygon is considered processed, and the above processing can be repeated with the next polygon, until all of the polygons have been processed.</p><p id="p0025" num="0025">The exemplary embodiments can receive the edges from an edge feeder component, configured to send all of the edges that hit on the screen or tile, as will be appreciated by those skilled in the hardware art(s). In addition, in the case of the leftmost tile or complete screen implementation, the edges to the left of the present tile also can be sent, as will be appreciated by those skilled in the hardware art(s).</p><p id="p0026" num="0026">The exemplary embodiments can be included within any suitable device, for example, including any suitable<!-- EPO <DP n="14"> --> servers, workstations, PCs, laptop computers, PDAs, Internet appliances, handheld devices, cellular telephones, wireless devices, other devices, and the like, capable of performing the processes of the exemplary embodiments, and which can communicate via one or more interface mechanisms, including, for example, Internet access, telecommunications in any suitable form (e.g., voice, modem, and the like), wireless communications media, one or more wireless communications networks, cellular communications networks, G3 communications networks, Public Switched Telephone Network (PSTNs), Packet Data Networks (PDNs), the Internet, intranets, a combination thereof, and the like.</p><p id="p0027" num="0027">It is to be understood that the exemplary embodiments are for exemplary purposes, as many variations of the specific hardware used to implement the exemplary embodiments are possible, as will be appreciated by those skilled in the hardware art(s). For example, the functionality of one or more of the components of the exemplary embodiments can be implemented via one or more hardware devices.</p><p id="p0028" num="0028">The exemplary embodiments can store information relating to various processes described herein. This information can be stored in one or more memories, such as a hard disk, optical disk, magneto-optical disk, RAM, and the like. One or more databases can store the information used to implement the exemplary embodiments of the present inventions. The databases can be organized using data structures (e.g., records, tables, arrays, fields, graphs, trees, lists, and the like) included in one or more memories or storage devices listed herein. The processes described with respect to the exemplary embodiments can include appropriate data structures for storing data collected and/or generated by the processes of the devices and subsystems of the exemplary embodiments in one or more databases.<!-- EPO <DP n="15"> --></p><p id="p0029" num="0029">All or a portion of the exemplary embodiments can be implemented by the preparation of application-specific integrated circuits or by interconnecting an appropriate network of conventional component circuits, as will be appreciated by those skilled in the electrical art(s).</p><p id="p0030" num="0030">As stated above, the components of the exemplary embodiments can include computer readable medium or memories according to the teachings of the present inventions and for holding data structures, tables, records, and/or other data described herein. Computer readable medium can include any suitable medium that participates in providing instructions to a processor for execution. Such a medium can take many forms, including but not limited to, non-volatile media, volatile media, transmission media, and the like. Non-volatile media can include, for example, optical or magnetic disks, magneto-optical disks, and the like. Volatile media can include dynamic memories, and the like. Transmission media can include coaxial cables, copper wire, fiber optics, and the like. Transmission media also can take the form of acoustic, optical, electromagnetic waves, and the like, such as those generated during radio frequency (RF) communications, infrared (IR) data communications, and the like. Common forms of computer-readable media can include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, any other suitable magnetic medium, a CD-ROM, CDRW, DVD, any other suitable optical medium, punch cards, paper tape, optical mark sheets, any other suitable physical medium with patterns of holes or other optically recognizable indicia, a RAM, a PROM, an EPROM, a FLASH-EPROM, any other suitable memory chip or cartridge, a carrier wave or any other suitable medium from which a computer can read.</p><p id="p0031" num="0031">While the present inventions have been described in connection with a number of exemplary embodiments, and implementations, the present inventions are not so<!-- EPO <DP n="16"> --> limited, but rather cover various modifications, and equivalent arrangements, which fall within the purview of prospective claims.</p></description><claims mxw-id="PCLM56979269" lang="DE" load-source="patent-office"><!-- EPO <DP n="18"> --><claim id="c-de-01-0001" num="0001"><claim-text>Prozessoreinheit (11) zum Verarbeiten von Vektorgrafikprimitiven, wobei die Prozessoreinheit umfasst:
<claim-text>einen ersten und einen zweiten internen Puffer (13, 14);</claim-text>
<claim-text>Zähler, die im zweiten internen Puffer oder einem externen Speicher (16) gespeichert sind, konfiguriert zum Speichern eines Wertes, der einen aktuellen Zustand einer Füllregel für jeden eines Subpixel-Abtastpunkts für ein Pixel anzeigt;</claim-text>
<claim-text>wobei der erste interne Puffer (13) so konfiguriert ist, dass er zwei Indikatorbits für jedes Pixel speichert, die anzeigen, ob begrenzte Zählerwerte aus dem zweiten Puffer (14), wobei die begrenzten Zählerwerte aus einem Bereich des zweiten Puffers abgerufen werden, oder vollständige Zählerwerte aus dem externen Speicher (16) abgerufen werden sollen; und</claim-text>
<claim-text>Bestimmungslogik (12), die so konfiguriert ist, dass sie basierend auf den Indikatorbitwerten bestimmt, ob abgerufen werden soll oder nicht und der Zählerwert aus dem zweiten Puffer oder dem externen Speicher abgerufen werden soll oder nicht.</claim-text></claim-text></claim><claim id="c-de-01-0002" num="0002"><claim-text>Prozessoreinheit nach Anspruch 1, wobei die Indikatorbits des ersten internen Puffers (13) einen Wert zum Anzeigen umfassen, dass sich eine<!-- EPO <DP n="19"> --> Zustandsfüllregel bei einem aktuellen Pixel nicht ändert.</claim-text></claim><claim id="c-de-01-0003" num="0003"><claim-text>Prozessoreinheit nach Anspruch 1, wobei die Indikatorbits des ersten internen Puffers (13) Werte zum Anzeigen eines Bereichs des zweiten internen Puffers umfassen, aus welchem der begrenzte Wert jedes Zählers abgerufen wird.</claim-text></claim><claim id="c-de-01-0004" num="0004"><claim-text>Prozessoreinheit nach Anspruch 1, wobei die Indikatorbits mit einem Wert von 00 anzeigen können, dass sich der Zustand der Füllregel bei einem aktuellen Pixel nicht ändert.</claim-text></claim><claim id="c-de-01-0005" num="0005"><claim-text>Grafikverarbeitungsvorrichtung (10), umfassend eine Prozessoreinheit (11) nach einem der vorhergehenden Ansprüche und ferner umfassend eine Anzeige, einen Bus (17) zum Empfangen von Anweisungen und Daten sowie den externen Speicher (16).</claim-text></claim></claims><claims mxw-id="PCLM56979270" lang="EN" load-source="patent-office"><!-- EPO <DP n="17"> --><claim id="c-en-01-0001" num="0001"><claim-text>A processor unit (11) for processing vector graphics primitives, the processor unit comprising:
<claim-text>a first and a second internal buffer (13, 14);</claim-text>
<claim-text>counters stored in the second internal buffer or an external memory (16) configured to store a value indicating a current state of a fill rule for each of a sub-pixel sampling point for a pixel;</claim-text>
<claim-text>the first internal buffer (13) configured to store two indicator bits for each pixel that indicate whether to retrieve limited counter values from the second buffer (14), wherein the limited counter values are retrieved from a range of the second buffer, or complete counter values from the external memory (16); and</claim-text>
<claim-text>determination logic (12) configured to determine whether or not to retrieve and to retrieve the counter value from the second buffer or the external memory based on the indicator bit values.</claim-text></claim-text></claim><claim id="c-en-01-0002" num="0002"><claim-text>The processor unit of claim 1, wherein the indicator bits of the first internal buffer (13) include a value for indicating that a state filling rule does not change on a current pixel.</claim-text></claim><claim id="c-en-01-0003" num="0003"><claim-text>The processor unit of claim 1, wherein the indicator bits of the first internal buffer (13) include values for indicating a range of the second internal buffer from which the limited value of each counter is retrieved.</claim-text></claim><claim id="c-en-01-0004" num="0004"><claim-text>The processor unit of claim 1, wherein the indicator bits can indicate with a value of 00 that the state of the filling rule does not change on a current pixel.</claim-text></claim><claim id="c-en-01-0005" num="0005"><claim-text>A graphics processing device (10), comprising a processor unit (11) as claimed in any preceding claim and further comprising a display, a bus (17) for receiving instructions and data, and the external memory (16).</claim-text></claim></claims><claims mxw-id="PCLM56979271" lang="FR" load-source="patent-office"><!-- EPO <DP n="20"> --><claim id="c-fr-01-0001" num="0001"><claim-text>Unité de processeur (11) pour le traitement de primitives graphiques vectorielles, l'unité de processeur comprenant :
<claim-text>un premier et un deuxième tampons internes (13, 14) ;</claim-text>
<claim-text>des compteurs stockés dans le deuxième tampon interne ou une mémoire externe (16) conçue pour stocker une valeur indiquant l'état actuel d'une règle de remplissage pour chaque point d'échantillonnage de sous-pixel pour un pixel ;</claim-text>
<claim-text>le premier tampon interne (13) conçu pour stocker deux bits indicateurs pour chaque pixel qui indiquent si on doit extraire ou pas des valeurs limitées de compteur du deuxième tampon (14), dans lequel les valeurs limitées du compteur sont extraites d'une plage du deuxième tampon, ou des valeurs complètes de compteur de la mémoire externe (16); et</claim-text>
<claim-text>une logique de détermination (12) conçue pour déterminer si une extraction doit avoir lieu ou non et pour extraire la valeur de compteur du deuxième tampon ou de la mémoire externe en fonction des valeurs de bits indicateurs.</claim-text></claim-text></claim><claim id="c-fr-01-0002" num="0002"><claim-text>Unité de processeur selon la revendication 1, dans laquelle les bits indicateurs du premier tampon interne (13) incluent une valeur pour indiquer qu'une règle d'état de remplissage ne change pas sur un pixel actuel.</claim-text></claim><claim id="c-fr-01-0003" num="0003"><claim-text>Unité de processeur selon la revendication 1, dans laquelle les bits indicateurs du premier tampon interne (13) incluent des valeurs pour indiquer une plage du deuxième tampon interne à partir duquel la valeur limitée de chaque compteur est extraite.</claim-text></claim><claim id="c-fr-01-0004" num="0004"><claim-text>Unité de processeur selon la revendication 1, dans laquelle les bits indicateurs peuvent indiquer par une valeur de 00 que l'état de la règle de remplissage ne change pas sur un pixel actuel.</claim-text></claim><claim id="c-fr-01-0005" num="0005"><claim-text>Dispositif (10) de traitement de graphiques, comprenant une unité de processeur (11) telle que revendiquée dans n'importe laquelle des revendications précédentes et comprenant en outre un affichage, un bus (17) pour recevoir des instructions et des données, et la mémoire externe (16).</claim-text></claim></claims><drawings mxw-id="PDW16668819" load-source="patent-office"><!-- EPO <DP n="21"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="153" he="174" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="22"> --><figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="154" he="190" img-content="drawing" img-format="tif"/></figure></drawings><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
