<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-1351133-B1" country="EP" doc-number="1351133" kind="B1" date="20140101" family-id="28044685" file-reference-id="306727" date-produced="20180822" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146554325" ucid="EP-1351133-B1"><document-id><country>EP</country><doc-number>1351133</doc-number><kind>B1</kind><date>20140101</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-03251678-A" is-representative="NO"><document-id mxw-id="PAPP154828248" load-source="docdb" format="epo"><country>EP</country><doc-number>03251678</doc-number><kind>A</kind><date>20030318</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140450409" ucid="US-28339702-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>28339702</doc-number><kind>A</kind><date>20021029</date></document-id></priority-claim><priority-claim mxw-id="PPC140454601" ucid="US-36968902-P" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>36968902</doc-number><kind>P</kind><date>20020402</date></document-id></priority-claim></priority-claims><dates-of-public-availability><intention-to-grant-date><date>20130725</date></intention-to-grant-date></dates-of-public-availability><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1988101009" load-source="ipcr">G06F   9/312       20060101ALI20050831BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1988102151" load-source="ipcr">G06F   9/38        20060101ALI20050831BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1988111353" load-source="ipcr">G06F   9/30        20060101A I20051110RMEP        </classification-ipcr><classification-ipcr mxw-id="PCL1988117461" load-source="ipcr">G06F   9/318       20060101AFI20030717BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL1988101198" load-source="docdb" scheme="CPC">G06F   9/30185     20130101 LI20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1988113223" load-source="docdb" scheme="CPC">G06F   9/30189     20130101 LI20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1988127481" load-source="docdb" scheme="CPC">G06F   9/3812      20130101 FI20130101BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132195459" lang="DE" load-source="patent-office">Verhinderung der Erkennung von Speicherungen innerhalb der Befehlsfolge</invention-title><invention-title mxw-id="PT132195460" lang="EN" load-source="patent-office">Suppression of store into instruction stream detection</invention-title><invention-title mxw-id="PT132195461" lang="FR" load-source="patent-office">Suppression de la d√©tection des stockages dans l'ordre d'instructions</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR918137272" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>IP FIRST LLC</last-name><address><country>US</country></address></addressbook></applicant><applicant mxw-id="PPAR918167772" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>IP-FIRST LLC</last-name></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR918143435" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>HENRY GLENN G</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918160397" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>HENRY, GLENN G.</last-name></addressbook></inventor><inventor mxw-id="PPAR918999432" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>HENRY, GLENN G.</last-name><address><street>411 Lake Cliff Trail</street><city>Austin, Texas 78746</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918168198" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>PARKS TERRY</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918146063" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>PARKS, TERRY</last-name></addressbook></inventor><inventor mxw-id="PPAR918999430" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>PARKS, TERRY</last-name><address><street>6 Carriage House Lane</street><city>Austin, Texas 78737</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918149068" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>HOOKER RODNEY E</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918147784" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>HOOKER, RODNEY E.</last-name></addressbook></inventor><inventor mxw-id="PPAR918999431" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>HOOKER, RODNEY E.</last-name><address><street>9432 Big View Drive</street><city>Austin, Texas 78730</city><country>US</country></address></addressbook></inventor></inventors><assignees><assignee mxw-id="PPAR918999434" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>IP-First LLC</last-name><iid>100149067</iid><address><street>1045 Mission Court</street><city>Fremont, CA 94539</city><country>US</country></address></addressbook></assignee></assignees><agents><agent mxw-id="PPAR918999433" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>O'Connell, David Christopher</last-name><iid>100030418</iid><address><street>Haseltine Lake LLP Redcliff Quay 120 Redcliff Street</street><city>Bristol BS1 6HU</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS548989374" load-source="docdb">DE</country><country mxw-id="DS548989375" load-source="docdb">GB</country></ep-contracting-states></designated-states></international-convention-data></bibliographic-data><description mxw-id="PDES63957732" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p0001" num="0001">This application claims the benefit of <patcit id="pcit0001" dnum="US369689P"><text>U.S. Provisional Application No. 60/369689</text></patcit> filed on 4/2/02.</p><p id="p0002" num="0002">This application is related to the following co-pending U.S. Patent Applications, all of which have a common assignee and common inventors.
<tables id="tabl0001" num="0001"><table frame="all"><tgroup cols="4"><colspec colnum="1" colname="col1" colwidth="31mm"/><colspec colnum="2" colname="col2" colwidth="25mm"/><colspec colnum="3" colname="col3" colwidth="34mm"/><colspec colnum="4" colname="col4" colwidth="77mm"/><thead valign="top"><row><entry align="center"><u>SERIAL</u><u>NUMBER</u></entry><entry align="center"><u>FILING</u><u>DATE</u></entry><entry align="center"><u>DOCKET</u><u>NUMBER</u></entry><entry align="center"><u>TITLE</u></entry></row></thead><tbody><row><entry align="center">10/144595</entry><entry align="center">5/9/02</entry><entry align="center">CNTR.2176</entry><entry>APPARATUS AND METHOD FOR EXTENDING A MICROPROCESSOR INSTRUCTION SET</entry></row><row><entry align="center">10/144592</entry><entry align="center">5/9/02</entry><entry align="center">CNTR.2186</entry><entry>APPARATUS AND METHOD FOR CONDITIONAL INSTRUCTION EXECUTION</entry></row><row><entry align="center">10/227572</entry><entry align="center">8/22/02</entry><entry align="center">CNTR.2187</entry><entry>SUPPRESSION OF STORE CHECKING</entry></row><row><entry align="center">10/144593</entry><entry align="center">5/9/02</entry><entry align="center">CNTR.2188</entry><entry>APPARATUS AND METHOD FOR SELECTIVE CONTROL OF CONDITION CODE WRITE BACK</entry></row><row><entry align="center">10/144590</entry><entry align="center">5/9/02</entry><entry align="center">CNTR.2189</entry><entry>MECHANISM FOR EXTENDING THE NUMBER OF REGISTERS IN A MICROPROCESSOR</entry></row><row><entry align="center">10/227008</entry><entry align="center">8/22/02</entry><entry align="center">CNTR.2190</entry><entry>APPARATUS AND METHOD FOR EXTENDING DATA MODES IN A MICROPROCESSOR</entry></row><!-- EPO <DP n="2"> --><row><entry align="center">10/227571</entry><entry align="center">8/22/02</entry><entry align="center">CNTR.2191</entry><entry>APPARATUS AND METHOD FOR EXTENDING ADDRESS MODES IN A MICROPROCESSOR</entry></row><row><entry/><entry/><entry align="center">CNTR.2193</entry><entry>SELECTIVE INTERRUPT SUPPRESSION</entry></row><row><entry align="center">10/227583</entry><entry align="center">8/22/02</entry><entry align="center">CNTR.2195</entry><entry>NON-TEMPORAL MEMORY REFERENCE CONTROL MECHANISM</entry></row><row><entry align="center">10/144589</entry><entry align="center">5/9/02</entry><entry align="center">CNTR.2198</entry><entry>APPARATUS AND METHOD FOR SELECTIVE CONTROL OF RESULTS WRITE BACK</entry></row></tbody></tgroup></table></tables></p><heading id="h0002">BACKGROUND OF THE INVENTION</heading><heading id="h0003">FIELD OF THE INVENTION</heading><p id="p0003" num="0003">This invention relates in general to the field of microelectronics, and more particularly to a technique for incorporating selective suppression of store checking features at the instruction level into an existing microprocessor instruction set architecture.</p><heading id="h0004">DESCRIPTION OF THE RELATED ART</heading><p id="p0004" num="0004">Since microprocessors were fielded in the early 1970's, their use has grown exponentially. Originally applied in the scientific and technical fields, microprocessor use has moved over time from those specialty fields into commercial consumer fields that include products such as desktop and laptop computers, video game controllers, and many other common household and business devices.</p><p id="p0005" num="0005">Along with this explosive growth in use, the art has experienced a corresponding technology pull that is characterized by an escalating demand for increased speed, expanded addressing<!-- EPO <DP n="3"> --> capabilities, faster memory accesses, larger operand size, more types of general purpose operations (e.g., floating point, single-instruction multiple data (SIMD), conditional moves, etc.), and added special purpose operations (e.g., digital signal processing functions and other multi-media operations). This technology pull has resulted in an incredible number of advances in the art which have been incorporated in microprocessor designs such as extensive pipelining, super-scalar architectures, cache structures, out-of-order processing, burst access mechanisms, branch prediction, and speculative execution. Quite frankly, a present day microprocessor is an amazingly complex and capable machine in comparison to its 30-year-old predecessors.</p><p id="p0006" num="0006">But unlike many other products, there is another very important factor that has constrained, and continues to constrain, the evolution of microprocessor architecture. This factor - legacy compatibility - accounts for much of the complexity that is present in a modern microprocessor. For market-driven reasons, many producers have opted to retain all of the capabilities that are required to insure compatibility with older, so-called legacy application programs as new designs are provided which incorporate new architectural features.</p><p id="p0007" num="0007">Nowhere has this legacy compatibility burden been more noticeable than in the development history of x86-compatible microprocessors. It is well known that a present day virtual-mode, 32-/16-bit x86 microprocessor is still capable of executing<!-- EPO <DP n="4"> --> 8-bit, real-mode, application programs which were produced during the 1980's. And those skilled in the art will also acknowledge that a significant amount of corresponding architectural "baggage" is carried along in the x86 architecture for the sole purpose of retaining compatibility with legacy applications and operating modes. Yet while in the past developers have been able to incorporate newly developed architectural features into existing instruction set architectures, the means whereby use of these features is enabled - programmable instructions - have become scarce. More specifically, there are no "spare" instructions in certain instruction sets of interest that provide designers with a way to incorporate newer features into an existing architecture.</p><p id="p0008" num="0008">In the x86 instruction set architecture, for example, there are no remaining undefined 1-byte opcode states. All 256 opcode values in the primary 1-byte x86 opcode map are taken up with existing instructions. As a result, x86 microprocessor designers today must choose either to provide new features or to retain legacy compatibility. If new programmable features are to be provided, then they must be assigned to opcode values in order for programmers to exercise those features. And if spare opcode values do not remain in an existing instruction set architecture, then some of the existing opcode values must be redefined to provide for specification of the new features. Thus, legacy compatibility is sacrificed in order to make way for new feature growth.<!-- EPO <DP n="5"> --></p><p id="p0009" num="0009">There are a number of features that programmers desire in a present day microprocessor, but which have heretofore been precluded from incorporation because of the aforementioned reasons. One particular feature that is desirable for incorporation is store check suppression control at the instruction level.</p><p id="p0010" num="0010">Since virtually all microprocessors utilize multi-stage pipeline architectures, it is possible - indeed probable - that an instruction which is being fetched into the pipeline may very well be the target of a pending store operation that is proceeding through to completion in later stages of the pipeline, but which has not yet been completed. That is, the data to be stored to a destination location has not yet been written to memory (that is, external memory or internal cache). This situation can exist under many different conditions. For example, the store instruction may be proceeding through an earlier pipeline stage that is not dedicated to writing memory. Alternatively, the data may have been placed in a pending store buffer that is waiting for a convenient time to write to memory, while the store instruction was allowed to exit the pipeline. One skilled in the art will appreciate that pipeline architectures present various challenges to microprocessor designers that relate to the synchronization of instructions which are programmed for sequential execution, but which are executed in part by parallel operations in an pipeline fashion.<!-- EPO <DP n="6"> --></p><p id="p0011" num="0011">Store checking is an inherent feature of all pipeline microprocessors that is provided to insure that all instructions resident within in a microprocessor pipeline are indeed the instructions intended for execution by the application programmer. Apparatus and means are provided within these processors' pipelines to check all instructions proceeding into the pipeline against pending store events that have yet to post in memory, and furthermore to check all instructions in preceding pipeline stages against the destination addresses of store instructions when those instructions are executed. If a pending store event is detected whose destination address corresponds (corresponding generally with cache line granularity) to the location of an incoming instruction, then the pipeline is stalled and the store is allowed to post to memory. When the pipeline is stalled, the progression of instructions through the various pipeline stages is halted until the stall is removed. Following posting of the data, the incoming instruction is again fetched from its location and is allowed to proceed through the pipeline. During execution of a store instruction, if an instruction is detected in a previous pipeline stage whose location (i.e., its instruction pointer (IP)) corresponds to the destination address of the store instruction, then synchronization hardware in the microprocessor stalls the pipeline and flushes all pipeline stages above and up through the previous pipeline stage containing the detected instruction. After the store instruction writes its data, then the pipeline is refilled.<!-- EPO <DP n="7"> --></p><p id="p0012" num="0012">Store checking is an incredibly onerous task, requiring hardware that is proportional to the number of pipeline stages in a microprocessor. This is the reason why store destinations and instruction locations, as alluded to above, are typically checked only with cache line granularity. Furthermore, because of the complexities inherent in the translation of virtual to physical addresses, store checking is also generally accomplished using virtual addresses rather than physical addresses.</p><p id="p0013" num="0013">At present, a programmer has no control over store checking features in a microprocessor. If the programmer chooses to employ self-modifying code techniques, then he/she must insure that subsequent instructions which are the store targets of previous store operations are indeed desired for execution of the corresponding application program. At the source code level, this can be accomplished, although such a programming technique may not be desirable. Yet, a microprocessor does not execute source code. Automated compilers generate the instruction stream for microprocessors from the provided source code. And the resulting instruction stream may very well contain interlaced code and data within the same cache line due to alignment properties of a given compiler. Hence, even though a programmer has provided means for ensuring the coherency of self-modifying source code, pipeline synchronization events may be disadvantageously introduced as a result of code compilation.<!-- EPO <DP n="8"> --></p><p id="p0014" num="0014">A programmer, for various performance reasons, may desire to precede an instruction with a store that modifies the instruction's location, but the desired execution sequence is that the former contents of the location be executed. This is presently not possible because store checking mechanisms preclude such a sequence of execution events.</p><p id="p0015" num="0015">Therefore, what is needed is an apparatus and method that incorporate suppression of store checking features into an existing microprocessor architecture having a completely full opcode set, where incorporation of the suppression features allow a conforming microprocessor to retain the capability to execute legacy application programs while concurrently providing application programmers and/or compilers with the capability to control whether or not store checking is performed on any given instruction.</p><p id="p0016" num="0016">[0015A] <patcit id="pcit0002" dnum="EP0947919A"><text>EP0947919</text></patcit> discloses a method and apparatus for encoding an instruction in an instruction set which uses a prefix code to qualify an existing opcode of an existing instruction. An opcode and an escape code are selected. The opcode, the escape code, and the prefix code are combined to generate an instruction code which uniquely represents the operation performed by the instruction.</p><p id="p0017" num="0017">[0015B] <patcit id="pcit0003" dnum="EP0550289A"><text>EP0550289</text></patcit> discloses a pipeline computer which executes instructions in a plurality of pipeline segments where some instructions store into the instruction stream. Such instruction stream operations are detected and the pipeline is purged to avoid the use by the computer system of incorrect data.</p><heading id="h0005">SUMMARY OF THE INVENTION</heading><p id="p0018" num="0018">The present invention, among other applications, is directed to overcoming these and other problems and disadvantages of the prior art. The present invention provides a superior technique for extending a microprocessor instruction set beyond its current capabilities to provide for instruction-level store checking suppression features.</p><p id="p0019" num="0019">One aspect of the present invention contemplates a microprocessor mechanism, for extending an existing instruction set to provide for selective<!-- EPO <DP n="9"> --> suppression of store checking within a microprocessor pipeline. The microprocessor mechanism has an extended instruction and a translator. The extended instruction prescribes that store checking associated with the extended instruction be suppressed, where the extended instruction includes a selected opcode in the existing instruction set followed by an n-bit extended prefix. The selected opcode indicates the extended instruction, and the n-bit extended prefix indicates suppression of store checking. The translator receives the extended instruction, and generates a micro instruction sequence directing a microprocessor to execute a prescribed operation and to preclude store checking associated with execution of the prescribed operation.</p><p id="p0020" num="0020">(Deleted.)</p><p id="p0021" num="0021">A further aspect of the present invention provides a method for extending an existing instruction set architecture to provide for suppression of store checking at the instruction level. The method includes providing an extended instruction, the extended instruction including an extended tag along with an extended prefix, where the extended tag is a first opcode entity according to the existing instruction set architecture; prescribing, via the extended prefix, that store checking be suppressed for execution of the extended instruction, where remaining parts of the extended instruction prescribe an operation to be performed; and suppressing store checking associated with the extended instruction.</p><heading id="h0006">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p0022" num="0022">These and other objects, features, and advantages of the present invention will become better understood with regard to the following description, and accompanying drawings where:</p><p id="p0023" num="0023"><figref idrefs="f0001">FIGURE 1</figref> is a block diagram illustrating a related art microprocessor instruction format;</p><p id="p0024" num="0024"><figref idrefs="f0001">FIGURE 2</figref> is a table depicting how instructions in an instruction set architecture are mapped to logic states of bits in an 8-bit opcode byte within the instruction format of <figref idrefs="f0001">FIGURE 1</figref>;<!-- EPO <DP n="10"> --></p><p id="p0025" num="0025"><figref idrefs="f0002">FIGURE 3</figref> is a block diagram featuring an extended instruction format according to the present invention;</p><p id="p0026" num="0026"><figref idrefs="f0002">FIGURE 4</figref> Is a table showing how extended architectural features are mapped to logic states of bits in an 8-bit extended prefix embodiment according to the present invention;</p><p id="p0027" num="0027"><figref idrefs="f0003">FIGURE 5</figref> is a block diagram illustrating a pipeline microprocessor for employing selective store checking suppression control according to the present invention;<!-- EPO <DP n="11"> --></p><p id="p0028" num="0028"><figref idrefs="f0004">FIGURE 6</figref> is a block diagram featuring one embodiment of an extended prefix for prescribing that store checking be precluded in a microprocessor according to the present invention;</p><p id="p0029" num="0029"><figref idrefs="f0004">FIGURE 7</figref> is a block diagram featuring details of fetch stage logic within the microprocessor of <figref idrefs="f0003">FIGURE 5</figref>;</p><p id="p0030" num="0030"><figref idrefs="f0005">FIGURE 8</figref> is a block diagram illustrating details of translate stage logic within the microprocessor of <figref idrefs="f0003">FIGURE 5</figref>;</p><p id="p0031" num="0031"><figref idrefs="f0006">FIGURE 9</figref> is a block diagram illustrating details of execute stage logic within the microprocessor of <figref idrefs="f0003">FIGURE 5</figref>; and</p><p id="p0032" num="0032"><figref idrefs="f0007">FIGURE 10</figref> is a flow chart depicting a method for suppressing store checking associated with an instruction in a microprocessor according to the present invention.</p><heading id="h0007">DETAILED DESCRIPTION</heading><p id="p0033" num="0033">The following description is presented to enable one of ordinary skill in the art to make and use the present invention as provided within the context of a particular application and its requirements. Various modifications to the preferred embodiment will, however, be apparent to one skilled in the art, and the general principles discussed herein may be applied to other embodiments. Therefore, the present invention is not intended to be limited to the particular embodiments shown and described herein, but is to be accorded the widest scope consistent with the principles and novel features herein disclosed.<!-- EPO <DP n="12"> --></p><p id="p0034" num="0034">In view of the above background discussion on the techniques employed within present day microprocessors to extend the architectural features of those microprocessors beyond the capabilities of their associated instruction sets, a related art example will now be discussed with reference to <figref idrefs="f0001">FIGURES 1-2</figref>. The discussion highlights the instruction set limitations that microprocessor designers routinely face today. On the one hand, they desire to incorporate more recently developed architectural features into a microprocessor design and, on the other hand, market conditions dictate that they must retain the capability to execute legacy application programs. In the example of <figref idrefs="f0001">FIGURES 1-2</figref>, a completely defined opcode map rules out the possibility of defining new opcodes for the exemplary architecture. Thus, the designers are compelled to choose either to incorporate the new features and sacrifice legacy compatibility to some extent, or to forego more recent architectural advances altogether in favor of maintaining the ability to execute older application programs. Following the related art discussion, a discussion of the present invention will be provided with reference to <figref idrefs="f0002 f0003 f0004 f0005 f0006 f0007">FIGURES 3-11</figref>. By employing an existing, yet obsolete, opcode as a prefix tag for an extended instruction that follows, the present invention enables microprocessor designers to overcome the limitations of completely full instruction set architectures, thereby allowing them to provide programmers with the capability to selectively suppress store checking for an individual instruction or for groups of<!-- EPO <DP n="13"> --> instructions while concurrently retaining all the features that are required to run legacy application programs.</p><p id="p0035" num="0035">Turning to <figref idrefs="f0001">FIGURE 1</figref>, a block diagram is presented illustrating a related art microprocessor instruction format 100. The related art instruction 100 has a variable number of instruction entities 101-103, each set to a specified value, that together make up a specific instruction 100 for a microprocessor. The specific instruction 100 directs the microprocessor to perform a specific operation such as adding two operands together, or moving an operand from memory to an internal register or to memory from the internal register. In general, an opcode entity 102 within the instruction 100 prescribes the specific operation to be performed, and optional address specifier entities 103 follow the opcode 102 prescribing additional information about the specific operation such as how the operation is to be performed, where the operands are located, etc. The instruction format 100 additionally allows a programmer to prefix an opcode 102 with prefix entities 101. The prefixes 101 direct the application of specified architectural features during the execution of the specific operation prescribed by the opcode 102. Typically, these architectural features can be applied to most of the operations prescribed by any of the opcodes 102 in the instruction set. For example, prefixes 101 in many present day microprocessors direct operations to be executed using different operand sizes (e.g., 16-bit, 32-bit). Accordingly ,these processors are programmed to a default operand size (say, 32-bit), and prefixes 101 are provided<!-- EPO <DP n="14"> --> in their respective instruction sets enabling programmers to selectively override the default operand size (say, to generate 16-bit operands) on an instruction-by-instruction basis. Selectable operand size is merely one example of an architectural feature that spans a significant number of the operations (e.g., add, subtract, multiply, Boolean logic, etc.) prescribed by opcodes 102 within many present day microprocessors.</p><p id="p0036" num="0036">One well-known instance of the instruction format 100 shown in <figref idrefs="f0001">FIGURE 1</figref> is the x86 instruction format 100, which is employed by all present day x86-compatible microprocessors. More specifically, the x86 instruction format 100 (also known as the x86 instruction set architecture 100) uses 8-bit prefixes 101, 8-bit opcodes 102, and 8-bit address specifiers 103. The x86 architecture 100 has several prefixes 101 as well, two of which override default address and data sizes of an x86 microprocessor (i.e., opcode states 66H and 67H), another which directs the microprocessor to interpret a following opcode byte 102 according to alternative translation rules (i.e., prefix value 0FH, which causes translation to be performed according to the so-called 2-byte opcode rules), and other prefixes 101 which cause particular operations to be repeated until repetition criteria are satisfied (i.e., the REP opcodes: F2H and F3H).</p><p id="p0037" num="0037">Referring now to <figref idrefs="f0001">FIGURE 2</figref>, a table 200 is presented depicting how instructions 201 in an instruction set architecture are mapped to values an 8-bit opcode byte 102 within the<!-- EPO <DP n="15"> --> instruction format of <figref idrefs="f0001">FIGURE 1</figref>. The table 200 presents an exemplary 8-bit opcode map 200 that associates up to 256 values of an 8-bit opcode entity 102 with corresponding microprocessor opcode instructions 201. The table 200 maps a particular value of an opcode entity 102, say value 02H, to a corresponding instruction opcode 201 (i.e., instruction 102 201). In the particular case of the x86 opcode map, it is well known in the art that opcode value 14H is mapped to the x86 Add With Carry (ADC) instruction opcode, which directs that an 8-bit immediate operand be added to the contents of architectural register AL. One skilled in the art will also appreciate that the x86 prefixes 101 alluded to above (i.e., 66H, 67H, 0FH, F0H, F2H, and F3H) are actually opcode values 201 that contextually specify the application of certain architectural extensions to the operation prescribed by a following opcode entity 102. For example, preceding opcode 14H (normally, the ADC opcode discussed above) with prefix OFH results in an x86 processor executing an Unpack And Interleave Low Packed Single-Precision Floating-Point Values (UNPCKLPS) operation instead of the Add With Carry (ADC). Features such as described in this x86 example are enabled in part in a present day microprocessor because instruction translation logic in the microprocessor interprets the entities 101-103 of an instruction 100 in order. Hence, the use of specific opcode values as prefixes 101 in instruction set architectures has, in past times, allowed microprocessor designers to incorporate a significant number of advanced architectural features into a<!-- EPO <DP n="16"> --> complying microprocessor design without disadvantageously impacting the execution of older programs which do not employ those specific opcode states. For example, a legacy program that never uses x86 opcode 0FH will still run on a present day x86 microprocessor. And a newer application program, by employing x86 opcode 0FH as a prefix 101, can utilize a substantial number of x86 architectural features that have been more recently incorporated such as single instruction multiple data (SIMD) operations and conditional move operations.</p><p id="p0038" num="0038">The incorporation of architectural feature advances has been accomplished in the past through the designation of available (i.e. spare or unassigned) opcode values 201 as prefixes 101 (also known as architectural feature tags 101, feature indicators 101, or escape instructions 101). Yet, many instruction set architectures 100 have ceased to support the provision of enhancements for a very straightforward reason: all of the available or spare opcode values within those instruction sets 100 have been used up, that is, all of the opcode values in the opcode map 200 have been architecturally specified. When all of the available opcode values have been assigned as either opcode entities 102 or prefix entities 101, then there remain no more values to provide for the incorporation of new features. This significant problem exists in many microprocessor architectures today and consequently forces designers to choose between adding architectural features to a design and retaining compatibility with older programs.<!-- EPO <DP n="17"> --></p><p id="p0039" num="0039">It is notable that the instructions 201 shown in <figref idrefs="f0001">FIGURE 2</figref> are depicted generically (i.e., I24, I86) rather than specifically (i.e., Add With Carry, Subtract, Exclusive-OR). This is because fully occupied opcode maps 200 are presently precluding the incorporation of more recent architectural advances in a number of different microprocessor architectures. And although an 8-bit opcode entity 102 is alluded to in the example of <figref idrefs="f0001">FIGURE 2</figref>, one skilled in the art will appreciate that the specific size of the opcode 102 is irrelevant in any sense other than its use as a specific case to teach the problem of a full opcode structure 200. Accordingly, a fully populated 6-bit opcode map would exhibit 64 architecturally defined opcodes 201 and prefixes 201 and would likewise provide no spare opcode values for expansion.</p><p id="p0040" num="0040">One alternative that stops short of entirely obliterating an existing instruction set and replacing it with a new format 100 and opcode map 200 is to substitute new instruction meanings for only a small subset of existing opcodes 201 that are presently used by application programs, say opcodes 40H through 4FH like those shown in <figref idrefs="f0001">FIGURE 2</figref>. Under this hybrid technique, a conforming microprocessor operates exclusively in one of two operating modes: a legacy compatible mode, where opcodes 40H-4FH are interpreted according to legacy rules, or an enhanced mode, where opcodes 40H-4FH are interpreted according to enhanced architectural rules. This technique indeed enables designers to incorporate new features into a design, but when the conforming microprocessor is running in an enhanced mode it excludes<!-- EPO <DP n="18"> --> execution of any application program that uses opcodes 40H-4FH. Hence, from the standpoint of retaining legacy compatibility, the legacy compatible-enhanced mode technique is not an optimum choice.</p><p id="p0041" num="0041">The present inventors, however, have noted the use frequency of certain opcodes 201 in instruction sets 200 having fully populated opcode spaces over the breadth of application programs composed for execution on compliant microprocessors. They have accordingly observed that there are some opcodes 202 which, although they are architecturally defined, are not employed within application programs that are capable of being executed by the microprocessors. Instruction IF1 202 is depicted in <figref idrefs="f0001">FIGURE 2</figref> as such an example of this singularity. In fact, the very same opcode value 202 (i.e., F1H) maps to a valid instruction 202 in the x86 instruction set architecture that is not presently employed by any extant application program. While the unused x86 instruction 202 is a valid x86 instruction 202 that directs an architecturally specified operation on an x86 microprocessor, it is not employed in any application program that can be executed on any present day x86 microprocessor. The particular x86 instruction 202 is known as In Circuit Emulation Breakpoint (i.e., ICE BKPT, opcode value F1H), and was formerly employed exclusively in a class of microprocessor emulation equipment that no longer exists today. ICE BKPT 202 was never employed in an application program outside of an in-circuit emulator, and the form of in-circuit emulation equipment that formerly employed ICE BKPT 202 no<!-- EPO <DP n="19"> --> longer exists. Hence, in the x86 case, the present inventors have identified a means within a completely occupied instruction set architecture 200 whereby they can exploit a valid, yet obsolete, opcode 202 to allow for the incorporation of advanced architectural features in a microprocessor design without sacrificing legacy compatibility. In a fully-occupied instruction set architecture 200, the present invention employs an architecturally specified, yet unemployed, opcode 202 as a indicator tag for an n-bit prefix that follows, thus allowing microprocessor designers to incorporate up to 2<sup>n</sup> more recently developed architectural features into an existing microprocessor design, while concurrently retaining complete compatibility with all legacy software.</p><p id="p0042" num="0042">The present invention exploits the prefix tag/extended prefix concept by providing an n-bit extended store check suppression specifier prefix whereby programmers are enabled to prescribe that store checking be suppressed for a corresponding extended instruction from fetch of the instruction through completion of its execution. An alternative embodiment of the present invention comprehends execution of the extended instruction and a specified number of following instructions to the exclusion of store checking mechanisms in a microprocessor. The present invention will now be discussed with reference to <figref idrefs="f0002 f0003 f0004 f0005 f0006 f0007">FIGURES 3-10</figref>.<!-- EPO <DP n="20"> --></p><p id="p0043" num="0043">Turning to <figref idrefs="f0002">FIGURE 3</figref>, a block diagram is presented featuring an extended instruction format 300 according to the present invention. Very much like the format 100 discussed with reference to <figref idrefs="f0001">FIGURE 1</figref>, the extended instruction format 300 has a variable number of instruction entities 301-305, each set to a specified value, that together make up a specific instruction 300 for a microprocessor. The specific instruction 300 directs the microprocessor to perform a specific operation such as adding two operands together, or moving an operand from memory to a register within the microprocessor. Typically, an opcode entity 302 in the instruction 300 prescribes the specific operation to be performed, and optional address specifier entities 303 follow the opcode 302 prescribing additional information about the specific operation such as how the operation is to be performed, registers where the operands are located, direct and indirect data to be used in computation of memory addresses for source/result operands, etc. The instruction format 300 also allows a programmer to prefix an opcode 302 with prefix entities 301 that direct the application of existing architectural features during the execution of the specific operation prescribed by the opcode 302.</p><p id="p0044" num="0044">The extended instruction 300 according to the present invention, however, is a superset of the instruction format 100 described above with reference to <figref idrefs="f0001">FIGURE 1</figref>, having two additional entities 304, 305 which are optionally provided as an instruction extension to precede all remaining entities 301-303 in a formatted extended instruction 300. The purpose of the two additional<!-- EPO <DP n="21"> --> entities 304, 305 is to provide the capabilities for programmers to specify that store checking be suppressed, or precluded for the extended instruction 300 of which the two additional entities 304, 305 are part. The optional entities 304, 305 are an extended instruction tag 304 and an extended store check suppression prefix 305. The extended instruction tag 305 is an otherwise architecturally specified opcode within a microprocessor instruction set. In an x86 embodiment, the extended instruction tag 304, or escape tag 304, is opcode state F1H, the formerly used ICE BKPT instruction. The escape tag 304 indicates to microprocessor logic that the extended prefix 305, or extended features specifier 305, follows, where the extended prefix 305 prescribes suppression of store checking for the extended instruction 300. In one embodiment, the escape tag 304 indicates that accompanying parts 301-303, 305 of a corresponding instruction 300 prescribe an operation to be performed by the microprocessor. The store check suppression specifier 305, or extended prefix 305, specifies that the operation be performed without performing store checking for the extended instruction 300. Extended execution logic in the microprocessor executes the operation, but the operation is executed exclusive of any store checking.</p><p id="p0045" num="0045">To summarize the selective store check suppression technique according to the present invention, an extended instruction is configured to prescribe an operation to be performed according to an existing microprocessor instruction set,<!-- EPO <DP n="22"> --> where execution of the instruction is to be accomplished exclusive of store checking. The extended instruction includes one of the opcodes/instructions 304 in the existing instruction set and an n-bit extended prefix 305. The selected opcode/instruction serves as an indicator 304 that the instruction 300 is an extended features instruction 300 (that is, it prescribes extensions to the microprocessor architecture), and the n-bit features prefix 305 indicates that store checking is to be suppressed. In one embodiment, the extended prefix 305 is 8-bits in size, providing for the specification of store check suppression for the instruction and up to 255 following instructions or a combination of store check suppressions for the instructions and a group of n following instructions along with other extended features specified by remaining values of the 8-bit extended prefix 305. An n-bit prefix embodiment provides for the specification of up to 2<sup>n</sup> store check suppressions or combinations like those above.</p><p id="p0046" num="0046">Now turning to <figref idrefs="f0002">FIGURE 4</figref>, a table 400 is presented showing how store check suppression specifications are mapped to logic states of bits in an 8-bit extended prefix embodiment according to the present invention. Similar to the opcode map 200 discussed with reference to <figref idrefs="f0001">FIGURE 2</figref>, the table 400 of <figref idrefs="f0002">FIGURE 4</figref> presents an exemplary 8-bit extended prefix map 400 that associates up to 256 values of an 8-bit extended prefix entity 305 with corresponding store check suppressions of a number of instructions 401 (e.g., E34, E4D, etc.) in a conforming microprocessor. In the case of an x86 embodiment, the 8-bit<!-- EPO <DP n="23"> --> extended feature prefix 305 according to the present invention serves to provide for instruction-level control of store check suppression 401 (i.e., E00-EFF) which cannot be otherwise specified by the current x86 instruction set architecture.</p><p id="p0047" num="0047">The extended features 401 shown in <figref idrefs="f0002">FIGURE 4</figref> are depicted generically rather than specifically because the technique according to the present invention is applicable to a variety of different architectural extensions 401 and specific instruction set architectures. One skilled in the art will appreciate that many different architectural features 401, including those noted above, can be incorporated into an existing instruction set according to the escape tag 304-extended prefix 305 technique described herein. The 8-bit prefix embodiment of <figref idrefs="f0002">FIGURE 4</figref> provides for up to 256 different features 401, however, an n-bit prefix embodiment can allow for programming of up to 2<sup>n</sup> different features 401.</p><p id="p0048" num="0048">Now referring to <figref idrefs="f0003">FIGURE 5</figref>, a block diagram is presented illustrating a pipeline microprocessor 500 for performing selective store check suppression operations according to the present invention. The microprocessor 500 has three notable stage categories: fetch, translate, and execute. The fetch stage has fetch logic 501 that retrieves instructions from memory 503. The retrieved instructions are provided to extended pre-fetch logic 502. The extended pre-fetch logic 502 performs store checking on incoming instructions and is configured to detect instructions<!-- EPO <DP n="24"> --> having a store check suppression sequence of escape tag and extended prefix as described above with reference to <figref idrefs="f0002">FIGURES 3 and 4</figref>. Store checked instructions are synchronized as described above, cached in an instruction cache 504, and provided to an instruction queue 505 for access by translation logic 506. The translation logic 506 is coupled to a micro instruction queue 508. The translation logic 506 includes extended translation logic 507. The execute stage has execution logic 509 having extended execution logic 510 therein.</p><p id="p0049" num="0049">In operation, the fetch logic 501 retrieves formatted instructions according to the present invention from the memory 503, and routes these instructions through the extended pre-fetch logic 502. The pre-fetch logic 502 performs store checking and initiates synchronization of incoming instructions if they are affected by pending store events in later stages of the pipeline. If an extended instruction according to the present invention is detected, then the extended pre-fetch logic 502 allows the extended instruction to pass through to the instruction cache 504 and instruction queue 505 exclusive of store checking. Fetched instructions are provided to the instruction queue 505 in execution order. The instructions are retrieved from the instruction queue 505 and are provided to the translation logic 506. The translation logic 506 translates each of the provided instructions into a corresponding sequence of micro instructions that directs the microprocessor 500 to perform the operations prescribed by the instructions. The extended translation logic<!-- EPO <DP n="25"> --> 507 detects those instructions having an extended prefix tag according to the present invention and also provides for translation of corresponding extended store check suppression prefixes. In an x86 embodiment, the extended translation logic 507 is configured to detect an extended prefix tag of value F1H, which is the x86 ICE BKPT opcode. Extended micro instruction fields are provided in the micro instruction queue 506 to allow for the prescription store checking suppression for operations prescribed by accompanying parts of the instruction. Alternative embodiments of the extended translation logic 507 allow for prescription of store check suppression in the extended micro instruction fields for a first instruction according to the present invention and a specified number of following instructions.</p><p id="p0050" num="0050">The micro instructions are provided from the micro instruction queue 508 to the execution logic 509, wherein the extended execution logic 509 is configured to execute specified operations prescribed by micro instructions and to check the destination addresses of pending stores against the IP locations of all instructions in preceding pipeline stages. If a pending store's destination address corresponds to an IP location in a preceding stage, and the extended micro instruction field for the instruction in the preceding stage does not prescribe store checking suppression, then the extended execution logic 510 initiates a pipeline flush up through the preceding stage and allows the pending store to post. Following completion of the<!-- EPO <DP n="26"> --> store event, the pipeline is refilled. If, however, the extended micro instruction field for the instruction in the preceding stage prescribes store checking suppression, then the extended execution logic 510 precludes initiation of the pipeline flush. Thus, tagged instructions are allowed to proceed through execution without being flushed due to a store event in a following stage that would otherwise cause a pipeline synchronization flush and refill.</p><p id="p0051" num="0051">One skilled in the art will appreciate that the microprocessor 500 described with reference to <figref idrefs="f0003">FIGURE 5</figref> is a simplified representation of a present day pipeline microprocessor 500. In fact, a present day pipeline microprocessor 500 comprises upwards to 20-30 pipeline stages. However, these stages can be generally categorized into those three stage groups shown in the block diagram and thus, the block diagram 500 of <figref idrefs="f0003">FIGURE 5</figref> serves to teach the essential elements that are required to implement embodiments of the present invention as described hereinabove. Those elements of a microprocessor 500 which are extraneous to the present discussion, for clarity, are not depicted nor discussed.</p><p id="p0052" num="0052">Turning now to <figref idrefs="f0004">FIGURE 6</figref>, a block diagram is presented featuring an exemplary embodiment of an extended prefix 600 for prescribing store check suppression for a corresponding extended instruction in a microprocessor according to the present invention. The store check suppression prefix 600 is 8-bits in size and includes a suppression field 601. In one embodiment, the<!-- EPO <DP n="27"> --> suppression field 601 prescribes that store checking be precluded for the corresponding extended instruction. An alternative embodiment comprehends the suppression field specifying preclusion of store checking for the corresponding extended instruction and up to 255 following instructions. The number of instructions with checking suppressed is indicated by the suppression field.</p><p id="p0053" num="0053">Referring to <figref idrefs="f0004">FIGURE 7</figref>, a block diagram is presented illustrating details of fetch stage logic 700 within the microprocessor of <figref idrefs="f0003">FIGURE 5</figref>. The fetch stage logic 700 includes a pre-fetch buffer 704 that is coupled to memory 705. The pre-fetch buffer 704 provides pre-fetched instructions to extended pre-fetch logic 706. The extended pre-fetch logic 706 has a fetch controller 709 that is coupled to a suppress sequence detector 707 via a disable signal 708. The fetch controller 709 is also coupled to a machine specific register 702 that has an extended features field 703. The suppress sequence detector provides a control signal, SUPP, to pending store evaluation logic 710. The pending store evaluation logic 710 accesses a plurality of registers 711 containing the destination addresses of pending store events. The plurality of registers 711 is referred to in one embodiment as a lower linear instruction pointer (LIP) chain. The registers 711 are updated with the destination addresses from store buffers (e.g., write combine buffers, write back buffers, etc.) in the pipeline via bus 715. The pending store evaluation logic 710 is coupled to pipeline synchronization logic 712 via signal SMC HIT. The pipeline synchronization logic 712 provides a<!-- EPO <DP n="28"> --> control signal, STALL, to pipeline control logic (not shown). The extended pre-fetch logic 716 provides fetched instructions to a fill buffer 714, which is coupled to an instruction cache 716.</p><p id="p0054" num="0054">In operation, as cache lines are retrieved from memory 705, they are provided to the pre-fetch buffer 704. The extended pre-fetch logic 706 retrieves the contents of the cache lines and, among other functions, checks the IP address of incoming instructions against the destination addresses of pending store operations as reflected in the lower LIP chain of registers 711. If the pending store evaluation logic determines that a pre-fetched instruction's IP address corresponds to a pending store target in the registers 711, then signal SMC HIT is asserted, thus causing the pipeline synchronization logic 712 to assert signal STALL, which initiates a pipeline synchronization event. Accordingly, the pipeline is stalled until the pending store posts its data and the fetched instruction is again fetched and is allowed to proceed. If the fetched instruction's IP address does not correspond to any store target, then the extended pre-fetch logic 706 provides it to the fill buffer 714, and ultimately to the instruction cache 716.</p><p id="p0055" num="0055">The suppress sequence detector 707 also evaluates the contents of the cache lines from the pre-fetch buffer 704 to detect an escape tag/extended prefix sequence that directs suppression of store checking. If the sequence is detected, then signal SUPP is asserted, thus directing the pending store<!-- EPO <DP n="29"> --> evaluation logic 710 to preclude evaluation of the lower LIP chain registers 711 and to allow the corresponding extended instruction to proceed to the fill buffer 714.</p><p id="p0056" num="0056">During power-up of the microprocessor, the state of the extended field 703 within the machine specific register 702 is established via signal power-up state 701 to indicate whether the particular microprocessor is capable of processing extended instructions according to the present invention for suppressing store checking in the microprocessor. In one embodiment, the signal 701 is derived from a feature control register (not shown) that reads a fuse array (not shown) configured during fabrication of the part. The machine specific register 702 provides the state of the extended features field 703 to the fetch controller 709 and other logic described herein below. The fetch control logic 709 controls whether or not cache line data from the pre-fetch buffer 704 is evaluated to detect store check suppression sequences. Such a control feature is provided to allow supervisory applications (e.g., BIOS) to enable/disable extended execution features of the microprocessor. If extended features are disabled, then instructions having the opcode state selected as the extended features tag would be checked against pending store events as would any other instruction. The fetch controller 709 directs the suppress sequence detector 707 to disable extended sequence detection by asserting signal DISABLE 708.<!-- EPO <DP n="30"> --></p><p id="p0057" num="0057">Referring to <figref idrefs="f0005">FIGURE 8</figref>, a block diagram is presented featuring details of translate stage logic 800 within the microprocessor of <figref idrefs="f0003">FIGURE 5</figref>. The translate stage logic 800 has an instruction buffer 804 that provides an extended instruction to translation logic 805. The translation logic 805 is coupled to a machine specific register 802 having an extended features field 803 as described above with reference to <figref idrefs="f0004">FIGURE 7</figref>. The translation logic 805 has a translation controller 806 that provides a DISABLE signal 807 to an escape instruction detector 808 and an extended prefix translator 809. The escape instruction detector 808 is coupled to the extended translator 809 and to an instruction translator 810. The extended translation logic 809 and the instruction translation logic 810 access a control read-only memory (ROM) 811, wherein are stored template micro instruction sequences that correspond to some extended instructions. The translation logic 805 also has a micro instruction buffer 812 having an opcode extension field 813, a micro opcode field 814, a destination field 815, a source field 816, and a displacement field 817.</p><p id="p0058" num="0058">Operationally, during power-up of the microprocessor, the state of the extended field 803 within the machine specific register 802 is established via signal power-up state 801 to indicate whether the particular microprocessor is capable of translating and executing extended instructions according to the present invention as described above with reference to <figref idrefs="f0005">FIGURE 8</figref>. The machine specific register 802 provides the state of the<!-- EPO <DP n="31"> --> extended features field 803 to the translation controller 806. The translation control logic 806 controls whether or not instructions from the instruction buffer 804 are translated according to extended translation rules or according to conventional translation rules. If extended features are disabled, then instructions having the opcode state selected as the extended features tag would be translated according to the conventional translation rules. In an x86 embodiment having opcode state F1H selected as the tag, an occurrence of F1H under conventional translation would result in an illegal instruction exception. With extended translation disabled, the instruction translator 810 would translate all provided instructions 804 and would configure all fields 813-817 of the micro instruction 812. Under extended translation rules, however, occurrence of the tag would be detected by the escape instruction detector 808. The escape instruction detector 808 would direct the extended prefix translator 809 to translate the extended prefix portion of the extended instruction according to extended translation rules and to configure the opcode extension field 813, thus directing that store checking be suppressed for the micro instruction sequence corresponding to the extended instruction. The instruction translator 810 would translate to remaining parts of the extended instruction and would configure the micro opcode field 814, source field 816, destination field 815, and displacement field 817 of the micro instruction 812. Certain instructions would cause access to the control ROM 811 to obtain corresponding micro<!-- EPO <DP n="32"> --> instruction sequence templates. Configured micro instructions 812 are provided to a micro instruction queue (not shown) for subsequent execution by the processor.</p><p id="p0059" num="0059">Now referring to <figref idrefs="f0006">FIGURE 9</figref>, a block diagram is presented illustrating execute stage logic 900 within the microprocessor of <figref idrefs="f0003">FIGURE 5</figref>. The execute stage logic 900 has extended store logic 908 that is coupled to a data cache 911 and a bus unit 912. The bus unit 912 is employed to conduct memory transactions over a memory bus (not shown). From a previous stage of a microprocessor according to the present invention, the extended store logic 908 receives micro instructions from an extended micro instruction buffer 901, a data operand from data buffer 902, and a destination address operand from address buffer 903. The extended store logic 1005 includes store check logic 909 that is coupled to a plurality of linear IP registers 905, to pipeline synchronization logic 914 via signal IP HIT, and to a plurality of store buffers 910. The plurality of linear IP registers 905 are known as the upper LIP chain and each register 905 has an IP field 906 and a suppress store check field 907. The contents of the upper LIP chain 905 comprise the virtual addresses of instructions resident in preceding pipeline stages, in order, and the contents are provided to the chain 905 from the preceding pipeline stages via bus 904.</p><p id="p0060" num="0060">In operation, the extended store logic 908 is employed to write operands to cache 911 or memory via the bus unit 912 as directed by micro instructions provided in the extended micro<!-- EPO <DP n="33"> --> instruction buffer 901. For write/store operations directed by extended micro instructions, the store check logic 909 receives destination address information for the operation from the address buffer 903 along with the operand to be stored from buffer 902. The store check logic provides the address and data to the store buffers 910 while concurrently evaluating the contents of the upper LIP chain 905 to determine if there is an instruction in the pipeline whose virtual IP address 906 corresponds to the destination address of the pending store. If a corresponding virtual IP address 906 is found in the upper LIP chain 905, then the store check logic 910 evaluates the associated store check suppress field 907. If the contents of the associated field 907 indicate that store checking is to be suppressed, then the store check logic 909 allows pipeline activity to continue uninterrupted. The contents of the store buffers 910 are posted to cache 911 or memory via the bus unit 912 in accordance with memory traits prescribed for the store event as dictated by processor-specific architectural conventions. If, however, the store check logic 909 does not determine that store checking is to be suppressed for a corresponding virtual IP address 906, then signal IP HIT is asserted, signaling the pipeline synchronization logic 914 to initiate a pipeline flush/re-fill up through the stage where the corresponding virtual IP address 906 was detected. The pipeline synchronization logic 914 thus initiates the pipeline synchronization event via signal FLUSH 915. As instructions are processed, the extended micro instructions are provided to micro<!-- EPO <DP n="34"> --> instruction register 913 in synchronization with a pipeline clock (not shown).</p><p id="p0061" num="0061">To summarize significant aspects of the present invention as has been described above with reference to <figref idrefs="f0002 f0003 f0004 f0005 f0006">FIGURES 3-9</figref>, a programmable tag-prefix combination is provided for in an extended instruction by employing an architecturally defined, yet obsolete, opcode as the tag. In one embodiment, the prefix directs a conforming microprocessor to suppress store checking only for the extended instruction. In a different embodiment, the prefix directs the conforming microprocessor to suppress store checking for the extended instruction and a specified number of following instructions. When the extended instruction is fetched, extended pre-fetch logic according to the present invention detects the tag-prefix combination and allows the extended instruction to proceed into the processor's instruction cache exclusive of any store checking against pending store events. Extended translation logic indicates that store checking is to be suppressed for the instruction's corresponding micro instruction sequence via contents of opcode extension fields in extended micro instructions according to the present invention. The contents of the opcode extension fields are reflected in store check suppression fields in upper LIP chain registers so that when a store event is processed by extended store logic, synchronization events are not initiated for those extended instructions that have specified suppression of store checking.<!-- EPO <DP n="35"> --></p><p id="p0062" num="0062">Consequently, programmers and/or automated code compilation devices are provided with a mechanism for directing a conforming microprocessor to suppress store checking for single instructions or groups of instructions, thereby overcoming pipeline synchronization flushes due to interlaced code and data within the same cache line and also providing a more flexible means to implement algorithms comprising self-modifying code.</p><p id="p0063" num="0063">Now referring to <figref idrefs="f0007">FIGURE 10</figref>, a flow chart 1000 is presented depicting a method for fetching, translating, and executing instructions that enable a programmer to override store checking processes within a microprocessor at the instruction level. Flow begins at block 10023 wherein a program configured with extended feature instructions is provided to the microprocessor. Flow then proceeds to block 1004.</p><p id="p0064" num="0064">At block 1004, a next instruction is fetched for entry into the microprocessor's pipeline. Flow then proceeds to decision block 1008.</p><p id="p0065" num="0065">At decision block 1008, the instruction fetched in block 1004 is evaluated to determine if an extended escape code-extended prefix sequence is provided for the instruction. In an x86 embodiment, the evaluation is made to detect opcode value F1 (ICE BKPT) followed by a suppress store checking specifier entity. If the extended escape code and following entity are detected, then flow proceeds to block 1010. If the escape code and extended specifier are not detected, then flow proceeds to block 1006.<!-- EPO <DP n="36"> --></p><p id="p0066" num="0066">At block 1006, the instruction fetched in block 1004 is synchronized with pending store events. The targets of the pending store events are evaluated to determine if any of them correspond to the virtual address of the fetched instruction. If so, then the pipeline is stalled and the pending store events are allowed to complete. Following completion, the fetched instruction is re-fetched from memory and flow proceeds to block 1012.</p><p id="p0067" num="0067">At block 1008, an extended prefix part of the extended instruction is translated to prescribe that store checking be suppressed for a corresponding micro instruction sequence as the micro instruction sequence proceeds through the pipeline. Prescription of store check suppression is provided for by configuring an extended micro opcode field according to the present invention. Flow then proceeds to block 1012.</p><p id="p0068" num="0068">At block 1012, all remaining parts of the instruction are translated to determine a prescribed operation, register operand locations, memory address specifiers, along with the application of existing architectural features prescribed by prefixes according to the existing instruction set architecture. Flow then proceeds to block 1014.</p><p id="p0069" num="0069">At block 1014, an extended micro instruction sequence is configured to specify the prescribed operation along with its corresponding opcode extensions. Flow then proceeds to block 1016.<!-- EPO <DP n="37"> --></p><p id="p0070" num="0070">At block 1016, micro instruction sequences, including the extended micro instruction sequence configured in block 1014 are provided in execution order as they are processed by translation apparatus to a micro instruction queue for execution by the microprocessor. Flow then proceeds to decision block 1018.</p><p id="p0071" num="0071">At decision block 1018, a next micro instruction sequence is retrieved by extended execution logic according to the present invention. The extended execution logic evaluates the next micro instruction sequence to determine if a store event is specified. If not, then flow proceeds to block 1028. If so, then flow is directed to block 1020.</p><p id="p0072" num="0072">At block 1120, since a store event has bee specified, store checking logic queries an upper LIP chain according to the present invention. Flow then proceeds to decision block 1022.</p><p id="p0073" num="0073">At decision block 1022, an evaluation is made to determine if the destination address of the store event corresponds to any virtual IP addresses of instructions that follow the store event in the pipeline. If a corresponding virtual IP address is found within the LIP chain, then flow proceeds to decision block 1024. If not, then flow proceeds to block 1028.</p><p id="p0074" num="0074">At decision block 1024, a store check suppression field associated with the found virtual IP address is evaluated to determine if store checking is to be suppressed for the associated<!-- EPO <DP n="38"> --> instruction. If so, then flow proceeds to block 1028. If not, then flow proceeds to block 1026.</p><p id="p0075" num="0075">At block 1026, the extended execution logic indicates that a pipeline synchronization event is required for the associated instruction. Flow then proceeds to block 1028.</p><p id="p0076" num="0076">At block 1028, the operation prescribed by the next micro instruction sequence is executed. Flow then proceeds to block 1030</p><p id="p0077" num="0077">At block 1030, the method completes.</p><p id="p0078" num="0078">Although the present invention and its objects, features, and advantages have been described in detail, other embodiments are encompassed by the invention as well. For example, the present invention has been described in terms of a technique that employs a single, unused, opcode state within a completely full instruction set architecture as a tag to indicate that an extended feature prefix follows. But the scope of the present invention is not limited in any sense to full instruction set architectures, or unused instructions, or single tags. On the contrary the present invention comprehends instruction sets that are not entirely mapped, embodiments having used opcodes, and embodiments that employ more than one instruction tag. For example, consider an instruction set architecture where there are no unused opcode states. One embodiment of the present invention comprises selecting an opcode state that is presently used as the escape tag, where the selection criteria is determined according<!-- EPO <DP n="39"> --> to market-driven factors. An alternative embodiment comprehends employing a peculiar combination of opcodes as the tag, say back-to-back occurrences of opcode state 7FH. The essential nature of the present invention thus embodies use of a tag sequence followed by an n-bit extension prefix that allows a programmer/compiler to specify suppression of store checking for individual or groups of instructions in an existing microprocessor instruction set.</p><p id="p0079" num="0079">In addition, although a microprocessor setting has been employed to teach the present invention and its objects, features, and advantages, one skilled in the art will appreciate that its scope extends beyond the boundaries of microprocessor architecture to include all forms of programmable devices such as signal processors, industrial controllers, array processors, and the like.</p><p id="p0080" num="0080">Those skilled in the art should appreciate that they can readily use the disclosed conception and specific embodiments as a basis for designing or modifying other structures for carrying out the same purposes of the present invention, and that various changes, substitutions and alterations can be made herein without departing from the scope of the invention as defined by the appended claims.</p></description><claims mxw-id="PCLM56980685" lang="DE" load-source="patent-office"><!-- EPO <DP n="43"> --><claim id="c-de-01-0001" num="0001"><claim-text>Mikroprozessor-Mechanismus zum Erweitern eines vorhandenen Befehlsatzes, damit die gezielte Unterdr√ºckung der Speicherpr√ºfung in einer Mikroprozessor-Pipeline bereitgestellt wird, wobei der Mikroprozessor-Mechanismus umfasst:
<claim-text>einen erweiterten Befehl, der daf√ºr konfiguriert ist, vorzuschreiben, dass die dem erweiterten Befehl zugeordnete Speicherpr√ºfung unterdr√ºckt wird, wobei der erweiterte Befehl einen ausgew√§hlten Opcode in dem vorhandenen Befehlssatz umfasst, dem ein erweitertes n-Bit-Pr√§fix folgt, wobei der gew√§hlte Opcode den erweiterten Befehl anzeigt und das erweiterte n-Bit-Pr√§fix das Unterdr√ºcken der Speicherpr√ºfung anzeigt; und</claim-text>
<claim-text>einen √úbersetzer, der daf√ºr konfiguriert ist, den erweiterten Befehl zu empfangen, und daf√ºr, eine Mikrobefehlsfolge zu erzeugen, die einen Mikroprozessor anweist, eine vorgeschriebene Operation auszuf√ºhren und die Speicherpr√ºfung zu unterlassen, die mit dem Ausf√ºhren der vorgeschriebenen Operation verbunden ist.</claim-text></claim-text></claim><claim id="c-de-01-0002" num="0002"><claim-text>Mikroprozessor-Mechanismus nach Anspruch 1, wobei der erweiterte Befehl zudem umfasst:
<claim-text>verbleibenden Befehlsentit√§ten, die daf√ºr konfiguriert sind, die vorgeschriebenen Operation zu spezifizieren.</claim-text></claim-text></claim><claim id="c-de-01-0003" num="0003"><claim-text>Mikroprozessor-Mechanismus nach Anspruch 1, wobei das n-Bit-Pr√§fix umfasst:
<claim-text>ein Unterdr√ºckungsfeld, das daf√ºr konfiguriert ist, zu spezifizieren, dass die dem erweiterten Befehl zugeordnete Speicherpr√ºfung unterdr√ºckt wird.</claim-text></claim-text></claim><claim id="c-de-01-0004" num="0004"><claim-text>Mikroprozessor-Mechanismus nach Anspruch 1, wobei das n-Bit-Pr√§fix umfasst:
<claim-text>ein Unterdr√ºckungsfeld, das daf√ºr konfiguriert ist, zu spezifizieren, dass die dem erweiterten Befehl zugeordnete Speicherpr√ºfung und eine vorgeschriebene Anzahl folgender Befehle unterdr√ºckt werden.</claim-text></claim-text></claim><claim id="c-de-01-0005" num="0005"><claim-text>Mikroprozessor-Mechanismus nach Anspruch 1, wobei der gew√§hlte Opcode den Opcode ICE BKPT (d. h. Opcode F1) im x86-Mikroprozessor-Befehlsatz umfasst.</claim-text></claim><claim id="c-de-01-0006" num="0006"><claim-text>Mikroprozessor-Mechanismus nach Anspruch 1, wobei der √úbersetzer umfasst:<!-- EPO <DP n="44"> -->
<claim-text>einen Escape-Befehls-Erkenner, der den gew√§hlten Opcode innerhalb des erweiterten Befehls erkennt;</claim-text>
<claim-text>einen Befehls√ºbersetzer, der verbleibende Teile des erweiterten Befehls √ºbersetzt, um die vorgeschriebene Operation zu bestimmen; und</claim-text>
<claim-text>einen √úbersetzer f√ºr das erweiterte Pr√§fix, der mit dem Escape-Befehls-Erkenner und dem Befehls√ºbersetzer verbunden ist und das erweiterte n-Bit-Pr√§fix √ºbersetzt und der das Unterdr√ºcken der Speicherpr√ºfung innerhalb der Mikrobefehlsfolge spezifiziert.</claim-text></claim-text></claim><claim id="c-de-01-0007" num="0007"><claim-text>Mikroprozessor-Mechanismus nach Anspruch 1, ferner umfassend:
<claim-text>eine erweiterte Hollogik, die den erweiterten Befehl aus dem Speicher empf√§ngt und die den gew√§hlten Opcode und das erweiterte n-Bit-Pr√§fix erkennt, und die erlaubt, dass der erweiterte Befehl an den √úbersetzer gelangt, jedoch unter Ausschluss einer Pr√ºfung auf anh√§ngige Speichervorg√§nge, die dem Ort des erweiterten Befehls zugewiesen sind.</claim-text></claim-text></claim><claim id="c-de-01-0008" num="0008"><claim-text>Verfahren zum Erweitern einer vorhandenen Befehlsatz-Architektur, damit die Unterdr√ºckung der Speicherpr√ºfung auf der Befehlsebene bereitgestellt wird, umfassend:
<claim-text>das Bereitstellen eines erweiterten Befehls, wobei der erweiterte Befehl eine Markierung f√ºr einen erweiterten Befehl zusammen mit einem erweiterten Pr√§fix enth√§lt, und die Markierung f√ºr den erweiterten Befehl eine erste Opcode-Entit√§t gem√§√ü der vorhandenen Befehlsatz-Architektur ist;</claim-text>
<claim-text>das Vorschreiben, und zwar mit Hilfe des erweiterten Pr√§fixes, dass die Speicherpr√ºfung f√ºr die Ausf√ºhrung des erweiterten Befehls unterdr√ºckt wird, wobei verbleibende Teile des erweiterten Befehls eine Operation vorschreiben, die auszuf√ºhren ist; und</claim-text>
<claim-text>das Unterdr√ºcken der Speicherpr√ºfung, die dem erweiterten Befehl zugeordnet ist.</claim-text></claim-text></claim><claim id="c-de-01-0009" num="0009"><claim-text>Verfahren nach Anspruch 8, wobei das Vorschreiben umfasst:
<claim-text>das Verwenden einer zweiten Opcode-Entit√§t gem√§√ü der vorhandenen Befehlsatz-Architektur zum Vorschreiben der Operation.</claim-text></claim-text></claim><claim id="c-de-01-0010" num="0010"><claim-text>Verfahren nach Anspruch 8, wobei das Bereitstellen das W√§hlen des x86 ICE BKPT Opcodes (d. h. Opcode F1) als Markierung des erweiterten Befehls umfasst.<!-- EPO <DP n="45"> --></claim-text></claim><claim id="c-de-01-0011" num="0011"><claim-text>Verfahren nach Anspruch 8, ferner umfassend:
<claim-text>das √úbersetzen des erweiterten Befehls in eine Mikrobefehlsfolge, die die erweiterte Ausf√ºhrungslogik anweist, die Operation auszuf√ºhren ohne die Speicherpr√ºfung vorzunehmen.</claim-text></claim-text></claim><claim id="c-de-01-0012" num="0012"><claim-text>Verfahren nach Anspruch 11, wobei das √úbersetzen umfasst:
<claim-text>innerhalb der √úbersetzungslogik das Erkennen der Markierung des erweiterten Befehls; und</claim-text>
<claim-text>das √úbersetzen des erweiterten Pr√§fixes und der verbleibenden Teile gem√§√ü den erweiterten √úbersetzungsregeln, damit die Mikrobefehlsfolge erzeugt wird.</claim-text></claim-text></claim></claims><claims mxw-id="PCLM56980686" lang="EN" load-source="patent-office"><!-- EPO <DP n="40"> --><claim id="c-en-01-0001" num="0001"><claim-text>A microprocessor mechanism, for extending an existing instruction set to provide for selective suppression of store checking within a microprocessor pipeline, the microprocessor mechanism comprising:
<claim-text>an extended instruction, configured to prescribe that store checking associated with said extended instruction be suppressed, wherein said extended instruction comprises a selected opcode in the existing instruction set followed by an n-bit extended prefix, said selected opcode indicating said extended instruction, and said n-bit extended prefix indicating suppression of store checking; and</claim-text>
<claim-text>a translator, configured to receive said extended instruction, and configured to generate a micro instruction sequence directing a microprocessor to execute a prescribed operation, and to preclude store checking associated with execution of said prescribed operation.</claim-text></claim-text></claim><claim id="c-en-01-0002" num="0002"><claim-text>The microprocessor mechanism as recited in claim 1, wherein said extended instruction further comprises:
<claim-text>remaining instruction entities, configured to specify said prescribed operation.</claim-text></claim-text></claim><claim id="c-en-01-0003" num="0003"><claim-text>The microprocessor mechanism as recited in claim 1, wherein said n-bit prefix comprises:
<claim-text>a suppression field, configured to specify that store checking associated with said extended instruction be suppressed.</claim-text></claim-text></claim><claim id="c-en-01-0004" num="0004"><claim-text>The microprocessor mechanism as recited in claim 1, wherein said n-bit prefix comprises:
<claim-text>a suppression field, configured to specify that that store checking associated with said extended instruction and a prescribed number of following instructions be suppressed.</claim-text><!-- EPO <DP n="41"> --></claim-text></claim><claim id="c-en-01-0005" num="0005"><claim-text>The microprocessor mechanism as recited in claim 1, wherein said selected opcode comprises opcode ICE BKPT (i.e., opcode F1) in the x86 microprocessor instruction set.</claim-text></claim><claim id="c-en-01-0006" num="0006"><claim-text>The microprocessor mechanism as recited in claim 1, wherein said translator comprises:
<claim-text>an escape instruction detector, for detecting said selected opcode within said extended instruction;</claim-text>
<claim-text>an instruction translator, for translating remaining parts of said extended instruction to determine said prescribed operation; and</claim-text>
<claim-text>an extended prefix translator, coupled to said escape instruction detector and said instruction translator, for translating said n-bit extended prefix, and for specifying suppression of store checking within said micro instruction sequence.</claim-text></claim-text></claim><claim id="c-en-01-0007" num="0007"><claim-text>The microprocessor mechanism as recited in claim 1, further comprising:
<claim-text>extended fetch logic, for receiving said extended instruction from memory, for detecting said selected opcode and said n-bit extended prefix, and for allowing said extended instruction to pass to said translator exclusive of performing a check for pending store events corresponding to the location of the extended instruction.</claim-text></claim-text></claim><claim id="c-en-01-0008" num="0008"><claim-text>A method for extending an existing instruction set architecture to provide for suppression of store checking at the instruction level, the method comprising:
<claim-text>providing an extended instruction, the extended instruction including an extended instruction tag along with an extended prefix, wherein the extended instruction tag is a first opcode entity according to the existing instruction set architecture;</claim-text>
<claim-text>prescribing, via the extended prefix, that store checking be suppressed for execution of the extended instruction, wherein remaining parts of the extended instruction prescribe an operation to be performed; and</claim-text>
<claim-text>suppressing store checking associated with the extended instruction.</claim-text><!-- EPO <DP n="42"> --></claim-text></claim><claim id="c-en-01-0009" num="0009"><claim-text>The method as recited in claim 8, wherein said prescribing comprises:
<claim-text>employing a second opcode entity according to the existing instruction set architecture to prescribe the operation.</claim-text></claim-text></claim><claim id="c-en-01-0010" num="0010"><claim-text>The method as recited in claim 8, wherein said providing comprises choosing the x86 ICE BKPT opcode (i.e., opcode F1) as the extended instruction tag.</claim-text></claim><claim id="c-en-01-0011" num="0011"><claim-text>The method as recited in claim 8, further comprising:
<claim-text>translating the extended instruction into a micro instruction sequence that directs extended execution logic to execute the operation without performing store checking.</claim-text></claim-text></claim><claim id="c-en-01-0012" num="0012"><claim-text>The method as recited in claim 11, wherein said translating comprises:
<claim-text>within translation logic, detecting the extended instruction tag; and</claim-text>
<claim-text>translating the extended prefix and the remaining parts according to extended translation rules to generate the micro instruction sequence.</claim-text></claim-text></claim></claims><claims mxw-id="PCLM56980687" lang="FR" load-source="patent-office"><!-- EPO <DP n="46"> --><claim id="c-fr-01-0001" num="0001"><claim-text>M√©canisme de micro-processeur, pour √©tendre un ensemble d'instructions existant, pour r√©aliser une suppression s√©lective d'une v√©rification de stockage dans un micro-processeur √† pipeline, le m√©canisme de micro-processeur comprenant :
<claim-text>une instruction √©tendue, configur√©e pour prescrire que la v√©rification de stockage associ√©e √† ladite instruction √©tendue soit supprim√©e, o√π ladite instruction √©tendue comprend un code op√©ration s√©lectionn√© dans l'ensemble d'instructions existant suivi d'un pr√©fixe n-bit √©tendu, ledit code op√©ration s√©lectionn√© indiquant ladite instruction √©tendue, et ledit pr√©fixe n-bit √©tendu indiquant la suppression de la v√©rification de stockage ; et</claim-text>
<claim-text>un traducteur, configur√© pour recevoir ladite instruction √©tendue, et configur√© pour produire une s√©quence de micro-instructions dirigeant un micro-processeur pour ex√©cuter une op√©ration prescrite, et pour emp√™cher la v√©rification de stockage associ√©e √† l'ex√©cution de ladite op√©ration prescrite.</claim-text></claim-text></claim><claim id="c-fr-01-0002" num="0002"><claim-text>M√©canisme de micro-processeur selon la revendication 1, dans lequel ladite instruction √©tendue comprend en outre :
<claim-text>des entit√©s d'instructions restantes, configur√©es pour sp√©cifier ladite op√©ration prescrite.</claim-text></claim-text></claim><claim id="c-fr-01-0003" num="0003"><claim-text>M√©canisme de micro-processeur selon la revendication 1, dans lequel ledit pr√©fixe n-bit comprend :
<claim-text>un champ de suppression, configur√© pour sp√©cifier que la v√©rification de stockage, associ√©e √† ladite instruction √©tendue, soit supprim√©e.</claim-text></claim-text></claim><claim id="c-fr-01-0004" num="0004"><claim-text>M√©canisme de micro-processeur selon la revendication 1, dans lequel ledit pr√©fixe n-bit comprend :<!-- EPO <DP n="47"> -->
<claim-text>un champ de suppression, configur√© pour sp√©cifier que la v√©rification de stockage associ√©e √† ladite instruction √©tendue et un nombre prescrit d'instructions suivantes sont supprim√©es.</claim-text></claim-text></claim><claim id="c-fr-01-0005" num="0005"><claim-text>M√©canisme de micro-processeur selon la revendication 1, dans lequel ledit code op√©ration s√©lectionn√© comprend le code op√©ration ICE BKPT (i.e. code op√©ration F1) dans l'ensemble d'instructions de micro-processeur x86.</claim-text></claim><claim id="c-fr-01-0006" num="0006"><claim-text>M√©canisme de micro-processeur selon la revendication 1, dans lequel ledit traducteur comprend :
<claim-text>un d√©tecteur d'instruction d'√©chappement, pour d√©tecter ledit code op√©ration dans ladite instruction √©tendue ;</claim-text>
<claim-text>un traducteur d'instruction, pour traduire des parties restantes de ladite instruction √©tendue pour d√©terminer ladite op√©ration prescrite ; et</claim-text>
<claim-text>un traducteur de pr√©fixe √©tendu, coupl√© audit d√©tecteur d'instruction d'√©chappement et audit traduction d'instruction, pour traduire ledit pr√©fixe n-bit √©tendu, et pour sp√©cifier la suppression de la v√©rification de stockage dans ladite s√©quence de micro-instructions.</claim-text></claim-text></claim><claim id="c-fr-01-0007" num="0007"><claim-text>M√©canisme de micro-processeur selon la revendication 1, comprenant en outre :
<claim-text>une logique d'extraction √©tendue, pour recevoir ladite instruction √©tendue de la m√©moire, pour d√©tecter ledit code op√©ration s√©lectionn√© et ledit pr√©fixe n-bit √©tendu, et pour permettre √† ladite instruction √©tendue de passer audit traducteur excluant l'ex√©cution d'une v√©rification d'√©v√®nements de stockage pendants correspondant √† l'emplacement de l'instruction √©tendue.</claim-text></claim-text></claim><claim id="c-fr-01-0008" num="0008"><claim-text>Proc√©d√© d'extension d'une architecture d'ensemble d'instructions existante pour la r√©alisation de la<!-- EPO <DP n="48"> --> suppression de la v√©rification de stockage au niveau de l'instruction, le proc√©d√© comprenant :
<claim-text>r√©aliser une instruction √©tendue, l'instruction √©tendue incluant un marqueur d'instruction √©tendu conjointement avec un pr√©fixe √©tendu, o√π le marqueur d'instruction √©tendu est une premi√®re entit√© de code op√©ration en accord avec l'architecture de l'ensemble d'instructions existante ;</claim-text>
<claim-text>prescrire, via le pr√©fixe √©tendu, que la v√©rification de stockage soit supprim√©e pour l'ex√©cution de l'instruction √©tendue, o√π des parties restantes de l'instruction √©tendue prescrivent une op√©ration √† ex√©cuter ; et</claim-text>
<claim-text>supprimer la v√©rification de stockage associ√©e √† l'instruction √©tendue.</claim-text></claim-text></claim><claim id="c-fr-01-0009" num="0009"><claim-text>Proc√©d√© selon la revendication 8, dans lequel ladite prescription comprend :
<claim-text>utiliser une deuxi√®me entit√© de code op√©ration en accord avec l'architecture de l'ensemble d'instructions existante pour prescrire l'op√©ration.</claim-text></claim-text></claim><claim id="c-fr-01-0010" num="0010"><claim-text>Proc√©d√© selon la revendication 8, dans lequel ladite r√©alisation comprend la s√©lection du code op√©ration x86 ICE BKPT (i.e. code op√©ration F1) comme marqueur d'instruction √©tendue.</claim-text></claim><claim id="c-fr-01-0011" num="0011"><claim-text>Proc√©d√© selon la revendication 8, comprenant en outre :
<claim-text>traduire l'instruction √©tendue en une s√©quence de micro-instructions qui dirige la logique d'ex√©cution √©tendue afin d'ex√©cuter l'op√©ration sans ex√©cuter de v√©rification de stockage.</claim-text></claim-text></claim><claim id="c-fr-01-0012" num="0012"><claim-text>Proc√©d√© selon la revendication 11, dans lequel ladite traduction comprend :<!-- EPO <DP n="49"> -->
<claim-text>dans la logique de traduction, d√©tecter le marqueur d'instruction √©tendue ; et</claim-text>
<claim-text>traduire le pr√©fix √©tendu et les parties restantes en accord avec des r√®gles de traduction √©tendues pour produire la s√©quence des micro-instructions.</claim-text></claim-text></claim></claims><drawings mxw-id="PDW16669234" load-source="patent-office"><!-- EPO <DP n="50"> --><figure id="f0001" num="1,2"><img id="if0001" file="imgf0001.tif" wi="165" he="203" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="51"> --><figure id="f0002" num="3,4"><img id="if0002" file="imgf0002.tif" wi="165" he="183" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="52"> --><figure id="f0003" num="5"><img id="if0003" file="imgf0003.tif" wi="165" he="209" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="53"> --><figure id="f0004" num="6,7"><img id="if0004" file="imgf0004.tif" wi="165" he="215" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="54"> --><figure id="f0005" num="8"><img id="if0005" file="imgf0005.tif" wi="165" he="167" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="55"> --><figure id="f0006" num="9"><img id="if0006" file="imgf0006.tif" wi="165" he="158" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="56"> --><figure id="f0007" num="10"><img id="if0007" file="imgf0007.tif" wi="165" he="203" img-content="drawing" img-format="tif"/></figure></drawings><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
