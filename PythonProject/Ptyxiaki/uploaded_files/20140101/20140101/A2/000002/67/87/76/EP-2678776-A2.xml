<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2678776-A2" country="EP" doc-number="2678776" kind="A2" date="20140101" family-id="46653644" file-reference-id="311895" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146551293" ucid="EP-2678776-A2"><document-id><country>EP</country><doc-number>2678776</doc-number><kind>A2</kind><date>20140101</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-12750056-A" is-representative="NO"><document-id mxw-id="PAPP154825216" load-source="docdb" format="epo"><country>EP</country><doc-number>12750056</doc-number><kind>A</kind><date>20120222</date><lang>EN</lang></document-id><document-id mxw-id="PAPP168045653" load-source="docdb" format="original"><country>EP</country><doc-number>12750056.9</doc-number><date>20120222</date></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140447072" ucid="US-201113031747-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201113031747</doc-number><kind>A</kind><date>20110222</date></document-id></priority-claim><priority-claim mxw-id="PPC140454262" ucid="US-2012026125-W" linkage-type="W" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>2012026125</doc-number><kind>W</kind><date>20120222</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-2085585795" load-source="docdb">G06F  15/16        20060101ALI20150311BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-2085585796" load-source="docdb">G06F  12/08        20060101ALI20150311BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-2085585797" load-source="docdb">G06F   9/445       20060101ALI20150311BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-2085585798" load-source="docdb">G06F   9/44        20060101AFI20150311BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-2085585799" load-source="docdb">G06F   9/30        20060101ALI20150311BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1687189694" load-source="docdb" scheme="CPC">G06F   9/4484      20180201 LI20180219BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987051406" load-source="docdb" scheme="CPC">G06F   9/44594     20130101 LI20151230BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987053807" load-source="docdb" scheme="CPC">G06F   9/44573     20130101 FI20151230BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987054489" load-source="docdb" scheme="CPC">G06F   9/44526     20130101 LI20151230BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987063622" load-source="docdb" scheme="CPC">G06F   9/44584     20130101 LI20151230BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132186363" lang="DE" load-source="patent-office">AUSLIEFERUNGS- UND STARTSYSTEM FÜR EINE SOFTWAREANWENDUNG</invention-title><invention-title mxw-id="PT132186364" lang="EN" load-source="patent-office">SOFTWARE APPLICATION DELIVERY AND LAUNCHING SYSTEM</invention-title><invention-title mxw-id="PT132186365" lang="FR" load-source="patent-office">SYSTÈME DE LANCEMENT ET DE DIFFUSION D'APPLICATION LOGICIELLE</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR918158714" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>URBACH JULIAN MICHAEL</last-name><address><country>US</country></address></addressbook></applicant><applicant mxw-id="PPAR918142213" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>URBACH, JULIAN MICHAEL</last-name></addressbook></applicant><applicant mxw-id="PPAR918986919" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Urbach, Julian Michael</last-name><iid>101406109</iid><address><street>1010 Wilshire Boulevard, No 1604</street><city>Los Angeles, CA 90017</city><country>US</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR918150189" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>URBACH JULIAN MICHAEL</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918142375" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>URBACH, JULIAN MICHAEL</last-name></addressbook></inventor><inventor mxw-id="PPAR918991529" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>URBACH, JULIAN MICHAEL</last-name><address><street>1010 Wilshire Boulevard, No 1604</street><city>Los Angeles, CA 90017</city><country>US</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR918984603" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Boult Wade Tennant</last-name><iid>101370347</iid><address><street>Verulam Gardens 70 Gray's Inn Road</street><city>London WC1X 8BT</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="US-2012026125-W"><document-id><country>US</country><doc-number>2012026125</doc-number><kind>W</kind><date>20120222</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2012116068-A2"><document-id><country>WO</country><doc-number>2012116068</doc-number><kind>A2</kind><date>20120830</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS548816165" load-source="docdb">AL</country><country mxw-id="DS548927230" load-source="docdb">AT</country><country mxw-id="DS548816166" load-source="docdb">BE</country><country mxw-id="DS548929592" load-source="docdb">BG</country><country mxw-id="DS548865787" load-source="docdb">CH</country><country mxw-id="DS548934867" load-source="docdb">CY</country><country mxw-id="DS548927231" load-source="docdb">CZ</country><country mxw-id="DS548914216" load-source="docdb">DE</country><country mxw-id="DS548816167" load-source="docdb">DK</country><country mxw-id="DS548934868" load-source="docdb">EE</country><country mxw-id="DS548930895" load-source="docdb">ES</country><country mxw-id="DS548929593" load-source="docdb">FI</country><country mxw-id="DS548929598" load-source="docdb">FR</country><country mxw-id="DS548914217" load-source="docdb">GB</country><country mxw-id="DS548816168" load-source="docdb">GR</country><country mxw-id="DS548816169" load-source="docdb">HR</country><country mxw-id="DS548934869" load-source="docdb">HU</country><country mxw-id="DS548865788" load-source="docdb">IE</country><country mxw-id="DS548816170" load-source="docdb">IS</country><country mxw-id="DS548929599" load-source="docdb">IT</country><country mxw-id="DS548934870" load-source="docdb">LI</country><country mxw-id="DS548914222" load-source="docdb">LT</country><country mxw-id="DS548927232" load-source="docdb">LU</country><country mxw-id="DS548914223" load-source="docdb">LV</country><country mxw-id="DS548914224" load-source="docdb">MC</country><country mxw-id="DS548927233" load-source="docdb">MK</country><country mxw-id="DS548837581" load-source="docdb">MT</country><country mxw-id="DS548930896" load-source="docdb">NL</country><country mxw-id="DS548837582" load-source="docdb">NO</country><country mxw-id="DS548930897" load-source="docdb">PL</country><country mxw-id="DS548929600" load-source="docdb">PT</country><country mxw-id="DS548930902" load-source="docdb">RO</country><country mxw-id="DS548929601" load-source="docdb">RS</country><country mxw-id="DS548930903" load-source="docdb">SE</country><country mxw-id="DS548865789" load-source="docdb">SI</country><country mxw-id="DS548837583" load-source="docdb">SK</country><country mxw-id="DS548837584" load-source="docdb">SM</country><country mxw-id="DS548927234" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><abstract mxw-id="PA99618898" ref-ucid="WO-2012116068-A2" lang="EN" load-source="patent-office"><p num="0000">One embodiment allocates a first virtual memory; receives executable code of a first piece of software; writes the executable code of the first piece of software directly into the first virtual memory; marks the first virtual memory as executable; executes the executable code of the first piece of software directly from the first virtual memory; and downloads and executes executable code of a second piece of software as facilitated by the executable code of the first piece of software.</p></abstract><abstract mxw-id="PA99818583" ref-ucid="WO-2012116068-A2" lang="EN" source="national office" load-source="docdb"><p>One embodiment allocates a first virtual memory; receives executable code of a first piece of software; writes the executable code of the first piece of software directly into the first virtual memory; marks the first virtual memory as executable; executes the executable code of the first piece of software directly from the first virtual memory; and downloads and executes executable code of a second piece of software as facilitated by the executable code of the first piece of software.</p></abstract><abstract mxw-id="PA99618899" ref-ucid="WO-2012116068-A2" lang="FR" load-source="patent-office"><p num="0000">L'invention concerne un mode de réalisation qui attribue une première mémoire virtuelle ; reçoit un code exécutable d'un premier logiciel ; écrit le code exécutable du premier logiciel directement dans la première mémoire virtuelle ; marque la première mémoire virtuelle comme exécutable ; exécute le code exécutable du premier logiciel directement depuis la première mémoire virtuelle ; et télécharge et exécute le code exécutable d'un second logiciel facilité par le code exécutable du premier logiciel.</p></abstract><abstract mxw-id="PA99818584" ref-ucid="WO-2012116068-A2" lang="FR" source="national office" load-source="docdb"><p>L'invention concerne un mode de réalisation qui attribue une première mémoire virtuelle ; reçoit un code exécutable d'un premier logiciel ; écrit le code exécutable du premier logiciel directement dans la première mémoire virtuelle ; marque la première mémoire virtuelle comme exécutable ; exécute le code exécutable du premier logiciel directement depuis la première mémoire virtuelle ; et télécharge et exécute le code exécutable d'un second logiciel facilité par le code exécutable du premier logiciel.</p></abstract><description mxw-id="PDES50929995" ref-ucid="WO-2012116068-A2" lang="EN" load-source="patent-office"><!-- EPO <DP n="2"/>--><p id="p0001" num="0001"> SOFTWARE APPLICATION DELIVERY AND LAUNCHING SYSTEM </p><p id="p0002" num="0002">TECHNICAL FIELD </p><p id="p0003" num="0003"> The present disclosure generally relates to the distribution of computer software over a computer network and more specifically relates to deploying computer software over a computer network from a server to a client for execution on the client without installing any portion of the software on the client. </p><p id="p0004" num="0004">BACKGROUND </p><p id="p0005" num="0005"> Computer software may be distributed to individual computer systems in various ways. For example, a piece of software may be stored on a Compact Disc (CD) or a Digital Versatile Disc (DVD). A person may put such a disc in a disc drive of a computer system to install the piece of software stored on the disc onto the computer system. More recently, computer networks provide another channel for software distribution. A person may download a piece of software from a remote computer system (e.g., a server) over a computer network (e.g., the Internet) onto his own computer system (e.g., a client). Often, the file downloaded over the network may be an installation suite, script, or executable in which the piece of software is embedded. The person may save the downloaded file on the hard drive of his computer system, either at a permanent location or in a temporary directory, and run the saved file to install the piece of software on his computer system. </p><p id="p0006" num="0006">SUMMARY </p><p id="p0007" num="0007"> The present disclosure generally relates to the distribution of computer software over a computer network and more specifically relates to deploying computer software over a computer network from a server to a client for execution on the client without installing any portion of the software on the client. </p><p id="p0008" num="0008"> Particular embodiments allocate a first virtual memory; receive executable code of a first piece of software; write the executable code of the first piece of software directly into the first virtual memory; mark the first virtual memory as executable; execute the executable code of the first piece of software directly from the first virtual memory; and download and execute executable code of a second piece of software as facilitated by the 
<!-- EPO <DP n="3"/>-->
 executable code of the first piece of software. </p><p id="p0009" num="0009"> These and other features, aspects, and advantages of the disclosure are described in more detail below in the detailed description and in conjunction with the following figures. </p><p id="p0010" num="0010">BRIEF DESCRIPTION OF THE DRAWINGS</p><p id="p0011" num="0011">FIGURE 1 illustrates an example method of deploying a piece of computer software from a server to a client for execution on the client without installing any portion of the software on the client. </p><p id="p0012" num="0012"> FIGURE 2 illustrates an example method of streaming a piece of computer software from a server to a client for execution on the client. </p><p id="p0013" num="0013"> FIGURE 3 illustrates an example network environment. </p><p id="p0014" num="0014"> FIGURE 4 illustrates an example computer system. DETAILED DESCRIPTION OF EXAMPLE EMBODIMENTS </p><p id="p0015" num="0015"> The present disclosure is now described in detail with reference to a few embodiments thereof as illustrated in the accompanying drawings. In the following description, numerous specific details are set forth in order to provide a thorough understanding of the present disclosure. It is apparent, however, to one skilled in the art, that the present disclosure may be practiced without some or all of these specific details. In other instances, well known process steps and/or structures have not been described in detail in order not to unnecessarily obscure the present disclosure. In addition, while the disclosure is described in conjunction with the particular embodiments, it should be understood that this description is not intended to limit the disclosure to the described embodiments. To the contrary, the description is intended to cover alternatives, modifications, and equivalents as may be included within the spirit and scope of the disclosure as defined by the appended claims. </p><p id="p0016" num="0016"> Computer software may be distributed from one computer system (e.g., a server) to another computer system (e.g., a client) over a computer network (e.g., the Internet). In fact, an increasing number of software developers, manufactures, and distributors consider computer networks as a convenient, fast, and cost-effective channel for software distribution. For example, a person often is able to download the latest version of a piece 
<!-- EPO <DP n="4"/>-->
 of computer software developed by a company from that company's website. In a typical scenario, the person may load a web page that contains the download link to the piece of software in a web browser executed on his computer system, and then click the download link provided in the web page. This usually causes a file to be downloaded to the person's computer system. The file may be an installation script or executable or the executable code of the software itself. The person may save the file on the hard drive of his computer system. If the file is an installation script or executable, the person may run the downloaded file to install the software onto his computer system. On the other hand, if the file is the executable code of the software, the person may run the software directly (e.g., by double clicking on the executable file). </p><p id="p0017" num="0017"> Having to save or install the software programs downloaded over the computer networks onto the hard drive of a computer system in order to execute the programs may be inconvenient or cumbersome at times. For example, first, saving downloaded files to a hard drive and installing software onto a computer system often take time. Furthermore, if a piece of software is large in size (e.g., Adobe® PDF Reader®), the installation process may take a significant amount of time. The user of the computer system may have to go through several steps (e.g., installation, setup, etc.) before he can execute the downloaded software. Second, saving files to a hard drive and installing software onto a computer system use up storage capacity (e.g., hard drive space) of the computer system. Sometimes, a computer system (e.g., a netbook or notebook computer) may not have sufficient storage space for all of the software its user wishes to install onto the computer system. Third, software developers may update their software and release newer versions of the software from time to time. The newer versions of a piece of software usually are of a better quality than the older versions. Thus, people may wish to keep their software relatively up-to-date. However, to update a piece of software, a person often needs to uninstall the older version of the software currently installed on his computer system and then download and install the newer version. In addition, some software developers may want to deliver software -based application services to users that do not require such installations as they would like to avoid having any downloaded code remain on permanent data storage devices after the initial, or any subsequent, use. </p><p id="p0018" num="0018"> To address some of these issues, particular embodiments enable a user of one computer system (e.g., a client) to download computer software programs from another 
<!-- EPO <DP n="5"/>-->
 computer system (e.g., a server) over a computer network (e.g., the Internet) for execution on the user's computer system without having to store or install the software programs or any other types of software onto any permanent storage (e.g., the hard drive) of the user's computer system. In other words, the user may download a piece of software onto his computer system and execute that piece of software on his computer system. After the execution of the software is completed (e.g., after the user exits the software), there is no trace of the software or any other related software left on the user's computer system. </p><p id="p0019" num="0019"> For purpose of clarification, hereafter, the computer system to which the software is downloaded and on which the software is executed is referred to as the "client", and the computer system from which the software is downloaded is referred to as the "server". However, one skilled in the art may appreciate that the embodiments described in more detail below may be suitably applied to any two computer systems (e.g., two servers, two clients, or a server and a client). In addition, the piece of software downloaded from the server to the client and executed on the client (i.e., the software that a person wants to use) is referred as the target software. </p><p id="p0020" num="0020"> In particular embodiments, another piece of software, hereafter referred to as the "stub software" or simply a "stub", may facilitate the downloading and the execution of the target software. In particular embodiments, the stub may be implemented using any suitable programming language and compiled as computer executable code. In particular embodiments, the executable code of the stub may be stored on the server and downloaded to the client for execution using a client-side script written in any suitable programming language, such as, for example and without limitation, Java, JavaScript, Python, etc., which may be executed in a web browser. For example, the client-side script may be included in a web page as a clickable link. To access the client-side script, a user may load the web page containing the client-side script in a web browser (e.g., Microsoft Internet Explorer, Mozilla Firefox, or Google Chrome) residing on the client and then click the link to the client-side script provided in the web page. This causes the client-side script code to be transmitted to the web browser for execution by the web browser. </p><p id="p0021" num="0021"> FIGURE 1 illustrates an example method of deploying a target software from a server to a client for execution on the client through the use of a stub. In particular embodiments, once the client-side script is executed in a web browser, the script accesses 
<!-- EPO <DP n="6"/>-->
 a foreign function library residing on the client, as illustrated in STEP 100. Many programming languages provide foreign function interfaces. A foreign function interface is a mechanism by which a software program written in one programming language can invoke routines or make use of services written in another programming language (e.g., functions provided by an operating system or software library). Typically, the functions implementing the foreign function interface of a programming language are included in a foreign function library provided by that programming language. For example, Python provides a foreign function library called the "ctypes package"; Java provides Java Native Interface and Java Native Access that enable Java programs to access native shared libraries; and JavaScript provides JavaScript Native Interface (JSNI), also called JavaScript Foreign Function Interface (JSFFI). Some web browsers (e.g., Mozilla Firefox) also support native or foreign function access for code executing in these web browsers. </p><p id="p0022" num="0022"> Depending on the specific programming language in which the script code is written, the script may invoke the corresponding foreign function library of that programming language. For example, with Python, there is a function called "load_l ibrary" that may be used to load a specific library. Microsoft Windows provides a function called "LoadLibrary" for loading a specified module into the address space of the calling process. </p><p id="p0023" num="0023"> In particular embodiments, through the appropriate foreign function interface, the script may obtain a pointer to a memory allocation function residing on the client, as illustrated in STEP 102. The specific memory allocation function available on the client may depend on the operating system of the client or the software libraries available on the client. For example, Microsoft Windows provides a function called "VirtualAl loc" for reserving or committing a region of pages in the virtual address space of the calling process. C and C++ programming languages both provide a library function called "mal loc" for performing dynamic memory allocation of a specified size. </p><p id="p0024" num="0024"> In particular embodiments, using the memory allocation function (e.g., "VirtualAl loc"), the script may allocate a specific amount of memory, as illustrated in STEP 104. The allocated memory should be sufficient for the executable code of the stub. In particular embodiments, the executable code of the stub may be downloaded from the server and written into the allocated memory, as illustrated in STEP 106. In 
<!-- EPO <DP n="7"/>-->
 particular embodiments, the stub may require some library functions contained in various shared libraries. For example, with Microsoft Windows, the share libraries are called dynamic-link libraries (DLLs). The shared libraries containing the functions needed by the stub may be loaded using an appropriate library loading function (e.g., "LoadLibrary" or "load_library"). </p><p id="p0025" num="0025"> In particular embodiments, the memory in which the executable code of the stub is written is marked as executable memory. For example, Microsoft Windows provides a mechanism called data execution prevention (DEP), which is a set of hardware and software technologies that perform additional checks on memory to help protect against malicious code exploits. Briefly, all memory locations in a process are marked as nonexecutable unless the location explicitly contains executable code. Thus, the memory locations where the executable code of the stub are written need to be marked as executable in order for the stub code to be executed. With Microsoft Windows, specific memory locations may be marked as executable by setting an appropriate flag or attribute (e.g., marking the allocated memory as "PAGE_EXECUTE", "PAGE_EXECUTE_READ", "PAGE_EXECUTE_READWRI E", or "PAGE_EXECUTE_WRI ECOPY"). </p><p id="p0026" num="0026"> In particular embodiments, the script may obtain a pointer to the executable code of the stub in the allocated memory, as illustrated in STEP 110. In particular embodiments, the executable code of the stub may be launched directly from memory, as illustrated in STEP 112. In particular embodiments, the stub may facilitate the download and execution of the target software on the client, as illustrated in STEP 114. This process is described in more detail below in connection with FIGURE 2. </p><p id="p0027" num="0027"> In particular embodiments, after the stub completes its tasks (i.e., facilitating the download and execution of the target software on the client), the script may obtain a pointer to a memory de-allocation function residing on the client, again through the appropriate foreign function interface, as illustrated in STEP 116. The specific memory de-allocation function available on the client may depend on the operating system of the client or the software libraries available on the client. For example, Microsoft Windows provides a function called "VirtualFree" for releasing, de-committing, or releasing and de-committing a region of pages within the virtual address space of the calling process. C and C++ programming languages both provide library functions such as "dealloc" and "free" for freeing up (i.e., de-allocating) allocated dynamic memory. 
<!-- EPO <DP n="8"/>-->
 In particular embodiments, using the memory de-allocation function (e.g., "Vi rtual Free"), the script may de-allocate the memory in which the executable code of the stub is written, as illustrated in STEP 118. Subsequently, this memory space may be used for other purposes and other data may be loaded into the same memory space, overriding the executable code of the stub. Thus, after the memory locations where the executable code of the stub is written are freed (i.e., de-allocated), the executable code of the stub is gone (e.g., replaced or removed) from the client. There is no trace of the executable code of the stub left on the client, as the stub is not saved in or installed on any permanent storage (e.g., the hard drive) of the client. </p><p id="p0028" num="0028"> In particular embodiments, instead of explicitly de-allocating the memory locations where the executable code of the stub is written, the memory locations may be freed up implicitly. For example, if the user exists the web browser or leaves the web page containing the client-side script, all memory locations involved with the script are freed up, which means the memory locations where the executable code of the stub is written are also freed up. </p><p id="p0029" num="0029"> In particular embodiments, once executed directly from the allocated memory on the client, the stub facilitates the downloading and execution of the target software. In particular embodiments, the stub may establish a network connection between the client and a server where the target software is stored and download the executable code of the target software from the server over the network connection to the client. In particular embodiments, the executable code of the target software may be embedded in a data stream sent from the server to the client over the network connection. Upon receiving the data stream, the stub may extract the executable code of the target software and load it directly into the Random- Access Memory (RAM) of the client for execution on the client. The target software is not saved in or installed onto any permanent storage (e.g., the hard drive) of the client, same as the stub. Once the target software completes its execution on the client, the RAM space in which the executable code of the target software is loaded may be released and the target software no longer exists anywhere on the client. </p><p id="p0030" num="0030"> The target software may be downloaded and launched on the client without having to be saved or installed on the client, which may decrease the usage of the storage capacity of the client. Furthermore, since the target software is downloaded just prior to its execution on the client, the latest or any desired version of the target software may be 
<!-- EPO <DP n="9"/>-->
 obtained each time the target software is downloaded and launched. </p><p id="p0031" num="0031"> FIGURE 2 illustrates an example method for the stub to facilitate the downloading and execution of the target software on the client. In particular embodiments, the target software being downloaded is an application program. The executable code of the target software may be stored on a server, which may be the same server where the executable code of the stub is stored or a different server. </p><p id="p0032" num="0032"> In particular embodiments, the stub may establish a network connection between the client and the server where the executable code of the target software is stored, as illustrated in step 200. The stub may take over an existing connection already established between the server and the client (e.g., the connection established by the web browser) or establish a new connection. If the stub establishes a new network connection, the new connection may be established using any suitable handshaking methods between two computer systems coupled to a computer network. For example, the stub executing on the client may send a connection request to the server, and the server, upon receiving the connection request, may send a response back, indicating whether the connection request is accepted or rejected. If the server has accepted the connection request, the network connection may be established between the client and the server accordingly. In particular embodiments, communications between the server and the client may use any suitable communication protocol, such as, for example and without limitation, Hypertext Transfer Protocol (HTTP), User Datagram Protocol (UDP), or Transport Control Protocol (TCP). </p><p id="p0033" num="0033"> In particular embodiments, there may be multiple software programs stored on the server or there may be multiple versions of a particular software program stored on the server, which may be downloaded to individual clients. In particular embodiments, each version of each piece of software that may be downloaded from a server to a client by a stub executing on the client may be identified by a unique identifier. This unique identifier may be used to notify the server which specific piece of software a client's stub wishes to download. In particular embodiments, each piece of downloadable software may be considered a network resource. Thus, a particular piece of downloadable software may be identified by its unique network path or Uniform Resource Identifier (URI). The stub may reference to the target software using its URI. </p><p id="p0034" num="0034"> Sometimes, a piece of software may have multiple versions. In particular 
<!-- EPO <DP n="10"/>-->
 embodiments, the stub may determine the most suitable version of the target software for the client. For example, there are multiple versions of the Microsoft Windows operating systems (e.g., Windows XP, Windows ME, or Windows 7) as well as 32-bit operating systems and 64-bit operating systems. The stub may examine the operating system of the client to determine the specific version of the target software most compatible with the operating system of the client. If the operating system of the client is a 32-bit operating system, then the stub may identify a 32-bit version of the target software. On the other hand, if the operating system of the client is a 64-bit operating system, then the stub may identify a 64-bit version of the target software. </p><p id="p0035" num="0035"> In particular embodiments, when requesting a network connection with the particular server where the target software is stored, the stub may send the unique identifier of the target software to the server together with the connection request or as a part of the connection request. Alternatively, in particular embodiments, the stub may send the identifier of the target software to the server as a separate request after the connection between the server and the client has been established. The server may then determine which particular piece of software it should transmit to the requesting client. The process may be similar to invoking a data stream via a web browser (e.g., by clicking on a URL or URI link to a downloadable file contained in a web page). </p><p id="p0036" num="0036"> In particular embodiments, the server may transmit a data stream to the requesting client, and more specifically, to the stub executing on the requesting client, over the network connection, as illustrated in step 202. The network connection may be a TCP connection, a UDP connection, a HTTP connection, or any other suitable connection. In particular embodiments, the data stream may be a video stream or an audio stream. In particular embodiments, the executable code of the target software requested by the stub may be embedded in the data stream as one or more data packets. For example, the target software may be a video decoder that receives a video stream encoded by a video codec, decodes the data and renders the video data on a display of the client. As another example, the target software may be a computer game. </p><p id="p0037" num="0037"> In particular embodiments, the executable code of the target software may be embedded in the data stream. In particular embodiments, the executable code of the target software may be machine code or native code and may be platform-dependent. In particular embodiments, the executable code of the target software has been complied to 
<!-- EPO <DP n="11"/>-->
 run on the platform of the particular client requesting the target software (e.g., based on the client's hardware architecture and operating system). </p><p id="p0038" num="0038"> In particular embodiments, the data stream may include two portions. In particular embodiments, the first portion of the data stream (i.e. the beginning of the data stream) may contain the executable code of the target software. In particular embodiments, the executable code of the target software may be optionally compressed using any suitable compression methods. For example, a lossless compression method, such as zip or gzip, may be used to compress the executable code of the target software. In particular embodiments, the executable code of the target software may be embedded within a video stream. As most types of video streams are generic container formats, data, and more specifically, the executable code of the target software, may be embedded in such a video stream. In particular embodiments, the first portion of the data stream may also include operational variables and parameters, such as a parameter that indicates the size of the memory space (e.g., RAM memory space) needed to load and execute the executable code of the software. </p><p id="p0039" num="0039"> In particular embodiments, the second portion of the data stream may optionally contain additional data that may be consumed by the target software during its execution. In particular embodiments, the additional data may be optionally encoded or compressed using any suitable encoding or compressing methods and transmitted as one or more data packets. Again, if the data stream is a video stream, then the additional data may be encoded using a video encoding method, such as MPEG encoding. </p><p id="p0040" num="0040"> In particular embodiments, upon receiving the data stream, the stub may access the first portion of the data stream to extract the executable code of the target software embedded therein. If needed, the stub may decode or decompress the extracted executable code of the target software. The decoding or decompressing methods used by the stub may correspond to the encoding or compressing methods used to encode or compress the executable code of the target software. For example, if the executable code of the target software has been compressed using a suitable compression algorithm (e.g., a lossless compression algorithm), the stub may decompress it using a corresponding decompression algorithm. Similarly, if the executable code of the target software has been encoded using a suitable encoding algorithm, the stub may decode it using a corresponding decoding algorithm. In addition, in particular embodiments, the stub may 
<!-- EPO <DP n="12"/>-->
 also access the first portion of the data stream to extract the parameters that indicate the size of the memory space needed to load and execute the executable code of the target software. </p><p id="p0041" num="0041"> In particular embodiments, to prevent unauthorized or malicious software from being downloaded and executed on the client, the stub may validate the executable code of the target software extracted from the first portion of the data stream using any suitable validation methods, as illustrated in step 204. In particular embodiments, a white list of trusted sources (e.g., domain names or IP addresses of trusted servers) may be provided with the stub. Upon receiving a piece of software, the stub may compare the source (e.g., the server or website) transmitting the software against its white list. Only software transmitted by the trusted sources on the white list may be executed on the client. Software received from sources not on the white list may be discarded or quarantined. In particular embodiments, the executable code of the target software embedded in the first portion of the data stream may be signed and associated with a digital certificate. The stub may validate the executable code of the target software using its associated digital certificate. </p><p id="p0042" num="0042"> If the executable code of the target software is not valid (step 206, "NO"), then the executable code of the target software is not launched on the client and may be discarded. On the other hand, if the executable code of the target software is valid (step 206, "YES"), then, in particular embodiments, the stub may allocate a sufficient amount of memory on the client for loading and executing the executable code of the target software, as illustrated in step 208. In particular embodiments, the amount of memory allocated may not be less than the size of the memory space needed to load and execute the executable code of the target software, as indicated by the variable included in the first portion of the data stream. In particular embodiments, the allocated memory may be dynamic memory, virtual memory, or RAM of the client. </p><p id="p0043" num="0043"> Most operating systems provide library functions that enable an application program to allocate and de-allocate virtual or dynamic memory and perform other types of memory-related functions during runtime. In particular embodiments, the stub may, through an appropriate foreign function library, invoke appropriate library functions provided by the operating system of the client to allocate the required memory space for the executable code of the target software. For example, as described above, "mal l oc" 
<!-- EPO <DP n="13"/>-->
 is a standard library function of both C and C++ programming languages for allocating dynamic memory space. For Microsoft Windows platforms, "VirtualAlloc" is a Win32 library function for reserving a region of pages in the virtual address space. Once the memory has been allocated, the stub may invoke appropriate library functions to set the flag for the allocated memory space as "executable", which indicates to the operating system that the data stored in the allocated memory are executable code. For example, with Microsoft Windows, the attribute "PAGE_EXECUTE", "PAGE_EXECUTE_READ", "PAGE_EXECUTE_READWRITE", or "PAGE_EXECUTE_WRI ECOPY" may be specified in connection with the memory allocation (e.g., using "VirtualAlloc") to ask the operating system for a sufficient amount of virtual memory that has the right for executing code, and operationally with the rights for reading or writing code. </p><p id="p0044" num="0044"> In particular embodiments, the stub may load the executable code of the target software directly into the allocated memory (e.g., the allocated dynamic memory) without having to save or install the executable code of the target software on the hard drive of the client, as illustrated in step 210. In particular embodiments, the stub may invoke appropriate library functions provided by the operating system of the client or the software libraries on the client to copy the binary data representing the executable code of the target software directly into the allocated virtual or dynamic memory space. For example, with Microsoft Windows, "CopyMemory" is a function for copying a block of memory from one location to another location; and "memcpy" is a standard library function of both C and C++ programming languages for copying data from one memory location to another memory location. </p><p id="p0045" num="0045"> In particular embodiments, the target software may require certain library functions. If a required library function already exists on the client, the stub may load the shared library containing the required library function for the target software. For example, with Microsoft Windows, a shared library (e.g., a DLL) may be loaded using the "LoadLibrary" function. On the other hand, if a required library function does not exist on the client, the stub may download the shared library containing the required library function or the required library function by itself from an appropriate server, allocate virtual memory for the shared library or the required library function, and write the shared library or the required library function in the allocated virtual memory so that 
<!-- EPO <DP n="14"/>-->
 the target software may use the library function when needed. In other words, for those resources (e.g., library functions) needed by the target software during its execution, if the resources already exist on the client, the resources on the client are used; and if the resources do not exist on the client, the stub download the resources for the target software. </p><p id="p0046" num="0046"> In particular embodiments, the stub may also adjust a branch table, also referred to as a jump table, to include the information concerning the executable code of the target software loaded in the allocated memory. This process may be referred to as a "fix-up" process. A branch table is an efficient method of transferring program control from one part to another part of a program or from one program to another program. By adjusting the appropriate branch table entries, the operating system may be made aware of the executable code of the software now loaded in the allocated memory. </p><p id="p0047" num="0047"> The actual steps that are performed during a fix-up process may vary depending on the platform or the operating system of the client. For example, with Microsoft Windows platform, an executable format typically has a relocation table and an import table. In general, the executable code is linked assuming it will be loaded to a fixed address. In order to load the executable code into a different address, any absolute addresses used by the executable code are found and "fixed-up" to cater for the change in the base address. This may be achieved using the relocation table. In particular embodiments, the relocation table compiles a list of all of the absolute addresses within the executable code such that they may be fixed up when the executable code is loaded. The import table lists the absolute addresses of all of the routines that the executable code may call. This may include both API routines and routines in other dynamic-link libraries (DLLs). These import addresses are replaced with the actual addresses of the routines within the address space of the current process. The import table is a list of the location of these addresses within the executable code (the addresses may be within a jump table or trampoline area, but also may be a list of data for indirect calls). </p><p id="p0048" num="0048"> Particular embodiments may take advantage of the Portable Executable (PE) format, which is a file format for executables, object code, and DLLs used in Microsoft Windows operating systems. The PE format is versatile in numerous environments of operating system software architecture. Generally, the PE format is a data structure that encapsulates the information necessary for the Microsoft Windows operating system 
<!-- EPO <DP n="15"/>-->
 loader to manage the wrapped executable code. Particular embodiments may compile and save the executable code of the software using the PE format. For other platforms, implementations of the invention may operate with raw executable code that requires a single entry point without any fixups. In some implementations, the raw executable code can be configured to perform the fixups itself and can cover such code as ELF and MACH-O. </p><p id="p0049" num="0049"> In particular embodiments, the target software may be executed on the client, as illustrated in step 212. In particular embodiments, the executable code of the target software may be launched directly from the allocated dynamic memory in which it is stored. In particular embodiments, the stub may cause the executable code of the target software loaded in the allocated memory to begin execution. Consequently, the stub may transfer the execution to the target software. </p><p id="p0050" num="0050"> In particular embodiments, the stub may pass the socket, or more precisely, the Internet socket or the network socket, associated with the network connection between the client and the server and the data stream to the target software that is now being executed on the client, as illustrated in 214. Network sockets constitute a mechanism for delivering incoming data packets to the appropriate application process or thread. By passing the network socket associated with the data stream to the target software, the target software may now receive the additional data packets that contain the additional data in the second portion of the data stream. The target software may then consume (e.g., process) the additional data contained in the second portion of the data stream. In particular embodiments, the stub may invoke appropriate library functions provided by the operating system of the client to pass the network socket to the now executing target software. For example, the Windows Sockets Application Programming Interface (API), also referred to as Winsock, enables a network socket to be passed from one process to another using the "WSADuplicateSocket" function. </p><p id="p0051" num="0051"> The target software may continue its execution until it is completed. In particular embodiments, once the target software has completed its execution (i.e., has exited), the dynamic memory space used to load the executable code of the target software program may be de-allocated (e.g., by the operating system of the client). For example, with Microsoft Windows, the "VirtualFree" function may be invoked to free up the allocated memory where the excitable code of the target software is stored. 
<!-- EPO <DP n="16"/>-->
 Subsequently, this memory space may be used for other purposes and other data may be loaded into the same memory space, overriding the executable code of the target software. At this point, the target software no longer exits on the client without any state changes to client (e.g., no files on a drive, no system registry changes, etc.) because it was installed by the stub directly into memory and not stored in any persistent media on the client including, in some embodiments, the browser cache or other temporary data storage mechanisms. </p><p id="p0052" num="0052"> In some embodiments, a first executable code object embedded in the stream and launched by the stub may itself cause another process to be generated by requesting another data stream that also includes a second executable code object. The second executable code object may be launched as a child process of the first executable code object and share the same sand-boxed file system generated by the first executable code object. For example, the first executable code object may be a virtual machine that allows one or more second executable code objects to run entirely in memory and sand- boxed by the first virtual machine code object. In particular implementation, for example, writes to a data storage subsystem by the second code object are written by the virtual machine into memory, not a peripheral device which could be analyzed when a user logs off the client. For example, this embodiment can be used to allow for demonstration versions of software in that the first executable code object may be a virtual machine that sandboxes a second program to be demonstrated or tested. As discussed above, when the first and second executable code objects end, all traces of them in memory are gone. The foregoing embodiment can also be used to prevent unauthorized access to data that is typically cached during application execution. </p><p id="p0053" num="0053"> Particular embodiments may be implemented in a network environment. FIGURE 3 illustrates an example network environment 300. Network environment 300 includes a network 310 coupling one or more servers 320 and one or more clients 330 to each other. In particular embodiments, network 310 is an intranet, an extranet, a virtual private network (VPN), a local area network (LAN), a wireless LAN (WLAN), a wide area network (WAN), a metropolitan area network (MAN), a portion of the Internet, or another network 310 or a combination of two or more such networks 310. This disclosure contemplates any suitable network 310. </p><p id="p0054" num="0054"> One or more links 350 couple a server 320 or a client 330 to network 310. In 
<!-- EPO <DP n="17"/>-->
 particular embodiments, one or more links 350 each includes one or more wireline, wireless, or optical links 350. In particular embodiments, one or more links 350 each includes an intranet, an extranet, a VPN, a LAN, a WLAN, a WAN, a MAN, a portion of the Internet, or another link 350 or a combination of two or more such links 350. This disclosure contemplates any suitable links 350 coupling servers 320 and clients 330 to network 310. </p><p id="p0055" num="0055"> In particular embodiments, each server 320 may be a unitary server or may be a distributed server spanning multiple computers or multiple datacenters. Servers 320 may be of various types, such as, for example and without limitation, web server, news server, mail server, message server, advertising server, file server, application server, exchange server, database server, or proxy server. In particular embodiments, each server 320 may include hardware, software, or embedded logic components or a combination of two or more such components for carrying out the appropriate functionalities implemented or supported by server 320. For example, a web server is generally capable of hosting websites containing web pages or particular elements of web pages. More specifically, a web server may host HTML files or other file types, or may dynamically create or constitute files upon a request, and communicate them to clients 330 in response to HTTP or other requests from clients 330. A mail server is generally capable of providing electronic mail services to various clients 330. A database server is generally capable of providing an interface for managing data stored in one or more data stores. </p><p id="p0056" num="0056"> In particular embodiments, the executable code of a stub 322 and the executable code of a piece of software 324 may reside on a server 320. They may be downloaded to a client 330 for execution without being saved or installed on client 330. While they are being executed on client 330, they exit in the virtual memory on client 330. After their executions are completed, they are removed from client 330 when the virtual memory is freed up, thus leaving no trace on client 330. </p><p id="p0057" num="0057"> In particular embodiments, one or more data storages 340 may be communicatively linked to one or more severs 320 via one or more links 350. In particular embodiments, data storages 340 may be used to store various types of information. In particular embodiments, the information stored in data storages 340 may be organized according to specific data structures. In particular embodiment, each data storage 340 may be a relational database. Particular embodiments may provide interfaces 
<!-- EPO <DP n="18"/>-->
 that enable servers 320 or clients 330 to manage, e.g., retrieve, modify, add, or delete, the information stored in data storage 340. </p><p id="p0058" num="0058"> In particular embodiments, each client 330 may be an electronic device including hardware, software, or embedded logic components or a combination of two or more such components and capable of carrying out the appropriate functionalities implemented or supported by client 330. For example and without limitation, a client 330 may be a desktop computer system, a notebook computer system, a netbook computer system, a handheld electronic device, or a mobile telephone. This disclosure contemplates any suitable clients 330. A client 330 may enable a network user at client 330 to access network 330. A client 330 may enable its user to communicate with other users at other clients 330. </p><p id="p0059" num="0059"> A client 330 may have a web browser 332, such as MICROSOFT INTERNET EXPLORER, GOOGLE CHROME or MOZILLA FIREFOX, and may have one or more add-ons, plug-ins, or other extensions, such as TOOLBAR or YAHOO TOOLBAR. A user at client 330 may enter a Uniform Resource Locator (URL) or other address directing the web browser 332 to a server 320, and the web browser 332 may generate a Hyper Text Transfer Protocol (HTTP) request and communicate the HTTP request to server 320. Server 320 may accept the HTTP request and communicate to client 330 one or more Hyper Text Markup Language (HTML) files responsive to the HTTP request. Client 330 may render a web page based on the HTML files from server 320 for presentation to the user. This disclosure contemplates any suitable web page files. As an example and not by way of limitation, web pages may render from HTML files, Extensible Hyper Text Markup Language (XHTML) files, or Extensible Markup Language (XML) files, according to particular needs. Such pages may also execute scripts such as, for example and without limitation, those written in JAVASCRIPT, JAVA, MICROSOFT SILVERLIGHT, combinations of markup language and scripts such as AJAX (Asynchronous JAVASCRIPT and XML), and the like. Herein, reference to a web page encompasses one or more corresponding web page files (which a browser may use to render the web page) and vice versa, where appropriate. </p><p id="p0060" num="0060"> Particular embodiments may be implemented on one or more computer systems.</p><p id="p0061" num="0061">FIGURE 4 illustrates an example computer system 400. In particular embodiments, one or more computer systems 400 perform one or more steps of one or more methods 
<!-- EPO <DP n="19"/>-->
 described or illustrated herein. In particular embodiments, one or more computer systems 400 provide functionality described or illustrated herein. In particular embodiments, software running on one or more computer systems 400 performs one or more steps of one or more methods described or illustrated herein or provides functionality described or illustrated herein. Particular embodiments include one or more portions of one or more computer systems 400. </p><p id="p0062" num="0062"> This disclosure contemplates any suitable number of computer systems 400. This disclosure contemplates computer system 400 taking any suitable physical form. As example and not by way of limitation, computer system 400 may be an embedded computer system, a system-on-chip (SOC), a single-board computer system (SBC) (such as, for example, a computer-on-module (COM) or system-on-module (SOM)), a desktop computer system, a laptop or notebook computer system, an interactive kiosk, a mainframe, a mesh of computer systems, a mobile telephone, a personal digital assistant (PDA), a server, or a combination of two or more of these. Where appropriate, computer system 400 may include one or more computer systems 400; be unitary or distributed; span multiple locations; span multiple machines; or reside in a cloud, which may include one or more cloud components in one or more networks. Where appropriate, one or more computer systems 400 may perform without substantial spatial or temporal limitation one or more steps of one or more methods described or illustrated herein. As an example and not by way of limitation, one or more computer systems 400 may perform in real time or in batch mode one or more steps of one or more methods described or illustrated herein. One or more computer systems 400 may perform at different times or at different locations one or more steps of one or more methods described or illustrated herein, where appropriate. </p><p id="p0063" num="0063"> In particular embodiments, computer system 400 includes a processor 402, memory 404, storage 406, an input/output (I/O) interface 408, a communication interface 410, and a bus 412. Although this disclosure describes and illustrates a particular computer system having a particular number of particular components in a particular arrangement, this disclosure contemplates any suitable computer system having any suitable number of any suitable components in any suitable arrangement. </p><p id="p0064" num="0064"> In particular embodiments, processor 402 includes hardware for executing instructions, such as those making up a computer program. As an example and not by 
<!-- EPO <DP n="20"/>-->
 way of limitation, to execute instructions, processor 402 may retrieve (or fetch) the instructions from an internal register, an internal cache, memory 404, or storage 406; decode and execute them; and then write one or more results to an internal register, an internal cache, memory 404, or storage 406. In particular embodiments, processor 402 may include one or more internal caches for data, instructions, or addresses. This disclosure contemplates processor 402 including any suitable number of any suitable internal caches, where appropriate. As an example and not by way of limitation, processor 402 may include one or more instruction caches, one or more data caches, and one or more translation lookaside buffers (TLBs). Instructions in the instruction caches may be copies of instructions in memory 404 or storage 406, and the instruction caches may speed up retrieval of those instructions by processor 402. Data in the data caches may be copies of data in memory 404 or storage 406 for instructions executing at processor 402 to operate on; the results of previous instructions executed at processor 402 for access by subsequent instructions executing at processor 402 or for writing to memory 404 or storage 406; or other suitable data. The data caches may speed up read or write operations by processor 402. The TLBs may speed up virtual-address translation for processor 402. In particular embodiments, processor 402 may include one or more internal registers for data, instructions, or addresses. This disclosure contemplates processor 402 including any suitable number of any suitable internal registers, where appropriate. Where appropriate, processor 402 may include one or more arithmetic logic units (ALUs); be a multi-core processor; or include one or more processors 402. Although this disclosure describes and illustrates a particular processor, this disclosure contemplates any suitable processor. </p><p id="p0065" num="0065"> In particular embodiments, memory 404 includes main memory for storing instructions for processor 402 to execute or data for processor 402 to operate on. As an example and not by way of limitation, computer system 400 may load instructions from storage 406 or another source (such as, for example, another computer system 400) to memory 404. Processor 402 may then load the instructions from memory 404 to an internal register or internal cache. To execute the instructions, processor 402 may retrieve the instructions from the internal register or internal cache and decode them. During or after execution of the instructions, processor 402 may write one or more results (which may be intermediate or final results) to the internal register or internal cache. 
<!-- EPO <DP n="21"/>-->
 Processor 402 may then write one or more of those results to memory 404. In particular embodiments, processor 402 executes only instructions in one or more internal registers or internal caches or in memory 404 (as opposed to storage 406 or elsewhere) and operates only on data in one or more internal registers or internal caches or in memory 404 (as opposed to storage 406 or elsewhere). One or more memory buses (which may each include an address bus and a data bus) may couple processor 402 to memory 404. Bus 412 may include one or more memory buses, as described below. In particular embodiments, one or more memory management units (MMUs) reside between processor 402 and memory 404 and facilitate accesses to memory 404 requested by processor 402. In particular embodiments, memory 404 includes random access memory (RAM). This RAM may be volatile memory, where appropriate Where appropriate, this RAM may be dynamic RAM (DRAM) or static RAM (SRAM). Moreover, where appropriate, this RAM may be single-ported or multi-ported RAM. This disclosure contemplates any suitable RAM. Memory 404 may include one or more memories 404, where appropriate. Although this disclosure describes and illustrates particular memory, this disclosure contemplates any suitable memory. </p><p id="p0066" num="0066"> In particular embodiments, storage 406 includes mass storage for data or instructions. As an example and not by way of limitation, storage 406 may include an HDD, a floppy disk drive, flash memory, an optical disc, a magneto-optical disc, magnetic tape, or a Universal Serial Bus (USB) drive or a combination of two or more of these. Storage 406 may include removable or non-removable (or fixed) media, where appropriate. Storage 406 may be internal or external to computer system 400, where appropriate. In particular embodiments, storage 406 is non-volatile, solid-state memory. In particular embodiments, storage 406 includes read-only memory (ROM). Where appropriate, this ROM may be mask-programmed ROM, programmable ROM (PROM), erasable PROM (EPROM), electrically erasable PROM (EEPROM), electrically alterable ROM (EAROM), or flash memory or a combination of two or more of these. This disclosure contemplates mass storage 406 taking any suitable physical form. Storage 406 may include one or more storage control units facilitating communication between processor 402 and storage 406, where appropriate. Where appropriate, storage 406 may include one or more storages 406. Although this disclosure describes and illustrates particular storage, this disclosure contemplates any suitable storage. 
<!-- EPO <DP n="22"/>-->
 In particular embodiments, I/O interface 408 includes hardware, software, or both providing one or more interfaces for communication between computer system 400 and one or more I/O devices. Computer system 400 may include one or more of these I/O devices, where appropriate. One or more of these I/O devices may enable communication between a person and computer system 400. As an example and not by way of limitation, an I/O device may include a keyboard, keypad, microphone, monitor, mouse, printer, scanner, speaker, still camera, stylus, tablet, touch screen, trackball, video camera, another suitable I/O device or a combination of two or more of these. An I/O device may include one or more sensors. This disclosure contemplates any suitable I/O devices and any suitable I/O interfaces 408 for them. Where appropriate, I/O interface 408 may include one or more device or software drivers enabling processor 402 to drive one or more of these I/O devices. I/O interface 408 may include one or more I/O interfaces 408, where appropriate. Although this disclosure describes and illustrates a particular I/O interface, this disclosure contemplates any suitable I/O interface. </p><p id="p0067" num="0067"> In particular embodiments, communication interface 410 includes hardware, software, or both providing one or more interfaces for communication (such as, for example, packet-based communication) between computer system 400 and one or more other computer systems 400 or one or more networks. As an example and not by way of limitation, communication interface 410 may include a network interface controller (NIC) or network adapter for communicating with an Ethernet or other wire-based network or a wireless NIC (WNIC) or wireless adapter for communicating with a wireless network, such as a WI-FI network. This disclosure contemplates any suitable network and any suitable communication interface 410 for it. As an example and not by way of limitation, computer system 400 may communicate with an ad hoc network, a personal area network (PAN), a local area network (LAN), a wide area network (WAN), a metropolitan area network (MAN), or one or more portions of the Internet or a combination of two or more of these. One or more portions of one or more of these networks may be wired or wireless. As an example, computer system 400 may communicate with a wireless PAN (WPAN) (such as, for example, a BLUETOOTH WPAN), a WI-FI network, a WI-MAX network, a cellular telephone network (such as, for example, a Global System for Mobile Communications (GSM) network), or other suitable wireless network or a combination of two or more of these. Computer system 400 may include any suitable communication 
<!-- EPO <DP n="23"/>-->
 interface 410 for any of these networks, where appropriate. Communication interface 410 may include one or more communication interfaces 410, where appropriate. Although this disclosure describes and illustrates a particular communication interface, this disclosure contemplates any suitable communication interface. </p><p id="p0068" num="0068"> In particular embodiments, bus 412 includes hardware, software, or both coupling components of computer system 400 to each other. As an example and not by way of limitation, bus 412 may include an Accelerated Graphics Port (AGP) or other graphics bus, an Enhanced Industry Standard Architecture (EISA) bus, a front-side bus (FSB), a HYPERTRANSPORT (HT) interconnect, an Industry Standard Architecture (ISA) bus, an INFINIBAND interconnect, a low-pin-count (LPC) bus, a memory bus, a Micro Channel Architecture (MCA) bus, a Peripheral Component Interconnect (PCI) bus, a PCI- Express (PCI-X) bus, a serial advanced technology attachment (SATA) bus, a Video Electronics Standards Association local (VLB) bus, or another suitable bus or a combination of two or more of these. Bus 412 may include one or more buses 412, where appropriate. Although this disclosure describes and illustrates a particular bus, this disclosure contemplates any suitable bus or interconnect. </p><p id="p0069" num="0069"> Herein, reference to a computer-readable storage medium encompasses one or more non-transitory, tangible computer-readable storage media possessing structure. As an example and not by way of limitation, a computer-readable storage medium may include a semiconductor-based or other integrated circuit (IC) (such, as for example, a field-programmable gate array (FPGA) or an application-specific IC (ASIC)), a hard disk, an HDD, a hybrid hard drive (HHD), an optical disc, an optical disc drive (ODD), a magneto-optical disc, a magneto-optical drive, a floppy disk, a floppy disk drive (FDD), magnetic tape, a holographic storage medium, a solid-state drive (SSD), a RAM-drive, a SECURE DIGITAL card, a SECURE DIGITAL drive, or another suitable computer- readable storage medium or a combination of two or more of these, where appropriate. Herein, reference to a computer-readable storage medium excludes any medium that is not eligible for patent protection under 35 U.S.C. § 101. Herein, reference to a computer- readable storage medium excludes transitory forms of signal transmission (such as a propagating electrical or electromagnetic signal per se) to the extent that they are not eligible for patent protection under 35 U.S.C. § 101. A computer-readable non-transitory storage medium may be volatile, non-volatile, or a combination of volatile and non- 
<!-- EPO <DP n="24"/>-->
 volatile, where appropriate. </p><p id="p0070" num="0070"> This disclosure contemplates one or more computer-readable storage media implementing any suitable storage. In particular embodiments, a computer-readable storage medium implements one or more portions of processor 402 (such as, for example, one or more internal registers or caches), one or more portions of memory 404, one or more portions of storage 406, or a combination of these, where appropriate. In particular embodiments, a computer-readable storage medium implements RAM or ROM. In particular embodiments, a computer-readable storage medium implements volatile or persistent memory. In particular embodiments, one or more computer-readable storage media embody software. Herein, reference to software may encompass one or more applications, bytecode, one or more computer programs, one or more executables, one or more instructions, logic, machine code, one or more scripts, or source code, and vice versa, where appropriate. In particular embodiments, software includes one or more application programming interfaces (APIs). This disclosure contemplates any suitable software written or otherwise expressed in any suitable programming language or combination of programming languages. In particular embodiments, software is expressed as source code or object code. In particular embodiments, software is expressed in a higher-level programming language, such as, for example, C, Perl, or a suitable extension thereof. In particular embodiments, software is expressed in a lower- level programming language, such as assembly language (or machine code). In particular embodiments, software is expressed in JAVA. In particular embodiments, software is expressed in Hyper Text Markup Language (HTML), Extensible Markup Language (XML), or other suitable markup language. </p><p id="p0071" num="0071"> Herein, "or" is inclusive and not exclusive, unless expressly indicated otherwise or indicated otherwise by context. Therefore, herein, "A or B" means "A, B, or both," unless expressly indicated otherwise or indicated otherwise by context. Moreover, "and" is both joint and several, unless expressly indicated otherwise or indicated otherwise by context. Therefore, herein, "A and B" means "A and B, jointly or severally," unless expressly indicated otherwise or indicated otherwise by context. </p><p id="p0072" num="0072"> This disclosure encompasses all changes, substitutions, variations, alterations, and modifications to the example embodiments herein that a person having ordinary skill in the art would comprehend. Similarly, where appropriate, the appended claims encompass 
<!-- EPO <DP n="25"/>-->
 all changes, substitutions, variations, alterations, and modifications to the example embodiments herein that a person having ordinary skill in the art would comprehend. Moreover, reference in the appended claims to an apparatus or system or a component of an apparatus or system being adapted to, arranged to, capable of, configured to, enabled to, operable to, or operative to perform a particular function encompasses that apparatus, system, component, whether or not it or that particular function is activated, turned on, or unlocked, as long as that apparatus, system, or component is so adapted, arranged, capable, configured, enabled, operable, or operative. 
</p></description><claims mxw-id="PCLM44725913" ref-ucid="WO-2012116068-A2" lang="EN" load-source="patent-office"><claim-statement><!-- EPO <DP n="26"/>-->CLAIMS What is claimed is: </claim-statement><claim id="clm-0001" num="1"><claim-text>1. A method, comprising: </claim-text><claim-text> allocating, by a first computing device, a first virtual memory; </claim-text><claim-text> receiving, by the first computing device, executable code of a first piece of software; </claim-text><claim-text> writing, by the first computing device, the executable code of the first piece of software directly into the first virtual memory; </claim-text><claim-text> marking, by the first computing device, the first virtual memory as executable; executing, by the first computing device, the executable code of the first piece of software directly from the first virtual memory; and </claim-text><claim-text> downloading and executing, by the first computing device, executable code of a second piece of software as facilitated by the executable code of the first piece of software. </claim-text></claim><claim id="clm-0002" num="2"><claim-text>2. The method recited in Claim 1, further comprising loading one or more shared libraries needed by the executable code of the first piece of software. </claim-text></claim><claim id="clm-0003" num="3"><claim-text>3. The method recited in Claim 2, the executable code of the first piece of software being a client-side script executed in a browser running on the first computing device. </claim-text></claim><claim id="clm-0004" num="4"><claim-text>4. The method recited in Claim 3, wherein the client-side script accesses a foreign function interface supported by the browser. </claim-text></claim><claim id="clm-0005" num="5"><claim-text>5. The method recited in Claim 4, wherein the browser is Mozilla Firefox and the client-side script is JavaScript. </claim-text></claim><claim id="clm-0006" num="6"><claim-text>6. The method recited in Claim 3, wherein the client-side script accesses a foreign function library residing on the first computing device. <!-- EPO <DP n="27"/>--> </claim-text></claim><claim id="clm-0007" num="7"><claim-text>7. The method recited in Claim 6, wherein the foreign function library is a ctypes library. </claim-text></claim><claim id="clm-0008" num="8"><claim-text>8. The method recited in Claim 1, further comprising de-allocating the first virtual memory after the execution of the executable code of the first piece of software is completed so that there is no trace of the executable code of the first piece of software on the first computing device. </claim-text></claim><claim id="clm-0009" num="9"><claim-text>9. The method recited in Claim 1, wherein downloading and executing the executable code of the second piece of software as facilitated by the executable code of the first piece of software comprises: </claim-text><claim-text> receiving the executable code of the second piece of software; </claim-text><claim-text> extracting the executable code of the second piece of software from the data stream; </claim-text><claim-text> allocating a second virtual memory; </claim-text><claim-text> writing the executable code of the second piece of software directly into the second virtual memory; </claim-text><claim-text> marking the second virtual memory as executable; and </claim-text><claim-text> executing the executable code of the second piece of software directly from the second virtual memory. </claim-text></claim><claim id="clm-0010" num="10"><claim-text>10. The method recited in Claim 9, further comprising: </claim-text><claim-text> validating the executable code of the second piece of software; </claim-text><claim-text> loading one or more first shared libraries needed by the executable code of the second piece of software existing on the first computing device; and </claim-text><claim-text> downloading one or more second shared libraries needed by the executable code of the second piece of software from a second computing device. </claim-text></claim><claim id="clm-0011" num="11"><claim-text>11. The method recited in Claim 9, further comprising de-allocating the second virtual memory after the execution of the executable code of the second piece of software is completed so that there is no trace of the executable code of the second piece of software on the first computing device. <!-- EPO <DP n="28"/>--> </claim-text></claim><claim id="clm-0012" num="12"><claim-text>12. The method recited in Claim 9, further comprising determining the second piece of software based on an operating system of the first computing device. </claim-text></claim><claim id="clm-0013" num="13"><claim-text>13. The method recited in Claim 9, wherein: </claim-text><claim-text> the executable code of the first piece of software is received from a second computing device; and </claim-text><claim-text> the executable code of the second piece of software is received from a third computing device. </claim-text></claim><claim id="clm-0014" num="14"><claim-text>14. The method recited in Claim 9, wherein the executable code of the first piece of software and the executable code of the second piece of software are both received from a second computing device. </claim-text></claim><claim id="clm-0015" num="15"><claim-text>15. The method recited in Claim 9, wherein the executable code of the second piece of software is embedded in a data stream. </claim-text></claim><claim id="clm-0016" num="16"><claim-text>16. A first system, comprising: </claim-text><claim-text> a memory comprising instructions executable by one or more processors; and one or more processors coupled to the memory and operable to execute the instructions, the one or more processors being operable when executing the instructions to: </claim-text><claim-text> allocate a first virtual memory; </claim-text><claim-text> receive executable code of a first piece of software; </claim-text><claim-text> write the executable code of the first piece of software directly into the first virtual memory; </claim-text><claim-text> mark the first virtual memory as executable; </claim-text><claim-text> execute the executable code of the first piece of software directly from the first virtual memory; and </claim-text><claim-text> download and execute executable code of a second piece of software as facilitated by the executable code of the first piece of software. <!-- EPO <DP n="29"/>--> </claim-text></claim><claim id="clm-0017" num="17"><claim-text>17. The system recited in Claim 16, wherein the one or more processors are further operable when executing the instructions to load one or more shared libraries needed by the executable code of the first piece of software. </claim-text></claim><claim id="clm-0018" num="18"><claim-text>18. The system recited in Claim 16, the executable code of the first piece of software being a client-side script executed in a browser running on the first computing device. </claim-text></claim><claim id="clm-0019" num="19"><claim-text>19. The system recited in Claim 18, wherein the client-side script accesses a foreign function interface supported by the browser. </claim-text></claim><claim id="clm-0020" num="20"><claim-text>20. The system recited in Claim 19, wherein the browser is Mozilla Firefox and the client-side script is JavaScript. </claim-text></claim><claim id="clm-0021" num="21"><claim-text>21. The system recited in Claim 18, wherein the client-side script accesses a foreign function library residing on the first computing device. </claim-text></claim><claim id="clm-0022" num="22"><claim-text>22. The system recited in Claim 21, wherein the foreign function library is a ctypes library. </claim-text></claim><claim id="clm-0023" num="23"><claim-text>23. The system recited in Claim 16, wherein the one or more processors are further operable when executing the instructions to de-allocate the first virtual memory after the execution of the executable code of the first piece of software is completed so that there is no trace of the executable code of the first piece of software on the first computing device. </claim-text></claim><claim id="clm-0024" num="24"><claim-text>24. The system recited in Claim 16, wherein downloading and executing the executable code of the second piece of software as facilitated by the executable code of the first piece of software comprises: </claim-text><claim-text> receive the executable code of the second piece of software; </claim-text><claim-text> extract the executable code of the second piece of software from the data stream; allocate a second virtual memory; <!-- EPO <DP n="30"/>--> write the executable code of the second piece of software directly into the second virtual memory; </claim-text><claim-text> mark the second virtual memory as executable; and </claim-text><claim-text> execute the executable code of the second piece of software directly from the second virtual memory. </claim-text></claim><claim id="clm-0025" num="25"><claim-text>25. The system recited in Claim 24, wherein the one or more processors are further operable when executing the instructions to: </claim-text><claim-text> validate the executable code of the second piece of software; </claim-text><claim-text> load one or more first shared libraries needed by the executable code of the second piece of software existing on the first computing device; and </claim-text><claim-text> download one or more second shared libraries needed by the executable code of the second piece of software from a second computing device. </claim-text></claim><claim id="clm-0026" num="26"><claim-text>26. The system recited in Claim 24, wherein the one or more processors are further operable when executing the instructions to de-allocate the second virtual memory after the execution of the executable code of the second piece of software is completed so that there is no trace of the executable code of the second piece of software on the first computing device. </claim-text></claim><claim id="clm-0027" num="27"><claim-text>27. The system recited in Claim 24, wherein the one or more processors are further operable when executing the instructions to determine the second piece of software based on an operating system of the first computing device. </claim-text></claim><claim id="clm-0028" num="28"><claim-text>28. The system recited in Claim 24, wherein: </claim-text><claim-text> the executable code of the first piece of software is received from a second computing device; and </claim-text><claim-text> the executable code of the second piece of software is received from a third computing device. </claim-text></claim><claim id="clm-0029" num="29"><claim-text>29. The system recited in Claim 24, wherein the executable code of the first piece of software and the executable code of the second piece of software are both <!-- EPO <DP n="31"/>--> received from a second computing device. </claim-text></claim><claim id="clm-0030" num="30"><claim-text>30. The system recited in Claim 24, wherein the executable code of the second piece of software is embedded in a data stream. </claim-text></claim><claim id="clm-0031" num="31"><claim-text>31. One or more computer-readable storage media embodying software operable when executed by a first computer system to: </claim-text><claim-text> allocate a first virtual memory; </claim-text><claim-text> receive executable code of a first piece of software; </claim-text><claim-text> write the executable code of the first piece of software directly into the first virtual memory; </claim-text><claim-text> mark the first virtual memory as executable; </claim-text><claim-text> execute the executable code of the first piece of software directly from the first virtual memory; and </claim-text><claim-text> download and execute executable code of a second piece of software as facilitated by the executable code of the first piece of software. </claim-text></claim><claim id="clm-0032" num="32"><claim-text>32. The media recited in Claim 31, wherein the software is further operable when executed by the first computer system to load one or more shared libraries needed by the executable code of the first piece of software. </claim-text></claim><claim id="clm-0033" num="33"><claim-text>33. The media recited in Claim 31, the executable code of the first piece of software being a client-side script executed in a browser running on the first computing device. </claim-text></claim><claim id="clm-0034" num="34"><claim-text>34. The media recited in Claim 33, wherein the client-side script accesses a foreign function interface supported by the browser. </claim-text></claim><claim id="clm-0035" num="35"><claim-text>35. The media recited in Claim 34, wherein the browser is Mozilla Firefox and the client-side script is JavaScript. </claim-text></claim><claim id="clm-0036" num="36"><claim-text>36. The media recited in Claim 33, wherein the client- side script accesses a <!-- EPO <DP n="32"/>--> foreign function library residing on the first computing device. </claim-text></claim><claim id="clm-0037" num="37"><claim-text>37. The media recited in Claim 36, wherein the foreign function library is a ctypes library. </claim-text></claim><claim id="clm-0038" num="38"><claim-text>38. The media recited in Claim 31, wherein the software is further operable when executed by the first computer system to de-allocate the first virtual memory after the execution of the executable code of the first piece of software is completed so that there is no trace of the executable code of the first piece of software on the first computing device. </claim-text></claim><claim id="clm-0039" num="39"><claim-text>39. The media recited in Claim 31, wherein downloading and executing the executable code of the second piece of software as facilitated by the executable code of the first piece of software comprises: </claim-text><claim-text> receive the executable code of the second piece of software; </claim-text><claim-text> extract the executable code of the second piece of software from the data stream; allocate a second virtual memory; </claim-text><claim-text> write the executable code of the second piece of software directly into the second virtual memory; </claim-text><claim-text> mark the second virtual memory as executable; and </claim-text><claim-text> execute the executable code of the second piece of software directly from the second virtual memory. </claim-text></claim><claim id="clm-0040" num="40"><claim-text>40. The media recited in Claim 39, wherein the software is further operable when executed by the first computer system to: </claim-text><claim-text> validate the executable code of the second piece of software; </claim-text><claim-text> load one or more first shared libraries needed by the executable code of the second piece of software existing on the first computing device; and </claim-text><claim-text> download one or more second shared libraries needed by the executable code of the second piece of software from a second computing device. </claim-text></claim><claim id="clm-0041" num="41"><claim-text>41. The media recited in Claim 39, wherein the software is further operable <!-- EPO <DP n="33"/>--> when executed by the first computer system to de-allocate the second virtual memory after the execution of the executable code of the second piece of software is completed so that there is no trace of the executable code of the second piece of software on the first computing device. </claim-text></claim><claim id="clm-0042" num="42"><claim-text>42. The media recited in Claim 39, wherein the software is further operable when executed by the first computer system to determine the second piece of software based on an operating system of the first computing device. </claim-text></claim><claim id="clm-0043" num="43"><claim-text>43. The media recited in Claim 39, wherein: </claim-text><claim-text> the executable code of the first piece of software is received from a second computing device; and </claim-text><claim-text> the executable code of the second piece of software is received from a third computing device. </claim-text></claim><claim id="clm-0044" num="44"><claim-text>44. The media recited in Claim 39, wherein the executable code of the first piece of software and the executable code of the second piece of software are both received from a second computing device. </claim-text></claim><claim id="clm-0045" num="45"><claim-text>45. The media recited in Claim 39, wherein the executable code of the second piece of software is embedded in a data stream. </claim-text></claim></claims><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
