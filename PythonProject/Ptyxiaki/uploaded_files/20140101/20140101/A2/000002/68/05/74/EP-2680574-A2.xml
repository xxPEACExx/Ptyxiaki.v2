<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2680574-A2" country="EP" doc-number="2680574" kind="A2" date="20140101" family-id="29779740" file-reference-id="318226" date-produced="20180824" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146549114" ucid="EP-2680574-A2"><document-id><country>EP</country><doc-number>2680574</doc-number><kind>A2</kind><date>20140101</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-13185692-A" is-representative="NO"><document-id mxw-id="PAPP154823037" load-source="docdb" format="epo"><country>EP</country><doc-number>13185692</doc-number><kind>A</kind><date>20030623</date><lang>EN</lang></document-id><document-id mxw-id="PAPP176648224" load-source="docdb" format="original"><country>EP</country><doc-number>13185692.4</doc-number><date>20030623</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140447619" ucid="EP-03014095-A" linkage-type="3" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>03014095</doc-number><kind>A</kind><date>20030623</date></document-id></priority-claim><priority-claim mxw-id="PPC140446335" ucid="US-18580002-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>18580002</doc-number><kind>A</kind><date>20020628</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-2137520808" load-source="docdb">H04N   5/775       20060101ALI20141104BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-2137522458" load-source="docdb">H04N   5/765       20060101ALI20141104BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-2137523728" load-source="docdb">G11B  20/10        20060101ALI20141104BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-2137524905" load-source="docdb">G11B  27/00        20060101ALI20141104BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-2137525365" load-source="docdb">H04N   5/783       20060101AFI20141104BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-2137526869" load-source="docdb">H04N   9/804       20060101ALI20141104BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-2137528747" load-source="docdb">H04N   5/85        20060101ALI20141104BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-2137529759" load-source="docdb">H04N   9/806       20060101ALI20141104BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-2137529809" load-source="docdb">G11B  27/034       20060101ALI20141104BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-2137533841" load-source="docdb">H04N   9/82        20060101ALI20141104BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1988103329" load-source="docdb">H04N   5/92        20060101ALI20051220RMJP        </classification-ipcr><classification-ipcr mxw-id="PCL1988119738" load-source="docdb">H04N   5/93        20060101ALI20051220RMJP        </classification-ipcr><classification-ipcr mxw-id="PCL1988121784" load-source="docdb">H04N   5/76        20060101AFI20051220RMJP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL2070993054" load-source="docdb" scheme="CPC">H04N   5/783       20130101 LI20140423BHEP        </classification-cpc><classification-cpc mxw-id="PCL2070993605" load-source="docdb" scheme="CPC">G11B2020/10694     20130101 LA20140423BHEP        </classification-cpc><classification-cpc mxw-id="PCL2070993802" load-source="docdb" scheme="CPC">G11B2020/10537     20130101 LA20140423BHEP        </classification-cpc><classification-cpc mxw-id="PCL2070995497" load-source="docdb" scheme="CPC">H04N   9/8042      20130101 LA20140423BHEP        </classification-cpc><classification-cpc mxw-id="PCL2070996657" load-source="docdb" scheme="CPC">H04N   5/85        20130101 LA20140423BHEP        </classification-cpc><classification-cpc mxw-id="PCL2070997762" load-source="docdb" scheme="CPC">G11B  27/005       20130101 LI20140423BHEP        </classification-cpc><classification-cpc mxw-id="PCL2070999555" load-source="docdb" scheme="CPC">H04N   5/765       20130101 LA20140423BHEP        </classification-cpc><classification-cpc mxw-id="PCL2071001405" load-source="docdb" scheme="CPC">H04N   5/775       20130101 LA20140423BHEP        </classification-cpc><classification-cpc mxw-id="PCL2071001696" load-source="docdb" scheme="CPC">G11B  20/10527     20130101 LI20140423BHEP        </classification-cpc><classification-cpc mxw-id="PCL2071002707" load-source="docdb" scheme="CPC">G11B  27/034       20130101 FI20140422BHEP        </classification-cpc><classification-cpc mxw-id="PCL2071004565" load-source="docdb" scheme="CPC">H04N   9/8227      20130101 LA20140423BHEP        </classification-cpc><classification-cpc mxw-id="PCL2071004725" load-source="docdb" scheme="CPC">H04N   9/8063      20130101 LA20140423BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132179826" lang="DE" load-source="patent-office">Verfahren und Systeme zur Verarbeitung der Digitaldatenrate und zur Änderung der Wiedergaberichtung</invention-title><invention-title mxw-id="PT132179827" lang="EN" load-source="patent-office">Methods and systems for processing digital data rate and directional playback changes</invention-title><invention-title mxw-id="PT132179828" lang="FR" load-source="patent-office">Procédés et systèmes de traitement de taux de données numériques et de change de lecture directionnelle</invention-title><citations><patent-citations><patcit mxw-id="PCIT377496192" load-source="docdb" ucid="US-83968201-A" dnum-type="application"><document-id format="epo"><country>US</country><doc-number>83968201</doc-number><kind>A</kind><date>20010420</date></document-id><sources><source name="APP" created-by-npl="N"/></sources></patcit></patent-citations></citations></technical-data><related-documents><relation type="division"><child-doc ucid="EP-13185692-A"><document-id load-source="patent-office" format="epo"><country>EP</country><doc-number>13185692</doc-number><kind>A</kind><date>20030623</date></document-id></child-doc><parent-doc ucid="EP-03014095.8"><document-id load-source="patent-office" format="epo"><country>EP</country><doc-number>03014095.8</doc-number><date>20030623</date></document-id></parent-doc></relation></related-documents><parties><applicants><applicant mxw-id="PPAR918157898" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>MICROSOFT CORP</last-name><address><country>US</country></address></addressbook></applicant><applicant mxw-id="PPAR918141052" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>MICROSOFT CORPORATION</last-name></addressbook></applicant><applicant mxw-id="PPAR918986052" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>MICROSOFT CORPORATION</last-name><iid>100178266</iid><address><street>One Microsoft Way</street><city>Redmond, Washington 98052-6399</city><country>US</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR918148440" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>EVANS GLENN F</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918139683" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>EVANS, GLENN F.</last-name></addressbook></inventor><inventor mxw-id="PPAR918980757" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>EVANS, GLENN F.</last-name><address><street>7833 NE 133rd Pl.</street><city>Kirkland, 98034</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918150990" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>CHAKRABARTI ALOK</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918139816" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>CHAKRABARTI, ALOK</last-name></addressbook></inventor><inventor mxw-id="PPAR918979132" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>CHAKRABARTI, ALOK</last-name><address><street>5724 141st Pl SE.</street><city>Bellevue, WA Washington 98006</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918171067" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>GATES MATTHIJS A</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR918159960" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>GATES, MATTHIJS A.</last-name></addressbook></inventor><inventor mxw-id="PPAR918990690" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>GATES, MATTHIJS A.</last-name><address><street>1318 Broadmoor Drive E.</street><city>Seattle, WA Washington 98112</city><country>US</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR918981424" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Goddar, Heinz J.</last-name><iid>100002032</iid><address><street>Boehmert &amp; Boehmert Pettenkoferstrasse 20-22</street><city>80336 München</city><country>DE</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS548845757" load-source="docdb">AT</country><country mxw-id="DS548801394" load-source="docdb">BE</country><country mxw-id="DS548847128" load-source="docdb">BG</country><country mxw-id="DS548843419" load-source="docdb">CH</country><country mxw-id="DS548843315" load-source="docdb">CY</country><country mxw-id="DS548845758" load-source="docdb">CZ</country><country mxw-id="DS548801395" load-source="docdb">DE</country><country mxw-id="DS548843316" load-source="docdb">DK</country><country mxw-id="DS548843317" load-source="docdb">EE</country><country mxw-id="DS548842483" load-source="docdb">ES</country><country mxw-id="DS548847129" load-source="docdb">FI</country><country mxw-id="DS548835758" load-source="docdb">FR</country><country mxw-id="DS548801396" load-source="docdb">GB</country><country mxw-id="DS548843318" load-source="docdb">GR</country><country mxw-id="DS548845759" load-source="docdb">HU</country><country mxw-id="DS548843420" load-source="docdb">IE</country><country mxw-id="DS548835759" load-source="docdb">IT</country><country mxw-id="DS548843319" load-source="docdb">LI</country><country mxw-id="DS548802222" load-source="docdb">LU</country><country mxw-id="DS548847130" load-source="docdb">MC</country><country mxw-id="DS548845760" load-source="docdb">NL</country><country mxw-id="DS548847131" load-source="docdb">PT</country><country mxw-id="DS548845761" load-source="docdb">RO</country><country mxw-id="DS548843320" load-source="docdb">SE</country><country mxw-id="DS548835760" load-source="docdb">SI</country><country mxw-id="DS548801397" load-source="docdb">SK</country><country mxw-id="DS548802223" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA128669785" lang="EN" load-source="patent-office"><p id="pa01" num="0001">Various methods and systems permit digital data, such as video data, audio/video data, audio/video/subpicture data and the like, to be processed in a manner that permits playback at different speeds in both forward and reverse directions. Various embodiments are also directed to handling playback rate changes in a manner that can enhance the user's experience.
<img id="iaf01" file="imgaf001.tif" wi="125" he="99" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA128499158" lang="EN" source="EPO" load-source="docdb"><p>Various methods and systems permit digital data, such as video data, audio/video data, audio/video/subpicture data and the like, to be processed in a manner that permits playback at different speeds in both forward and reverse directions. Various embodiments are also directed to handling playback rate changes in a manner that can enhance the user's experience.</p></abstract><description mxw-id="PDES63955215" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><b><u>TECHNICAL FIELD</u></b></heading><p id="p0001" num="0001">This invention relates to methods and systems for processing renderable digital data, such as video data, audio/video data, and the like. In particular, the invention relates to methods and systems for processing playback speed or rate changes and directional changes (i.e. forward and reverse data playback).</p><heading id="h0002"><b><u>BACKGROUND</u></b></heading><p id="p0002" num="0002">As the performance of processors, acceleration hardware and storage devices continue to improve, playback speeds beyond normal (i.e., 1.0) are possible. However, buffering and stream alignment issues limit the degree of interactivity between an application and user-perceived changes in the actual playback speed. It is possible to solve this problem in a monolithic and closed environment, where all the components of the solution are intertwined. But it's a much harder issue in the case of an open and componentized solution. Several attempts have been made to solve the problem, although each has fundamental flaws and oversights that have limited their usefulness.</p><p id="p0003" num="0003">The playback rate (also referred to as the playback speed) determines the amount of time that each frame of data is displayed. Fast playback rates typically display frames for shorter periods of time than slower playback rates. Fast playback rates have high bandwidth requirements that can exceed most processor storage retrieval and hardware capabilities. Usually fast playback rates are <i>approximated</i> using so-called "scan modes" that selectively present only a (small) portion of a data stream by discarding some of the data of the stream. This is somewhat analogous to a rapidly progressing slide show.<!-- EPO <DP n="2"> --></p><p id="p0004" num="0004">Many video applications, such as those that execute on computers or in connection with interactive television sets, are composed of a user interface that controls a source (or source filter). The source (or source filter) is part of a data processing pipeline that processes the data so that the data can be ultimately rendered for a user. The source reads media files and typically passes the data samples or buffers (which are usually compressed using, e.g., MPEG) to some type of decoder for processing. The decoder decompresses the data and passes it to some type of renderer that is configured to and capable of rendering the data for the user. The renderer typically uses an internal (or external) clock, and various timing information that is included with the data samples themselves, to present or render the samples at the correct time. When the renderer begins processing, an initial rendering clock time can be passed to the source and decoder. The source can then begin to produce samples with timestamps that start at some point after the initial renderer time. The timestamps are used by the renderer to schedule and render the various data samples based on their authored time of presentation. Small delays between pipeline and/or processing components (such as filters), can occur since samples are buffered between each stage in the data processing pipeline. The (graph or) pipeline latency is the cumulative propagation delay of the sample from the source (filter) to the time that it is presented or rendered. It has been and continues to be a goal of developers to enable systems to <i>smoothly</i> playback data, such as video content, at different playback rates (both in the forward and reverse directions). The nature of data processing pipelines and various data formats, however, continues to present challenges to developers.</p><p id="p0005" num="0005">Consider, for example, some different data formats-the MPEG-2, DVD and HDTV formats.<!-- EPO <DP n="3"> --></p><heading id="h0003"><u>MPEG-2</u></heading><p id="p0006" num="0006">The MPEG-2 format is a format referred to as a "forward decoding" format. An example representation of an MPEG-2 format is shown in <figref idrefs="f0001">Fig. 1</figref> generally at 10. Each video sequence is composed of a series of Groups of Pictures (or "GOPs"). A GOP is composed of a sequence of pictures or frames. Frames can be encoded in three types: intra-frames (I-frames), forward predicted frames (P-frames), and bi-directional predicted frames (B-frames).</p><p id="p0007" num="0007">An I-frame or "key frame" (such as 1-frame 12) is encoded as a single image, with no reference to any past or future frames. The encoding scheme used is similar to JPEG compression. A P-frame (such as P-frame 18) is encoded relative to the past reference frame. P-frames can also be considered as "delta frames" in that they contain changes over their reference frame. A reference frame is a P- or I-frame. The past reference frame is the closest preceding reference frame. A B-frame (or bi-directional frame, such as frames 14 and 16) is encoded relative to the past reference frame, the future reference frame, or both frames. The future reference frame is the closest following reference frame (I or P). B-frames are a function of only the adjacent reference frames.</p><p id="p0008" num="0008">The GOP structure is intended to assist random access into a sequence. A GOP is typically an independently decodable unit that can be of any size as long as it begins with an I-frame.</p><p id="p0009" num="0009">One problem associated with the MPEG-2 format pertains to being able to playback the data in reverse. Playing the data forward is typically not a problem because the format itself is forward decoding-meaning that one must typically decode the I frame first and then move on to the other frames in the GOP. Playing<!-- EPO <DP n="4"> --> back the data in reverse, however, is a little more challenging because one cannot backward-decode the GOP.</p><heading id="h0004"><u>DVD</u></heading><p id="p0010" num="0010">Normally, when images are recorded on a disk, such as a DVD, the video is actually broken into small units covering a pre-determined time period (typically ½-second units or video object basic units ("VOBUs")). The advantage of this format is that when you play the video, you can progress through the video units one by one. If one wants to jump to an arbitrary piece of video, one can simply jump to the video unit of interest and the audio and video will be synchronized. The location at which all streams are synchronized is referred to as a "clean point". Accordingly, when the video and audio units are compressed, they are compressed in a unit that is to be rendered at the exact same time-that is, there is no skew between the audio and video.</p><p id="p0011" num="0011">All references to I-frames when discussed within the MPEG2 context can be extended to keyframes in other data formats. The term I-frame is synonymous with a keyframe when discussed outside of the MPEG2 context.</p><heading id="h0005"><u>HDTV: ATSC (American Television Standards (Commission) and DVB (European format)</u></heading><p id="p0012" num="0012">High Definition Television or HDTV uses the MPEG-2 format as well. Here, however, video blocks and audio blocks are aligned with a bit of a skew. In this case, one cannot simply fast forward or jump to a certain point in the stream because, while there may be a video sample at that point, the associated audio sample begins at another location in the stream. Additionally, the audio sample can only be decoded forward as a block. This means that one has to back up<!-- EPO <DP n="5"> --> within the stream and look for the associated audio sample. Depending on the particular format, one may not really know where the beginning of the corresponding audio block or sample is located. Thus, one has to keep looking back in the stream for some point before both the video and audio samples of interest.</p><p id="p0013" num="0013">With these different types of formats come challenges when one attempts to enable different playback rates and directions for an open and componentized solution.</p><p id="p0014" num="0014">Consider now <figref idrefs="f0001">Fig. 2</figref> which illustrates an exemplary system 200 that can render data from a DVD. System 200 includes an application 202 that communicates with a source component 204 that reads data off of a DVD 206. The data that is read off of the DVD includes audio and video data that has been encoded and multiplexed together. As the source reads the data off of the DVD, it applies timestamps to the data packets which are then used to synchronize and schedule the packets for rendering. The packets are then provided to a demultiplexer (or "demux") 208 which splits the packets into different constituent portions-audio, video and, if present, subpicture packets. The packets are then provided by the demultiplexer to an associated decoder such as video decoder 210 (for decoding video packets), audio decoder 212 (for decoding audio packets) and subpicture decoder 214 (for decoding subpicture packets). Each one of the packets has associated timing information, which defines when the packet is supposed to be rendered. The various decoders then decompress their associated packets and send the individual data samples or packets (including the packets' timestamps) to the appropriate renderers—such as video renderer 216 and audio renderer 218.<!-- EPO <DP n="6"> --></p><p id="p0015" num="0015">System 200 also typically includes a global clock 220 that is used by the various renderers to ascertain when to render certain data samples whose timestamps coincide with a time indicated by the global clock.</p><p id="p0016" num="0016">Assume now that a user indicates, via application 202, that he/she wish to have the data samples rendered at a different, perhaps faster rate.</p><p id="p0017" num="0017">A past approach for regulating a forward rate change is to manipulate the global clock 22 0. That is, if one wishes to play data twice as fast as the normal rate, then by manipulating the speed of the global clock, the desired rate change can be implemented. The problem with this approach is that the audio renderer can experience problems associated with frequency shifts and distorted audio output-which degrades the user's experience. Additionally, when the video renderer attempts to comply with the clock change, the video renderer can get behind in its processing which results in the renderer dropping samples to attempt to catch up. The overall result of this is a frequency shift on the audio, and a tug-and-pull on the video. The subpicture component, which can produce data that gets sent to the video renderer, can also have problems associated with the global clock change thus causing, for example, the subpicture to be rendered at an inappropriate time or in connection with inappropriate video. Thus, the quality of the output can be significantly degraded.</p><p id="p0018" num="0018">Another approach that attempts to deal with a forward rate change is to have source 204 notify demultiplexer 208, which, in turn, notifies video decoder 210 to make the appropriate rate change. The decoder 210 can then do scaling operations on the samples' timestamps to make the video play at a different rate. The problem with this approach is that there is no guarantee that the video decoder 210, audio decoder 212 and subpicture decoder 214 will process the samples using<!-- EPO <DP n="7"> --> the same techniques and algorithms-which is particularly true if the different decoders come from different vendors. Hence, the rate change can be affected at slightly different speeds which, in turn, can cause the video and audio to start to drift. Even worse, the subpicture can become unsynchronized which can cause it to appear at the wrong time.</p><p id="p0019" num="0019">Additionally, these two approaches were only really employed in the context of forward-played video and not backward-played video. Using these past approaches, there really was (and is) no way to tell the video renderer to play the video backwards. The video renderer typically has no control over or knowledge about how the video is read off of the disk.</p><p id="p0020" num="0020">Accordingly, this invention arose out of concerns associated with providing improved methods and systems for processing renderable digital data.</p><heading id="h0006"><b><u>SUMMARY</u></b></heading><p id="p0021" num="0021">Various methods and systems permit digital data, such as video data, audio/video data, audio/video/subpicture data and the like, to be processed in a manner that permits playback in both forward and reverse directions. Various embodiments are also directed to handling playback rate changes in a manner that can enhance the user's experience.</p><heading id="h0007"><b><u>BRIEF DESCRIPTION OF THE DRAWINGS</u></b></heading><p id="p0022" num="0022"><ul><li><figref idrefs="f0001">Fig. 1</figref> is diagram of an exemplary block of data that can b e processed in accordance with one or more embodiments.</li><li><figref idrefs="f0001">Fig. 2</figref> is a block diagram of a system for processing data blocks.<!-- EPO <DP n="8"> --></li><li><figref idrefs="f0002">Fig. 3</figref> is a block diagram of an exemplary computing environment within which principles of the described embodiment can be implemented.</li><li><figref idrefs="f0003">Fig. 4</figref> is a block diagram of a system for processing data blocks in accordance with one embodiment.</li><li><figref idrefs="f0004">Fig. 5</figref> is a flow diagram that describes steps in a method in accordance with one embodiment.</li><li><figref idrefs="f0005">Fig. 6</figref> is a block diagram of a system for processing data blocks and illustrates certain aspects of one or more of the described embodiments.</li><li><figref idrefs="f0006">Fig. 7</figref> is a flow diagram that describes steps in a method in accordance with one embodiment.</li><li><figref idrefs="f0007">Fig. 8</figref> is a flow diagram that describes steps in a method in accordance with one embodiment.</li><li><figref idrefs="f0008 f0009">Figs. 9-13</figref> are diagrams that illustrate exemplary data blocks in a manner that is useful for understanding one or more of the described embodiments.</li><li><figref idrefs="f0010">Fig. 14</figref> is block diagram of an exemplary system for processing data blocks in accordance with one embodiment.</li><li><figref idrefs="f0011">Fig. 15</figref> is block diagram of an exemplary system for processing data blocks in accordance with one embodiment.</li><li><figref idrefs="f0012">Fig. 16</figref> is a diagram that illustrates a technique for processing complex data in accordance with one embodiment.</li></ul></p><heading id="h0008"><b><u>DETAILED DESCRIPTION</u></b></heading><heading id="h0009"><b><u>Overview</u></b></heading><p id="p0023" num="0023">Various methods and systems described below permits digital data, such as video data, audio/video data, audio/video/subpicture data, to be processed in a<!-- EPO <DP n="9"> --> manner that permits smooth playback in both forward and reverse directions. Additionally, playback rate changes can be handled in a manner that enhances the user's experience.</p><heading id="h0010"><b><u>Exemplary Computing System</u></b></heading><p id="p0024" num="0024"><figref idrefs="f0002">Fig. 3</figref> illustrates an example of a suitable computing environment 300 on which the system and related methods described below can be implemented.</p><p id="p0025" num="0025">It is to be appreciated that computing environment 300 is only one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the media processing system. Neither should the computing environment 300 be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary computing environment 300.</p><p id="p0026" num="0026">The various described embodiments can be operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and/or configurations that may be suitable for use with the media processing system include, but are not limited to, personal computers, server computers, thin clients, thick clients, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.</p><p id="p0027" num="0027">In certain implementations, the system and related methods may well be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules<!-- EPO <DP n="10"> --> include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The embodiments can also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.</p><p id="p0028" num="0028">In accordance with the illustrated example embodiment of <figref idrefs="f0002">Fig. 3</figref>, computing system 300 is shown comprising one or more processors or processing units 302, a system memory 304, and a bus 306 that couples various system components including the system memory 304 to the processor 302.</p><p id="p0029" num="0029">Bus 306 is intended to represent one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnects (PCI) bus also known as Mezzanine bus.</p><p id="p0030" num="0030">Computer 300 typically includes a variety of computer readable media. Such media may be any available media that is locally and/or remotely accessible by computer 300, and it includes both volatile and non-volatile media, removable and non-removable media.</p><p id="p0031" num="0031">In <figref idrefs="f0002">Fig. 3</figref>, the system memory 304 includes computer readable media in the form of volatile, such as random access memory (RAM) 310, and/or non-volatile<!-- EPO <DP n="11"> --> memory, such as read only memory (ROM) 308. A basic input/output system (BIOS) 312, containing the basic routines that help to transfer information between elements within computer 300, such as during start-up, is stored in ROM 308. RAM 310 typically contains data and/or program modules that are immediately accessible to and/or presently be operated on by processing unit(s) 302.</p><p id="p0032" num="0032">Computer 300 may further include other removable/non-removable, volatile/non-volatile computer storage media. By way of example only, <figref idrefs="f0002">Fig. 3</figref> illustrates a hard disk drive 328 for reading from and writing to a non-removable, non-volatile magnetic media (not shown and typically called a "hard drive"), a magnetic disk drive 330 for reading from and writing to a removable, non-volatile magnetic disk 332 (e.g., a "floppy disk"), and an optical disk drive 334 for reading from or writing to a removable, non-volatile optical disk 336 such as a CD-ROM, DVD-ROM or other optical media. The hard disk drive 328, magnetic disk drive 330, and optical disk drive 334 are each connected to bus 306 by one or more interfaces 326.</p><p id="p0033" num="0033">The drives and their associated computer-readable media provide nonvolatile storage of computer readable instructions, data structures, program modules, and other data for computer 300. Although the exemplary environment described herein employs a hard disk 328, a removable magnetic disk 332 and a removable optical disk 336, it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, random access memories (RAMs), read only memories (ROM), and the like, may also be used in the exemplary operating environment.<!-- EPO <DP n="12"> --></p><p id="p0034" num="0034">A number of program modules may be stored on the hard disk 328, magnetic disk 3 32, optical disk 336, ROM 308, or RAM 310, including, by way of example, and not limitation, an operating system 314, one or more application programs 316 (e.g., multimedia application program 324), other program modules 318, and program data 320. A user may enter commands and information into computer 300 through input devices such as keyboard 338 and pointing device 340 (such as a "mouse"). Other input devices may include an audio/video input device(s) 353, a microphone, joystick, game pad, satellite dish, serial port, scanner, or the like (not shown). These and other input devices are connected to the processing unit(s) 302 through input interface(s) 342 that is coupled to bus 306, but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB).</p><p id="p0035" num="0035">A monitor 356 or other type of display device is also connected to bus 306 via an interface, such as a video adapter or video/graphics card 344. In addition to the monitor, personal computers typically include other peripheral output devices (not shown), such as speakers and printers, which may be connected through output peripheral interface 346.</p><p id="p0036" num="0036">Computer 300 may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer 350. Remote computer 350 may include many or all of the elements and features described herein relative to computer.</p><p id="p0037" num="0037">As shown in <figref idrefs="f0002">Fig. 3</figref>, computing system 300 is communicatively coupled to remote devices (e.g., remote computer 350) through a local area network (LAN) 351 and a general wide area network (WAN) 352. Such networking environments<!-- EPO <DP n="13"> --> are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.</p><p id="p0038" num="0038">When used in a LAN networking environment, the computer 300 is connected to LAN 351 through a suitable network interface or adapter 348. When used in a WAN networking environment, the computer 300 typically includes a modem 354 or other means for establishing communications over the WAN 352. The modem 354, which may be internal or external, may be connected to the system bus 306 via the user input interface 342, or other appropriate mechanism.</p><p id="p0039" num="0039">In a networked environment, program modules depicted relative to the personal computer 300, or portions thereof, may be stored in a remote memory storage device. By way of example, and not limitation, <figref idrefs="f0002">Fig. 3</figref> illustrates remote application programs 316 as residing on a memory device of remote computer 350. It will be appreciated that the network connections shown and described are exemplary and other means of establishing a communications link between the computers may be used.</p><heading id="h0011"><b><u>First Exemplary Embodiment -Reverse Playback/Rate Changes</u></b></heading><p id="p0040" num="0040"><figref idrefs="f0003">Fig. 4</figref> diagrammatically illustrates a first embodiment in which digital data that is embodied on some type of media is processed so that it can be rendered in reverse. In this example, a system includes an application 400 th at provides an interface through which a user can interact with the particular digital media that is to be processed and rendered. The system also includes one or more sources 402 for reading the data that is to be rendered, one or more decoders 406 for decoding or decompressing data that is to be rendered, and one or more renderers 408 for rendering the data (although only one of each type of component is shown).<!-- EPO <DP n="14"> --> Digital media which is to be rendered by renderer 408 is provided on a media 410 which, in this example, comprises a disk such as a DVD. However, any type of medium can be utilized to store the digital media. It should be appreciated that while the source, decoder and renderer are shown as separate individual components, it is possible for the functionality of each to be provided in a more integrated fashion.</p><p id="p0041" num="0041">Media 410 typically holds a large amount of data that can be rendered. The data is usually organized into logical units. Here, the logical units are represented as <i>blocks</i>. The term "blocks" is not intended to designate any specific type of data or medium. Rather, the term is used to illustrate the principles under which this embodiment operates. Accordingly, the illustrated blocks can represent different types or formats of data which usually break up the data into sections beginning with keyframes. For example, the blocks can comprise GOPs such as would be utilized to format data in the MPEG-1 or MPEG-2 format. The blocks can also represent VOBUs such as would be used to format data on a DVD.</p><p id="p0042" num="0042">One characteristic of such blocks is that the individual blocks are comprised of sub-portions that represent sub-components of the blocks. So, in the case where the block represents a GOP, individual sub-portions can include an I-frame and one or more P-frames or B-frames. The sub-portions of each block are indicated numerically inside each block. For example, Block 1 is comprised of sub-portions 1, 2, 3, and 4, each of which indicating a video frame.</p><p id="p0043" num="0043">Blocks can also be decomposed into smaller independent subblocks which are passed to downstream components to be processed as blocks. For example, in DVD a VOBU could contain several GOPs. The VOBU block can be broken into several subblocks, each containing a GOP. This is useful when playing content in<!-- EPO <DP n="15"> --> reverse, since the larger blocks can be decomposed into smaller blocks whose order is reversed when they are sent downstream. New timestamps need to be computed for each of the new subblocks (see <figref idrefs="f0010">figure 14</figref>).</p><p id="p0044" num="0044">When a user indicates, via application 400, that they wish to play particular data (such as video data) in reverse, application 400 notifies source 402 that reverse playback is intended. The application can also typically indicate a time range or <i>source time</i> over which the reverse playback is to occur. When the source 402 enters a time period over which the reverse playback is to occur, the source reads blocks of data within the relative source time in reverse.</p><p id="p0045" num="0045">Consider, for example, <figref idrefs="f0003">Fig. 4</figref>. Notice that media 410 is shown to include three individual blocks (designated as Block 1, Block 2 and Block 3) as group A. Actually, media 410 includes many more blocks than those illustrated. Assume though, in this instance, that the user has indicated to source 402 via application 400 that they desire to play the blocks of group A in reverse.</p><p id="p0046" num="0046">As the source reads data from media 410 it keeps track of the source time and when the source time coincides with Blocks 1-3, Blocks 1-3 are read in reverse order. Specifically, Block 3 is read first, then Block 2, and then Block 1. Hence, notice to the left of source 402 that the ordering of the blocks, as read, is Block 3/Block 2/Block 1 to define a group B. Source 402 then adds one or more flags to the blocks to indicate that they are intended for reverse playback. Specifically, notice that a start flag is added to Block 3 and an end flag is added to Block 1. Any suitable arrangement of flags can be used to designate the blocks for reverse playback. For example, the flags can be added to each block. Source 402 can also process the blocks by adding timestamps to the blocks. This can be done<!-- EPO <DP n="16"> --> by mapping each block's source time to monotonically increasing timestamps that are used by the renderer to schedule rendering activities.</p><p id="p0047" num="0047">Each block is then provided by source 402 to decoder 406. It will be appreciated that a demultiplexer or splitter can be interposed between the source and decoder-but for simplicity sake is not illustrated here. So, in this example, Block 3 can be provided to decoder 406, then Block 2 and finally Block 1. Alternately, the source can pre-parse blocks and send smaller subblocks of a block at a time in reverse order to the decoder for processing or decoding/decompressing. This reduces the size of the blocks propagating to the decoder.</p><p id="p0048" num="0048">When the decoder 406 receives the blocks, it has to decode from left to right. But the flags on the block indicate to the decoder that it is to decode the blocks and reverse the order of the sub-portions (frames) of the blocks that it emits to renderer 408. Specifically, when decoder 406 receives Block 3, it decodes the block as usual and can buffer the decoded block portions while it processes the other blocks. The decoder 406 similarly processes Blocks 2 and 1. When the decoder reaches the end flag, it knows that the particular block sequence for which reverse play is to occur has been defined. The decoder can now reverse the timestamps on the block sub-portions and can emit the block sub-portions to renderer 408 in reverse order: The emitted block sub-portions are designated as group C.</p><p id="p0049" num="0049">As can be seen, the renderer receives a stream of data that is reversed relative to the order that the stream would have if it was forward-played. The renderer can now schedule the stream for rendering. The renderer here is unaware<!-- EPO <DP n="17"> --> of the stream being played in reverse direction, as that detail is confined within the source and decoder components.</p><p id="p0050" num="0050">Now assume that the user wishes to implement a rate change to change the playback rate. In this embodiment, rate changes can be implemented as follows. Assume that a user wishes to have data rendered at a rate that is faster or slower than normal, i.e., 1x. Rate changes can be communicated to source 402 via application 400. The rate change information can be provided from the source to decoder 406 so that rate change processing can be performed by the decoder. In this embodiment, the decoder can perform rate change processing by manipulating the timestamps of the samples or block sub-portions that it processes. For example, if a group of samples is to be rendered at 1x and has timestamps that extend from <i>t<sub>1</sub></i> to <i>t<sub>4</sub></i>, such samples can be rendered at 2x by changing the timestamps from <i>t<sub>1</sub></i> - <i>t<sub>4</sub></i> to <i>t<sub>1</sub></i> - t<sub>2</sub>, where <i>t<sub>2</sub> - t<sub>1</sub></i> = (<i>t<sub>4</sub></i> - <i>t<sub>1</sub></i>) / 2.</p><p id="p0051" num="0051"><figref idrefs="f0004">Fig. 5</figref> is a flow diagram that describes steps in a method in accordance with one embodiment. The method can be implemented in any suitable hardware, software, firmware or combination thereof. In the illustrated example, the method can be implemented in connection with the system shown and described in connection with <figref idrefs="f0003">Fig. 4</figref>.</p><p id="p0052" num="0052">Step 500 receives an indication that reverse playback is desired. This step can be implemented by receiving a communication or call from a software application that reverse playback is desired. This communication can include a range of source times over which reverse playback is desired. Step 502 arranges one or more data blocks to define a playback order. This step can be implemented by reading blocks that correspond to an indicated source time range in reverse. One example of how this can be done is given above. Step 504 associates one or<!-- EPO <DP n="18"> --> more flags with the data block(s). The flag or flags are intended to indicate that one or more of the blocks of interest are subject to reverse playback. Here, a reverse playback start flag and a reverse playback end flag can be associated with the block(s) of interest.</p><p id="p0053" num="0053">Step 506 decodes blocks into individual block sub-portions and can further process the block sub-portions pursuant to the desired reverse playback. This can include, for example, buffering the block sub-portions for a predetermined period of time. For example, the block sub-portions can be buffered until all of the block sub-portions intended for reverse playback have been decoded. Alternately or additionally, the block sub-portions can be buffered until a pre-determined number or amount of sub-portions have been buffered. The buffered decoded data can also be used with compressed source data to completely regenerate the reverse playback stream. Additionally, the block sub-portions can also be processed so as to manipulate their associated timestamps. This can include reversing the effective order of the timestamps for the individual sub-portions. This can also include any timestamp processing due to any rate changes that might be requested. Such timestamp processing can include changing the values of the timestamps.</p><p id="p0054" num="0054">Step 508 emits the block sub-portions in reverse order. In this step, the flag(s) of step 504 can be utilized to indicate that the block sub-portions should be emitted in reverse order. Thus, when for example, decoder 406 (<figref idrefs="f0003">Fig. 4</figref>) processes the block sub-portions, the presence of any flags can indicate that the decoder should emit the block sub-portions in reverse order. The decoder can then emit the block sub-portions in reverse order. One example of how this is done is given above. Step 510 then renders the emitted block sub-portions in the reverse order that the sub-portions were emitted.<!-- EPO <DP n="19"> --></p><p id="p0055" num="0055">The same algorithm can be applied to break up a block into subblocks, which may be used by higher level components such as the source or decoder. Effectively, the source is breaking up the entire video into subblocks (VOBUs in the DVD case) and emitting them in reverse order with reversed timestamps. The decoder can break the VOBUs into GOP blocks to pass to the renderer by reading and caching a VOBU, then emitting the cached data in reverse order.</p><p id="p0056" num="0056">The above-described processes and systems have a higher requirement of memory to buffer the decoded block sub-portions. But the advantages of this approach include the following. First, some systems attempt to achieve reverse playback by repeating a process that effectively jumps backward in position and plays forward for a number of frames, and then again jumps backward in position and plays forward for a number of frames. This process can become extremely computationally inefficient since it repeats work and will usually degrade the user's experience. Other approaches can only work on one data block at a time.</p><p id="p0057" num="0057">The above systems and methods can actually change the order of multiple blocks when reverse playback is desired. Further, use of flags permits the system to actually render individual block sub-portions or frames in reverse order. Also rate changes can be smoothly provided by manipulating the timestamps of the block sub-portions. Other advantages will be apparent to those of skill in the art.</p><p id="p0058" num="0058">As a performance advantage, the methods and systems described above can take advantage of various pipelined video acceleration techniques in the graphics processor. This is particularly true for the decoder. This can permit the data pipeline to effectively run continuously and can avoid initialization startup costs. Various pipelined video acceleration techniques are described in <patcit id="pcit0001" dnum="US83968201A"><text>U.S. Patent Application Serial No. 09/839,682</text></patcit>, entitled "An Extensible Multimedia<!-- EPO <DP n="20"> --> Application Program Interface And Related Methods", filed on April 20, 2001, the disclosure of which is incorporated by reference herein.</p><heading id="h0012"><b><u>Second Exemplary Embodiment-Reverse Playback/Rate Changes</u></b></heading><p id="p0059" num="0059">In the embodiment described above, the decoder was configured to process any rate changes as well as any reverse playback requests from the application. Systems for pro cessing renderable data can, however, include more components in the chain or processing pipeline. For example, one type of processing pipeline is known as a filter graph. Filter graph is a directed network of filters (or processing units). It can contain many different types of filters that are configured to process data to be finally rendered. In addition to source and decoder filters, such filter graphs can contain transform filters, effects filters, network links, analysis filters and the like.</p><p id="p0060" num="0060">It can be advantageous to distribute playback and rate change processing across the system, pipeline or filter graph. One reason for this is increased flexibility of implementation as well as an open and extensible architecture. For example, if the user requests a rate change for a sample that has already been processed by the decoder, but which is queued up at a downstream component that is unable to effectuate the rate change, most if not all current systems will typically ignore the rate change.</p><p id="p0061" num="0061">Typically, rate changes can take place in one of two ways. First, the user can request that a rate change take place presently or "now, which semantically means at the next available time. Perhaps the user manipulates a slider in UI that affects the playback rate. Second, a rate change can be scheduled at a given location in the source content. For example, perhaps the user indicates that a rate<!-- EPO <DP n="21"> --> change to 2x is desirable starting at a source time of 00:00:05. These two scenarios are fundamentally different. The first scenario is the more difficult scenario because of the timing of the request and the state of the processing pipeline at that moment. It's possible that the source content has already been read by the source and forwarded to the next component in the pipeline. The second scenario is a less difficult problem, because one knows where the rate changes are going to occur and hence, the rate changes can be scheduled in advance.</p><p id="p0062" num="0062">As noted above, when the source processes data, it reads the data from a particular medium and maps source times associated with the data to timestamps that are used to schedule rendering. For example, the table immediately below illustrates a representation of the mapping operation that is performed by the source for a forward play at 1x.
<tables id="tabl0001" num="0001"><table frame="all"><tgroup cols="2"><colspec colnum="1" colname="col1" colwidth="24mm"/><colspec colnum="2" colname="col2" colwidth="27mm"/><thead><row><entry><b>Source Time</b></entry><entry><b>Timestamp</b></entry></row></thead><tbody><row><entry valign="bottom">00:00:01</entry><entry valign="bottom">Frame 1 (0 sec.)</entry></row><row><entry valign="bottom">00:00:02</entry><entry valign="bottom">Frame 2 (1 sec.)</entry></row><row><entry valign="bottom">00:00:03</entry><entry valign="bottom">Frame 3 (2 sec.)</entry></row><row><entry valign="bottom">00:00:04</entry><entry valign="bottom">Frame 4 (3 sec.)</entry></row><row><entry valign="bottom">00:00:05</entry><entry valign="bottom">Frame 5 (4 sec.)</entry></row></tbody></tgroup></table></tables></p><p id="p0063" num="0063">In the table above, source times that correspond to 00:00:01 through 00:00:05 are mapped to timestamps that coincide with particular frames that are to be rendered. For example, 00:00:01 maps to a timestamp that corresponds to<!-- EPO <DP n="22"> --> Frame 1; 00:00:02 maps to a timestamp that corresponds to Frame 2 and so on. Thus, there is a one-to-one mapping relationship for forward playback at 1x.</p><p id="p0064" num="0064">When there is a request for a reverse playback, the mapping operation is charged somewhat. In this instance, the source still maps source times to timestamps. However, the source does so in a manner that not only provides a continuous, monotonically increasing stream of timestamps, but takes into account the reverse playback request as well. For example, the table below illustrates a mapping operation for a reverse playback at 1x over the source time range of 00:00:01 through 00:00:05:
<tables id="tabl0002" num="0002"><table frame="all"><tgroup cols="2"><colspec colnum="1" colname="col1" colwidth="24mm"/><colspec colnum="2" colname="col2" colwidth="27mm"/><thead><row><entry><b>Source Time</b></entry><entry><b>Timestamp</b></entry></row></thead><tbody><row><entry valign="bottom">00:00:01</entry><entry valign="bottom">Frame 5 (0 sec.)</entry></row><row><entry valign="bottom">00:00:02</entry><entry valign="bottom">Frame 4 (1 sec.)</entry></row><row><entry valign="bottom">00:00:03</entry><entry valign="bottom">Frame 3 (2 sec.)</entry></row><row><entry valign="bottom">00:00:04</entry><entry valign="bottom">Frame 2 (3 sec.)</entry></row><row><entry valign="bottom">00:00:05</entry><entry valign="bottom">Frame 1 (4 sec.)</entry></row></tbody></tgroup></table></tables></p><p id="p0065" num="0065">Notice here that the source times are reassigned to reflect reverse playback, but the corresponding timestamps continue to monotonically increase. Thus, when the renderer receives the data samples, it will schedule rendering so as to affect reverse playback.</p><p id="p0066" num="0066">Now assume that there is a jump to another portion of the source content. Perhaps the source content is to be rendered for a source time range of 00:00:01 through 00:00:05, and then there is to be a jump to a source time range of 00:00:20<!-- EPO <DP n="23"> --> through 00:00:24. In this case, the mapping operation would produce a stream of monotonically increasing timestamps as follows:
<tables id="tabl0003" num="0003"><table frame="all"><tgroup cols="2"><colspec colnum="1" colname="col1" colwidth="24mm"/><colspec colnum="2" colname="col2" colwidth="29mm"/><thead><row><entry><b>Source Time</b></entry><entry><b>Timestamp</b></entry></row></thead><tbody><row><entry valign="bottom">00:00:01</entry><entry valign="bottom">Frame 1 (0 sec.)</entry></row><row><entry valign="bottom">00:00:02</entry><entry valign="bottom">Frame 2 (1 sec.)</entry></row><row><entry valign="bottom">00:00:03</entry><entry valign="bottom">Frame 3 (2 sec.)</entry></row><row><entry valign="bottom">00:00:04</entry><entry valign="bottom">Frame 4 (3 sec.)</entry></row><row><entry valign="bottom">00:00:05</entry><entry valign="bottom">Frame 5 (4 sec.)</entry></row><row><entry valign="bottom">00:00:20</entry><entry valign="bottom">Frame 6 (5 sec.)</entry></row><row><entry valign="bottom">00:00:21</entry><entry valign="bottom">Frame 7 (6 sec.)</entry></row><row><entry valign="bottom">00:00:22</entry><entry valign="bottom">Frame 8 (7 sec.)</entry></row><row><entry valign="bottom">00:00:23</entry><entry valign="bottom">Frame 9 (8 sec.)</entry></row><row><entry valign="bottom">00:00:24</entry><entry valign="bottom">Frame 10 (9 sec.)</entry></row></tbody></tgroup></table></tables></p><p id="p0067" num="0067">Thus, in this embodiment, the source's responsibility is to receive requests from the application and map the context based location of the source data (i.e. the source times) into monotonically increasing output timestamps. In doing so, a continuous stream of data can be provided to the renderer for rendering. This is advantageous from the standpoint of other components, particularly the decoder, in that the other component do not need to keep track of timestamps and where they are in a particular process. Rather, the other components can simply receive and process samples having a linear stream of timestamps.<!-- EPO <DP n="24"> --></p><p id="p0068" num="0068">To facilitate processing at the source, the source can maintain a history of when it performed rate changes and where the rate changes map into a list of events that are to occur in the future. Then, if the application starts asking for rate changes at a particular time, the source is aware of how it has organized the rate changes in the past. It is also aware of whether the source content associated with any rate changes has already been passed to a downstream component for processing. If so, the source can take steps to attempt to have the rate change implemented by, for example, passing the rate change request to downstream components and having those components perform associated processing for implementing the rate change. In other approaches, any such rate change requests for source content that had already left the source were simply dropped.</p><heading id="h0013"><u>Querying the Pipeline to Ascertain Component Capabilities</u></heading><p id="p0069" num="0069">One advantageous feature of some of the embodiments described above and below is that the source has the ability to query components within the processing pipeline to ascertain the capabilities of the components. For example, the source can query the components such as the decoder to ascertain whether they support reverse playback, which playback rates they support, their maximum and minimum playback rates and the like. By doing so, the source can then make intelligent decisions concerning how it reads the source data and, in some instances, the format of the source data that it sends along to the other components.</p><p id="p0070" num="0070">As an example, consider the following. To implement rate changes and to do so intelligently, it can be advantageous for the source to know the maximum rate that is supported by the entire pipeline or filter graph. This can be the case for<!-- EPO <DP n="25"> --> both forward and reverse playback. In this embodiment, one or more of the pipeline components are provided with an interface (which is simply a collection of callable methods) that can be queried by the source. When the pipeline is constructed or instantiated, the source can query one or more of the interfaces to ascertain the capabilities of the components. For example, the source might query the components to ascertain if any of them support reverse playback. If not, this can cause the source to enter a simpler mode in which it does not support reverse playback and indicate that to the application which will make the application present a smarter UI to the user. This can include, for example, to just reading the key frames of the blocks in the reverse order, rather than reverse reading the whole block and tagging them with appropriate flags, which the decoder cannot act upon anyway. Additionally, the source can query to ascertain the playback rates that are supported. By knowing this, the source can adapt its processing to ensure that it does not overwhelm the pipeline. For example, if a particular playback speed is not supported by the pipeline, then the source may only send certain block portions (e.g. I frames only) for further processing by the pipeline. This helps to ensure that the pipeline is not unduly burdened with data that it cannot efficiently process, while at the same time attempts to provide a rendered display that is as close to the requested playback rate as possible.</p><p id="p0071" num="0071">One way of implementing the querying process is as follows. When the source first starts out or is instantiated, it queries, either directly or indirectly, every component down the pipeline for their capabilities, e.g. their maximum forward and reverse rates. One way of doing this is for the source to query the first downstream component, and for the first downstream component to query its first downstream component and so on. As an example, consider <figref idrefs="f0005">Fig. 6</figref> which<!-- EPO <DP n="26"> --> shows an exemplary pipeline 600 that includes a source 602, demux 604, decoders 606, 606a, components 608, 608a, 610, 610a (which can be any suitable components), and renderers 612, 612a. In this case, source 602 queries demux 604; demux 604 queries decoders: 606, 606a, and so on. The query results can then be bubbled back up the pipeline.</p><p id="p0072" num="0072">Assume in this example that the source is interested in the maximum forward playback rates of the various components. In this example, each of the component's maximum rates is shown immediately beneath the component. So, for example, the maximum rate of renderer 612 is 2x; and the maximum rate of renderer 612a is 3x and so on. There are a couple of ways that the source can make a decision on the maximum rate of the pipeline in general. First, the source can, in a conservative approach, simply take the minimum of all of the rates of the various components. So, in this particular example, the minimum of all of the rates is 2x. Hence, with this knowledge, the source can assume that any requested rates below 2x can be rendered smoothly without having to drop meaningful amounts of data. A second, more aggressive approach, is to assume that there is a multiplicative effect as between the various components. For example, if a first component can support 2x and its downstream component can support 3x, then the maximum rate change that can be provided together by the components is 6x. Thus, in the figure, when the renderer 612 is queried by component 610, it reports a playback rate of 2x (which is indicated in parentheses between the components). Accordingly, component 610 can report, because of the multiplicative effect, a playback rate of 4x to component 608. Likewise, component 608 can report a playback rate of 8x to component 606 and so on. Assume in this example that demux 604 supports only a 1x playback rate. The demux 604 can now report to<!-- EPO <DP n="27"> --> source 602 two playback rates-16x and 32x. In accordance with this approach, the source can now select the lower of the two playback rate, i.e. 16x as the maximum playrate supported by the pipeline to achieve a generally smooth playback rate.</p><p id="p0073" num="0073">Once the source knows the rate capabilities of the pipeline (e.g. 16x), it knows that it can provide entire data blocks to the pipeline when the requested rate equal to or less than 16x and the data will be rendered at this rate. It also knows that for any requested rate changes greater than 16x, it may have to do some additional processing to attempt to provide the higher rate. This can involve sending only truncated and/or selective blocks for processing by the pipeline. This mode is referred to as a "scan mode" where, for example, only keyframes might be sent by the source to the pipeline for processing.</p><p id="p0074" num="0074"><figref idrefs="f0006">Fig. 7</figref> is a flow diagram that describes steps in a method in accordance with one embodiment. The method can be implemented in any suitable hardware, software, firmware or combination thereof. In the illustrated example, the method can be implemented in connection with a system such as the one shown and described in connection with <figref idrefs="f0005">Fig. 6</figref>.</p><p id="p0075" num="0075">Step 700 provides a data processing pipeline. Any suitable data processing pipeline can be provided. Suitable pipelines typically include one or more components that read source data off of some type of medium (such as a disk), demultiplex the data into individual data streams, decode the data and process it in some manner, and render the data for a user to enjoy. These different functionalities tend to be performed by different components-although such need not be the case.<!-- EPO <DP n="28"> --></p><p id="p0076" num="0076">Step 702 queries a component for providing playback support capabilities. Examples of playback support capabilities include, without limitation, playback rates (maximum, minimum and/or a range of rates), playback directions (forward, reverse), and the like. Step 704 determines whether there are any components downstream of a queried component. If there are, step 706 goes to the next component and returns to step 702 to query the component to provide its playback support capabilities. If there are no additional downstream components, then step 708 reports the playback support capabilities up the data processing pipeline.</p><p id="p0077" num="0077">This step can be implemented in a couple of different ways. First, as noted above, the capabilities of each component can be reported to the source, which can then make intelligent data processing decisions. For example, the playback rates of each of the components can be reported to the source so that it can select the minimum playback rate. Second, the capabilities of each of the components can be considered in connection with the capabilities of all of the other components. For example, the playback rates of all of the components in a particular pipeline or sub-pipeline can be multiplied so that an overall effective playback rate that is supported by the pipeline or sub-pipeline can be ascertained. Once ascertained, the source can make intelligent decisions on how to process data, as noted above.</p><p id="p0078" num="0078">In the example embodiments described above, every suitably configured component (filter) can be thought of as a data manipulator. That is, individual components can partially process the data and pass along appropriate hints as to how the data has been manipulated. The next component can further process the data towards achieving a desired playback rate or direction.</p><p id="p0079" num="0079">If necessary, for example, the source can reduce the amount of data that it provides to the decoder while at the same time maintain any timing information<!-- EPO <DP n="29"> --> (such as a rate change) with the data. This gives the decoder a hint that a rate change is desired. The decoder can receive the data from the source and, in addition to decoding, can process it in a manner that attempts to achieve the rate change. Components in a chain can have the option of processing the data in a manner that is directed to achieving the desired playback, or, the component can pass the data down to the next component along with information on any rate changes. Such processing can include reversing data block portions, reassigning timestamps in an event that a reverse playback request has been received, and removing any associated flags from the data.</p><p id="p0080" num="0080">Thus, in this example, the source is responsible for flipping the stream around at the block level and adding flags to indicate that reverse playback is intended. The blocks are then propagated downstream to other components. When a component encounters data having a reverse flag, the component has the option of passing the blocks to another component downstream, or processing the data to, for example, flip the order of the frames, remove the flags, and push the data to the next component. Ultimately then, the renderers receive what looks like a forward stream having appropriately increasing timestamps.</p><heading id="h0014"><b><u>Rate Changes for Blocks That Have Left the Source</u></b></heading><p id="p0081" num="0081">The above-described embodiments work well when a rate change is to occur at a given time, and the source has not yet read the data blocks over which the rate change is to be implemented. There is another situation, briefly mentioned above, where a rate change request is received after the source has read the data blocks and/or passed the blocks along to a downstream component for processing.<!-- EPO <DP n="30"> --></p><p id="p0082" num="0082">In the embodiment about to be described, flexibility is enhanced by distributing processing across the component pipeline or filter graph. Specifically, the application can request the source component to perform a rate change at a specific time or source time. The rate change information is then propagated through the pipeline until it encounters a component, whose queue contains a data sample with the source time associated with the rate change. The component can then queue up the rate change request so that the rate change is processed with the sample. When the corresponding sample is processed by the component, the component can perform any necessary processing such as altering the output data (e.g. the sample's timestamp). If further processing is necessary, the component can pass along the rate change information (as well as any other useful information) with each output sample. Eventually the renderer will receive the sample and can schedule rendering. It is to be appreciated that the renderer can also be configured to implement playback or rate change processing as part of the distributed process.</p><p id="p0083" num="0083">Another significant advantage is that the source's rate change queue is limited to data it has not sent or read yet. The remainder of the queue is distributed across the pipeline, which in most cases will be relatively short.</p><p id="p0084" num="0084">As an example, consider the following. When an application sends a rate change request to then source, the source can look in its buffers and ascertain whether the data relative to which the rate change is to take place is located in its buffers. The source can typically do this by noting the source times over which the rate change is to take place. If the data in the source's buffer have corresponding source times that are greater than the source times over which the rate change is to take place, then the data samples have already been passed to a<!-- EPO <DP n="31"> --> downstream component. If the source locates a buffer that contains a data sample subject to the rate change, the source can associate rate change information with the sample.</p><p id="p0085" num="0085">That is, in accordance with this embodiment, every data sample contains a list that includes properties that define (1) any rate changes, (2) the time range when the sample should be played, (3) whether the sample is to be played in forward or reverse. These lists are propagated along with the data sample so that components in the pipeline do not have to maintain a list of every rate change that has occurred in the past.</p><p id="p0086" num="0086">If the source checks its buffers and does not find the samples on which the rate change is to occur, the source sends the rate change request to the next downstream component. The next component then performs a similar process by checking its buffers to ascertain whether the buffers contain the sample on which the rate change is to occur. If the component finds the appropriate data sample, it can either add the rate change information to the sample when it processes the sample, or it can look into its buffers and attach the rate change information to the sample in its buffer. This process can be performed by any suitably configured components in the data pipeline.</p><p id="p0087" num="0087"><figref idrefs="f0007">Fig. 8</figref> is a flow diagram that describes steps in a method in accordance with one embodiment. The method can be implemented in any suitable hardware, software, firmware or combination thereof. In the illustrated example, the method can be implemented in connection with a system such as the one shown and described in connection with <figref idrefs="f0005">Fig. 6</figref>.</p><p id="p0088" num="0088">Step 800 receives a rate change request for a particular source time. Typically, the rate change request originates with an application and is passed to<!-- EPO <DP n="32"> --> the source. Responsive to receiving the rate change request, step 802 examines one or more buffers to ascertain whether a corresponding data sample over which the rate change is to occur is present. The buffers that are examined are the buffers that are associated with the component that received the rate change request. If the sample is found (step 804) then step 806 attaches rate change information to the sample. This step can be implemented in a couple of ways. For example, the rate change information can be attached to the sample while it is in the buffer. This can be implemented when the buffer is a read/write queue. Alternately, the rate change information can be cached and attached to the sample when it is processed by the component. This step can be implemented when the buffer is a read only queue.</p><p id="p0089" num="0089">If, on the other hand, the sample is not found in the component's buffers, step 808 sends the rate change request to the next in line downstream component. Step 810 then examines the buffers associated with the downstream component. This step can be implemented by the component that received the rate change request. If the sample is found (step 812), the method can branch to step 806. If, on the other hand, the sample is not found, step 814 determines whether there is another downstream component. If so, the method branches to step 808 and sends the rate change request to the next component. If, on the other hand, there are no additional downstream components, step 816 discards the rate change request. Presumably, this step is implemented by the renderer. Discarding the rate change request will only have a temporary effect on the output rate of the rendering.<!-- EPO <DP n="33"> --></p><heading id="h0015"><b><u>Rate Changes for Data Without Clean Points</u></b></heading><p id="p0090" num="0090">Multiplexed data streams (such as ATSC MPEG2) may not necessarily have secondary streams aligned at the video's keyframes. This poses problems when attempting to break up the content into distinct blocks separated by keyframes.</p><p id="p0091" num="0091">There are two solutions to generate data for the secondary streams for an arbitrary time interval corresponding to the block of primary stream data:
<ol><li>1) Trimming<br/>
The source seeks backwards in the content such that every stream has data present in the interval and each stream is told to skip to the start timestamp of the interval.</li><li>2) Discard fragments<br/>
The source seeks to the start of the primary stream and the secondary stream discard the block fragments until the next frame start. The stream will be missing data for this interval and a discontinuity will have to be sent at the start of the interval.</li></ol></p><p id="p0092" num="0092">A truncation marker will need to be inserted in each stream to end the data after the time interval. <figref idrefs="f0012">Fig. 16</figref> illustrates how extra data can be read for secondary streams and how it can be modified to match the video stream interval. For forward playback, rate changes in the same direction during full frame mode are not affected by clean points.</p><p id="p0093" num="0093">For forwards or reverse keyframe scan mode, the secondary streams either need to be trimmed or fragmented. Since a large amount of data is being skipped<!-- EPO <DP n="34"> --> anyways, fragmentation may be preferable since it will simplify the source's design. More complex seeking can be added as an enhancement, but may incur a performance cost due to the seeking and interaction with the reader.</p><p id="p0094" num="0094">For smooth reverse playback, trimmed secondary streams are required for continuous reverse audio. However, the buffering requirements (twice the buffer space) on the source and the extra rapid decoding/discarding may not be feasible. However the audio decoding is relatively fast compared to the video decoding.</p><p id="p0095" num="0095">The source is responsible for discarding samples outside of the trimming range.</p><heading id="h0016"><b><u>Implementation Example</u></b></heading><p id="p0096" num="0096">Aspects of the above-described embodiments will now be described in the context of a specific implementation example. It is to be understood that the example described below is intended for illustrative purposes and should not be construed to limit application of the claimed subject matter.</p><p id="p0097" num="0097">The example about to be described utilizes the following architectural aspects. An IRateChangeData interface is provided on each sample and is used to maintain rate change information, flags and rate change locations. A sample allocator creates samples that support the IRateChargeData interface. The interface IRateChangeControl (usually on the filter's input pin, or on the input to a component) provides a method ::ScheduleRateChange to request a rate change insertion. It also supports the method ::GetMaxRate to query the maximum forward and reverse decode rates. The method ::GetFurthestPosition is provided to query the furthest stream time that has not yet been processed and to determine the time interval for which rate changes can be scheduled after that time.<!-- EPO <DP n="35"> --></p><p id="p0098" num="0098">Another method, ::ScheduleRateChangeNow requests that a rate change be scheduled at the next available time location and that the actual location be returned. This method could be called on the stream which is the least able to recover from missed rate changes. The :: ScheduleRateChange method would be called on the other streams using the location returned by ::ScheduleRateChangeNow.</p><p id="p0099" num="0099">In addition, the example is drawn along the following assumptions concerning data format. For smooth reverse, reverse scan and forward scan playback (where the term "scan" is used to denote a truncated playback due to playback speed beyond a maximum rate supported by a pipeline or graph), usually the source must be able to break the stream into disjoint blocks separated by clean points. A clean point is a location in the compressed data, where all streams are synchronized (i.e. each stream begins a new sample at the same presentation timestamp). For example, the DVD source will use VOBUs as source blocks. For other content formats, the source will break the stream into GOPs since the video and the audio streams start new frames at keyframe boundaries. For content without clean points, such as general MPEG-2 content, please refer to the previous section on "Rate Changes for Data Without Clean Points".</p><p id="p0100" num="0100">With respect to scheduling and processing a rate change request:
<ul><li>The filter sends an IRateChangeControl::ScheduleRateChange request to the decoder to insert a mid-sample rate change at a specific source timestamp. The decoder determines if it will encounter a sample containing the rate change location. If it has already processed the timestamp or does not handle rate changes, it<!-- EPO <DP n="36"> --> passes the rate change request to each of its output pins controlled by corresponding to the input pin.</li><li>Alternatively, to schedule an immediate rate change the filter sends an IRateChangeControl::ScheduleRateChangeNow request to the decoder (usually of the stream which cannot easily recover from data loss, e.g. audio which would cause noticeable 'pops') to insert a mid-sample rate change at a the next available source timestamp. The request is recursively passed downstream until a component decides that it must process the rate change insertion request. The actual location is returned up the stream to the initial filter. The filter then propagates the rate change request to the other streams using the timestamp returned by the ScheduleRateChangeNow request.</li><li>When the decoder handles the request, it internally queues the rate change information to be processed when it receives a sample containing the rate change timestamp. When the sample is encountered, the decoder performs any rate change interpolation and copies the rate change information into the output sample's IRateChangeData interface.</li><li>Timestamp information in the data stream is not altered directly by the source or any intermediate filters. Each filter simply modifies the stream's contents.</li></ul></p><p id="p0101" num="0101">With respect to computing rate changes:<!-- EPO <DP n="37"> -->
<ul><li>The source filter uses the IRateChangeControl::GetMaxRate method to query the decoder's maximum forward and backward playback bit rates. If the global flag is set to true, then a filter must compute and return the maximum rates of both its corresponding output pins and its maximum internal rate.</li></ul></p><p id="p0102" num="0102">With respect to the IRateChangeData interface:
<ul><li>The IRateChangeData interface is used to both indicate the presence of a rate change and to store rate change information related to the sample.</li><li>The IRateChangeData interface maintains the following information:
<ul><li>o LONG Rate - a signed fixed point scale value (x100000) where a negative value indicates reverse playback. A value of 0 indicates that no rate change event is present in this sample (although the flags field may still contain sample information).</li><li>○ REFERENCETIME Location - The source timestamp location of the rate change</li><li>○ DWORD Flags - A bit wise OR of the following flags
<ul><li>■ Flag_ReverseStart - the first sample in a 'reverse playback' group of samples</li><li>■ Flag_ReverseEnd - the last sample in a 'reverse playback' group of samples</li><li>■ Flag_ScanMode - part of a video section in forward or reverse scan mode<!-- EPO <DP n="38"> --></li><li>■ Flag_TruncationPoint - the Location specifies that the sample should be truncated at this point. The 'Rate' field is not used.</li><li>■ Flag_SkipPoint - the Location specifies that the start of the sample up to this point should be discarded. The 'Rate' field is not used.</li></ul></li></ul></li></ul></p><p id="p0103" num="0103">With respect to timestamps and data interpretation at different playback rates:
<ul><li>The source filter is responsible for ensuring that timestamps are continuous and monotonically increasing. Timestamps are modified to appear as a continuous linear piece of video. Discontinuities indicate that there is a break in the source data.</li><li>Changes in playback direction can only occur at sample boundaries and not in the middle of a 'reverse playback' group of samples (see below).</li><li>In smooth forward playback (below the maximum forward rate), samples are sent normally as indicated in <figref idrefs="f0008">Fig. 9</figref>.</li><li>For smooth reverse play, it is assumed that decoders decode blocks of samples forward, and then deliver the frames in reverse order. The Flag_ReverseStart flag (in the IRateChangeData::Flags data field) indicates that this sample is the first sample in a group of samples that is intended to be played backwards. The Flag_ReverseEnd flag indicates that the sample is the last sample of a "reverse playback" group of samples. The start and end<!-- EPO <DP n="39"> --> timestamps of the interval over which the samples are to be played does not change. The display order of the data is reversed as indicated in <figref idrefs="f0008">Fig. 10</figref>.</li><li>The display timestamp of a frame in the first interval is computed as: <maths id="math0001" num=""><math display="block"><mtable columnalign="left"><mtr><mtd><msub><mi mathvariant="italic">R</mi><mi mathvariant="italic">frame</mi></msub></mtd><mtd><mo>=</mo><mi mathvariant="italic">IntervalStart</mi><mo>+</mo><mi mathvariant="italic">IntervalLength</mi><mo>-</mo><mi mathvariant="italic">Offset</mi></mtd></mtr><mtr><mtd><mspace width="1em"/></mtd><mtd><mo>=</mo><msub><mi mathvariant="italic">R</mi><mrow><mi mathvariant="italic">s</mi><mo>⁢</mo><mn mathvariant="italic">3</mn></mrow></msub><mo>+</mo><mfenced separators=""><msub><mi mathvariant="italic">R</mi><mrow><mi mathvariant="italic">e</mi><mo>⁢</mo><mn mathvariant="italic">3</mn></mrow></msub><mo>-</mo><msub><mi mathvariant="italic">R</mi><mrow><mi mathvariant="italic">s</mi><mo>⁢</mo><mn mathvariant="italic">3</mn></mrow></msub></mfenced><mo>-</mo><mfenced separators=""><msub><mi mathvariant="italic">R</mi><mi mathvariant="italic">old</mi></msub><mo>-</mo><msub><mi mathvariant="italic">R</mi><mrow><mi mathvariant="italic">s</mi><mo>⁢</mo><mn mathvariant="italic">3</mn></mrow></msub></mfenced></mtd></mtr><mtr><mtd><mspace width="1em"/></mtd><mtd><mo>=</mo><mfenced separators=""><msub><mi mathvariant="italic">R</mi><mrow><mi mathvariant="italic">e</mi><mo>⁢</mo><mn mathvariant="italic">3</mn></mrow></msub><mo>-</mo><msub><mi mathvariant="italic">R</mi><mi mathvariant="italic">old</mi></msub></mfenced><mo>+</mo><msub><mi mathvariant="italic">R</mi><mrow><mi mathvariant="italic">s</mi><mo>⁢</mo><mn mathvariant="italic">3</mn></mrow></msub></mtd></mtr></mtable></math><img id="ib0001" file="imgb0001.tif" wi="88" he="18" img-content="math" img-format="tif"/></maths></li><li>During forward (or reverse) scan playback beyond the maximum rate, only keyframes (I frames) are sent to the decoder (without discontinuities) as approximations of the video to be displayed for the time interval. The output timestamp will be the same as the original interval's end timestamp as noted in <figref idrefs="f0008">Fig. 11</figref>. Timestamps are modified to appear as a linear piece of video played at 1x speed. The start and end timestamps indicate the period over which the sample is to be played.</li><li>Transitions between scan (only keyframes sent) and smooth modes (full video sent) inherently change the actual data. A rate change at a rate below the maximum rate indicates samples will be sent in smooth mode; otherwise samples are sent in scan mode. Each sample's IRateChangeData flags contains a hint to aid the decoder in determining the mode of the sample (smooth or scan, and reverse or forward).</li><li>A direction change is indicated by a change in the sign of the rate.<br/>
Direction changes can only occur at sample boundaries and cannot occur in the middle of 'reverse playback' groups of samples.<!-- EPO <DP n="40"> --></li><li>Multiple same-direction rate changes can occur within a sample and across samples of mixed scan and non-scan modes as illustrated in <figref idrefs="f0009">Fig. 12</figref>.</li><li>The rate change mechanism in this example only assumes that the video format can be broken into blocks separated by keyframes. To ensure that timestamps monotonically increase, the length of each block (between keyframes) must be computable by the source filter to compute the end timestamp and the next timestamp of the subsequence key frame.</li><li>Timestamps are not usually modified by filters as they propagate through the pipeline. The renderers modify the timestamps (using a rate change command stream) to produce the output timestamps. If a component does not modify timestamps, then it must map all output timestamp information back into the input timestamp (and vice versa) when queried for its location or when propagating rate change information downstream.</li><li>It is possible for a source filter not to attach timestamps to the samples, but to indicate that they are part of a reverse playback block. In this situation, the first filter to read in-band timestamps is responsible for generating monotonically increasing timestamps on the samples belonging to the whole block.</li><li>An intermediate filter is permitted to break up a reverse sample into smaller reverse samples, sent in the reverse order that they are received, as indicated in <figref idrefs="f0009">Fig. 13</figref>.</li></ul><!-- EPO <DP n="41"> --></p><p id="p0104" num="0104">The above described example embodies several advantages. First, rate changes can be provided as real-time interactive changes, if they are in the same direction and in the same mode. Additionally, the decoder's bit rates are not exceeded when the maximum number of frames are displayed in scan mode. Additionally, timestamps are only modified by the renderers and the timestamp mapping code can be centralized and hidden.</p><heading id="h0017"><b><u>Interfaces</u></b></heading><p id="p0105" num="0105">In this particular implementation example, the following interfaces can be used:
<pre listing-type="program-listing">     Interface IRateChangeControl
     {
            HRESULT ScheduleRateChange( TIME SourcePosition,
                   LONG Rate)
            HRESULT ScheduleRateChangeNow( LONG Rate,
                   TIME* pActualSourcePosition)
            HRESULT ScheduleTruncation(TIME SourcePosition)
            HRESULT ScheduleSkip(TIME SourcePosition)
            HRESULT GetMaxRate( BOOL IncludeDownstream,
                   DWORD* pForwardRate, DWORD* pReverseRate)
            HRESULT GetFurthestPosition( BOOL IncludeDownstream,
                   TIME* pSourcePosition, TIME* pValidDuration)
     }</pre></p><p id="p0106" num="0106">The method ScheduleRateChange() requests an rate change insertion<!-- EPO <DP n="42"> -->
<ul><li>The SourcePosition parameter specifies the timestamp to execute the rate change at relative to the source timestamps</li><li>The Rate specifies the rate x 10000, which is negative if in reverse<br/>
playback</li></ul></p><p id="p0107" num="0107">The method ScheduleRateChangeNow() requests an rate change insertion at the soonest available time and returns the time at which it will occur
<ul><li>The pActualSourcePosition parameter returns the actual timestamp the rate change was scheduled for</li><li>The Rate specifies the rate x 10000, which is negative if in reverse<br/>
playback</li></ul></p><p id="p0108" num="0108">The method ScheduleTruncation() requests an data truncation
<ul><li>The SourcePosition parameter specifies the timestamp to truncate the sample at</li><li>The method ScheduleSkip() requests an data skip from the start of the sample</li><li>The SourcePosition parameter specifies the timestamp to skip from<br/>
the start of the sample to</li></ul></p><p id="p0109" num="0109">The method GetMaxRate() queries the maximum forward and reverse decode rates
<ul><li>The pForwardRate and pBackwardRate parameters return positive values indicating the maximum relative forward and backward playback rates</li><li>The IncludeDownstream flag indicates that the component should recursively include any downstream dependencies in its computation</li></ul><!-- EPO <DP n="43"> --></p><p id="p0110" num="0110">The method GetFurthestPosition() queries the furthest stream time that has not yet been processed
<ul><li>The pSourcePosition is a return parameter which indicates the current timestamp (relative to the source timestamps) of the output.</li><li>The pValidPeriod is a return parameter which indicates the duration after the source position which the rate change could be scheduled for (i.e. the time until the next source position available after this one).</li></ul></p><heading id="h0018"><b><u>Component Responsibilities</u></b></heading><p id="p0111" num="0111">In this particular implementation example, the various components have responsibilities that are outlined below. It is to be appreciated that these responsibilities are described for the purpose of illustrating to the reader one possible allocation of responsibilities. The discussion below is not intended to limit application of the claimed subject matter to any one specific implementation.</p><p id="p0112" num="0112">In general, the source is responsible for generating a continuous data stream, the decoder is responsible for modifying the stream, and the renderer will ultimately be the rate change component. If the renderer does not support the rate change mechanisms, then the previous filter is responsible for acting on behalf of the renderer by altering timestamps to perform the rate change.</p><heading id="h0019"><b><u>Source</u></b></heading><p id="p0113" num="0113">The source is responsible for generating and managing timestamp information. The source should generate monotonically increasing streams by<!-- EPO <DP n="44"> --> shifting out timestamp discontinuities and flipping around reverse playback blocks into forward stream blocks and tagging each to be played backwards.</p><p id="p0114" num="0114">The source is also responsible for figuring out how to implement a user request for rate changes at particular locations. It also figures out how to schedule a rate change to be performed "now", by either
<ul><li>querying the downstream filters' locations and deciding where to schedule the actual change based on the available locations and available time intervals. It may enforce a minimum distance from the available location to allow for propagation delays through the components.</li><li>by using the ScheduleRateChangeNow method on one stream, then propagating the request's (returned) location to the other streams using ScheduleRateChange.</li></ul></p><p id="p0115" num="0115">Since samples are sent out with varying formats (e.g. forward versus reverse samples), the source maintains a block (e.g. a GOP or VOBU) history of the most recent direction change. A rate change in a different direction can only occur after the most recent direction change.</p><heading id="h0020"><b><u>Decoder and Intermediate Components</u></b></heading><p id="p0116" num="0116">The decoder primarily acts as a stream preprocessor to aid the renderer (e.g. by cutting the b it rate, adding data for slow motion, and the like). When receiving a rate change, the decoder performs as much interpolation as possible. It can also pass the rate change onto the next filter for subsequent processing.</p><p id="p0117" num="0117">The decoder can also break reverse playback blocks into smaller reverse blocks for proc essing by the renderer. For example with DVD data, the original<!-- EPO <DP n="45"> --> VOBU block can be decomposed into two or more smaller subblocks (GOPs in this example). The order of the subblocks are reversed and their timestamps are also reversed (see <figref idrefs="f0010">figure 14</figref>). The renderer then receives the new blocks and can reverse each one as it receives it. This has the advantage of reducing the amount of buffered uncompressed data that the renderer needs to retain.</p><p id="p0118" num="0118">If the next filter (usually the renderer) does not support rate changes, then the decoder must modify its output timestamps to perform the rate change.</p><heading id="h0021"><b><u>Renderer</u></b></heading><p id="p0119" num="0119">The renderer ultimately implements rate change. It computes the effective presentation timestamp of a sample after the rate change. It also maintains a rate change history so that it can handle salvage/failure situations when, for example, a rate change cannot be done, or the renderer receives a rate change request that should have occurred in the past.</p><p id="p0120" num="0120">Furthermore, if the renderer can perform some buffering of output frames, then the renderer can actually perform the reverse playback using acceleration techniques. The renderer will receive reverse order samples from the decoder and begin recording or caching the decoded frames. Once the end of the reverse block has been received, the cached frames can be rendered in reverse order.</p><heading id="h0022"><b><u>TimeStamp Manager for Renderers</u></b></heading><p id="p0121" num="0121">The timestamp management code, as noted above, can be abstracted into a rate change management function that the renderer can use to map input timestamps (and rate change requests and possibly the current clock location) into an output timestamp for the sample.<!-- EPO <DP n="46"> --></p><p id="p0122" num="0122">As an example, consider <figref idrefs="f0010">Fig. 14</figref> and the following discussion. <figref idrefs="f0010">Fig. 14</figref> illustrates a rate change request to be made by the user at a specified location. Suppose that 12 frames of content have been sent to the renderers in various block sizes. The user has requested a rate change of 2x at time 00:00:15.</p><p id="p0123" num="0123">The source maps the content specific location to the corresponding output sample 7's timestamp. The rate change requests are sent to each output pin to request that the next filter insert a rate change. In this example, the video decoder has buffered sample 7, so it attaches the rate change information to sample 7. The audio decoder has already processed sample 7, so it passes the request to the audio renderer. The renderer will break the next buffer into two sections to be played at different rates. Each renderer consults the timestamp manager to map each input timestamp into an output timestamp.</p><p id="p0124" num="0124">A second situation occurs when the user wants to change the rate immediately. The source queries the next available timestamp and the amount of time available until it occurs. Using this timestamp, the source propagates a rate change down the pipeline or filter graph.</p><p id="p0125" num="0125">The next available timestamp can be computed by the times tamp manager or in a distributed recursive fashion. The timestamp manager has the advantage of not requiring each filter along the chain to account for rate changes to the stream (by querying each queued sample for rate changes). As an example , consider <figref idrefs="f0011">Fig. 15</figref>.</p><p id="p0126" num="0126">There, the timestamp manager includes a registry. Each renderer registers and updates the timestamp manager with its current progress. The timestamp manager can compute the next available time to schedule a rate change and pass it back to the source (e.g. at frame 5, with 2 frames to propagate the rate change).<!-- EPO <DP n="47"> --> The source can also find out where the renderers are (in source timestamps) and compute the source location to the application. The timestamp manager then extrapolates the location of each renderers and returns it to the source.</p><p id="p0127" num="0127">By having the timestamp mapping and registry functions occur at a central location, standardization and uniformity are enhanced in that these functions can be removed from other components in the pipeline. Additionally, errors can be reduced by providing a centralized location for the timestamp mapping.</p><p id="p0128" num="0128">The following is a list of further preferred embodiments of the invention:
<ul><li>Embodiment 1. A computer-readable media, wherein the instructions cause one or more processors to arrange the data blocks by reading in one or more blocks, in reverse order, from a medium containing the blocks.</li><li>Embodiment 2. A computer-readable media, wherein the instructions cause one or more processors to associate one or more flags with one or more blocks, where one or more flags indicating, to at least one downstream component, that the blocks are subject to reverse playback.<!-- EPO <DP n="48"> --></li><li>Embodiment 3. A computer-readable media, wherein the instructions cause one or more processors to:
<ul><li>associate one or more flags with one or more blocks, where one or more flags indicating, to at least one downstream component, that the blocks are subject to reverse playback; and</li><li>use one or more flags to change the order of block sub-portions to effectuate reverse playback.</li></ul></li><li>Embodiment 4. A method, wherein the digital data comprises video data.</li><li>Embodiment 5. A method, wherein the data blocks have sub-portions comprising key frames.</li><li>Embodiment 6. A data pipeline having multiple components, the pipeline being configured to implement the method.</li><li>Embodiment 7. One or more computer-readable media having computer-readable instructions thereon which, when executed by one or more processors, cause one or more processors to implement the method.</li><li>Embodiment 8. A method further comprising after associating said one or more flags, decoding, with a decoder, one or more blocks into individual block sub-portions.<!-- EPO <DP n="49"> --></li><li>Embodiment 9. A method further comprising after associating said one or more flags, with a decoder:
<ul><li>decoding one or more blocks into individual block sub-portions; and</li><li>using one or more flags to emit block sub-portions in reverse order to a downstream component.</li></ul></li><li>Embodiment 10. A method further comprising after associating said one or more flags, with a decoder:
<ul><li>decoding one or more blocks into individual block sub-portions;</li><li>using one or more flags to emit block sub-portions in reverse order to a downstream component, wherein the block sub-portions have one or more associated timestamps that can be used for scheduling the sub-portions for rendering, and further comprising manipulating the order of the timestamps of the block sub-portions.</li></ul></li><li>Embodiment 11. A method, wherein the digital data comprises video data.</li><li>Embodiment 12. A method, wherein the data blocks have sub-portions comprising key frames.</li><li>Embodiment 13. A data pipeline having multiple components, the pipeline being configured to implement the method.<!-- EPO <DP n="50"> --></li><li>Embodiment 14. One or more computer-readable media having computer-readable instructions thereon which, when executed by one or more processors, cause the one or more processors to implement the method.</li><li>Embodiment 15. An architecture, wherein the block sub-portions have one or more associated Timestamps that can be used for scheduling the sub-blocks for rendering, the second component further being configured to manipulate the order of the timestamps of the block sub-portions.</li><li>Embodiment 16. An architecture, wherein the data blocks have sub-portions comprising key frames.</li><li>Embodiment 17. A data pipeline having multiple components, the pipeline being configured to implement the method.</li><li>Embodiment 18. One or more computer-readable media having computer-readable instructions thereon which, when executed by one or more processors, cause the one or more processors to implement the method.</li><li>Embodiment 19. A method, wherein the first-mentioned downstream component comprises a decoder.</li><li>Embodiment 20. A method, wherein one of said components comprises a video renderer.<!-- EPO <DP n="51"> --></li><li>Embodiment 21. A method, wherein one of said components comprises a video decoder.</li><li>Embodiment 22. An architecture comprising:
<ul><li>a source component configured to:
<ul><li>receive a rate change request for changing a playback rate at which digital data is to be played back;</li><li>determine whether data associated with the rate change request has been provided from the source component to a first downstream component;</li><li>wherein if the data has not been provided to the first downstream component, the source component is configured to process the data effective to at least indicate that the data is subject to a rate change request;</li><li>wherein if the data has been provided to the first downstream component, the source component is configured to pass the rate change request to the first downstream component to attempt to have the rate change implemented</li></ul></li><li>a first downstream component configured to:
<ul><li>receive the rate change request and determine whether data associated with the rate change request has been provided to a second downstream component;</li><li>wherein if the data has not been provided to the second downstream component, the first downstream component is configured to process the data effective to at least indicate that the data is subject to a rate change request;<!-- EPO <DP n="52"> --></li><li>wherein if the data has been provided to the second downstream component, the first downstream component is configured to pass the rate change request to the second downstream component to attempt to have the rate change implemented.</li></ul></li></ul></li><li>Embodiment 23. The architecture of embodiment 22, wherein one of the downstream components comprises a decoder.</li><li>Embodiment 24. The architecture of embodiment 22, wherein one of the downstream components comprises a renderer.</li><li>Embodiment 25. The architecture of embodiment 22, wherein one of the downstream components comprises a video renderer.</li><li>Embodiment 26. One or more computer-readable media having computer-readable instructions thereon which, when executed by one or more processors, cause the one or more processors to implement the method.</li><li>Embodiment 27. An architecture comprising:
<ul><li>a source component comprising part of a data-rendering pipeline;</li><li>at least one other component associated with the source component;</li><li>the source component being configured to query at least said other component in the data-rendering pipeline to ascertain data-processing capabilities of the pipeline;<!-- EPO <DP n="53"> --></li><li>the source further being configured to adjust one or more of the following, responsive to receiving query results: (a) a direction in which data is capable of being read by the source component, and (b) a format of the data that is provided by the source component to other components in the data-rendering pipeline.</li></ul></li><li>Embodiment 28. The architecture of embodiment 27, wherein the query ascertains whether components support reverse playback.</li><li>Embodiment 29. The architecture of embodiment 27, wherein the query ascertains component playback rates.</li><li>Embodiment 30. The architecture of embodiment 27, wherein the query ascertains component playback rates and whether components support reverse playback.</li><li>Embodiment 31. The architecture of embodiment 27, wherein the query ascertains at least one maximum playback rate supported by the data-rendering pipeline.</li><li>Embodiment 32. The architecture of embodiment 27, wherein the query ascertains at least one maximum forward playback rate supported by the data-rendering pipeline.<!-- EPO <DP n="54"> --></li><li>Embodiment 33. The architecture of embodiment 27, wherein the query ascertains at least one maximum reverse playback rate supported by the data-rendering pipeline.</li><li>Embodiment 34. A method, wherein said query ascertains whether components support reverse playback.</li><li>Embodiment 35. A method, wherein said query ascertains component playback rates.</li><li>Embodiment 36. A method, wherein said query ascertains component playback rates and whether components support reverse playback.</li><li>Embodiment 37. A method, wherein said query ascertains at least one maximum playback rate supported by the data-rendering pipeline.</li><li>Embodiment 38. One or more computer-readable media having computer-readable instructions thereon which, when executed by one or more processors, cause the one or more processors to implement the method.</li><li>Embodiment 39. An architecture comprising:
<ul><li>a source component comprising part of a data-rendering pipeline;</li><li>multiple components associated with the source component for processing data;<!-- EPO <DP n="55"> --></li><li>the source component being configured to initiate a query that is directed to ascertain component capabilities along the pipeline;</li><li>individual components being configured to receive the query and propagate the query along the pipeline to other components; and</li><li>the source component being configured to receive query results and use the query results to determine how to process data that is to be rendered by the pipeline.</li></ul></li><li>Embodiment 40. The architecture of embodiment 39, wherein said query ascertains whether components support reverse playback.</li><li>Embodiment 41. The architecture of embodiment 39, wherein said query ascertains component playback rates.</li><li>Embodiment 42. The architecture of embodiment 39, wherein said query ascertains component playback rates and whether components support reverse playback.</li><li>Embodiment 43. The architecture of embodiment 39, wherein said query ascertains at least one maximum playback rate supported by the data-rendering pipeline.<!-- EPO <DP n="56"> --></li><li>Embodiment 44. The architecture of embodiment 39, where said one maximum playback rate comprises a minimum of all of the rates of the components.</li><li>Embodiment 45. The architecture of embodiment 39, where said one maximum playback rate comprises a multiplicative product of component playback rates.</li><li>Embodiment 46. One or more computer-readable media having computer-readable instructions thereon which, when executed by one or more processors, cause the one or more processors to implement the method.</li><li>Embodiment 47. One or more computer-readable media having computer-readable instructions thereon which, when executed by one or more processors, cause the one or more processors to implement the method.</li></ul></p><heading id="h0023"><b><u>Conclusion</u></b></heading><p id="p0129" num="0129">The methods and systems described above can provide improved methods and systems for processing renderable digital data. Various methods and systems permit digital data, such as video data, audio/video data, audio/video/subpicture data and the like, to be processed in a manner that permits playback in both forward and reverse directions in a manner that enhances the user's experience. Various embodiments can also handle playback rate changes in a manner that can enhance the user's experience.<!-- EPO <DP n="57"> --></p><p id="p0130" num="0130">Although the invention has been described in language specific to structural features and/or methodological steps, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or steps described. Rather, the specific features and steps are disclosed as preferred forms of implementing the claimed invention.</p><p id="p0131" num="0131">The invention may also refer to one or more of the following examples:
<ul><li>1. An example of a method comprising:
<ul><li>receiving an indication that reverse playback of digital data is desired;</li><li>responsive to said receiving, arranging one or more data blocks to define, at least in part, a reverse playback order; and</li><li>sending the arranged blocks to a downstream component for further processing.</li></ul></li><li>2. The method of example 1, wherein the act of receiving is performed by a source component that is configured to read data that is the subject of the reverse playback indication.</li><li>3. The method of example 1 or 2, wherein the act of arranging comprises reading in one or more blocks, in reverse order, from a medium containing the blocks.</li><li>4. The method of one of examples 1 to 3, wherein the act of arranging comprises associating one or more flags with one or more blocks, where one or more flags indicating, to at least one downstream component, that the blocks are subject to reverse playback.</li><li>5. The method of example 4 further comprising using one or more flags to change the order of block sub-portions to effectuate reverse playback.</li><li>6. The method of one of examples 1 to 5, wherein the digital data comprises video data.</li><li>7. The method of one of examples 1 to 6, wherein the data blocks have sub-portions comprising key frames.</li><li>8. The method of one of examples 1 to 7, wherein the step of arranging comprises:
<ul><li>responsive to said receiving, reading in one or more blocks, in reverse order, from a medium containing the blocks to define, at least in part, a reverse playback order; and<!-- EPO <DP n="58"> --></li><li>associating one or more flags with one or more blocks, where one or more flags indicating, to at least one downstream component, that the blocks are subject to reverse playback.</li></ul></li><li>9. The method of example 8 further comprising after associating said one or more flags, decoding one or more blocks into individual block sub-portions.</li><li>10. The method of example 8 further comprising after associating said one or more flags:
<ul><li>decoding one or more blocks into individual block sub-portions; and</li><li>using one or more flags to emit block sub-portions in reverse order to a downstream component.</li></ul></li><li>11. The method of example 8 further comprising after associating said one or more flags:
<ul><li>decoding one or more blocks into individual block sub-portions;</li><li>using one or more flags to emit block sub-portions in reverse order to a downstream component; and</li><li>wherein the block sub-portions have one or more associated timestamps that can be used for scheduling the sub-portions for rendering, and further manipulating the order of the timestamps of the block sub-portions.</li></ul></li><li>12. The method of example 8 further comprising after associating said one or more flags:
<ul><li>decoding one or more blocks into individual block sub-portions;</li><li>using one or more flags to emit block sub-portions in reverse order to a downstream component;</li><li>wherein the block sub-portions have one or more associated timestamps that can be used for scheduling the sub-portions for rendering, and further manipulating the order of the timestamps of the block sub-portions; and</li><li>said manipulating further comprising implementing a rate change by manipulating timestamp values.</li></ul></li><li>13. The method of example 8 further comprising after associating said one or more flags:
<ul><li>decoding one or more blocks into individual block sub-portions;</li><li>using one or more flags to emit block sub-portions in reverse order to a downstream component;<!-- EPO <DP n="59"> --></li><li>wherein the block sub-portions have one or more associated timestamps that can be used for scheduling the sub-portions for rendering, and further manipulating the order of the timestamps of the block sub-portions; and</li><li>said manipulating comprising reversing the effective order of the timestamps on the emitted block sub-portions.</li></ul></li><li>14. The method of example 8 further comprising:
<ul><li>after associating said one or more flags, decoding one or more blocks into individual block sub-portions; and</li><li>using one or more flags to reverse the order of block sub-portions.</li></ul></li><li>15. The method of example 8 further comprising:
<ul><li>after associating said one or more flags, decoding one or more blocks into individual block sub-portions; and</li><li>with a decoder, using one or more flags to reverse the order of block sub-portions.</li></ul></li><li>16. The method of example 8, wherein the steps of receiving, reading in and associating are performed by a source component.</li><li>17. An example of a method comprising:
<ul><li>receiving an indication that reverse playback of digital data is desired;</li><li>reading data blocks from a medium and arranging one or more data blocks to define, at least in part, a reverse playback order; and</li><li>associating timestamps with data blocks in addition to, as well as those data blocks subject to the reverse playback, in a monotonically increasing fashion across all data blocks.</li></ul></li><li>18. The method of example 17, wherein the act of associating comprises associating the timestamps in a manner to effectuate a change in a rate at which the data blocks are played back.</li><li>19. The method of example 17 or 18 further comprising determining whether data blocks that are subject to a rate change have been passed to a downstream component and, if so, passing a rate change request to a downstream component to attempt to have the rate change implemented.<!-- EPO <DP n="60"> --></li><li>20. The method of one of examples 17 to 19, wherein the act of receiving is performed by a source component that is configured to read data that is the subject of the reverse playback indication.</li><li>21. The method of one of examples 17 to 20, wherein the act of arranging comprises reading in one or more blocks, in reverse order, from a medium containing the blocks.</li><li>22. The method of one of examples 17 to 21, wherein the act of arranging comprises associating one or more flags with one or more blocks, where one or more flags indicating, to at least one downstream component, that the blocks are subject to reverse playback.</li><li>23. The method of one of examples 17 to 21, wherein the act of arranging comprises associating one or more flags with one or more blocks, where one or more flags indicating, to at least one downstream component, that the blocks are subject to reverse playback and further comprising using the one or more flags to change the order of block sub-portions to effectuate reverse playback.</li><li>24. The method of one of examples 17 to 23, wherein the digital data comprises video data.</li><li>25. The method of one of examples 17 to 24, wherein the data blocks have sub-portions comprising key frames.</li><li>26. An example of a method comprising:
<ul><li>receiving, at a source, a rate change request for changing a playback rate at which digital data is to be played back;</li><li>determining whether data associated with the rate change request has been provided from the source to a downstream component;</li><li>if the data has not been provided to a downstream component, processing the data effective to at least indicate that the data is subject to a rate change request; and</li><li>if the data has been provided to a downstream component, passing the rate change request to a downstream component to attempt to have the rate change implemented.</li></ul><!-- EPO <DP n="61"> --></li><li>27. The method of example 26 further comprising:
<ul><li>receiving the rate change request with a downstream component;</li><li>determining whether data associated with the rate change request has been provided to another downstream component;</li><li>if the data has not been provided to another downstream component, processing the data effective to at least indicate that the data is subject to a rate change request; and</li><li>if the data has been provided to a different downstream component, passing the rate change request to the different downstream component to attempt to have the rate change implemented, or if the data has already been rendered, dropping the rate change request.</li></ul></li><li>28. The method of example 26 or 27, wherein the first-mentioned downstream component comprises a demultiplexer or a decoder.</li><li>29. The method of one of examples 26 to 28, wherein one of said components comprises a renderer, a video renderer or a video decoder.</li><li>30. An example of a method comprising:
<ul><li>querying, with a source component that comprises part of a data-rendering pipeline, at least one other component in the data-rendering pipeline to ascertain component capabilities;</li><li>responsive to query results, adjusting one or more of the following: (a) a direction in which data is capable of being read by the source component, and (b) a format in which the data is provided by the source component to other components in the data-rendering pipeline.</li></ul></li><li>31. An example of a method comprising:
<ul><li>initiating a query at a source component that comprises part of a data-rendering pipeline having multiple components, the query being directed to ascertain component capabilities along the pipeline;</li><li>propagating the query along the pipeline, from component to component;</li><li>receiving query results with the source component; and</li><li>using the query results, with the source component, to determine how to process data that is to be rendered by the pipeline.</li></ul></li><li>32. The method of example 30 or 31, wherein said querying ascertains whether components support reverse playback.<!-- EPO <DP n="62"> --></li><li>33. The method of example one of examples 30 to 32, wherein said querying ascertains component playback rates.</li><li>34. The method of one of examples 30 to 33, wherein said querying ascertains component playback rates and whether components support reverse playback.</li><li>35. The method of one of examples 30 to 34, wherein said querying ascertains at least one maximum playback rate supported by the data-rendering pipeline.</li><li>36. The method of example 35, wherein said maximum playback rate comprises a minimum of all of the rates of the components.</li><li>37. The method of example 35 or 36, wherein said maximum playback rate comprises a multiplicative product of component playback rates.</li><li>38. The method of one of examples 30 to 37, wherein said querying ascertains at least one maximum forward playback rate supported by the data-rendering pipeline.</li><li>39. The method of one of examples 30 to 38, wherein said querying ascertains at least one maximum reverse playback rate supported by the data-rendering pipeline.</li><li>40. An example of a method comprising:
<ul><li>attaching information to one or more data samples that are to be rendered by a renderers that comprises part of a data-processing pipeline, the information defining:
<ul><li>rate changes, if any, that a data sample is subject to;</li><li>a timestamp associated with when a data sample should be rendered; and</li><li>whether the data sample is to be rendered in forward or reverse direction;</li><li>propagating the one or more data samples and their associated information along the pipeline;</li><li>receiving data samples and their associated information at one or more components downstream of a source that reads in the data samples from a medium;</li><li>processing, at said one or more downstream components, one or more data samples sufficient to implement either or both of a rate change and a rendering direction, said processing comprising at least manipulating timestamp values associated with the data samples.</li></ul></li></ul><!-- EPO <DP n="63"> --></li><li>41. The method of example 40, wherein the act of processing comprises reversing data sample orders to effectuate reverse playback.</li><li>42. The method of example 40 or 41, wherein:
<ul><li>the act of processing comprises reversing data sample orders to effectuate reverse playback;<br/>
and</li><li>at least one of said acts of manipulating timestamp values and reversing data sample orders is performed by the renderer.</li></ul></li><li>56. An example of an architecture comprising:
<ul><li>a source for generating and managing timestamp information associated with data samples that are to be rendered, the source being configured to:
<ul><li>generate monotonically increasing timestamps for data samples that are subject to forward and reverse playback;</li><li>reverse the order of data blocks containing data samples to effect reverse playback;</li><li>tag each block that is to be played in reverse;</li><li>enable rate changes to be scheduled by querying downstream components for the purpose of scheduling the rate change;</li><li>a decoder configured to decode data samples; and</li><li>a renderer configured to render data samples.</li></ul></li></ul></li><li>57. The architecture of example 56 further comprising:
<ul><li>a timestamp manager that can be queried by the source for the next available timestamp and</li><li>the amount of time available until the timestamp occurs for purposes of implementing a rate change.</li></ul></li><li>58. The architecture of example 56 or 57 further comprising a registry associated with the timestamp manager, the renderer being configured to register with the timestamp manager and update the registry as it renders data samples.</li><li>59. The architecture of example 56, wherein:
<ul><li>the decoder is configured to:
<ul><li>perform interpolation on data samples responsive to receiving a rate change;<!-- EPO <DP n="64"> --></li><li>pass rate changes onto a downstream component;</li><li>break reverse playback blocks into smaller reverse blocks for processing; and</li><li>modify output timestamps of data samples to assist in implementing a rate change; and</li><li>the renderer is configured to:
<ul><li>compute an effective presentation timestamp of a data sample associated with a rate change;</li><li>receive data samples intended for reverse playback; and</li><li>cache data samples so that the renderer can render the data samples in reverse order.</li></ul></li></ul></li></ul></li><li>60. The architecture of example 59, wherein a component can decompose a reverse playback block into subblocks, then emit the subblocks in reverse order with appropriately altered timestamps.</li><li>61. The architecture of example 59 or 60 further comprising a timestamp manager that can be used by the renderer to map input timestamps to output timestamps for implementing a rate change.</li><li>62. An example of one or more data samples comprising:
<ul><li>an interface that is used to maintain:
<ul><li>rate change information associated with a rate at which the data sample can be rendered;</li><li>one or more flags associated with a change in playback direction; and</li><li>rate change locations.</li></ul></li></ul></li><li>63. An example of a data-rendering pipeline comprising multiple components that are configured to process one or more data samples of example 62.</li></ul></p></description><claims mxw-id="PCLM56976128" lang="EN" load-source="patent-office"><!-- EPO <DP n="65"> --><claim id="c-en-0001" num="0001"><claim-text>A method comprising:
<claim-text>receiving, at a source component, a rate change request for a data sample having particular source time;</claim-text>
<claim-text>responsive to receiving the rate change request, examining one or more buffers associated with the source component to ascertain whether a corresponding data sample over which the rate change is to occur is present;</claim-text>
<claim-text>if the data sample is found in the one or more buffers, attaching rate change information to the data sample; and</claim-text>
<claim-text>if the data sample is not found in the source component's buffers, sending the rate change request to a next in line downstream component.</claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The method of claim 1, wherein said act of attaching comprises attaching the rate change information to the data sample while the data sample is still in the buffer.</claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The method of claim 1, wherein said act of attaching comprises caching the rate change information and attaching the rate change information to the data sample when the data sample is processed by the source component.</claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The method of one of claims 1 to 3 further comprising:
<claim-text>receiving the rate change request with the next in line downstream component; and</claim-text>
<claim-text>responsive to receiving the rate change request, examining one or more buffers associated with the downstream component to ascertain whether a corresponding data sample over which the rate change is to occur is present and:
<claim-text>if the data sample is found in the downstream component's buffers, attaching rate change information to the data sample; and</claim-text>
<claim-text>if the data sample is not found in the downstream component's buffers, sending the rate change request to a next in line downstream component.</claim-text></claim-text><!-- EPO <DP n="66"> --></claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The method of claim 4 further comprising continuing to send the rate change request to downstream components if the data sample is not found in any buffers of components that receive the request, until the rate change request is received by a renderer; and, if the rate change request is received by the renderer and the data sample has been rendered by the renderer, discarding the rate change request.</claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The method of one of claims 1 to 5 further comprising implementing the rate change request at a component downstream from the source component.</claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>The method of one of claims 1 to 5 further comprising implementing the rate change request at a renderer downstream from the source component.</claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>A data pipeline having multiple components, the pipeline being configured to implement the method of one of claims 1 to 7.</claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>One or more computer-readable media having computer-readable instructions thereon which, when executed by one or more processors, cause one or more processors to perform the method of one of claims 1 to 7.</claim-text></claim><claim id="c-en-0010" num="0010"><claim-text>An architecture comprising components to perform the method of one of claims 1 to 7.</claim-text></claim><claim id="c-en-0011" num="0011"><claim-text>The architecture of claim 10 comprising a decoder component.</claim-text></claim><claim id="c-en-0012" num="0012"><claim-text>The architecture of claim 10 or 11 comprising a renderer component.</claim-text></claim><claim id="c-en-0013" num="0013"><claim-text>The architecture of one of claims 10 to 12 comprising at least a portion of a filter graph.</claim-text></claim></claims><drawings mxw-id="PDW16666913" load-source="patent-office"><!-- EPO <DP n="67"> --><figure id="f0001" num="1,2"><img id="if0001" file="imgf0001.tif" wi="165" he="223" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="68"> --><figure id="f0002" num="3"><img id="if0002" file="imgf0002.tif" wi="165" he="229" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="69"> --><figure id="f0003" num="4"><img id="if0003" file="imgf0003.tif" wi="165" he="229" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="70"> --><figure id="f0004" num="5"><img id="if0004" file="imgf0004.tif" wi="165" he="146" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="71"> --><figure id="f0005" num="6"><img id="if0005" file="imgf0005.tif" wi="151" he="224" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="72"> --><figure id="f0006" num="7"><img id="if0006" file="imgf0006.tif" wi="157" he="179" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="73"> --><figure id="f0007" num="8"><img id="if0007" file="imgf0007.tif" wi="165" he="220" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="74"> --><figure id="f0008" num="9,10,11"><img id="if0008" file="imgf0008.tif" wi="165" he="220" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="75"> --><figure id="f0009" num="12,13"><img id="if0009" file="imgf0009.tif" wi="165" he="220" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="76"> --><figure id="f0010" num="14"><img id="if0010" file="imgf0010.tif" wi="165" he="220" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="77"> --><figure id="f0011" num="15"><img id="if0011" file="imgf0011.tif" wi="165" he="220" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="78"> --><figure id="f0012" num="16"><img id="if0012" file="imgf0012.tif" wi="150" he="120" img-content="drawing" img-format="tif"/></figure></drawings><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
