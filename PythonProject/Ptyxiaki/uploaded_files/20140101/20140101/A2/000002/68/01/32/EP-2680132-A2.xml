<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2680132-A2" country="EP" doc-number="2680132" kind="A2" date="20140101" family-id="48670409" file-reference-id="317509" date-produced="20180824" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146549498" ucid="EP-2680132-A2"><document-id><country>EP</country><doc-number>2680132</doc-number><kind>A2</kind><date>20140101</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-13172329-A" is-representative="YES"><document-id mxw-id="PAPP154823421" load-source="docdb" format="epo"><country>EP</country><doc-number>13172329</doc-number><kind>A</kind><date>20130617</date><lang>EN</lang></document-id><document-id mxw-id="PAPP191080936" load-source="docdb" format="original"><country>EP</country><doc-number>13172329.8</doc-number><date>20130617</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140446928" ucid="US-201213537731-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201213537731</doc-number><kind>A</kind><date>20120629</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1992703536" load-source="docdb">G06F   9/38        20060101AFI20151130BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-2079670038" load-source="docdb" scheme="CPC">G06F   9/381       20130101 FI20150401BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2079676789" load-source="docdb" scheme="CPC">G06F   8/452       20130101 LI20150331BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2079677308" load-source="docdb" scheme="CPC">G06F   8/4452      20130101 LI20150331BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2079677437" load-source="docdb" scheme="CPC">G06F   8/443       20130101 LI20150331BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132180978" lang="DE" load-source="patent-office">Gestufte Schleifenanweisungen</invention-title><invention-title mxw-id="PT132180979" lang="EN" load-source="patent-office">Staged loop instructions</invention-title><invention-title mxw-id="PT132180980" lang="FR" load-source="patent-office">Instructions pour boucle étagée</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR918167010" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>ANALOG DEVICES INC</last-name><address><country>US</country></address></addressbook></applicant><applicant mxw-id="PPAR918134769" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>ANALOG DEVICES, INC.</last-name></addressbook></applicant><applicant mxw-id="PPAR918992121" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Analog Devices, Inc.</last-name><iid>100076447</iid><address><street>One Technology Way</street><city>Norwood, Massachusetts 02062-9106</city><country>US</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR918160082" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>PERKINS MICHAEL</last-name><address><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR918140857" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>PERKINS, MICHAEL</last-name></addressbook></inventor><inventor mxw-id="PPAR918982419" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>PERKINS, MICHAEL</last-name><address><street>3f2 3 Newton Street Gorgie</street><city>Edinburgh, EH11 1TQ</city><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR918167170" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>HIGHAM ANDREW</last-name><address><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR918156825" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>HIGHAM, ANDREW</last-name></addressbook></inventor><inventor mxw-id="PPAR918982920" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>HIGHAM, ANDREW</last-name><address><street>Flat 3, F1 109 Warrender Park Road</street><city>Edinburgh, EH9 1EN</city><country>GB</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR918985011" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Beck, Simon Antony</last-name><suffix>et al</suffix><iid>100038100</iid><address><street>Withers &amp; Rogers LLP 4 More London Riverside</street><city>London SE1 2AU</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS548869121" load-source="docdb">AL</country><country mxw-id="DS548843012" load-source="docdb">AT</country><country mxw-id="DS548869123" load-source="docdb">BE</country><country mxw-id="DS548805339" load-source="docdb">BG</country><country mxw-id="DS548896817" load-source="docdb">CH</country><country mxw-id="DS548865375" load-source="docdb">CY</country><country mxw-id="DS548843013" load-source="docdb">CZ</country><country mxw-id="DS548869124" load-source="docdb">DE</country><country mxw-id="DS548865376" load-source="docdb">DK</country><country mxw-id="DS548865377" load-source="docdb">EE</country><country mxw-id="DS548871682" load-source="docdb">ES</country><country mxw-id="DS548805340" load-source="docdb">FI</country><country mxw-id="DS548896826" load-source="docdb">FR</country><country mxw-id="DS548869125" load-source="docdb">GB</country><country mxw-id="DS548865714" load-source="docdb">GR</country><country mxw-id="DS548869126" load-source="docdb">HR</country><country mxw-id="DS548843014" load-source="docdb">HU</country><country mxw-id="DS548871683" load-source="docdb">IE</country><country mxw-id="DS548865715" load-source="docdb">IS</country><country mxw-id="DS548896827" load-source="docdb">IT</country><country mxw-id="DS548865716" load-source="docdb">LI</country><country mxw-id="DS548805341" load-source="docdb">LT</country><country mxw-id="DS548885173" load-source="docdb">LU</country><country mxw-id="DS548805342" load-source="docdb">LV</country><country mxw-id="DS548805343" load-source="docdb">MC</country><country mxw-id="DS548885174" load-source="docdb">MK</country><country mxw-id="DS548885175" load-source="docdb">MT</country><country mxw-id="DS548865717" load-source="docdb">NL</country><country mxw-id="DS548869128" load-source="docdb">NO</country><country mxw-id="DS548865718" load-source="docdb">PL</country><country mxw-id="DS548805344" load-source="docdb">PT</country><country mxw-id="DS548843015" load-source="docdb">RO</country><country mxw-id="DS548805345" load-source="docdb">RS</country><country mxw-id="DS548865719" load-source="docdb">SE</country><country mxw-id="DS548896828" load-source="docdb">SI</country><country mxw-id="DS548869129" load-source="docdb">SK</country><country mxw-id="DS548869450" load-source="docdb">SM</country><country mxw-id="DS548885180" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA128670167" lang="EN" load-source="patent-office"><p id="pa01" num="0001">Loop instructions are analyzed and assigned stage numbers based on dependencies between them and machine resources available. The loop instructions are selectively executed based on their stage numbers, thereby eliminating the need for explicit loop set-up and tear-down instructions. On a Single Instruction, Multiple Data machine, the final instance of each instruction may be executed on a subset of the processing elements or vector elements, dependent on the number of iterations of the original loop.
<img id="iaf01" file="imgaf001.tif" wi="78" he="121" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA128499540" lang="EN" source="EPO" load-source="docdb"><p>Loop instructions are analyzed and assigned stage numbers based on dependencies between them and machine resources available. The loop instructions are selectively executed based on their stage numbers, thereby eliminating the need for explicit loop set-up and tear-down instructions. On a Single Instruction, Multiple Data machine, the final instance of each instruction may be executed on a subset of the processing elements or vector elements, dependent on the number of iterations of the original loop.</p></abstract><description mxw-id="PDES63955597" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><u>TECHNICAL FIELD</u></heading><p id="p0001" num="0001">Embodiments of the current invention generally relate to efficient use of hardware parallelism and, in particular, to loop unrolling and software pipelining.</p><heading id="h0002"><u>BACKGROUND</u></heading><p id="p0002" num="0002">Compilers take computer source code written in a high-level, generic language (such as C, C++, or Java) and translate it into a low-level, machine-specific object code. Compiling code for a simple, single-core processor may consist of a relatively straightforward, one-for-one translation of high-level instructions into low-level instructions. For example, accessing data in a C++ class may be compiled into address arithmetic and memory accesses machine-level instructions.</p><p id="p0003" num="0003">Compiling code for a processor having multiple functional units or support for vector processing, however, may be much more complicated. A typical goal is to run the compiled program as quickly as possible by keeping each core (and/or each processor, execution unit, and pipeline, in accordance with the specific hardware of a given device) as busy as possible. This goal, however, requires that instructions originally written in series/sequence be compiled to run in parallel, and not all instructions are capable of being executed concurrently. If an input for a second instruction depends upon the result of a first instruction, for example, the first and second instructions cannot run in parallel; the second instruction must wait for the first to complete.</p><p id="p0004" num="0004">A "smart" compiler recognizes instructions capable of being run in parallel and creates machine code tailored to do so (either explicitly, such as code produced for a very-long-instruction-word ("VLIW") processor, or implicitly, such as code produced for a superscalar processor). Two broad categories of parallelizable situation include (i) instructions exhibiting instruction-level parallelism and (ii) instructions exhibiting data-level parallelism. Instruction-level parallelism refers to two or more instructions that have no dependencies on each other's output and may thus be computed in parallel. Data-level parallelism refers to performing operations on sets (i.e., vectors) of data in which individual operations on members of the sets are not dependent upon the operations involving other members. In order to add two matrices<!-- EPO <DP n="2"> --> together, for example, the data-level parallelism of the elements in the matrices may be exploited to run some or all of the element-addition instructions in parallel because the element-level addition operations are independent.</p><p id="p0005" num="0005">One way that compilers achieve instruction- and data-level parallelism is by exploiting loops (e.g., <i>for</i> and <i>while</i> loops) written in the source code. Two or more iterations of a loop may be executed in parallel (i.e., "vectorization," which takes advantage of data-level parallelism) and/or consecutive iterations of a loop may be partially overlapped (i.e., "software pipelining", which takes advantage of instruction-level parallelism). One powerful algorithm for software pipelining is known as "modulo scheduling." Regarding vectorization, a <i>for</i> loop (for example) may call for ten iterations; if the instructions executed in each iteration are independent of those of the other iterations, and if the compiler has access to (for example) five processing elements, the compiler may create assembly code that executes two iterations of the loop at each of the five processing elements in parallel. Regarding software pipelining, if, for example, a loop includes two instructions but the first instruction does not depend on the result of the previous iteration's second instruction, the first instruction of the next iteration of the loop may be scheduled to run in parallel with the still-executing second instruction of the current iteration of the loop.</p><p id="p0006" num="0006">One disadvantage of vectorization and of software pipelining is that they increase the size of the executed code. Vectorization requires code to cope with odd-sized, final iterations of loops (if, e.g., a loop requires eleven iterations and five processing elements are available, the last iteration uses only one of the processing elements). This "partially-filled" final iteration may be more than merely inefficient; many large-scale processor arrays are tuned to expect a steady stream of valid data, and individual processing elements may not be so easily turned off. Software pipelining requires set-up instructions (a "loop prolog") to prepare the hardware environment before an efficient set of core instructions (a "loop kernel") may be run, after which further overhead instructions (a "loop epilog") are needed to tear down the loop and clean up the hardware environment for further instructions. In many cases, this additional, overhead code may be larger than the loop-kernel code itself and, on processors having limited instruction-cache or buffer capacity, may diminish performance. Another disadvantage is poor handling of loops having a variable number of iterations (known as a loop's "trip count"); because the trip count cannot be known at compile time, various tests of the trip count are required at run time,<!-- EPO <DP n="3"> --> thereby increasing the run time of the program (especially when the trip count turns out to be small).</p><p id="p0007" num="0007">Existing systems that attempt to address these drawbacks may only create further disadvantages. For example, some processors (e.g., vector processors) implement a method of selectively disabling individual processing elements in the final iteration of a loop. Disabling processing elements in the final iteration of the loop, however, does not interact well with software pipelining, which overlaps instructions from various iterations in the loop kernel. Other systems express set-up, tear-down and steady state of a loop by storing the loop instructions in a fixed-size buffer and issuing a special loop instruction, but these systems not only place a limit on the size of the loop kernel (based on the size of the fixed buffer), but also cannot deal with more-complicated loops (such as those that require register renaming). Still other systems deal with complicated loops using an intricate set of rotating hardware registers, but these registers take up valuable real estate from other portions of the processor. A need therefore exists for a way to efficiently execute loop kernels of arbitrary size and complexity.</p><heading id="h0003"><u>SUMMARY</u></heading><p id="p0008" num="0008">In general, various aspects of the systems and methods described herein provide a compiler and a hardware mechanism to allow set-up and tear-down of software-pipelined, vectorized loops without the need for software prologs and epilogs. Embodiments of the current invention reduce code size and, in the case of unknown trip counts, improve the performance of the resulting code. Loop code is analyzed, and each instruction is assigned a stage number reflecting an overall order of execution; specifically, each instruction may be assigned to one of a plurality of temporally ordered "stages," each of which has a "stage number" reflecting its place within the execution order. When the loop is executed, the instructions therein are selectively executed based on their stage number.</p><p id="p0009" num="0009">In one aspect, a method of executing a loop by a computer processor includes loading loop kernel instructions for the loop into a memory of the computer processor (wherein each loop kernel instruction has a stage number associated therewith). A stage threshold is determined during each iteration of the loop, and a loop prolog is executed by executing subsets of the loop kernel instructions based on the stage threshold and stage numbers. A loop kernel is<!-- EPO <DP n="4"> --> executed by repeatedly executing the loop kernel instructions, and a loop epilog is executed by executing a second set of subsets of the loop kernel instructions based on the stage threshold and stage numbers.</p><p id="p0010" num="0010">The computer processor may be a scalar processor, where the loop kernel instructions include instructions having instruction-level parallelism or multi-cycle latencies and/or the loop kernel instructions are software pipelined. The stage numbers may be adjusted in accordance with each copy of an unrolled loop kernel. A final execution of a loop instruction may run on fewer processing or vector elements than on earlier iterations of the loop. The fewer processing or vector elements may be selected in accordance with a mask bits controlling each processing or vector element. A loop setup instruction that includes information relating to the stage threshold may be received; the loop setup instruction may include a total loop count, a number of processing elements to use in executing the loop instructions, a stage count, or a loop-unroll factor. Executing the loop epilog, loop kernel, and the loop prolog may include comparing the instruction stage numbers to a stage threshold in the computer processor.</p><p id="p0011" num="0011">In another aspect, a system for executing computer-executable loop instructions includes a sequencer for receiving a loop-setup instruction comprising loop information. One or more registers store data related to a stage threshold (the data being derived from the loop information). A processing element executes (i) a loop prolog by executing subsets of received loop kernel instructions based on the stage threshold and stage numbers associated with the loop kernel instructions, (ii) a loop kernel by repeatedly executing the loop kernel instructions, and (iii) a loop epilog by executing a second set of subsets of the loop kernel instructions based on the stage threshold and stage numbers.</p><p id="p0012" num="0012">The registers may include stage-mask or stage-threshold registers. At least one additional processing element may execute loop kernel instructions, or vector instructions may process multiple data elements in parallel. During a final execution of an instruction, only a subset of the processing or vector elements may execute loop kernel instructions. Mask registers may store information related to executing loop kernel instructions in the final iteration. The loop information may include a total loop count, a number of processing elements to use in executing the loop instructions, a stage count, or a loop-unroll factor. A loop-count register may store a loop count, which may be derived from a total loop count divided by a number of<!-- EPO <DP n="5"> --> processing elements to use in executing the loop instructions and adjusted in accordance with a stage count and rounded in accordance with a loop-unroll factor.</p><p id="p0013" num="0013">These and other objects, along with advantages and features of the present invention herein disclosed, will become more apparent through reference to the following description, the accompanying drawings, and the claims. Furthermore, it is to be understood that the features of the various embodiments described herein are not mutually exclusive and can exist in various combinations and permutations.</p><heading id="h0004"><u>BRIEF DESCRIPTION OF THE DRAWINGS</u></heading><p id="p0014" num="0014">In the drawings, like reference characters generally refer to the same parts throughout the different views. In the following description, various embodiments of the present invention are described with reference to the following drawings, in which:</p><p id="p0015" num="0015"><figref idrefs="f0001">FIG. 1</figref> is a flowchart illustrating a method for annotating loop instructions with stage information in accordance with one embodiment of the invention;</p><p id="p0016" num="0016"><figref idrefs="f0002">FIG. 2</figref> is a block diagram illustrating execution of a staged loop in accordance with one embodiment of the invention;</p><p id="p0017" num="0017"><figref idrefs="f0003">FIG. 3</figref> is a block diagram illustrating execution of a partially unrolled staged loop in accordance with one embodiment of the invention;</p><p id="p0018" num="0018"><figref idrefs="f0004">FIG. 4</figref> is a block diagram illustrating execution of a partially unrolled staged loop requiring a delayed start in accordance with one embodiment of the invention;</p><p id="p0019" num="0019"><figref idrefs="f0005">FIG. 5</figref> is a block diagram illustrating execution of a staged loop running on multiple processing elements in accordance with one embodiment of the invention;</p><p id="p0020" num="0020"><figref idrefs="f0006">FIG. 6</figref> is a block diagram of a system for annotating loop instructions with stages in accordance with one embodiment of the invention;</p><p id="p0021" num="0021"><figref idrefs="f0007">FIG. 7</figref> is a block diagram of a system for executing staged loop instructions in accordance with one embodiment of the invention; and</p><p id="p0022" num="0022"><figref idrefs="f0008">FIG. 8</figref> is a flowchart diagram of a method for executing staged loop instructions in accordance with one embodiment of the invention.<!-- EPO <DP n="6"> --></p><heading id="h0005"><u>DETAILED DESCRIPTION</u></heading><p id="p0023" num="0023">Described herein are various embodiments of methods and systems for running loops on a computer system having multiple processing elements or functional units by tagging loop-kernel instructions, or groups of loop instructions, with additional information regarding which instructions should be executed, and in what order, to set up and tear down the loop kernel in an efficient manner. When a processor receives the instructions, it analyzes the tag information and, based thereon, executes certain of the loop-kernel instructions before and after executing the loop kernel, thereby eliminating the need for explicit loop setup/tear-down instructions. For example, a compiler may tag some instructions in a loop with a [0] tag, other instructions with a [1] tag, and still other instructions with a [2] tag; very generally, and as will be explained in greater detail below, instructions within a tagged group exhibit instruction-level parallelism, and instructions in higher-numbered tagged groups may depend on the outputs of instructions in lower-numbered groups. In a first iteration of the loop, the processor may execute (in parallel) instructions tagged with [0]; in a second iteration, instructions tagged with either [0] or [1], and in third and subsequent iterations, all instructions (i.e., those tagged with either [0], [1], or [2]). In the next-to-last iteration of the loop, the processor may execute only instructions tagged with [1] or [2], and in the final iteration of the loop, only instructions tagged with [2]. As explained in greater detail below, this simple example may be expanded to more complicated loops and/or processor architectures.</p><p id="p0024" num="0024">For explanatory purposes, several general attributes or properties of loops will first be defined. Code for a traditional loop includes loop set-up instructions (i.e., a loop prolog), a loop kernel, and loop tear-down instructions (i.e., a loop epilog). A loop executing in accordance with one embodiment of the current invention includes one or more iterations at the beginning of its execution in which not all of the loop instructions execute, one or more iterations in which all of the loop instructions execute (i.e., the "steady-state" portion of the loop's execution), and, finally, one or more iterations at the end of the execution of the loop in which not all of the loop instructions execute. In one embodiment, the iterations at the beginning and end of the loop's execution provide the set-up and tear-down functionality for the steady-state portion of the loop, without the need for explicit extra instructions to do so.</p><p id="p0025" num="0025">The total number of cycles between the start of each consecutive loop iteration in the pipelined loop is known as the initiation interval, which is also the number of instruction lines<!-- EPO <DP n="7"> --> within the steady-state loop kernel. When executing in this steady state, every (initiation interval) cycles a new iteration begins, while an iteration that began earlier finishes its execution. The initiation interval is shorter than the total number of cycles taken to complete an iteration of the unpipelined loop because multiple iterations of the original loop have been overlapped, allowing later iterations of the loop to begin before earlier ones have completed. For example, if the initiation interval is 2, and the total number of cycles needed to complete an iteration is 6, then iterations <i>n, n</i>+<i>1,</i> and <i>n</i>+<i>2</i> will all be in flight at the same time.</p><p id="p0026" num="0026">Instructions in the loop are given a "stage number" dependent on the number of multiples of the initiation interval that have passed since the loop iteration was begun. In the above example, the first two instruction lines in the unpipelined loop belong to the first stage, instruction lines three and four belong to the second stage, while instruction lines five and six belong to the third stage. The total number of stages is known as the stage count; in this example the stage count is three. In the steady state of the loop kernel, iteration <i>n</i> is executing the instructions in the final stage (in this case, the third stage), iteration <i>n</i>+<i>1</i> is executing the penultimate stage (in this case, the second stage) and so on. In our example, iteration <i>n</i>+<i>2</i> is beginning execution by executing the instructions in the first stage.</p><p id="p0027" num="0027">In one embodiment of the invention, the stage number is used to tag instructions in the loop kernel. Instructions belonging to the first stage are tagged with [0], instructions belonging to the second stage are tagged with [1], and so on.</p><p id="p0028" num="0028">A smaller initiation interval gives a more efficient loop kernel. Factors that help to decrease the initiation interval include a greater number of functional units available on the processor, and a smaller number of data dependences between instructions. A small initiation interval also generally increases the stage count required to generate code for the loop, which in turn leads to more code expansion if explicit loop prologs and epilogs must be generated. The number of stages required to run before the loop reaches steady state is one less than the stage count (i.e., stage count - 1); the number of cycles required to run before the loop reaches steady state is thus (stage count - 1) × (initiation interval). In one embodiment of the present invention, the code expansion for this overhead is removed.</p><p id="p0029" num="0029">Unrolling a loop refers to re-writing some or all of the loop instructions as greater number of non-loop instructions. A two-instruction <i>for</i> loop that iterates six times, for example, may be completely unrolled by being re-written as twelve normal (non-loop) instructions. As<!-- EPO <DP n="8"> --> another example, that <i>for</i> loop may be partially unrolled by being re-written to have more instructions per iteration, but fewer total iterations (as, e.g., a four-instruction <i>for</i> loop that iterates three times). If a loop originally is written to have an odd number of iterations (e.g., two-instruction <i>for</i> loop that iterates five times), this partial-unrolling technique may include an initial (or final) set of instructions outside of the loop (e.g., two instructions plus a four-instruction <i>for</i> loop that iterates twice).</p><p id="p0030" num="0030">Loop unrolling may be used to facilitate software pipelining when a loop contains an instruction whose result is live (i.e. needs to be kept available) for a long time. Because a new iteration begins every (initiation interval) cycles in the pipelined kernel, an instruction's result cannot normally be used more than (initiation interval) cycles after its definition, as the result would be overwritten or "clobbered" by the copy of the instruction in the subsequent iteration before this use is reached. This problem may be solved by unrolling the loop kernel. Unrolling the loop will, of course, introduce another copy of the long-lifetime instruction into the loop kernel; to avoid this instruction overwriting the long lifetime value it is given a re-named register in which to store its value (so as to avoid clobbering the result of the earlier instruction). Using one of the above-defined terms, a loop kernel may be unrolled if the initiation interval of the loop (i.e., the "length" of the loop) is shorter than the lifetime of one of the instructions in the loop (i.e., the "long-lifetime" instruction). The level of unrolling necessary is a function of how far the initiation interval is exceeded and is known as the loop-unroll factor. If no unrolling is necessary, the loop-unroll factor is one; if two copies of the loop kernel are required, the loop-unroll factor is two, and so on.</p><p id="p0031" num="0031">Another attribute of a loop is whether its iteration count is fixed or variable. If is fixed, a compiler may more easily schedule its execution by (for example) testing whether the iteration count is odd or even (which may affect partially unrolled loops, as discussed above) and generating code accordingly. If the iteration count is variable, however (e.g., a <i>for</i> loop that iterates from <i>1 to x,</i> the compiler cannot tell if the iteration count will be odd or even.</p><p id="p0032" num="0032">Turning now to an embodiment of the current invention, <figref idrefs="f0001">FIG. 1</figref> illustrates a method 100 for compiling code for a loop. In a first step 102, instruction dependencies (e.g., impediments to instruction-level or data-level parallelism) are determined in the loop instructions. In a second step 104, an unpipelined version of the loop is produced which obeys these dependences, together with an initiation interval, such that a new iteration may be started and overlapped with<!-- EPO <DP n="9"> --> currently executing iterations every (initiation interval) cycles without exceeding the parallel resources available on the machine. In a third step 106, the loop-unroll factor for the loop is determined (based on, e.g., the initiation interval of the loop and the lifetime of the loop instructions). In a fourth step 108, the number of iterations of the loop is determined (e.g., unknown or known, and if known, odd or even). In a fifth step 110, stage numbers are assigned to the instructions in the loop based at least in part on the dependencies and parallelism available on the hardware.</p><p id="p0033" num="0033">In one embodiment, instructions for a given loop have dependencies therebetween, but the unroll factor for the loop is one (i.e., no unrolling is required) and the number of iterations of the loop is known. In this embodiment, a compiler tags each loop instruction with pipeline information, i.e., a stage number. The information may be in the form of a three- or four-bit binary number, but the current invention is not limited to any particular expression of the information. The stage number may be held within the instruction encoding itself or may be specified by another mechanism, such as a parallel data structure.</p><p id="p0034" num="0034">During execution, the running of the loop eventually reaches a steady state in which every loop instruction is executed in each iteration, but prior to reaching the steady state, only a subset of the loop instructions are executed in each iteration. Independent instructions are executed first, possibly followed by intermediate instructions that may depend on those first instructions, followed by instructions that may depend on the first and intermediate instructions, and so on until all the instructions are being executed. In the last few iterations of the loop, the instructions that began execution first cease doing so, and the later-added, dependent instructions execute until all instructions have executed their indicated number of times.</p><p id="p0035" num="0035">Semantically, instructions are executed by testing their stage number against a stage threshold that may vary in each iteration. In the loop set-up portion, instructions are executed if their stage number is less than or equal to the stage threshold; in the loop tear-down portion, instructions are executed if their stage number is greater than or equal to the stage threshold. The stage threshold is incremented every iteration during the loop set-up and tear-down portions; the stage threshold is initialized to its lowest value in the loop set-up portion and initialized to its next-to-lowest value in the loop tear-down portion. The stage threshold remains constant in the steady-state portion of the loop. In one embodiment, the stage threshold is incremented by an amount equal to the loop-unroll factor, as described in greater detail below. Those of skill in the<!-- EPO <DP n="10"> --> art will understand that there are many ways to achieve such semantics in hardware, and the present invention is not restricted to the use of stage thresholds. Other ways to achieve the same result may be the use of mask registers, which may be shifted on beginning the next iteration of the loop kernel, or use of other state derived from the values of the loop trip count, stage count and unroll factor. The discussion of stage thresholds is used here for clarity of explanation only.</p><p id="p0036" num="0036">An example 200, shown in <figref idrefs="f0002">FIG. 2</figref>, may aid in describing this embodiment of the invention. While the example 200 includes a specific set of instructions and dependencies, the present invention is not limited to only this configuration, and the example 200 is meant for illustrative purposes only. In this example, a loop executes three iterations and includes five instructions: <i>a, b, c</i>, <i>d,</i> and <i>e</i>. A conflict exists between instructions <i>a</i> and <i>c</i> (i.e., instruction <i>c</i> depends on the output of instruction <i>a</i> and/or the hardware prohibits their simultaneous execution). Similarly, instructions <i>d</i> and <i>e</i> cannot be run simultaneously with instructions <i>a, b,</i> or <i>c</i> due to another conflict. Based on these dependencies, the compiler assigns instructions <i>a</i> and <i>b</i> to stage [0], instruction <i>c</i> to stage [1], and instructions <i>d</i> and <i>e</i> to stage [2].</p><p id="p0037" num="0037">The initiation interval of the loop kernel may also be determined. As discussed above, the initiation interval is the number of cycles it takes to execute one iteration of the pipelined loop kernel. In this example, we assume that the hardware is capable of executing instructions <i>a</i>, <i>c</i>, and <i>d</i> in a first cycle and instructions <i>b</i> and <i>e</i> in a second cycle. The initiation interval is thus two because it takes two cycles to execute all of the loop instructions. For example:
<pre listing-type="program-listing">        for (i = 1; i &lt;= 3; i++) {
               a[0]; c[1]; d[2]; // executed in a first cycle
               b[0];       e[2]; // executed in a second cycle
        }</pre></p><p id="p0038" num="0038">Using this information, the loop kernel 202 may be constructed, showing instructions <i>a</i>, <i>c</i>, and <i>d</i> in a first cycle and instructions <i>b</i> and <i>e</i> in a second cycle. Although only one iteration of the loop kernel 202 is shown, the loop kernel 202 may execute any number of times (in accordance with the number of iterations specified in the original code). The instructions have been annotated with their stage numbers [0], [1], and [2] and, using this information, a system may derive the loop set-up and tear-down instructions by testing the stage numbers against a stage threshold. For example, in a first iteration 204, the system executes instructions having a stage number less than or equal to a stage threshold of [0] (namely, instructions <i>a[0]</i> and <i>b[0]</i>). For illustrative purposes, the instructions have been further annotated with subscripts<!-- EPO <DP n="11"> --> corresponding to the number of times they have executed (e.g., <i>a<sub>1</sub></i> and <i>b<sub>1</sub></i>), but this information is not required by the system. In a second iteration 206, the system executes instructions having a stage number less than or equal to an incremented stage threshold of [1] (namely, instructions <i>a<sub>2</sub>[0], b<sub>2</sub>[0],</i> and <i>c<sub>1</sub>[1]).</i> Note that the first execution of instruction <i>c<sub>1</sub></i> in second iteration 206 occurs after the first execution of instructions <i>a<sub>1</sub></i> and <i>b<sub>1</sub></i> in the first iteration 204, thus satisfying the dependency/conflict between the instructions.</p><p id="p0039" num="0039">In this example 200, the loop enters its steady state on the third iteration 202. The stage threshold is again incremented to [2], and all instructions execute. Other loops may require fewer or more set-up iterations, depending on the nature of the loop, and the current invention is not limited to any particular number of set-up (or tear-down) iterations.</p><p id="p0040" num="0040">Once the loop has reached its second-to-last iteration, it exits the loop kernel 202 and enters a first tear-down iteration 208. The stage threshold is initialized to its next-lowest value (i.e., [1]) and, in the tear-down portion, only instructions having a stage number greater than or equal to the stage threshold (namely, instructions <i>c<sub>3</sub>[1], d<sub>2</sub>[2],</i> and <i>c<sub>2</sub>[2]</i>) execute. In other words, in this example, instructions <i>a</i> and <i>b</i> have already executed their required number of three times, their execution halts in the first tear-down iteration 208. The stage threshold is again incremented to [2] and, in a final tear-down iteration 210, only instructions <i>d<sub>3</sub>[2]</i> and <i>e<sub>3</sub>[2]</i> execute, thus fulfilling the requirement that each instruction execute three times, while respecting the dependencies between the instructions.</p><p id="p0041" num="0041">In another embodiment of the current invention, with reference again to step 104 in <figref idrefs="f0001">FIG. 1</figref>, a loop requires partial unrolling. As discussed above, this requirement may occur when of the lifetime of the result of an instruction in the loop exceeds the loop's initiation interval. As described above, instructions are assigned stage numbers in accordance with their dependencies, and the instructions are scheduled in each iteration of the loop in accordance with the limitations of the hardware to run the instructions. In addition, in this embodiment, the loop kernel is unrolled (i.e., the loop instructions are duplicated in the loop kernel) as required to allow the long-lifetime instruction result to be preserved until its use. In one embodiment, in each successive duplication of the original loop-kernel instructions, (i) the stage numbers of the instructions are decremented by one and (ii) a duplicate (i.e., re-named) register is defined for the duplication(s) of the long-lifetime instructions in the loop kernel (to thereby prevent their values from clobbering each other). Finally, while in the above example (in which the loop-unroll<!-- EPO <DP n="12"> --> factor was one) instructions are selected for execution by incrementing the stage threshold by one, the stage threshold is incremented by the loop-unroll factor (to reflect that more that one unrolled iteration of the loop is present in the loop kernel). Again, other ways of providing this functionality are possible in hardware, including but not restricted to the use of mask registers. The description here in terms of a stage threshold if given for clarity.</p><p id="p0042" num="0042">In general, the range of the stage numbers may be assigned to run from zero to a maximum value necessary (e.g., one, two, or more). When the loop-unroll factor is greater than one, however, the lower bound on the stage number range may be a negative number. In one embodiment, the lower bound is equal to (1 - loop-unroll factor) and the upper bound is equal to (stage count - 1). Any convenient range may be used, however, and the current invention is not limited to any particular range. For example, an all-negative range from (1 - loop-unroll factor - stage count) to -1 may make design of the hardware simpler.</p><p id="p0043" num="0043">As before, an illustrative example 300 may aid in describing this embodiment of the invention. In this example, a loop has seven iterations and three instructions, <i>a, b,</i> and <i>c</i>: instruction <i>b</i> depends on the output of instruction <i>a</i>, and instruction <i>c</i> depends on the output of instruction <i>b</i>. The system that will run the code is capable of running all three instructions simultaneously, making the loop's initiation interval equal to one. For example:
<pre listing-type="program-listing">        for (i = 1; i &lt;= 7; i++) {
               a; b; c;
        }</pre>
Thus, in a straightforward case, the three instructions <i>a, b, c</i> might be assigned three stage numbers [0], [1], [2], respectively, and the loop may be run in a manner similar to the above example 200 shown in <figref idrefs="f0002">FIG. 2</figref>.</p><p id="p0044" num="0044">In this case, however, instruction <i>b</i> takes two cycles to complete, making its execution time greater than the initiation interval of the loop (i.e., one). The loop may therefore be unrolled to accommodate this instruction; one unroll level (loop unroll factor = two) provides a more efficient operation (e.g., one with no or fewer pipeline stalls due to the longer execution time of instruction <i>b</i>). Furthermore, instruction <i>c</i>, which depends on the output of instruction <i>b</i>, may be assigned a later stage number to reflect this dependency. In one embodiment, instruction <i>a</i> is assigned stage [0], instruction <i>b</i> is assigned stage [1], and instruction <i>c</i> is assigned stage [3] (i.e., stage [2] is empty because of the longer execution time of instruction <i>b</i>). The second copy<!-- EPO <DP n="13"> --> of the loop kernel instructions added for the unroll have stage numbers decremented by one unit. For example:
<pre listing-type="program-listing">        for (i = 1; i &lt;= 7; i += 2) {
               a[0]; b[1]; c[3];
               a[-1]; b[0]; c[2];
        }</pre></p><p id="p0045" num="0045">Referring again to <figref idrefs="f0003">FIG. 3</figref>, the loop kernel 302 is shown with a first portion 304 that includes the first iteration of the loop-kernel instructions <i>a[0], b[1],</i> and <i>c[3]</i> and a second portion 306 that includes the same instructions with their stage numbers decremented by one (e.g., <i>a[-1], b[0],</i> and <i>c[2]).</i> As in the above example, a system executing this loop may be passed only this information (i.e., the loop-kernel instructions and their tag information) and may derive the loop set-up and tear-down instructions based only thereon.</p><p id="p0046" num="0046">Thus, in a first iteration 308 of the loop, the stage threshold is set to stage number [0], and instructions in the loop kernel 302 having a stage number less than or equal to 0 are run (namely, instructions <i>a<sub>1</sub>[0], a<sub>2</sub>[-1]</i> and <i>b<sub>1</sub>[0]</i>). In a second iteration 310, the stage threshold is incremented in accordance with the loop-unroll factor of two to [2] and instructions having a stage number less than or equal to [2] are run (namely, <i>a<sub>3</sub>[0], b<sub>2</sub>[1], a<sub>4</sub>[0], b<sub>3</sub>[0]</i> and <i>c<sub>1</sub>[2]</i>). Thus, in the second iteration 310, instructions <i>a<sub>3</sub>[0]</i> and <i>b<sub>2</sub>[1]</i> are run in a first unrolled instance of the loop, and instructions <i>a<sub>4</sub>[-1], b<sub>3</sub>[0]</i> and <i>c<sub>1</sub>[2]</i> are run in a second unrolled instance of the loop. Because instruction <i>b</i> has a lifetime of two cycles, the result of instruction <i>b<sub>3</sub>[0]</i> is stored in a re-named register to avoid overwriting the result of the earlier-executed instruction <i>b<sub>2</sub>[1].</i></p><p id="p0047" num="0047">As described above, once the instructions of the second iteration 310 have executed (and, in the case of instruction <i>b<sub>3</sub>[0],</i> are still executing), the instructions of the loop kernel 302 begin to execute. In one embodiment, the stage threshold is again incremented by two (i.e., by an amount equal to the loop-unroll factor) to [4] and, because [4] is greater than the maximum stage number, all instructions in the loop are executed. Again, although only one copy of the loop kernel 302 is illustrated, it is the steady-state portion of the loop and may execute any number of times (in accordance with the loop parameters specified in the original source code).</p><p id="p0048" num="0048">Once the next-to-last iteration of the loop has been reached, a first tear-down iteration 312 begins. In this iteration, the stage threshold is initialized to the next-to-lowest stage number (i.e., [0]); instructions having a stage number greater than or equal to zero (namely, <i>a<sub>6</sub>[0], b<sub>6</sub>[1],<!-- EPO <DP n="14"> --> c<sub>4</sub>[3], b<sub>7</sub>[0]</i> and <i>c<sub>5</sub>[2])</i> are executed. Finally, in a final tear-down iteration 314, the instruction having a stage number greater than or equal to the again-incremented stage threshold (i.e., [2]) are executed. As with the above example, each instruction <i>a, b, c</i> executes seven times in accordance with the original loop iteration count, and each dependency is honored (e.g., each instance of instruction <i>b</i> executes one clock cycle after the execution of the corresponding instruction <i>a</i>; likewise the instructions <i>c</i> execute two cycles after the instructions <i>b</i>).</p><p id="p0049" num="0049">In another embodiment of the present invention, with reference to step 108 of <figref idrefs="f0001">FIG. 1</figref>, the number of iterations of a loop may not be known at compile time. In cases in which the loop-unroll factor is one, such as in the example 200 shown in <figref idrefs="f0002">FIG. 2</figref>, the uncertainty in the iteration count may not present a challenge; the steady-state portion of the loop simply repeats the requisite number of times, in accordance with the runtime iteration count. In cases in which the loop-unroll factor is greater than one, however, it may be more difficult to create the requisite number of iterations. Because the partially unrolled loop in the loop kernel has two or more iterations built in, total loop iteration counts that are not multiples of those two or more unrolled iterations may be difficult to construct.</p><p id="p0050" num="0050">As an example, the loop 300 shown in <figref idrefs="f0003">FIG. 3</figref> has a partially unrolled kernel 302 (having a loop unroll factor of two). In that simple example, the kernel 302 executes just one time, and the total number of iterations of the loop is seven (i.e., each instruction executes seven times). If the total number of iterations were nine, eleven, or thirteen, etc., the loop kernel 302 might be repeated two, three, or four, etc. times to create the necessary number of total iterations. If, however, the total number of desired iterations is eight, the loop structure of <figref idrefs="f0003">FIG. 3</figref> is not able to create that number without modification (i.e., one iteration of the loop 302 is too few but two iterations is too many).</p><p id="p0051" num="0051">In one embodiment, the instructions making up the first iteration of the loop set-up are delayed by one or more initiation intervals, as necessary, to create a desired total iteration count. The number of iterations called for by the original loop in the source code is <i>N</i>; the number of iterations of a loop constructed in accordance with embodiments of the current invention may be <i>(N</i> + <i>[stage count - 1]),</i> in which the <i>(stage count - 1)</i> additional iterations are used for loop set-up and tear-down iterations. If <i>(N + [stage count - 1])</i> is not an integer multiple of the loop-unroll factor, it is rounded up until it is (i.e., the loop is set up to run at least one more iteration).<!-- EPO <DP n="15"> --> In this event, the initial value of the stage threshold is reduced below zero so that on entry to the pipelined loop, initial parts of the unrolled loop are turned off.</p><p id="p0052" num="0052">Once again, an example is helpful. The loop 300 of <figref idrefs="f0003">FIG. 3</figref>, which was configured to run seven total iterations, has been modified to run eight iterations, as shown by the diagram 400 in <figref idrefs="f0004">FIG. 4</figref>. The loop kernel 402 has been duplicated to execute twice, which would have normally produced nine total iterations of the loop. However, in this case the initial value of the stage threshold is set to [-1]. The first cycle 404 of the loop prolog is therefore disabled as all instructions on this line have stage number greater than the initial stage threshold. As a result, each of the instructions <i>a, b, c</i> execute eight times (instead of nine).</p><p id="p0053" num="0053">Another benefit of the delaying indicated at 404 involves the register renaming necessary in loop unrolling. On exit from a pipelined loop, any values computed during the loop and used outside it have to be stored in a known register so that it is possible to find the correct value. However the act of register renaming of results with long lifetime during loop unrolling creates more than one register in which the value lives during the loop. If a loop kernel 402 can exit halfway through its execution (or, in the case of loops having loop-unroll factors greater than two, at some point other than fully through its execution), the final value of a result that is used outside the loop may be held in any of these renamed registers; i.e. if the loop trip count is unknown at compile time then it is not known which register will hold the final result). By placing the delay 404 at the beginning of the loop prolog 404, the kernel 402 exits after a full completion of its execution, thus making sure that it is always known which register will hold the final value of a result in the loop. Coming into the kernel 402, it is easy to ensure that all copies of a renamed register are initialized to their correct initial values if required.</p><p id="p0054" num="0054">In one embodiment, more than one processing element is available for execution of code, and the compiler sends data-independent instructions to each processing element. If the number of iterations of a loop is not a multiple of the number of processing elements, some of the processing units may be idle in the last iteration of the loop (i.e., their operations may be masked off). An example embodiment 500 of a seven-iteration loop executing on a two-processing-element system is illustrated in <figref idrefs="f0005">FIG. 5</figref>. The code may exhibit the following dependencies:
<pre listing-type="program-listing">        for (i = 1; i &lt;= 7; i++) {
               a[1]; c[0];<!-- EPO <DP n="16"> -->
               b[0]; d[1];
        }</pre>
Because seven is not an even multiple of two, four iterations of the loop are sent to a first processing element 502 and three iterations are sent to a second processing element 504. The stage [0] instructions begin executing in a first stage 506, in accordance with the stage threshold, and the loop kernels 508 execute in subsequent stages. The kernel 508 exits first on the second processor 504, while it runs an additional iteration on the first processor 502. Both processors 502, 504 execute stage [1] instructions in a final iteration 510.</p><p id="p0055" num="0055">One embodiment of a system 600 for annotating loop instructions with stage numbers appears in <figref idrefs="f0006">FIG. 6</figref>. A source-code analysis module 602 analyzes source code for candidate instructions (e.g., loop instructions) that exhibit instruction-level or data-level parallelism. (Modules are typically realized in software form, i.e., as sets of computer-executable instructions stored in non-volatile memory for execution by a processor. Program modules include routines, programs, objects, components, and/or data structures, etc., that perform particular tasks or implement particular abstract data types. As is well-known in the art, however, functional modules may also be implemented in hardware or as mixed software/hardware components, depending on the requirements of a particular application.) The source-code analysis module 602 may identify these instructions in the source code based on pattern-matching, parsing, partial (or entire) compilation, or any other method of analyzing code known in the art. Any kind of source code is within the scope of the current invention. Once identified, a stage-number generation module 604 assigns stage numbers to the instructions, in accordance with embodiments of the current invention, based on inter-instruction dependencies, limitations, or features of the hardware that will run the code, or any other relevant factors. One or both of the modules 602, 604 may determine properties related to the loop, such as its initiation interval, stage count, and/or loop-unroll factor, and any or all of these properties may be used in assigning the stage numbers to the instructions. Once the stage numbers have been determined for some or all of the instructions, an assembly-code or object code output module 606 may prepare, format, and output assembly or object code (that includes the stage numbers) suitable for execution on one or more target processors. The current invention is not limited, however, to an implementation involving only these modules 602, 604, 606, and one of skill in the art will<!-- EPO <DP n="17"> --> understand that the functionality implemented in the modules 602, 604, 606 may be implemented in more or fewer modules.</p><p id="p0056" num="0056">A system 700 for executing code having stage-number annotations appears in <figref idrefs="f0007">FIG. 7</figref>. A sequencer 702 contains state information and issues instructions to one or a plurality of processing elements 704. The sequencer 702 may store information regarding a currently-executing loop, such as the loop-unroll factor, the number of iterations remaining in the loop (i.e., the "loop count"), which stage numbers should be executed in each iteration of the loop, and which of the plurality of processing elements 704 should execute instructions in a last iteration of a loop. One of skill in the art will realize that there are many ways to implement the sequencer 702 (or its similar functionality into another functional block), and the current invention is not limited to any particular implementation. Moreover, the processing elements 704 may be any type of general purpose or specialized compute block that is controlled by the sequencer. Moreover it is to be understood that the invention also applies to the control of independent elements within vectors processed within a single compute unit, which in this sense can be treated as if they existed in separate processing elements. Such a machine is typically referred to as a Single Instruction, Multiple Data (SIMD) processor.</p><p id="p0057" num="0057">The sequencer 702 (more specifically, the hardware implementing it) includes registers for storing state information, such as a loop-count register 706 for storing the loop count and a loop-unroll-factor register 708 for storing the loop-unroll count (also known as a modulo-variable expansion, or "MVE," unroll factor). A stage-mask register 710 is populated with information regarding which instructions should be executed in which iteration (based on their stage numbers); for example, one bit of the stage-mask register 710 may indicate that instructions of stage [0] should execute, another bit may indicate that instructions of stage [1] should execute, and so on. The stage-mask register may be reproduced at each processing element 704 in local stage-mask registers 714 (to account for the fact that each processing element 704 may execute instructions having different stage numbers in each iteration). A final-iteration mask register 712 may be used to indicate which of the plurality of processing elements 704 should be on or off during the final iteration of a loop.</p><p id="p0058" num="0058">The loop-count register 706 may be eight, sixteen, or any other number of bits in size; the value stored in the loop-count register 706 decrements (by, e.g., the loop-unroll factor) each time the loop iterates. Once the value in the loop-count register 706 reaches zero, the loop<!-- EPO <DP n="18"> --> ceases iterating. The loop-unroll-factor register 708 may be two bits in size to support a maximum unroll factor of four, three bits in size to support a maximum unroll factor of eight, or any other size. The stage-mask register 710 may be of a size equal to at least the sum of the loop-unroll factor and the maximum stage count. In one embodiment, the stage-mask register 710 is 23 bits in size. The final-iteration-mask register 712 may have one bit for each of the processing elements 704.</p><p id="p0059" num="0059">A loop instruction may be used to initialize the state registers 706, 708, 710, 712 in the sequencer 702. The loop instruction may include parameters that indicate the total loop count, the number of processing elements to use, the stage count, and the loop-unroll factor. The loop-unroll-factor register 708 is loaded with the value of the loop-unroll factor given in the loop instruction; the values of the other registers 706, 710, 712 may be derived from the loop-instruction parameters in accordance with equations (1)-(3), as shown below. <maths id="math0001" num="(1)"><math display="block"><mi>loop</mi><mo>-</mo><mi>count register</mi><mspace width="1em"/><mn>706</mn><mo>=</mo><mo>⌈</mo><mfrac><mrow><mo>⌈</mo><mfrac><mi>N</mi><mi mathvariant="italic">VLEN</mi></mfrac><mo>⌉</mo><mo>+</mo><mi mathvariant="italic">SC</mi><mo>-</mo><mn>1</mn></mrow><mi mathvariant="italic">MVE</mi></mfrac><mo>⌉</mo><mo>×</mo><mi mathvariant="italic">MVE</mi></math><img id="ib0001" file="imgb0001.tif" wi="156" he="30" img-content="math" img-format="tif"/></maths> <maths id="math0002" num="(2)"><math display="block"><mi>stage</mi><mo>-</mo><mi>mask register</mi><mspace width="1em"/><mn>710</mn><mo>=</mo><mfenced separators=""><mfenced separators=""><mo>-</mo><mn>1</mn></mfenced><mo>&lt;</mo><mo>&lt;</mo><mfenced separators=""><mi mathvariant="italic">SC</mi><mo>+</mo><mfenced separators=""><mi mathvariant="italic">LC</mi><mo>-</mo><mfenced separators=""><mo>⌈</mo><mfrac><mi>N</mi><mi mathvariant="italic">VLEN</mi></mfrac><mo>⌉</mo><mo>+</mo><mi mathvariant="italic">SC</mi><mo>-</mo><mn>1</mn></mfenced><mo>-</mo><mn>1</mn></mfenced></mfenced></mfenced></math><img id="ib0002" file="imgb0002.tif" wi="156" he="24" img-content="math" img-format="tif"/></maths> <maths id="math0003" num="(3)"><math display="block"><mi>final</mi><mo>-</mo><mi>iteration</mi><mo>-</mo><mi>mask register</mi><mspace width="1em"/><mn>712</mn><mo>=</mo><mfenced separators=""><mn>1</mn><mo>&lt;</mo><mo>&lt;</mo><mfenced separators=""><mfenced separators=""><mfenced separators=""><mi>N</mi><mo>-</mo><mn>1</mn></mfenced><mo>%</mo><mi mathvariant="italic">VLEN</mi></mfenced><mo>+</mo><mn>1</mn></mfenced></mfenced><mo>-</mo><mn>1</mn></math><img id="ib0003" file="imgb0003.tif" wi="156" he="15" img-content="math" img-format="tif"/></maths> Regarding equation (1), the loop count is related to the number of iterations in the original code (N) divided by the number of processing elements 704 executing the instructions in parallel (VLEN or vector length). Additional iterations (SC - 1) are needed for loop set-up and tear down. The result is rounded up to the nearest multiple of the loop-unroll factor (MVE). Regarding equation (2), binary ones are shifted into the stage-mask register 710 in accordance with the stage count (SC), taking into account any rounding up made necessary by the loop-unroll factor (MVE) as computed in the loop-count register 706 (LC). Regarding equation (3), binary ones are shifted into the final-iteration-mask register 712 equal to the number of iterations (N) modulo the number of processing elements 704 (VLEN) to mask off the unneeded<!-- EPO <DP n="19"> --> processing elements 704 in the last iteration (i.e,. the modulo operation gives the number of "left over" instructions in the last iteration). For example, N = 13 and VLEN = 8 gives FMASK = 00011111, while N = 16 gives FMASK = 11111111. Finally, if the value of the loop-count register 706 is less than or equal to the number of bits in the stage-mask register 710 (i.e., the last few iterations of the loop may be approaching), any bits above and including the (LC - 1)<sup>th</sup> bit in the stage-mask register 710 are cleared, and the values from the final-iteration mask register 712 are used to re-populate the (LC - 1)<sup>th</sup> bit positions in the stage-mask register 710.</p><p id="p0060" num="0060">The recomputed contents of the stage-mask register 710 are then pushed out to the local copies 714 of the register in each processing element 704, wherein the (LC - 1)<sup>th</sup> bit positions, when reached, instruct some of the processing elements 704 to switch off during the last iteration. Each processing element 704 receives and decodes instructions and inspects each instruction's stage number; the instruction is executed if its corresponding bit entry in that processing element's local mask register 714 is set. In one embodiment, the bit position of the corresponding stage number in the local mask register 714 is computed at compile or assemble time and encoded in the instruction, thereby freeing up the hardware from computing and/or storing the value.</p><p id="p0061" num="0061">In one example, the loop instruction specifies that the loop count is 523, the number of processing elements (VLEN) is 4, the stage count is 3, and the loop-unroll (MVE) factor is 2. In this example, the loop-count register 706 receives a value of 134, the loop-unroll-factor register 708 receives a value of 2, the stage-mask register 710 receives a value of 11...11000 (as do all the local registers 714), and the final-iteration-mask register 712 receives a value of 0111.</p><p id="p0062" num="0062">The state registers 706 and 710 may be updated each time the loop iterates. In one embodiment, the loop-count register 706 is decremented by the value of the loop-unroll-factor register 708, and the state-mask register 710 is shifted right a number of times equal to the value loop-unroll-factor register 708. If the loop is nearing its last few iterations (e.g., if the value of the loop-count register 706 is less than or equal to the number of bits in the stage-mask register 710), zeros are shifted in; otherwise ones are shifted in. As described above, if the loop is in its last (or last few) iterations, the values of the final-iteration-mask register 712 are copied to the local mask registers 714 (at their (LC - 1)<sup>th</sup> bit positions).</p><p id="p0063" num="0063">For example, after one iteration of the loop introduced in the last example, the loop-count register 706 is updated to a value of 132, and the stage-mask register 710 is updated to a<!-- EPO <DP n="20"> --> value of 11...11110 (as are all the local registers 714). In another iteration of the loop near, but not at, the end of its lifetime, the loop-count register 706 is updated to a value of 4, and the stage-mask register 710 is updated to a value of 00...00111. The local registers 714 are updated to have different values in accordance with the final-iteration-mask register 712, namely, 00...1111, 00...1111, 00...1111, and 00...0111.In a final iteration of the loop, the loop-count register 706 is updated to a value of 2, and the stage-mask register 710 is updated to a value of 00...001. The local registers 714 are again updated to have different values in accordance with the final-iteration-mask register 712, namely, 00...0011, 00...0011, 00...0011, and 00...0001.</p><p id="p0064" num="0064">A method 800 for executing loop instructions in accordance with embodiments of the current invention is shown in <figref idrefs="f0008">FIG. 8</figref>. In a first step 802, a loop instruction is received with information about the loop to be run (e.g., loop-unroll factor and iteration count). State registers (in, e.g., a sequencer) are initialized with this information (and/or values derived therefrom). In a second step 804, a mask is computed for one or more processing elements and sent thereto; this mask (e.g., the stage mask described above with reference to <figref idrefs="f0007">FIG. 7</figref>) contains information about which stages of instructions to execute. In a third step 806, the loop instructions are executed in accordance with their stage number and the mask. In a fourth step 808, the mask (and state information) is updated on loop back. One of skill in the art will realize that there are many ways in which the bits that control the processing elements may be organized within mask registers or otherwise, and the present invention is not limited to the described implementation of global mask registers held within the sequencer and local mask registers within each processing element. For example, it is equally possible for all required state to be held within the sequencer and instructions distributed to the processing elements in accordance with which instructions are currently enabled for each processing element.</p><p id="p0065" num="0065">It should also be noted that embodiments of the present invention may be provided as one or more computer-readable programs embodied on or in one or more articles of manufacture. The article of manufacture may be any suitable hardware apparatus, such as, for example, a floppy disk, a hard disk, a CD ROM, a CD-RW, a CD-R, a DVD ROM, a DVD-RW, a DVD-R, a flash memory card, a PROM, a RAM, a ROM, or a magnetic tape. In general, the computer-readable programs may be implemented in any programming language. Some examples of languages that may be used include C, C++, or JAVA. The software programs may be further translated into machine language or virtual machine instructions and stored in a program file in<!-- EPO <DP n="21"> --> that form. The program file may then be stored on or in one or more of the articles of manufacture.</p><p id="p0066" num="0066">Certain embodiments of the present invention were described above. It is, however, expressly noted that the present invention is not limited to those embodiments, but rather the intention is that additions and modifications to what was expressly described herein are also included within the scope of the invention. Moreover, it is to be understood that the features of the various embodiments described herein were not mutually exclusive and can exist in various combinations and permutations, even if such combinations or permutations were not made express herein. In fact, variations, modifications, and other implementations of what was described herein will occur to those of ordinary skill in the art. As such, the invention is not to be defined only by the preceding illustrative description.</p></description><claims mxw-id="PCLM56976515" lang="EN" load-source="patent-office"><!-- EPO <DP n="22"> --><claim id="c-en-0001" num="0001"><claim-text>A method of executing a loop by a computer processor, the method comprising:
<claim-text>loading loop kernel instructions for the loop into a memory of the computer processor, each loop kernel instruction having a stage number associated therewith;</claim-text>
<claim-text>determining a stage threshold during each iteration of the loop;</claim-text>
<claim-text>executing a loop prolog by executing subsets of the loop kernel instructions based on the stage threshold and stage numbers;</claim-text>
<claim-text>executing a loop kernel by repeatedly executing the loop kernel instructions; and</claim-text>
<claim-text>executing a loop epilog by executing a second set of subsets of the loop kernel instructions based on the stage threshold and stage numbers.</claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The method of claim 1, wherein one or more of the following apply:
<claim-text>a) the computer processor is a scalar processor, wherein the loop kernel instructions comprise instructions having instruction-level parallelism or multi-cycle latencies, and wherein the loop kernel instructions are software pipelined;</claim-text>
<claim-text>b) the stage numbers are adjusted in accordance with each copy of an unrolled loop kernel.</claim-text></claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The method of claims 1 or 2, wherein a final execution of a loop instruction runs on fewer processing or vector elements than on earlier iterations of the loop.</claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The method of claim 3, wherein the fewer processing or vector elements are selected in accordance with a mask bits controlling each processing or vector element.</claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The method of any preceding claim, further comprising receiving a loop setup instruction that includes information relating to the stage threshold.</claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The method of claim 5, wherein the loop setup instruction comprises a total loop count, a number of processing elements to use in executing the loop instructions, a stage count, or a loop-unroll factor.<!-- EPO <DP n="23"> --></claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>The method of any preceding claim, wherein executing the loop epilog, loop kernel, and the loop prolog comprises comparing the instruction stage numbers to a stage threshold in the computer processor.</claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>A system (700) for executing computer-executable loop instructions, the system comprising:
<claim-text>a sequencer (702) for receiving a loop-setup instruction comprising loop information;</claim-text>
<claim-text>a register or registers (706, 708, 710, 712) for storing data related to a stage threshold, the data being derived from the loop information; and</claim-text>
<claim-text>a processing element (704) for executing (i) a loop prolog by executing subsets of received loop kernel instructions based on the stage threshold and stage numbers associated with the loop kernel instructions, (ii) a loop kernel by repeatedly executing the loop kernel instructions, and (iii) a loop epilog by executing a second set of subsets of the loop kernel instructions based on the stage threshold and stage numbers.</claim-text></claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>The system of claim 8, wherein the registers (706, 708, 710, 712) comprise stage-mask or stage-threshold registers.</claim-text></claim><claim id="c-en-0010" num="0010"><claim-text>The system of claim 8 or 9, further comprising at least one additional processing element (704)for executing loop kernel instructions, or vector instructions to process multiple data elements in parallel.</claim-text></claim><claim id="c-en-0011" num="0011"><claim-text>The system of claim 10, wherein, during a final execution of an instruction, only a subset of the processing or vector elements (704) execute loop kernel instructions.</claim-text></claim><claim id="c-en-0012" num="0012"><claim-text>The system of claim 11, wherein mask registers (712) store information related to executing loop kernel instructions in the final iteration.</claim-text></claim><claim id="c-en-0013" num="0013"><claim-text>The system of any of claims 8 to 12, wherein the loop information comprises a total loop count, a number of processing elements (704) to use in executing the loop instructions, a stage count, or a loop-unroll factor.</claim-text></claim><claim id="c-en-0014" num="0014"><claim-text>The system of any of claims 8 to 12, further comprising a loop-count register (706 for storing a loop count.<!-- EPO <DP n="24"> --></claim-text></claim><claim id="c-en-0015" num="0015"><claim-text>The system of claim 14, wherein the loop count is derived from a total loop count divided by a number of processing elements (704) to use in executing the loop instructions and adjusted in accordance with a stage count and rounded in accordance with a loop-unroll factor.</claim-text></claim></claims><drawings mxw-id="PDW16667295" load-source="patent-office"><!-- EPO <DP n="25"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="142" he="218" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="26"> --><figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="161" he="220" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="27"> --><figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="164" he="218" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="28"> --><figure id="f0004" num="4"><img id="if0004" file="imgf0004.tif" wi="165" he="211" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="29"> --><figure id="f0005" num="5"><img id="if0005" file="imgf0005.tif" wi="165" he="221" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="30"> --><figure id="f0006" num="6"><img id="if0006" file="imgf0006.tif" wi="161" he="228" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="31"> --><figure id="f0007" num="7"><img id="if0007" file="imgf0007.tif" wi="165" he="208" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="32"> --><figure id="f0008" num="8"><img id="if0008" file="imgf0008.tif" wi="144" he="231" img-content="drawing" img-format="tif"/></figure></drawings><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
