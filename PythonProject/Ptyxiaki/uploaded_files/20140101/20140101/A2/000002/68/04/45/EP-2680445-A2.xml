<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2680445-A2" country="EP" doc-number="2680445" kind="A2" date="20140101" family-id="48703132" file-reference-id="316601" date-produced="20180824" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146549243" ucid="EP-2680445-A2"><document-id><country>EP</country><doc-number>2680445</doc-number><kind>A2</kind><date>20140101</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-13171211-A" is-representative="YES"><document-id mxw-id="PAPP154823166" load-source="docdb" format="epo"><country>EP</country><doc-number>13171211</doc-number><kind>A</kind><date>20130610</date><lang>EN</lang></document-id><document-id mxw-id="PAPP178958729" load-source="docdb" format="original"><country>EP</country><doc-number>13171211.9</doc-number><date>20130610</date></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140450831" ucid="JP-2012145224-A" load-source="docdb"><document-id format="epo"><country>JP</country><doc-number>2012145224</doc-number><kind>A</kind><date>20120628</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-2126666865" load-source="docdb">H03M   7/40        20060101AFI20141128BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-2034533378" load-source="docdb" scheme="CPC">H03M   7/4031      20130101 LI20150729BHEP        </classification-cpc><classification-cpc mxw-id="PCL1991312736" load-source="docdb" scheme="CPC">G06F  17/30292     20130101 FI20131226BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132180213" lang="DE" load-source="patent-office">Kodeverarbeitungstechnik</invention-title><invention-title mxw-id="PT132180214" lang="EN" load-source="patent-office">Code processing technique</invention-title><invention-title mxw-id="PT132180215" lang="FR" load-source="patent-office">Technique de traitement de code</invention-title><citations><non-patent-citations><nplcit><text>None</text><sources><source mxw-id="PNPL45130899" load-source="docdb" name="APP"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR918136541" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>FUJITSU LTD</last-name><address><country>JP</country></address></addressbook></applicant><applicant mxw-id="PPAR918163557" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>FUJITSU LIMITED</last-name></addressbook></applicant><applicant mxw-id="PPAR918982532" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>FUJITSU LIMITED</last-name><iid>100126510</iid><address><street>1-1, Kamikodanaka 4-chome, Nakahara-ku</street><city>Kawasaki-shi, Kanagawa 211-8588</city><country>JP</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR918136010" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>NINOMIYA DAISUKE</last-name><address><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918167779" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>NINOMIYA, DAISUKE</last-name></addressbook></inventor><inventor mxw-id="PPAR918980022" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>NINOMIYA, DAISUKE</last-name><address><street>c/o FUJITSU LIMITED 1-1, Kamikodanaka 4-chome Nakahara-ku Kawasaki-shi</street><city>Kanagawa, 211-8588</city><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918164834" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>HIGUCHI MASAHIRO</last-name><address><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918156067" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>HIGUCHI, MASAHIRO</last-name></addressbook></inventor><inventor mxw-id="PPAR918992523" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>HIGUCHI, MASAHIRO</last-name><address><street>c/o FUJITSU LIMITED 1-1, Kamikodanaka 4-chome Nakahara-ku Kawasaki-shi</street><city>Kanagawa, 211-8588</city><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918145290" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>KOYAMA YUTAKA</last-name><address><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918150004" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>KOYAMA, YUTAKA</last-name></addressbook></inventor><inventor mxw-id="PPAR918982913" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>KOYAMA, YUTAKA</last-name><address><street>c/o FUJITSU LIMITED 1-1, Kamikodanaka 4-chome Nakahara-ku Kawasaki-shi</street><city>Kanagawa, 211-8588</city><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918159194" load-source="docdb" sequence="4" format="epo"><addressbook><last-name>NISHIGAKI MASAKI</last-name><address><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918169702" load-source="docdb" sequence="4" format="intermediate"><addressbook><last-name>NISHIGAKI, MASAKI</last-name></addressbook></inventor><inventor mxw-id="PPAR918994204" load-source="patent-office" sequence="4" format="original"><addressbook><last-name>NISHIGAKI, MASAKI</last-name><address><street>c/o FUJITSU LIMITED 1-1, Kamikodanaka 4-chome Nakahara-ku Kawasaki-shi</street><city>Kanagawa, 211-8588</city><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918156052" load-source="docdb" sequence="5" format="epo"><addressbook><last-name>MATSUMURA RYO</last-name><address><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918153620" load-source="docdb" sequence="5" format="intermediate"><addressbook><last-name>MATSUMURA, RYO</last-name></addressbook></inventor><inventor mxw-id="PPAR918989312" load-source="patent-office" sequence="5" format="original"><addressbook><last-name>MATSUMURA, RYO</last-name><address><street>c/o FUJITSU LIMITED 1-1, Kamikodanaka 4-chome Nakahara-ku Kawasaki-shi</street><city>Kanagawa, 211-8588</city><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918141590" load-source="docdb" sequence="6" format="epo"><addressbook><last-name>ONO TOSHIROU</last-name><address><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918148977" load-source="docdb" sequence="6" format="intermediate"><addressbook><last-name>ONO, TOSHIROU</last-name></addressbook></inventor><inventor mxw-id="PPAR918981914" load-source="patent-office" sequence="6" format="original"><addressbook><last-name>ONO, TOSHIROU</last-name><address><street>c/o FUJITSU LIMITED 1-1, Kamikodanaka 4-chome Nakahara-ku Kawasaki-shi</street><city>Kanagawa, 211-8588</city><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918164438" load-source="docdb" sequence="7" format="epo"><addressbook><last-name>OZAWA TAKAKI</last-name><address><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918142440" load-source="docdb" sequence="7" format="intermediate"><addressbook><last-name>OZAWA, TAKAKI</last-name></addressbook></inventor><inventor mxw-id="PPAR918987751" load-source="patent-office" sequence="7" format="original"><addressbook><last-name>OZAWA, TAKAKI</last-name><address><street>c/o FUJITSU LIMITED 1-1, Kamikodanaka 4-chome Nakahara-ku Kawasaki-shi</street><city>Kanagawa, 211-8588</city><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918153711" load-source="docdb" sequence="8" format="epo"><addressbook><last-name>KAWAI JUNJI</last-name><address><country>JP</country></address></addressbook></inventor><inventor mxw-id="PPAR918145162" load-source="docdb" sequence="8" format="intermediate"><addressbook><last-name>KAWAI, JUNJI</last-name></addressbook></inventor><inventor mxw-id="PPAR918988223" load-source="patent-office" sequence="8" format="original"><addressbook><last-name>KAWAI, JUNJI</last-name><address><street>c/o FUJITSU LIMITED 1-1, Kamikodanaka 4-chome Nakahara-ku Kawasaki-shi</street><city>Kanagawa, 211-8588</city><country>JP</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR918994052" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>HOFFMANN EITLE</last-name><iid>100061036</iid><address><street>Patent- und Rechtsanwälte Arabellastrasse 4</street><city>81925 München</city><country>DE</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS548851622" load-source="docdb">AL</country><country mxw-id="DS548856407" load-source="docdb">AT</country><country mxw-id="DS548851624" load-source="docdb">BE</country><country mxw-id="DS548838740" load-source="docdb">BG</country><country mxw-id="DS548803665" load-source="docdb">CH</country><country mxw-id="DS548802387" load-source="docdb">CY</country><country mxw-id="DS548856408" load-source="docdb">CZ</country><country mxw-id="DS548851625" load-source="docdb">DE</country><country mxw-id="DS548802388" load-source="docdb">DK</country><country mxw-id="DS548802389" load-source="docdb">EE</country><country mxw-id="DS548853273" load-source="docdb">ES</country><country mxw-id="DS548838741" load-source="docdb">FI</country><country mxw-id="DS548803666" load-source="docdb">FR</country><country mxw-id="DS548851626" load-source="docdb">GB</country><country mxw-id="DS548802394" load-source="docdb">GR</country><country mxw-id="DS548851627" load-source="docdb">HR</country><country mxw-id="DS548856409" load-source="docdb">HU</country><country mxw-id="DS548853274" load-source="docdb">IE</country><country mxw-id="DS548802395" load-source="docdb">IS</country><country mxw-id="DS548838742" load-source="docdb">IT</country><country mxw-id="DS548802396" load-source="docdb">LI</country><country mxw-id="DS548838743" load-source="docdb">LT</country><country mxw-id="DS548874157" load-source="docdb">LU</country><country mxw-id="DS548838744" load-source="docdb">LV</country><country mxw-id="DS548838745" load-source="docdb">MC</country><country mxw-id="DS548874158" load-source="docdb">MK</country><country mxw-id="DS548874159" load-source="docdb">MT</country><country mxw-id="DS548874160" load-source="docdb">NL</country><country mxw-id="DS548803667" load-source="docdb">NO</country><country mxw-id="DS548874161" load-source="docdb">PL</country><country mxw-id="DS548853275" load-source="docdb">PT</country><country mxw-id="DS548856089" load-source="docdb">RO</country><country mxw-id="DS548853276" load-source="docdb">RS</country><country mxw-id="DS548874162" load-source="docdb">SE</country><country mxw-id="DS548851629" load-source="docdb">SI</country><country mxw-id="DS548803668" load-source="docdb">SK</country><country mxw-id="DS548803669" load-source="docdb">SM</country><country mxw-id="DS548802397" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA128669913" lang="EN" load-source="patent-office"><p id="pa01" num="0001">A disclosed data structure of a phrase tree includes, as data of each node in the phrase tree, a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, a number of appearances or a code corresponding to a character string comprising the character or the character string and the second character when the number of appearances exceeds a threshold.
<img id="iaf01" file="imgaf001.tif" wi="165" he="52" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA128499286" lang="EN" source="EPO" load-source="docdb"><p>A disclosed data structure of a phrase tree includes, as data of each node in the phrase tree, a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, a number of appearances or a code corresponding to a character string comprising the character or the character string and the second character when the number of appearances exceeds a threshold.</p></abstract><description mxw-id="PDES63955343" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><p id="p0001" num="0001">In a conventional technique, a phrase tree is generated in order to compress an input character string. Each node in a phrase tree includes a code to be replaced with a character or character string, characters to be compressed, data representing the hierarchy level, a pointer to a parent node, pointers that point to each of child nodes, which corresponds to each character that may be used, and a counter that counts the number of times that a character corresponding to each of the child nodes appears. For example, when an input character string "ABABCABCABCCBCBCBCAAACBACBACBBCCBB" is inputted, a phrase tree such as illustrated in <figref idrefs="f0001">FIG. 1</figref> is generated. The threshold value for the number of appearances in order to generate a new node is "2". In this example, a root node is provided as the 0-th level node, and nodes for characters "0x00" to "0xFF" are provided as 1st level nodes. As 2nd level nodes, nodes for characters "0x42" and "0x41" are provided as child nodes of character "0x41", a node for character "0x43" is provided as a child node of character "0x42", a node for character "0x42" is provided as a child node of character "0x43". Furthermore, as 3rd level nodes, a node for character "0x43" is provided as a child node of character "0x42", and nodes for characters "0x43", "0x41" and "0x42" are provided as child nodes of character "0x42". For each node, a code (A), a character (B), the numbers of appearances (C) for characters of child nodes, and pointers (D) that point to child nodes are illustrated schematically.</p><p id="p0002" num="0002">As illustrated in <figref idrefs="f0002">FIG. 2</figref>, because the number of child node pointers and the number of counters for the numbers of appearances of characters for child nodes are equal to 256, which is equal to the number of characters that may be used, 3,085 bytes are used as a capacity of the memory used for one node. Presuming that 65,536 nodes, which are the maximum number of nodes that can be expressed with a 2 bytes of the code length are provided, about 192 Mbytes are totally used as a capacity of memory.</p><p id="p0003" num="0003">The phrase tree can compress various data, when the number of types of codes (in other words, the number of nodes) used for replacing the character strings becomes greater. However, when the types of codes increase in this way, the number of nodes also increases, and thus the overall size of the phrase tree becomes large.</p><p id="p0004" num="0004">Therefore, as one aspect, an object of this technique is to provide a technique for reducing a capacity of memory used for data structure representing the phase tree.<!-- EPO <DP n="2"> --></p><p id="p0005" num="0005">A data structure of a phrase tree in a first mode of this technique includes, as data of each node in the phrase tree, a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, the number of appearances or a code corresponding to a character string comprising the character or the character string and the second character when the number of appearances exceeds a threshold.</p><p id="p0006" num="0006">A data structure relating to a second mode of this technique includes: first data corresponding to a phrase tree; second data for a character or a character string, which corresponds to each node in the phrase tree; and third data for layers of the phrase tree. The first data includes, for each node of the phrase tree, correlation data to correlate a code for a parent node of the node or a greatest code among codes of child nodes of the node with a code for a character, which is represented by the node, and a layer identifier of a layer to which the node belongs, wherein the correlation data is arranged in order of a code assigned to the node. The second data includes, for each node in each layer of a second layer and subsequent layers in the phrase tree, a code for a character or a character string, which corresponds to the node, in order of the code assigned to the node. The third data includes, for each layer of the second layer and the subsequent layers in the phrase tree, the number of nodes belonging to the layer, a least code among codes of nodes belonging to the layer, and an of f set value of a position of a character or a character string corresponding to the least code in the second data from a beginning of the second data.</p><p id="p0007" num="0007">Reference will now be made, by way of example, to the accompanying Drawings, in which:
<ul><li><figref idrefs="f0001">FIG. 1</figref> is a diagram schematically depicting an example of a data structure representing a phrase tree in a conventional example;</li><li><figref idrefs="f0002">FIG. 2</figref> is a diagram depicting an example of a used memory amount in the conventional example;</li><li><figref idrefs="f0003">FIG. 3</figref> is a diagram depicting a data structure for one node in the phrase tree relating to a first embodiment;</li><li><figref idrefs="f0003">FIG. 4</figref> is a diagram depicting an example of an array for extended counters/child node numbers;</li><li><figref idrefs="f0002">FIG. 5</figref> is a functional block diagram of an information processing apparatus relating to the embodiments;<!-- EPO <DP n="3"> --></li><li><figref idrefs="f0004">FIG. 6</figref> is a diagram depicting a main processing flow relating to the embodiments;</li><li><figref idrefs="f0005">FIG. 7</figref> is a diagram depicting a processing flow of a processing for generating a phrase tree;</li><li><figref idrefs="f0004">FIG. 8</figref> is a diagram to explain a generation processing of data of the phrase tree;</li><li><figref idrefs="f0006">FIG. 9</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0007">FIG. 10</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0008">FIG. 11</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0009">FIG. 12</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0010">FIG. 13</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0011">FIG. 14</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0012">FIG. 15</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0013">FIG. 16</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0014">FIG. 17</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0010">FIG. 18</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0015">FIG. 19</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0016">FIG. 20A</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0017">FIG. 20B</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0018">FIG. 20C</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0019">FIG. 20D</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0020">FIG. 20E</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0021">FIG. 20F</figref> is a diagram to explain the generation processing of data<!-- EPO <DP n="4"> --> of the phrase tree;</li><li><figref idrefs="f0022">FIG. 21</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0023">FIG. 22A</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0024">FIG. 22B</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0025">FIG. 23</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0026">FIG. 24A</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0027">FIG. 24B</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0028">FIG. 24C</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0029">FIG. 24D</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0030">FIG. 24E</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0031">FIG. 24F</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0032">FIG. 25</figref> is a diagram to explain the generation processing of data of the phrase tree;</li><li><figref idrefs="f0033">FIG. 26A</figref> is a diagram to depict a processing flow of a processing for obtaining numbers;</li><li><figref idrefs="f0034">FIG. 26B</figref> is a diagram to depict a processing flow of an array setting processing;</li><li><figref idrefs="f0035">FIG. 27</figref> is a diagram to depict a processing flow of a processing for setting a current node;</li><li><figref idrefs="f0036">FIG. 28</figref> is a diagram depicting an example of the phrase tree;</li><li><figref idrefs="f0036">FIG. 29</figref> is a diagram depicting an example of the phrase tree after sorting;</li><li><figref idrefs="f0037">FIG. 30</figref> is a diagram to explain a compression map;</li><li><figref idrefs="f0038">FIG. 31</figref> is a diagram to explain generation of the compression map;</li><li><figref idrefs="f0039">FIG. 32</figref> is a diagram to explain a compressian map generation processing;</li><li><figref idrefs="f0039">FIG. 33</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0040">FIG. 34</figref> is a diagram to explain the compression map generation processing;<!-- EPO <DP n="5"> --></li><li><figref idrefs="f0041">FIG. 35</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0040">FIG. 36</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0041">FIG. 37</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0042">FIG. 38</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0042">FIG. 39</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0043">FIG. 40</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0044">FIG. 41</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0043">FIG. 42</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0045">FIG. 43</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0044">FIG. 44</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0045">FIG. 45</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0044">FIG. 46</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0046">FIG. 47</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0047">FIG. 48</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0048">FIG. 49</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0047">FIG. 50</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0049">FIG. 51</figref> is a diagram to explain the compression map generation processing;</li><li><figref idrefs="f0050">FIG. 52</figref> is a diagram depicting a processing flow of an entry addition processing:</li><li><figref idrefs="f0051">FIG. 53</figref> is a diagram depicting a processing flow of a compression processing;</li><li><figref idrefs="f0052">FIG. 54</figref> is a diagram depicting an example of the compression map;<!-- EPO <DP n="6"> --></li><li><figref idrefs="f0052">FIG. 55</figref> is a diagram to explain the compression processing;</li><li><figref idrefs="f0053">FIG. 56</figref> is a diagram depicting a processing flow of a decompression processing;</li><li><figref idrefs="f0054">FIG. 57</figref> is a diagram to explain the decompression processing;</li><li><figref idrefs="f0055">FIG. 58</figref> is a diagram to explain a processing when compressing using the data structure of the phrase tree;</li><li><figref idrefs="f0055">FIG. 59</figref> is a diagram to explain a processing when compressing using the data structure of the phrase tree;</li><li><figref idrefs="f0056">FIG. 60</figref> is a diagram to explain a processing when compressing using the data structure of the phrase tree;</li><li><figref idrefs="f0056">FIG. 61</figref> is a diagram to explain a processing when compressing using the data structure of the phrase tree;</li><li><figref idrefs="f0057">FIG. 62</figref> is a diagram to explain a processing when decompressing using the data structure of the phrase tree;</li><li><figref idrefs="f0057">FIG. 63</figref> is a diagram to explain a processing when decompressing using the data structure of the phrase tree;</li><li><figref idrefs="f0058">FIG. 64</figref> is a diagram to explain a processing when decompressing using the data structure of the phrase tree;</li><li><figref idrefs="f0059">FIG. 65</figref> is a diagram to explain a processing when decompressing using the data structure of the phrase tree;</li><li><figref idrefs="f0058">FIG. 66</figref> is a diagram to explain a processing when decompressing using the data structure of the phrase tree;</li><li><figref idrefs="f0060">FIG. 67</figref> is a diagram representing a phrase tree for explanation of a second embodiment;</li><li><figref idrefs="f0060">FIG. 68</figref> is a schematic diagram of a compression map in the second embodiment;</li><li><figref idrefs="f0061">FIG. 69</figref> is a diagram depicting a processing flow of a second entry addition processing in the second embodiment;</li><li><figref idrefs="f0062">FIG. 70</figref> is a diagram depicting a processing flow of a second compression processing in the second embodiment;</li><li><figref idrefs="f0063">FIG. 71</figref> is a diagram depicting an example of the compression map in the second embodiment;</li><li><figref idrefs="f0064">FIG. 72</figref> is a diagram depicting an example of the compression map in a third embodiment;</li><li><figref idrefs="f0065">FIG. 73</figref> is a diagram depicting an example of layer information in the third embodiment;</li><li><figref idrefs="f0065">FIG. 74</figref> is a diagram depicting a decompression map in the third embodiment;</li><li><figref idrefs="f0066">FIG. 75</figref> is a diagram depicting a processing flow of a second compression<!-- EPO <DP n="7"> --> map generation processing in the third embodiment;</li><li><figref idrefs="f0067">FIG. 76</figref> is a diagram depicting a processing flow of a third entry addition processing in the third embodiment;</li><li><figref idrefs="f0068">FIG. 77</figref> is a diagram depicting a processing flow of a setting processing in the third embodiment;</li><li><figref idrefs="f0069">FIG. 78</figref> is a diagram depicting a processing flow of a third compression processing in the third embodiment;</li><li><figref idrefs="f0070">FIG. 79</figref> is a diagram depicting a processing flowof a second decompression processing in the third embodiment;</li><li><figref idrefs="f0071">FIG. 80</figref> is a diagram to explain the second decompression processing;</li><li><figref idrefs="f0071">FIG. 81</figref> is a diagram depicting an example of the compression map in a fourth embodiment;</li><li><figref idrefs="f0072">FIG. 82</figref> is a diagram depicting an example of layer information in the fourth embodiment;</li><li><figref idrefs="f0072">FIG. 83</figref> is a diagram depicting an example of a decompression map in the fourth embodiment;</li><li><figref idrefs="f0073">FIG. 84</figref> is a diagram depicting a processing flow of a third compression map generation processing in the fourth embodiment;</li><li><figref idrefs="f0074">FIG. 85</figref> is a diagram depicting a fourth entry addition processing in the fourth embodiment;</li><li><figref idrefs="f0075">FIG. 86</figref> is a diagram depicting a processing flow of a second setting processing in the fourth embodiment;</li><li><figref idrefs="f0076">FIG. 87</figref> is a diagram depicting a processing flow of a fourth compression processing in the fourth embodiment;</li><li><figref idrefs="f0077">FIG. 88</figref> is a diagram depicting a processing flow of a third decompression processing in the fourth embodiment; and</li><li><figref idrefs="f0078">FIG. 89</figref> is a functional block diagram of a computer.</li></ul></p><heading id="h0001">[Embodiment 1]</heading><p id="p0008" num="0008"><figref idrefs="f0003">FIG. 3</figref> illustrates a data structure for one node in a phrase tree relating to this embodiment. A data block of one node includes an area for a code (IDX), an area for an array for character appearance numbers, an area for an array for counters/child node numbers, an area for spanned numbers, and an area for the number of appearances of characters. Moreover, separate from this, there is an area for counting the number of arrays for extended counters/child node numbers.</p><p id="p0009" num="0009">The area for the character appearance numbers is an array that holds the appearance sequential number (ranking) of each character (each character from 0x00 to 0xFF) that appears next to the character or character string<!-- EPO <DP n="8"> --> corresponding to the code of this node. However, "FF" represents an unused state except for when the number of appearances of the characters is 256. Each of other values represents an array index in the array for the counters/child node numbers. For example, focusing on the node of character "0x41(A)", when the character string for generating the phrase tree is "ABAAC", the character that first appears after the first "A" is B (0x42), so "0" is set in the 0x42-th array area in the array for the character appearance numbers, the character that appears after the next "A" is A, so "1" is set in the 0x41-th array area in the array for the character appearance numbers, and the character that appears after the further next "A" is C, so "2" is set in the 0x43-th array area in the array for the character appearance numbers.</p><p id="p0010" num="0010">In the array for the counters/child node numbers, the number of appearances (counter value) or the child node number (the number with "0x" given) is stored according to the appearance sequential number (ranking). In the example described above, the child node number (code) "0x0100" for character "0x42" is stored in the 0-th array area, the child number (code) "0x0104" for character "0x41" is stored in the 1st array area, and the number of appearances "1" for character "0x043" is stored in the 2nd array area. In this embodiment, there are only eight array areas for the number of appearances or child node numbers in the area for the array for the counters/child node numbers. When the number of array areas for the number of appearances or child node numbers exceeds eight, the array number of the extended counters/child node numbers is set in the area for the spanned number. The initial value of the spanned number is "0xFFFF".</p><p id="p0011" num="0011">The array for the extended counters/child node numbers is provided in a common area that can be referenced from any node. As illustrated in <figref idrefs="f0003">FIG. 4</figref>, this array includes eight array areas for the number of appearances or child node numbers, and an array area is finally provided for the array number of the extended counters/child node numbers (extended spanned number), which is to be referenced, when even this array becomes insufficient.</p><p id="p0012" num="0012">In the area for the number of appearances of characters, the number of characters that appeared after the character or character string that corresponds to this node is set. In the example described above, the three characters "B", "A" and "C" appeared, so "3" is set.</p><p id="p0013" num="0013">In this way, the number of child nodes, which can be identified by default, is limited, and the area for pointers that point to child nodes that do not have to be used is reduced. Moreover, there are also no pointers that point to a parent node, so the amount of memory used is reduced.</p><p id="p0014" num="0014">In this embodiment, a processing for generating such a kind of phrase tree, processing for generating a compression map, which is the data structure<!-- EPO <DP n="9"> --> to be stored onto a disk unit, from the phrase tree, compression processing and decompression processing using the compression map, and apparatus that performs such processing will be explained.</p><p id="p0015" num="0015"><figref idrefs="f0002">FIG. 5</figref> illustrates a functional block diagram of an information processing apparatus 100 relating to this embodiment. The information processing apparatus 100 has a phrase tree generator 110, a compression map generator 120, a data storage unit 130, a compression processing unit 140, a decompression processing unit 150 and an input and output unit 160.</p><p id="p0016" num="0016">The phrase tree generator 110 performs a processing for an input character string to be used for the generation of the phrase tree, which was inputted, for example, from the input and output unit 160, to generate data of the phrase tree relating to this embodiment. The compression map generator 120 generates a compression map from the data of the phrase tree, which was generated by the phrase tree generator 110, and stores the generated compression map in the data storage unit 130.</p><p id="p0017" num="0017">The compression processing unit 140 uses the compression map that is stored in the data storage unit 130, to perform a compression processing for the input character string to be compressed, which was inputted, for example, from the input and output unit 160, and then stores the compression result in the data storage unit 130. The decompression processing unit 150 uses the compression map that is stored in the data storage unit 130, to perform a decompression processing for the compression result that is stored, for example, in the data storage unit 130, and stores the decompression result in the data storage unit 130. The input and output unit 160 may output the decompression result to an output apparatus such as a display apparatus, or to another computer or the like.</p><p id="p0018" num="0018">Next, <figref idrefs="f0004 f0005 f0006 f0007 f0008 f0009 f0010 f0011 f0012 f0013 f0014 f0015 f0016 f0017 f0018 f0019 f0020 f0021 f0022 f0023 f0024 f0025 f0026 f0027 f0028 f0029 f0030 f0031 f0032 f0033 f0034 f0035 f0036 f0037 f0038 f0039 f0040 f0041 f0042 f0043 f0044 f0045 f0046 f0047 f0048 f0049 f0050 f0051 f0052 f0053 f0054 f0055 f0056 f0057 f0058 f0059">FIG. 6 to FIG. 66</figref> will be used to explain processing contents by the information processing apparatus 100. First, the phrase tree generator 110 performs a processing for generating a phrase tree for an input character string (<figref idrefs="f0004">FIG. 6</figref>: step S1). This processing for generating a phrase tree will be explained in detail using <figref idrefs="f0004 f0005 f0006 f0007 f0008 f0009 f0010 f0011 f0012 f0013 f0014 f0015 f0016 f0017 f0018 f0019 f0020 f0021 f0022 f0023 f0024 f0025 f0026 f0027 f0028 f0029 f0030 f0031 f0032 f0033 f0034 f0035">FIG. 7 to FIG. 27</figref>. The compression map generator 120 then performs a processing for generating a compression map from the phrase tree that was generated by the phrase tree generator 110, and stores the compression map in the data storage unit 130 (step S3). The processing for generating a compression map will be explained in detail using <figref idrefs="f0036 f0037 f0038 f0039 f0040 f0041 f0042 f0043 f0044 f0045 f0046 f0047 f0048 f0049 f0050">FIG. 28 to FIG. 52</figref>.</p><p id="p0019" num="0019">After that, when an input character string to be compressed is inputted from, for example, the input and output unit 160, the compression processing unit 140 performs a compression processing using the compression map, and stores the compression result in the data storage unit 130 (step S5). The compression<!-- EPO <DP n="10"> --> processing will be explained in detail using <figref idrefs="f0051 f0052">FIG. 53 to FIG. 55</figref>. When receiving an instruction from, for example, the input and output unit 160, the decompression processing unit 150 uses the compression map to performa decompressionprocessing for the compression result stored, for example, in the data storage unit 130, and stores the processing result in the data storage unit 130 (step S7). The decompression processing will be explained in detail using <figref idrefs="f0053">FIG. 56</figref> and <figref idrefs="f0054">FIG. 57</figref>.</p><p id="p0020" num="0020">Next, the processing for generating the phrase tree will be explained using <figref idrefs="f0005">FIG. 7</figref>. First, the phrase tree generator 110 generates data for the nodes having codes 0x0000 to 0x00FF (step S11). The first-layer nodes that are always provided are generated as the initial setting.</p><p id="p0021" num="0021">The phrase tree generator 110 then reads a 1-byte input character from the input character string, and sets the node corresponding to the read character as the current node (step S13). Furthermore, the phrase tree generator 110 reads the next 1-byte input character from the input character string (step S15). Then, the phrase tree generator 110 determines whether the next input character is the end of the input character string (step S17). When the next input character is the end of the input character string, the processing returns to the processing of the calling source.</p><p id="p0022" num="0022">On the other hand, when the next input character is not the end of the input character string, the phrase tree generator 110 uses the code of the input character as an array index to obtain a value A that is stored in the array for the character appearance numbers for the current node (step S18). Then, the phrase tree generator 110 performs a number obtaining processing (step S19). This number obtaining processing will be explained using <figref idrefs="f0033">FIG. 26A</figref> and <figref idrefs="f0034">FIG. 26B</figref>.</p><p id="p0023" num="0023">After that, the phrase tree generator 110 performs a processing for setting a current node (step S21). The processing for setting the current node will be explained using <figref idrefs="f0035">FIG. 27</figref>. After that, the processing returns to the step S15.</p><p id="p0024" num="0024">Before describing details of the number obtaining processing and processing for setting the current node, a detailed example will be explained using <figref idrefs="f0004 f0006 f0007 f0008 f0009 f0010 f0011 f0012 f0013 f0014 f0015 f0016 f0017 f0018 f0019 f0020 f0021 f0022 f0023 f0024 f0025 f0026 f0027 f0028 f0029 f0030 f0031 f0032">FIG. 8 to FIG. 25</figref> in order to make it easier to understand the processing. Here, the processing when a character string "ABABCABCABCCBCBCBCAAACBACBACBBCCBBCBECBECBDCBDCBGCBGCBHCBHCBFCBFCBICBI" is inputted will be explained. Moreover, not only the data structure of the phrase tree, but also a schematic diagram of the phrase tree will be explained.</p><p id="p0025" num="0025">At the step S11, when schematically illustrated as in <figref idrefs="f0004">FIG. 8</figref>, the nodes for the codes 0x0001 to 0x00FF are generated as the 1st-layer nodes. In<!-- EPO <DP n="11"> --> this example, mainly the nodes of the code "0x0041", "0x0042" and "0x0043" and the child nodes of these nodes are the targets of the processing, so only this portion is illustrated. Moreover, data blocks of a data structure such as illustrated in <figref idrefs="f0006">FIG. 9</figref> are generated. In this way, the data block illustrated in <figref idrefs="f0003">FIG. 3</figref> for the code "0x0041" that corresponds to character "0x41", the data block illustrated in <figref idrefs="f0003">FIG. 3</figref> for the code "0x0042" that corresponds to character "0x42", and the data block illustrated in <figref idrefs="f0003">FIG. 3</figref> for the code "0x0043" that corresponds to character "0x43" are generated. In this stage, the values set are initial values.</p><p id="p0026" num="0026">Next, the first "A" of the input character string "'A'BABCABCABCCBCBCBCAAACBACBACBBCCBBCBECBECBDCBDCBGCBGCBHCBHCBFCBFCBICBI" is read, and the node of the corresponding code "0x0041" is set as the current node. Then, the next "B" in the input character string "A'B'ABCABCABCCBCBCBCAAACBACBACBBCCBBCBECBECBDCBDCBGCBGCBHCBHCBFCBFCBICBI" is read. Then, as illustrated in <figref idrefs="f0007">FIG. 10</figref>, when referencing the value of index "0x42(B)" in the array for the character appearance numbers for the current node, the value is "0xFF". Therefore, the appearance sequential number "0", which is equal to the number of appearances of characters, is set as the character appearance number for "0x42". Moreover, the number of appearances of characters is updated from "0" to "1". Furthermore, in the array for counters/child node numbers, the value of the 0-th counter, which corresponds to the appearance sequential number, is less than "0x0100", so the number of appearances "0" is incremented by 1, then "1" is set as the value of the 0-th counter. The number of appearances (i.e. the value of the counter) has not reached the threshold value "2", so the current node is updated to the node of code "0x0042" that corresponds to the character "0x42". The new current node is represented by the black triangle, and the old current node is represented by the white triangle in the drawing.</p><p id="p0027" num="0027">Next, the "A" in the input character string "AB'A'BCABCABCCBCBCBCAAACBACBACBBCCBBCBECBECBDCBDCBGCBGCBHCBHCBFCBFCBICBI" is read. Then, as illustrated in <figref idrefs="f0008">FIG. 11</figref>, when referencing the value for index "0x41 (A)" in the array for the character appearance numbers for the current node, the value is "0xFF". Therefore, the appearance sequential number "0", which is equal to the number of appearances of characters, is set as the character appearance number for "0x41". Moreover, the number of appearances of characters is updated from "0" to "1". Furthermore, in the array for counters/child node numbers, the value of the 0-th counter, which corresponds to the appearance sequential number, is less than "0x0100", so the number of appearances "0" is incremented by 1, then "1" is set as the value of the 0-th counter. The number<!-- EPO <DP n="12"> --> of appearances has not reached the threshold value "2", so the current node is updated to the node of code "0x0041" that corresponds to the character "0x41".</p><p id="p0028" num="0028">Furthermore, "B" in the input character string "ABA'B'CABCABCCBCBCBCAAACBACBACBBCCBBCBECBECBDCBDCBGCBGCBHCBHCBFCBFCBICBI" is read. Then, as illustrated in <figref idrefs="f0009">FIG. 12</figref>, when referencing the value of index "0x42 (B)" in the array for the character appearance numbers for the current node, the appearance sequential number "0" is obtained. Furthermore, in the array for counters/child node numbers, the 0-th value, which corresponds to the appearance sequential number "0", is less than "0x0100", so the number of appearances "1" is incremented by 1. As a result, the number of appearances has reached the threshold value "2". Then, as illustrated in <figref idrefs="f0009">FIG. 12</figref>, a new child node for code "0x0100" is generated, and the code "0x0100" of the new child node is set as the 0-th value in the array for counters/child node numbers. The code "0x0100" is the code corresponding to "AB". The child node of the code "0x0100" is then set as the current node. The phrase tree changes from the state illustrated in <figref idrefs="f0004">FIG. 8</figref> to the state illustrated in <figref idrefs="f0010">FIG. 13</figref>.</p><p id="p0029" num="0029">The "C" is then read from the input character string "ABAB'C'ABCABCCBCBCBCAAACBACBACBBCCBBCBECBECBDCBDCBGCBGCBHCBHCBFCBFCBICBI". Then, as illustrated in <figref idrefs="f0011">FIG. 14</figref>, when referencing the value of index "0x43 (C)" in the array for character appearance numbers for the current node, the value is "0xFF" Therefore, the appearance sequential number "0", which is equal to the number of appearances of characters, is set as the character appearance number for "0x43". Moreover, the number of appearances of characters is updated from "0" to "1". Furthermore, in the array for counters/child node numbers, the value of the 0-th counter, which corresponds to the appearance sequential number, is less than "0x0100", so the number of appearances "0" is incremented by 1., and "1" is set as the value of the 0-th counter. Because the number of appearances has not reached the threshold value "2", the current node is updated to the node of code "0x0043" that corresponds to the character "0x43".</p><p id="p0030" num="0030">Furthermore, "A" in the input character string "ABABC'A'BCABCCBCBCBCAAACBACBACBBCCBBCBECBECBDCBDCBGCBGCBHCBHCBFCBFCBICBI" is read. In doing so, as illustrated in <figref idrefs="f0012">FIG. 15</figref>, when referencing the value of index "0x41 (A)" in the array for the character appearance numbers for the current node, the value is "0xFF". Therefore, the appearance sequential number "0", which is equal to the number of appearances of characters, is set as the character appearance number for "0x41". Moreover, the number of appearances of characters is updated from "0" to "1". Furthermore, in the array for counters/child node numbers, the value of the 0-th counter, which corresponds to the appearance sequential number, is less than "0x0100", so the number of<!-- EPO <DP n="13"> --> appearances "0" is incremented by 1, then "1" is set as the value of the 0-th counter. The number of appearances (i.e. the value of the counter) has not reached the threshold value "2", so the current node is updated to the node of code "0x0041" that corresponds to the character "0x41".'</p><p id="p0031" num="0031">Then, the "B" in the input character string "ABABCA'B'CABCCBCBCBCAAACBACBACBBCCBBCBECBECBDCBDCBGCBGCBHCBHCBFCBFCBICBI" is read. In doing so, as illustrated in <figref idrefs="f0013">FIG. 16</figref>, when referencing the value of index "0x42 (B)" in the array for the character appearance numbers for the current node, the value is "0". Therefore, in the array for counters/child node numbers, the 0-th value is referenced. As a result., because the code "0x0100" is obtained, the current node is updated to the node of the code "0x0100".</p><p id="p0032" num="0032">Moreover, the "C" in the input character string "ABABCAB'C'ABCCBCBCBCAAACBACBACBBCCBBCBECBECBDCBDCBGCBGCBHCBHCBFCBFCBICBI" is read. In doing so, as illustrated in <figref idrefs="f0014">FIG. 17</figref>, when referencing the value of index "0x43 (C) " in the array for character appearance numbers for the current node, the appearance sequential number "0" is obtained. Then, in the array for counters/child node numbers, the value of the 0-th counter, which corresponds to the appearance sequential number, is less than "0x0100", so the number of appearances "1" is incremented by 1. As a result, the number of appearances reaches the threshold value "2", so as illustrated in <figref idrefs="f0014">FIG. 17</figref>, a new child node for code "0x0101" is generated, and the code "0x0101" of the new child node is set as the 0-th value in the array for counters/child node numbers. The code "0x0101" is the code corresponding to "ABC". The child node of the code "0x0101" is set as the current node. The phrase tree changes from the state illustrated in <figref idrefs="f0010">FIG. 13</figref> to the state illustrated in <figref idrefs="f0010">FIG. 18</figref>.</p><p id="p0033" num="0033">Moreover, the "A" in the input character string "ABABCABC'A'BCCBCBCBCAAACBACBACBBCCBBCBECBECBDCBDCBGCBGCBHCBHCBFCBFCBICBI" is read. In doing so, as illustrated in <figref idrefs="f0015">FIG. 19</figref>, when referencing the value of index "0x41 (A) " in the array for character appearance numbers for the current node, the value is "0xFF". Therefore, the appearance sequential number "0", which is equal to the number of appearances of characters, is set as the character appearance number for "0x41". Moreover, the number of appearances of characters is updated from "0" to "1". Furthermore, in the array for counters/child node numbers, because the value of the 0-th counter, which corresponds to the appearance sequential number, is less than "0x0100", the number of appearances "0" is incremented by 1, and then, "1" is set as the value of the 0-th counter. Because the number of appearances has not reached the threshold value "2", the current node is updated to the node of code "0x0041" that corresponds to the character "0x41". Such a processing is repeated.<!-- EPO <DP n="14"> --></p><p id="p0034" num="0034">The stage is reached in which the "I" in the input character string "ABABCABCABCCBCBCBCAAACBACBACBBCCBBCBECBECBDCBDCBGCBGCBHCBHCBFCBFCB'I'CBI" is read. Here, the current node is the node of code "0x0102", and as illustrated in <figref idrefs="f0016 f0017 f0018 f0019 f0020 f0021">FIG. 20A to FIG. 20F</figref>, when referencing the value of index "0x49 (I)" in the array for character appearance numbers for the current node, the value is "0xFF". Therefore, the appearance sequential number "8", which is the number of appearances of characters, is set as the character appearance number for "0x49". Moreover, the number of appearances of characters is updated from "8" to "9". Furthermore, in the array for counters/child node numbers, the 8-th value, which corresponds to the appearance sequential number, is not included in the default array. Therefore, the array for the extended counters/child node numbers is referenced. Here, the 0-th array for the extended counters/child node numbers is identified, and the 0-th (=8-8) value in that array is referenced. Because the 0-th value, which corresponds to the appearance sequential number, in the 0-th array for extended counters/child node numbers is less than "0x0100", the number of appearances "0" is incremented by 1, and "1" is set as the number of appearances. The number of appearances has not reached the threshold value "2", so the current node is updated to the node of code "0x0049" that corresponds to the character "0x49". In this stage, the phrase tree is in a state as illustrated in <figref idrefs="f0022">FIG. 21</figref>. Eight child nodes (i.e. third-layer nodes) of the code "0x0102" have already been generated.</p><p id="p0035" num="0035">After that, the "C" in the input character string "ABABCABCABCCBCBCBCAAACBACBACBBCCBBCBECBECBDCBDCBGCBGCBHCBHCBFCBFCBI`C'BI" is read. In doing so, as illustrated in <figref idrefs="f0023">FIG. 22A</figref> and <figref idrefs="f0024">FIG. 22B</figref>, when referencing the value of index "0x43 (C)" in the array for character appearance numbers for the current node, the appearance sequential number "0" is obtained. Then, in the array for counters/child node numbers, the 0-th value, which corresponds to the appearance sequential number, is less than "0x0100", so the number of appearances "0" is incremented by 1, and then, "1" is set as the number of appearances. The number of appearances has not reached the threshold value "2", so the current node is updated to the node of code "0x0043" that corresponds to the character "0x43".</p><p id="p0036" num="0036">Furthermore, the "B" in the input character string "ABABCABCABCCBCBCBCAAACBACBACBBCCBBCBECBECBDCBDCBGCBGCBHCBHCBFCBFCBIC`B'I" is read. In doing so, as illustrated in <figref idrefs="f0025">FIG. 23</figref>, when referencing the value of index "0x42 (B) " in the array for character appearance numbers for the current node, the value is "1". Therefore, in the array for counters/child node numbers, the 1st value, which corresponds to the appearance sequential number, is referenced. As a result, the code "0x0102" is obtained, so the current node<!-- EPO <DP n="15"> --> is updated to the node of the code "0x0102".</p><p id="p0037" num="0037">Finally, the "I" in the input character string "ABABCABCABCCBCBCBCAAACBACBACBBCCBBCBECBECBDCBDCBGCBGCBHCBHCBFCBFCBICB'I"' is read. In doing so, as illustrated in <figref idrefs="f0026 f0027 f0028 f0029 f0030 f0031">FIG. 24A to FIG. 24F</figref>, when referencing the value of index "0x49 (I)" in the array for character appearance numbers for the current node, the appearance sequential number "8" is obtained. In the array for counters/child node numbers, the 8-th value, which corresponds to the appearance sequential number, is not included in the default array, so the array for extended counters/child node numbers is referenced. Here, when referencing the 0-th (=8-8) value in the 0-th array for extended counters/child nodenumbers, the value is less than "0x0100". Therefore, the number of appearances "1" is incremented by 1. As a result, the number of appearances has reached the threshold value "2", so as illustrated in <figref idrefs="f0026 f0027 f0028 f0029 f0030 f0031">FIG. 24A to FIG. 24F</figref>, a new child node of code "0x010D" is generated, and the code "0x010D" of the new child node is set as the 0-th value in the array for the counters/child node numbers. The code "0x010D" is a code corresponding to the character string "ABI". Then, the current node is changed to the child node of the code "0x010D". The phrase tree is changed from a state such as in <figref idrefs="f0025">FIG. 23</figref> to the state illustrated in <figref idrefs="f0032">FIG. 25</figref>. In this way, a phrase tree is generated in which there are four nodes in the second layer, and ten nodes in the third layer, however, child nodes are generated according to the appearance order, so in the second layer and third layer, the code is not arranged in order of codes of corresponding characters.</p><p id="p0038" num="0038">The number obtaining processing to carry out such a processing will be explained using <figref idrefs="f0033">FIG. 26A</figref>. The phrase tree generator 110 determines whether or not a condition that a value A is 0xFF and the number of appearances of characters is not 256 is satisfied (step S31). When this condition is satisfied, a character that has not appeared up to this point has appeared, so the phrase tree generator 110 sets the number of appearances of characters for the current node as the value A (step S33), and then increments the number of appearances of characters by 1 (step S35).</p><p id="p0039" num="0039">When it is determined that the condition of the step S31 is not satisfied, or after the step S35, the phrase tree generator 110 determines whether or not the value A is 8 or greater (step S37). When the value A is less than 8, the phrase tree generator 110 acquires the value B that is stored in the A-th array area in the array for counters/child node numbers (step S51). The processing then returns to the calling source processing.</p><p id="p0040" num="0040">On the other hand, when the value A is 8 or greater, the phrase tree generator 110 determines whether the spanned number is 0xFFFF (step S39). When the spanned number is 0xFFFF, the array for extended counters/child node numbers<!-- EPO <DP n="16"> --> has not been acquired. Therefore, when the spanned number is 0xFFFF, the phrase tree generator 110 performs an array setting processing (step S41). The processing then moves to step S43.</p><p id="p0041" num="0041">The array setting processing will be explained using <figref idrefs="f0034">FIG. 26B</figref>. The phrase tree generator 110 sets the current number of arrays as the spanned number for the current node, or as the extended spanned number in the array for the extended counters/child node numbers, which is currently referenced (step S68). Then, the phrase tree generator 110 increments the number of arrays by 1 (step S69). The processing then returns to the processing of the calling source.</p><p id="p0042" num="0042">When it is determined at the step S39 that the spanned number is not 0xFFFF, and another value is set as the spanned number, or after the step S41, the phrase tree generator 110 references the S-th array for extended counters/child node numbers (step S43). S is the acquired spanned number" or the "extended spanned number". The phrase tree generator 110 then calculates A = A - 8 (step S45). After that, the phrase tree generator 110 determines whether A is 8 or greater (step S47). When A is 8 or greater, 2 or more arrays for the extended counters/child node numbers are used. When A is 8 or greater, the phrase tree generator 110 determines whether the extended spanned number in the array for extended counters/child node numbers, which is currently referenced, is 0xFFFF (step S53). When the extended spanned number is not 0xFFFF, the processing moves to step S57. On the other hand, when the extended spanned number is 0xFFFF, a new array for the extended counters/child node numbers will be set, so the phrase tree generator 110 performs the array setting processing (<figref idrefs="f0034">FIG. 26B</figref>) (step S55). The processing then moves to step S57.</p><p id="p0043" num="0043">The phrase tree generator 110 then acquires the extended spanned number in the referenced array for extended counters/child node numbers, or in the array for extended counters/child node numbers, which is set in the array setting processing (step S57). The processing then returns to the step S43.</p><p id="p0044" num="0044">On the other hand, when the value A is less than 8, the phrase tree generator 110 acquires the value B that is stored in the A-th array area in the referenced array for extended counters/child node numbers (step S49). Then, the processing returns to the processing of the calling source.</p><p id="p0045" num="0045">By performing the processing described above, it is possible to obtain the codes of the child node or the number of appearances, which is the value of the counter.</p><p id="p0046" num="0046">Next, the current node setting processing will be explained using <figref idrefs="f0035">FIG. 27</figref>. The phrase tree generator 110 determines whether the value B that is stored in the A-th array area in the array for counters/child node numbers (or extended counters/child node numbers) is a child node number (in other words,<!-- EPO <DP n="17"> --> code of 0x0100 or greater) (step S71). When the value B represents a child node, the phrase tree generator 110 positions the current node at the child node (step S83). The processing then returns to the processing of the calling source.</p><p id="p0047" num="0047">On the other hand, when the value B does not represent a child node, the phrase tree generator 110 increments the value B by 1 (step S73). Then, the phrase tree generator 110 determines whether or not the value B is equal to or greater than a threshold value (step S75). When the value B is less than the threshold value, the phrase tree generator 110 positions the current node at the node of the code that corresponds to the input character (in other words, the node of the input character code) (step S77). The processing then moves to the processing of the calling source.</p><p id="p0048" num="0048">On the other hand, when the value B is equal to or greater than a threshold value, the phrase tree generator 110 sets a code for a new child node in the A-th array area in the array for counters/child node numbers (or extended counters/child node numbers) (step S79). The greatest code in the data block + 1 is set as the code of the new child node. Furthermore, the phrase tree generator 110 generates a data block of the new child node having the set code, and positions the current node at the generated node (step S81).</p><p id="p0049" num="0049">By performing such a processing, a phrase tree such as illustrated in <figref idrefs="f0026 f0027 f0028 f0029 f0030 f0031">FIG. 24A to FIG. 24F</figref> is generated.</p><p id="p0050" num="0050">Next, the processing for generating the compression map will be explained. As was described above, in the phrase tree, the codes in the first layer are given in order of the character code, and are sorted in ascending order of the code, however, in the second layer and subsequent layers, the codes are given in order of the appearance. Therefore, the codes are given independent of the layer or character code. In the simple example illustrated in <figref idrefs="f0036">FIG. 28</figref>, the nodes for the code "0x0100", "0x0104", "0x0106", and "0x0102" are given in the second layer, and the codes are not sequential. Moreover, the character code that is expressed by the childnode "0x0100" of the code "0x0041" corresponding to the character code "0x41" is "0x42", and the character code that is expressed by the child node "0x0104" is "0x41". Therefore, at this viewpoint as well, the code is not arranged in the order of the character code.</p><p id="p0051" num="0051">In this embodiment, when generating the compression map, the code is rearranged from the given state of the codes illustrated in <figref idrefs="f0036">FIG. 28</figref> to the state illustrated in <figref idrefs="f0036">FIG. 29</figref> so that the codes are sorted in order of layer and in order of a code of a corresponding character for each parent node (last character in a character string corresponding to the code). In the example in <figref idrefs="f0036">FIG. 29</figref>, in the second layer, the node of the character "0x41" is correlated with the code "0x0100", the node of character "0x42" is correlated with the<!-- EPO <DP n="18"> --> code "0x0101", the node of character "0x43" is correlated with the code "0x0102", and the node of character "0x42" is correlated with the code "0x0103". Moreover, in the third layer, the node of character "0x43" is correlated with the code "0x0104", the node of character "0x41" is correlated with the code "0x0105", the node of character "0x42" is correlated with the code "0x0106", and the node of character "0x43" is correlated with the code "0x0107". In this way, it becomes possible to perform a binary search of the nodes.</p><p id="p0052" num="0052">The compression map will be explained in more detail. The compression map is data in which correlation data that correlates the code of a parent node with the character code of its own node (a character corresponding to the code of its own node, or the last character of a character string corresponding to the code of its own node) is arranged in order of the code. Actually, this compression map includes correlation data that correlates the code of the current node with the array index in an array for character appearance numbers, for which it is confirmed that any code is stored in the array for counters/child node numbers for the current node instead of the counter value. In the case of a phrase tree such as illustrated in <figref idrefs="f0036">FIG. 28</figref>, a compression map such as illustrated on the left side of <figref idrefs="f0037">FIG. 30</figref> is generated. As described above, the codes are given in order of the appearance, so the code in the column of a parent node code is not sorted, and as a result, the character string itself that is expressed by the code is not sorted in the order of the character code. In the example in <figref idrefs="f0037">FIG. 30</figref>, the codes and character strings are illustrated, however, such data is not included in the compressionmap, and is supplementary information.</p><p id="p0053" num="0053">In this embodiment, a compression map is generated from the phrase tree, as illustrated on the right side of <figref idrefs="f0037">FIG. 30</figref>, by sorting and reassigning the codes such as described above, and arranging correlation data that correlates the code of a parent node with the character code of its own node in order of the newly reassigned codes. As can also be seen in the example in <figref idrefs="f0037">FIG. 30</figref>, the codes of the parent nodes are sorted in ascending order of the code. As a result, it is possible to carry out the binary searching of the compression map.</p><p id="p0054" num="0054">In this embodiment, in order to perform the sorting, a sorting area is adopted as illustrated in <figref idrefs="f0038">FIG. 31</figref>. In the sorting area, the code that is identified in the following processing is stored in order that the code is identified in the following processing. When doing this, the array indexes in the sorting area are the codes after sorting. In the example in <figref idrefs="f0038">FIG. 31</figref>, the code "0x0104" before sorting is firstly stored in the position of the array index "0x0100" as the code of the node in the second layer. In other words, the node of the code "0x0104" before sorting is handled as the code "0x0100" after sorting. For this node, the code of the parent node is "0x0041", and the<!-- EPO <DP n="19"> --> character code represented by this node is "0x41".</p><p id="p0055" num="0055">The processing contents will be explained in more detail step-by-step as an example of a case where data of the phrase tree such as illustrated in <figref idrefs="f0026 f0027 f0028 f0029 f0030 f0031">FIG. 24A to FIG. 24F</figref> is obtained.</p><p id="p0056" num="0056">First, there is no need to sort the nodes of the codes "0x0000" to "0x00FF", so such nodes are registered in the compression map as they are. For example, data such as illustrated in <figref idrefs="f0039">FIG. 32</figref> is registered in the compression map. The parent node is a root node, so the data "root" is registered as the code of the parent node, and the respective corresponding characters "0x00" to "0xFF" are also registered. Furthermore, as illustrated in <figref idrefs="f0039">FIG. 33</figref>, the nodes "0x0000" to "0x00FF" are registered in the sorting area in ascending order of the codes.</p><p id="p0057" num="0057">Next, the nodes of the codes registered in the sorting area are processed in ascending order of the array index (= the code after sorting). However, when there is no child node, correlation data is not registered in the compression map, so an explanation of the processing up to the code "0x0040" is omitted as illustrated in the phrase tree illustrated in <figref idrefs="f0032">FIG. 25</figref>. As illustrated in <figref idrefs="f0040">FIG. 34</figref>, when the array index "0x0041" is to be processed, the data block of the code "0x0041" is referenced, to search for the position where any value other than "0xFE"' is stored in sequence from the array index "0x00" of that array for character appearance numbers. In this example, the appearance sequential number "1" is registered in "0x41"-th array area, so "1st" array area in the array for counters/child node numbers is referenced. As a result, the code "0x0104", which is equal to or greater than "0x100", is registered, so "0x0104" is registered in the last end "0x0100" in the sorting area. Furthermore, asillustratedinFIG. 35, in the compression map, correlationdata that correlates the code after sorting of the parent node "0x0041" with character code that corresponds to array index "0x41" in the array for character appearance numbers is registered in "0x100"-th array area, which corresponds to the code after sorting.</p><p id="p0058" num="0058">Moreover, as illustrated in <figref idrefs="f0040">FIG. 36</figref>, the appearance sequential number "0" is registered in "0x42"-th array area in the array for character appearance numbers in the data block of the code "0x0041", so the "0"-th value in the array for counters/child node numbers is referenced. As a result, the code "0x0100", which is equal to or greater than "0x100" is registered, so "0x0100" is registered in the last end "0x0101" of the sorting area. Furthermore, in the compression map, as illustrated in <figref idrefs="f0041">FIG. 37</figref>, correlation data that correlates the code after sorting of the parent node "0x0041" with the character code that corresponds to the array index "0x42" in the array for character appearance numbers is<!-- EPO <DP n="20"> --> registered in "0x101"-th array area, which corresponds to the code after sorting.</p><p id="p0059" num="0059">Furthermore, as illustrated in <figref idrefs="f0042">FIG. 38</figref>, the appearance sequential number "2" is registered in "0x43"-th array area in the array for character appearance numbers in the data block of the code "0x0041", so the "2nd" array area in the array for counters/child node numbers is referenced. As a result, a value "1" that is less than "0x100" is registered, so the correlation data is not registered in the compression map. Correlation data is not registered in the compression map even though the processing is performed for the subsequent array indexes in the array for character appearance numbers.</p><p id="p0060" num="0060">Next, as illustrated in <figref idrefs="f0042">FIG. 39</figref>, when the array index "0x0042" is processed, the data block of the code "0x0042" is referenced to search for the position where any value other than "0xFF" is registered in sequence from the array index "0x00" in the array for character appearance numbers. In this example, the appearance sequential number "0" is registered in the "0x41"-th array area, so the "0"-th array area is referenced in the array for counters/child node numbers. As a result, a value "1" that is less than "0x100" is registered, so correlation data is not registered in the compression map.</p><p id="p0061" num="0061">Moreover, "0xFF" is registered in the "0x42"-th array area in the array for character appearance numbers in the data block of the code "0x0042", so data is not registered in the compression map.</p><p id="p0062" num="0062">Furthermore, as illustrated in <figref idrefs="f0043">FIG. 40</figref>, the appearance sequential number "1" is registered in "0x43"-th array area in the array for character appearance numbers in the data block of the code "0x0042", so "1st" array area in the array for counters/child node numbers is referenced. As a result, the code "0x0106", which is equal to or greater than "0x100" is registered, so "0x0106" is registered in the last end "0x0102" in the sorting area. Furthermore, in the compression map, as illustrated in <figref idrefs="f0044">FIG. 41</figref>, correlation data that correlates the code after sorting of the parent node "0x0042" with the character code that corresponds to the array index "0x43" in the array for character appearance numbers is registered in "0x102"-th array area, which corresponds to the code after sorting. Even though the processing is performed for the subsequent array indexes in the array for character appearance numbers, correlation data will not be registered in the compression map.</p><p id="p0063" num="0063">Next, as illustrated in <figref idrefs="f0043">FIG. 42</figref>, when the array index "0x0043" is processed, the data block of the code "0x0043" is referenced to search for the position where any value other than "0xFF is registered in sequence from the array index "0x00" in the array for character appearance numbers. In this example, the appearance sequential number "0" is registered in the "0x41"-th array area, so the "0"-th array area is referenced in the array for counters/chiid node<!-- EPO <DP n="21"> --> numbers. As a result, a value "1" that is less than "0x100" is registered, so correlation data is not registered in the compression map.</p><p id="p0064" num="0064">Furthermore, as illustrated in <figref idrefs="f0045">FIG. 43</figref>, the appearance sequential number "1" is registered in the "0x42"-th array area in the array for character appearance numbers in the data block of the code "0x0043", so "1st" array area in the array for counters/child node numbers is referenced. As a result, the code "0x0102", which is equal to or greater than "0x100", is registered, so "0x0102" is registered in the last end "0x0103" in the sorting area. Furthermore, in the compression map, as illustrated in <figref idrefs="f0044">FIG. 44</figref>, correlation data that correlates the code after sorting of the parent node "0x0043" with the character code that corresponds to the array index "0x42" in the array for character appearance numbers is registered in "0x103"-th array area, which corresponds to the code after sorting. Even though the processing is performed for the subsequent array indexes in the array for character appearance numbers, correlation data will not be registered in the compression map.</p><p id="p0065" num="0065">Even when the data block of the code "0x0044" after sorting is processed, data will not be registered in the compression map, and even when all of the data blocks up to the code "0x00FF" after sorting are processed, data will not be registered in the compression map.</p><p id="p0066" num="0066">Moreover, as illustrated in <figref idrefs="f0045">FIG. 45</figref>, when the array index "0x0100" is processed, the data block of the code "0x0100" is referenced to search for the position where any value other than "0xFF is stored in sequence from the array index "0x00" in the array for character appearance numbers. In this example, the appearance sequential number "0" is registered in the "0x43"-th array area, so "0" -th array area in the array for counters/child node numbers is referenced. As a result, the code "0x0101", which is equal to or greater than "0x100", is registered, so "0x0101" is registered in the last end "0x0104" in the sorting area. Furthermore, in the compression map, as illustrated in <figref idrefs="f0044">FIG. 46</figref>, correlation data that correlates the code after sorting of the parent node "0x0100" with the character code that corresponds to the array index "0x43" in the array for character appearance numbers is registered in "0x104"-th array area, which corresponds to the code after sorting. Even though the processing may be performed for the subsequent array indexes in the array for character appearance numbers, correlation data will not be registered in the compression map.</p><p id="p0067" num="0067">Moreover, even though the processing for the data blocks up to the code "0x0101" after sorting are processed, data will not be registered in the compression map.</p><p id="p0068" num="0068">Moreover, as illustrated in <figref idrefs="f0046">FIG. 47</figref>, when the array index "0x0102" is processed, the data block of code "0x0102" is referenced to search for the<!-- EPO <DP n="22"> --> position where any value other than "0xFF" is registered in sequence from the array index "0x00" in that array for character appearance numbers. In this example, the appearance sequential number "1" is registered in the "0x41"-th array area, so the "1st" array area in the array fcr counters/childnode numbers is referenced. As a result, the code "0x0105", which is equal to or greater than "0x100", is registered, so "0x0105" is registered in the last end "0x0105" in the sorting area. Furthermore, in the compressionmap, as illustrated in <figref idrefs="f0047">FIG. 48</figref>, correlation data that correlates the code after sorting of the parent node "0x0103" with the character code that corresponds to the array index "0x41" in the array for character appearance numbers is registered in the "0x105"-th array area, which corresponds to the code after sorting. For this data block, when the processing may is performed for the subsequent array indexes in the array for character appearance numbers, correlation data is added in smooth to the compression map.</p><p id="p0069" num="0069">Then, as illustrated in <figref idrefs="f0048">FIG. 49</figref>, the appearance sequential number "8" is registered in the "0x49"-th array area in the array for character appearances numbers in the data block of the code "0x0102", so the "0"-the array area in the array for extended counters/child node numbers is referenced. As a result, the code "0x010D", which is equal to or greater than "0x100" is registered, so "0x010D" is registered in the last end" 0x010D" in the sortingarea. Furthermore, in the compression map, as illustrated in <figref idrefs="f0047">FIG. 50</figref>, correlation data that correlates the code after sorting of the parent node "0x0103" with the character code that corresponds to the array index "0x49" in the array for character appearance numbers is registered in the "0x10D"-th array area, which corresponds to the code after sorting. Even though the processing may be performed for the subsequent array indexes, correlation data will not be registered in the compression map. In the following processing, data is not registered in the compression map, so an explanation is omitted.</p><p id="p0070" num="0070">Next, the compression map generation processing will be explained using <figref idrefs="f0049">FIG. 51</figref> and <figref idrefs="f0050">FIG. 52</figref>.</p><p id="p0071" num="0071">The compression map generator 120 adds correlation data that correlates the data "root", which expresses a root node, with the character code, which corresponds to the code of the node, as data for the nodes "0x0000" to "0x00FF" in the first layer to the compression map in sequence (<figref idrefs="f0049">FIG. 51</figref>, step S91). Moreover, the compressionmap generator 120 adds the codes of the nodes "0x0000" to "0x00FF" in the first layer to the sorting area in sequence (step S93). Then, the compression map generator 120 reads one unprocessed code in ascending order of the code after sorting from the sorting area (step S95). Here, when it is not possible to read any unprocessed code (step S97: NO route), the processing returns to the processing of the calling source.<!-- EPO <DP n="23"> --></p><p id="p0072" num="0072">On the other hand, when it is possible to read any unprocessed code (step S97: YES route), the compression map generator 120 references the data block of the node of the read code in the phrase tree (step S99). The compression map generator 120 then performs an entry addition processing (step S101). This entry addition processing will be explained using <figref idrefs="f0050">FIG. 52</figref>. After the entry addition processing has completed, the processing returns to the step S95.</p><p id="p0073" num="0073">Next, the processing flow of the entry addition processing will be explained.</p><p id="p0074" num="0074">The compression map generator 120 reads the value A in the array area of the unprocessed index in the array for character appearance numbers in the data block for the node of the read code in ascending order of the index (<figref idrefs="f0050">FIG. 52</figref>: step S111). Here, the compression map generator 120 determines whether the processing has already been performed to the end of the array for character appearance numbers (step S113). When the processing has already been performed to the end of the array for character appearance numbers, the processing returns to the processing of the calling source.</p><p id="p0075" num="0075">On the other hand, when the processing has not been performed to the end of the array for character appearance numbers, the compression map generator 120 determines whether a condition that the obtained value A is 0xFF and the number of appearances of characters is not 256 is satisfied (step S115). When this condition is satisfied, the code is not registered in the array for counters/child node numbers, so the processing returns to the step S111.</p><p id="p0076" num="0076">On the other hand, when the value A does not satisfy the condition described above, the compression map generator 120 determines whether the value A is 8 or greater (step S117). When the value A is 8 or greater, the array for extended counters/child node numbers is used, so the compression map generator 120 reads the value of the spanned number, and references the array for extended counters/child node numbers for the spanned number (this may also be the extended spanned number) (step S119). Moreover, the compression map generator 120 subtracts 8 from the value A (step S121). The compression map generator 120 then determines whether the value A is greater than 8 (step S123). When the value A is still greater than 8, the compression map generator 120 obtains the value C of the extended spanned number that is stored at the tail end of the array for extended counters/child node numbers (step S125). The processing then returns to the step S119.</p><p id="p0077" num="0077">On the other hand, when the value A is equal to or less than 8, the compression map generator 120 reads the value B that is stored in the A-th array area in the referenced array for extended counters/child node numbers (step S127). The processing then moves to step S130.<!-- EPO <DP n="24"> --></p><p id="p0078" num="0078">On the other hand, when the value A is less than 8 from the beginning, the compression map generator 120 reads the value B that is stored in the A-th array area in the array for counters/child node numbers (step S129).</p><p id="p0079" num="0079">The compression map generator 120 then determines whether the obtained value B is equal to or greater than "0x0100" (step S130). When the obtained value B is less than "0x0100", data will not be added to the compression map, so the processing returns to the step S111. However, when the obtained value B is equal to or greater than "0x0100", the compression map generator 120 adds the code B to the tail end of the sorting area (step S131). In addition, the compression map generator 120 adds correlation data that correlates the array index in the sorting area, which is the target of the processing, with the array index, which is the target of the processing, in the array for character appearance numbers to the compression map (step S133). The processing then returns to the step S111.</p><p id="p0080" num="0080">By performing the processing described above, the processing explained by using the aforementioned specific example above is performed. Moreover, with a compression map that is generated in this way, the compression map can be stored on a disk unit as it is, and can be used in the compression processing or decompression processing.</p><p id="p0081" num="0081">Next, the compression processing that uses the compression map will be explained using <figref idrefs="f0051 f0052">FIG. 53 to FIG. 55</figref>.</p><p id="p0082" num="0082">The compression processing unit 140 acquires one character from the input character string that is the target of the compression, and moves the current node at the code that corresponds to that character in the compression map (<figref idrefs="f0051">FIG. 53</figref>: step S141). The compression processing unit 140 also obtains the next one character from the input character string (step S143). Here, the compression processing unit 140 determines whether a character was able to be obtained at the step S143 (step S144). When a character can be obtained, the compression processing unit 140 determines whether the code of the current node is less than "0x0100" (step S147).</p><p id="p0083" num="0083">When the code of the current node is less than "0x0100", the compression processing unit 140 performs a binary search of the compression map in a range from the code "0x0100" to the last node to find a node satisfying a condition that "the parent node code in the map = the code of the current node, and the character code in the map = the obtained character" (step S149). The processing then moves to step S153.</p><p id="p0084" num="0084">On the other hand, when the current node is equal to or greater than "0x0100", the compression processing unit 140 performs a binary search of the compression map in a range from (the code of the current node + 1) to the last<!-- EPO <DP n="25"> --> node to find a node satisfying a condition that "the parent node code in the map = the code of the current node, and the character code in the map = the obtained character" (step S151). The processing then moves to step S153.</p><p id="p0085" num="0085">Moving to the processing of the step S153, the compression processing unit 140 determines whether the node satisfying the aforementioned condition was found in the binary search (step S153). When the node satisfying the aforementioned condition was not found, the compression processing unit 140 outputs the code of the current node as the compression result (step S157), and sets the node of the character obtained at the step S143 as the current node (step S159). The processing then returns to the step S143. On the other hand, when the node satisfying the condition was found, the compression processing unit 140 changes the current node to that node (step S155). The processing then returns to the step S143.</p><p id="p0086" num="0086">Whenany character couldnotbeobtainedat the step S143, the compression processing unit 140 outputs the code of the current node as the compression result (step S145). The processing then returns to the processing of the calling source.</p><p id="p0087" num="0087">The compression of a character string is performed by performing the aforementioned processing.</p><p id="p0088" num="0088">For example, the processing in the case in which a compression map such as illustrated in <figref idrefs="f0052">FIG. 54</figref> is generated, and a character string "ABCAA" is inputted as the target of compression will be explained in detail.</p><p id="p0089" num="0089">First, when processing "A" of the input character string "ABCAA", "0x0041" is set as the current node ("1" in <figref idrefs="f0052">FIG. 55</figref>). Next, when processing "B" in "ABCAA", a binary search is performed in a range from the code "0x0100" to "0x0107" to find a node satisfying a condition "the parent node code = 0x0041, and character code = 0x42". As a result, it is found that the code "0x0101" is the corresponding node, so "0x0101" is set as the current node ("2" in <figref idrefs="f0052">FIG. 55</figref>).</p><p id="p0090" num="0090">Moreover, when processing "C" in "ABCAA", a binary search is performed in a range from the code "0x0102" to "0x0107" to find a node satisfying a condition that "the parent node code = 0x0101, and the character code = 0x43". As a result, it is found that the code "0x0104" is the corresponding node, so "0x0104" is set as the current node ("3" in <figref idrefs="f0052">FIG. 55</figref>). Furthermore, when processing second "A" in "ABCAA", a binary search is performed in a range from the code "0x0105" to "0x0107" to find a node satisfying a oondition "the parent node code = 0x0104, and the character code = 0x41". Then, because no node satisfying the condition is found, the code "0x0104" of the current node is added to the compression result ("4" in <figref idrefs="f0052">FIG. 55</figref>). The node of the code "0x0041" that corresponds to the<!-- EPO <DP n="26"> --> character code "0x041" is set as the current node.</p><p id="p0091" num="0091">Furthermore, when processing third "A" in "ABCAA", a binary search is performed in a range from the code "0x0100" to "0x0107" to find a node satisfying a condition that "the parent node code = 0x0041, and the character code = 0x41". As a result, it is found that the code "0x0100" is the corresponding node, so "0x0100" is set as the current node ("5" in <figref idrefs="f0052">FIG. 55</figref>). With that, all of the characters of the input character string have been processed, so the code "0x0100" of the current node is outputted, and the processing ends ("6" in <figref idrefs="f0052">FIG. 55</figref>).</p><p id="p0092" num="0092">In this way, it is possible to perform the compression processing.</p><p id="p0093" num="0093">Next, the processing flow of the decompression processing will be explained using <figref idrefs="f0053">FIG. 56</figref> and <figref idrefs="f0054">FIG. 57</figref>. First, the decompression processing unit 150 reads one unprocessed code from compressed data, and sets the corresponding node in the compression map as the current node (<figref idrefs="f0053">FIG. 56</figref>: step S161). At the step S161, when it is not possible to acquire any code, the processing returns to the processing of the calling source (step S163: NO route). However, when a code can be acquired (step S163: YES route), the decompression processing unit 150 outputs the character of the current node to a work area (step S165). The decompression processing unit 150 then determines whether the code of the parent node is included in the current node (step S167). When the code of the parent node is a root, it is determined that the code of the parent node does not exist. When there is no code of the parent node, the decompression processing unit 150 outputs the character string in the work area starting from the back as the decompression result (step S169). The processing then returns to the step S161. On the other hand, when there is a code of the parent node, the decompression processing unit 150 positions the code of the parent node at the current node (step S171). The processing then returns to the step S165.</p><p id="p0094" num="0094">By performing, such a processing, it is possible to decompress codes to a character string.</p><p id="p0095" num="0095">For example, the case in which the codes "0x0104, 0100" are inputted as compressed data will be explained using a compression map such as illustrated in <figref idrefs="f0052">FIG. 54</figref>.</p><p id="p0096" num="0096">First, the node of the code "0x0104" is set as the current node, and the character "C" at the current node is outputted to the work area. The code of the parent node is "0x0101", so as the current node, the node of the code "0x0101" is set ("1" in <figref idrefs="f0054">FIG. 57</figref>). The character "B" in the code "0x0101" of the current node is then outputted to the work area. Furthermore, the code of the parent node is "0x0041", so as the current node, the node of the code "0x0041" is set ("2" in <figref idrefs="f0054">FIG. 57</figref>).</p><p id="p0097" num="0097">Then, the character "A" of the code "0x0041" for the current node<!-- EPO <DP n="27"> --> is outputted to the work area. However, there is no parent node, so by outputting the characters of the work area in reverse order, "ABC" is obtained.</p><p id="p0098" num="0098">Next, by reading the new code "0x0100", this node is set as the current node, and the character "A" at the node of that code is outputted to the work area. The code of the parent node is "0x0041", so as the current node, the node of the code "0x0041"is set ("4" in <figref idrefs="f0054">FIG. 57</figref>). Then, the character "A" at the current node is outputted to the work area. Here, there is no code of the parent node at the current node, so the character string in the work area is outputted in reverse order, and "AA" is further obtained. The decompression processing is then complete ("5" in <figref idrefs="f0054">FIG. 57</figref>).</p><p id="p0099" num="0099">The data structure of the phrase tree is changed in this way, so it is possible to reduce the memory capacity that is used during the processing.</p><p id="p0100" num="0100">It is also possible to perform the compression processing using the data of the phrase tree without generating the compression map.</p><p id="p0101" num="0101">For example, an example of the processing contents of compressing the character string "ABCAA" using the data of the phrase tree depicted in <figref idrefs="f0026 f0027 f0028 f0029 f0030 f0031">FIG. 24A to FIG. 24F</figref> will be explained.</p><p id="p0102" num="0102">As illustrated in <figref idrefs="f0055">FIG. 58</figref>, when reading "A" in "ABCP.A", the node of the code "0x0041" that corresponds to the character "A" is set as the current node. Furthermore, when "B" in "ABCAA" is read, the value "0" in the "0x42 (B)"-th array area in the array for character appearance numbers is obtained, and the value of the appearance sequential number "0" in the array for counters/child node numbers is read. In this case, the code "0x0100" is obtained. In the case of the code "0x0100", the node corresponding to this code is set as the current node.</p><p id="p0103" num="0103">Next, as illustrated in <figref idrefs="f0055">FIG. 59</figref>, when "C" in "ABCAA" is read, the value "0" in the "0x43 (C) "-th array area in the array for character appearance numbers is obtained, and the "0"-the value, which corresponds to the appearance sequential number "0", in the array for counters/child node numbers is read. Here, the code"0x0101" is obtained. In the case of the code "0x0101", the node of this code is set as the current node.</p><p id="p0104" num="0104">Moreover, when second "A" in "ABCAA" is read, as illustrated in <figref idrefs="f0056">FIG. 60</figref>, the value "0" in the "0x41 (A)"-th array area in the array for character appearance numbers is obtained, and the "0"-the value, which corresponds to the appearance sequential number "0", in the array for counters/child node numbers is read. As a result, the read value is less than the code "0x0100", so the code "0x0101" of the current node is outputted as the compression result.</p><p id="p0105" num="0105">Furthermore, when third "A" in "ABCAA" is read, as illustrated in <figref idrefs="f0056">FIG. 61</figref>, the value "1" in the "0x41 (A) "-th array area in the array for character<!-- EPO <DP n="28"> --> appearance numbers is obtained, and the value in the "1st" array area, which corresponds to the appearance sequential number "1", in the array for counters/child node numbers is read. As a result, the code "0x0104" is obtained. Here, the input character string ends, so the code "0x0104" is also outputted as the compression result. Indoingso, finally "0x0101" and "0x0104" are outputted as the compression result.</p><p id="p0106" num="0106">Moreover, it is possible to decompress the compressed data using the data of the phrase tree. Here, an example of the processing contents of decompressing the code "0x0101" and "0x0104" using the data of the phrase tree depicted in <figref idrefs="f0026 f0027 f0028 f0029 f0030 f0031">FIG. 24A to FIG. 24F</figref> will be explained.</p><p id="p0107" num="0107">First, as illustrated in <figref idrefs="f0057">FIG. 62</figref>, the node that includes the code "0x0101" in the array for counters/child node numbers is searched for. As a result, this time, the appearance sequential number "0" in the node of the code "0x0100" is identified. Then, the array index whose array area registers "0" in the array for character appearance numbers is searched for, and the code "0x43" is obtained. This character code "0x43" is outputted to the work area.</p><p id="p0108" num="0108">Next, as illustrated in <figref idrefs="f0057">FIG. 63</figref>, the node that includes the code "0x0100" in the array for counters/child node numbers is searched for. As a result, this time, the appearance sequential number "0" in the node of the code "0x0041" is identified. After that, the array index whose array area stores "0" in the array for character appearance numbers is searched for, and the code "0x42" is obtained. This character code "0x42" is outputted to the work area.</p><p id="p0109" num="0109">Next, the code "0x0041" is searched for, however, it is less than the code "0x0100". Therefore, the character "0x41" that corresponds to the code "0x0041" is outputted to the work area.</p><p id="p0110" num="0110">As a result, as illustrated in <figref idrefs="f0058">FIG. 64</figref>, the order of the characters in the work area is reversed, and "0x41", "0x42" and "0x43" are outputted as the decompression result.</p><p id="p0111" num="0111">Next, as illustrated in <figref idrefs="f0059">FIG. 65</figref>, the node that includes the code "0x0104" in the array for counters/child node numbers is searched for. As a result, this time, the appearance sequential number "1" in the node of the code "0x0041" is identified. After that, the array index whose array area stores "1" in the array for character appearance numbers is searched for, and the code "0x41" is obtained. This character code "0x41" is outputted to the work area.</p><p id="p0112" num="0112">Furthermore, the code "0x0041" is searched for, however, as described above, the code is less than the code "0x0100", so the character "0x41" that corresponds to the code "0x0041" is outputted to the work area.</p><p id="p0113" num="0113">As a result, as illustrated in <figref idrefs="f0058">FIG. 66</figref>, the order of the characters in the work area is reversed, and "0x41" and "0x41" are added to the decompression<!-- EPO <DP n="29"> --> result. In this way, "ABCAA" is obtained.</p><heading id="h0002">[Embodiment 2]</heading><p id="p0114" num="0114">In this embodiment, in order to improve the processing speed of the compression processing, the data structure of the compression map is changed.</p><p id="p0115" num="0115">More specifically, the maximum node number of the child nodes (i.e. the maximum code of the child nodes) is held for each node. In the compression processing, even at the step S149 or step S151, a node that has the current node as the parent node is searched for. In other words, child nodes of the current node are searched for. However, the search range at the step S149 is from "0x0100" to the last node, and at the step S151, the search range is from (the code of the current node + 1) to the last node.</p><p id="p0116" num="0116">In the phrase tree that is schematically illustrated in <figref idrefs="f0060">FIG. 67</figref>, for example, when the current node is a node of "0x0103", the search range of the child nodes is actually the nodes of "0x0105" to "0x0107", however, in the first embodiment, the node of "0x0104" was also the target of the search. In this example, only one node is extra, however, actually, there is a bad influence when there are plural child nodes for "0x0100", "0x0101" and "0x0102". Moreover, when "0x0101" is the current node, only "0x0104" is a child node, however, in the first embodiment, the search range is from "0x0102" to "0x0107".</p><p id="p0117" num="0117">On the other hand, by holding the maximum child node code for each node, it becomes possible to narrow down the search range to be from the node of {the maximum child node code + 1} of the node immediately before the current node to the maximum child node of the current node. In the case where there are no child nodes, the maximum child node code of the node corresponding to {the code of that node - 1} is copied.</p><p id="p0118" num="0118">By holding the maximum child node code for each node in this way, when the current node is "0x0103", "0x0107" is identified as the maximum child node code of the current node. Furthermore, "0x0105", which is calculated by adding "1" to the maximum child node code "0x0104" of a node "0x0102" (="0x0103" -1) immediately before the current node code "0x0103", is obtained, so the search range can be efficiently identified as "0x0105" to "0x0107".</p><p id="p0119" num="0119">More specifically, as illustrated in <figref idrefs="f0060">FIG. 68</figref>, the compression map is changed to a form that correlates the code of the parent node, the character code and the maximum code of child nodes.</p><p id="p0120" num="0120">Next, the compression map generation processing relating to this embodiment will be explained. In this embodiment, the entry addition processing in the compression map generation processing is changed as illustrated in <figref idrefs="f0061">FIG. 69</figref>. However, the changed part is only the part where step S135 is added.</p><p id="p0121" num="0121">At the step S135, after the array for character appearance numbers<!-- EPO <DP n="30"> --> for one node has been processed to the end, the compression map generator 120 sets the array index of the code finally added to the sorting area as the maximum code of the child nodes. For the node being processed, when the codes of the child nodes are not added to the sorting area, in other words, when there is no child node, the code that is the same as that of a node immediately before the node being processed is set as the maximum code of the child nodes.</p><p id="p0122" num="0122">Moreover, the processing flow of the compression processing relating to this embodiment is as illustrated in <figref idrefs="f0062">FIG. 70</figref>. However, the part that differs from the processing flow illustrated in <figref idrefs="f0051">FIG. 53</figref> is just the part from step S147 to step S151.</p><p id="p0123" num="0123">More specifically, the compression processing unit 140 determines whether or not the code of the current node is "0x0000" (step S147b). This is because, as for only the node of "0x0000", the maximum code of the child nodes for the node immediately before the current node cannot be acquired. When the current node code is "0x0000", the compression processing unit 140 performs a binary search in a range from the code "0x0100" to the maximum child node code in the compression map for a node satisfying a condition "the parent node code in the map = the code of the current node, and the character code in the map = the acquired character" (step S149b). The processing then moves to the step S153. The search range is narrowed more than that of the step S149.</p><p id="p0124" num="0124">On the other hand, when the current node is not "0x0000", the compression processing unit 140 performs a binary search in a range from the code obtained by adding "1" to the maximum child node code of the node immediately before the current node to the maximum child node code of the current node in the compression map for a node satisfying a condition that "the parent node code in the map = the code of the current node, and the character code in the map = the acquired character" (step S151b). The processing then moves to the step S153. Similarly, the search range is narrowed more than that of the step S151.</p><p id="p0125" num="0125">By performing the processing described above for the phrase tree in <figref idrefs="f0060">FIG. 67</figref>, a compression map such as illustrated in <figref idrefs="f0063">FIG. 71</figref> is obtained. Then, by performing the compression processing described above for the input character string "ABCAA" using such a compression map, the result is as described in the following. The processing result itself is the same as that illustrated in <figref idrefs="f0052">FIG. 55</figref>.</p><p id="p0126" num="0126">First, when "A" in the input character string "ABCAA" is processed, "0x0041" is set as the current node ("1" in <figref idrefs="f0052">FIG.55</figref>). Next, when "B" in "ABCAA" is processed, a binary search is performed in a range from the code "0x0100" to "0x0101" (the maximum child node code of the current node) for a node satisfying the condition that "the parent node code = 0x0041, and the character code =<!-- EPO <DP n="31"> --> 0x42". As a result, it is found that the code "0x0101" is the code of the node satisfying the condition, so"0x0101" is set as the current node ("2" in <figref idrefs="f0052">FIG. 55</figref>).</p><p id="p0127" num="0127">Furthermore, when "C" in "ABCAA" is processed, a binary search is performed in a range of the code "0x0104" (the code obtained by adding "1" to the maximum child node code of a node immediately before = the maximum child node code of the current node) for a node satisfying a condition that "the parent node code = 0x0101, and the character code = 0x43". As a result, it is found that the code "0x0104" is the code of the node satisfying the condition, so "0x0104" is set as the current node ("3" in <figref idrefs="f0052">FIG. 55</figref>).</p><p id="p0128" num="0128">Next, when second "A" in "ABCAA" is processed, the search range for searching for a node satisfying a condition that "the parent node code = 0x0104, and the character code = 0x41" is identified as being from the code "0x0108" (code obtained by adding "1" to the maximum child node code of a node immediately before) to the code "0x0107" (the maximum child node code of the current node), however, it can be seen that the starting point and the ending point of the search range are reversed, and that a search is unnecessary. As a result, the node searched for cannot be found, so the code "0x0104" of the current node is added to the compression result ("4" in <figref idrefs="f0052">FIG. 55</figref>). The node of the code "0x0041" corresponding to the character code "0x041" is set as the current node.</p><p id="p0129" num="0129">Furthermore, when processing third "A" in "ABCAA", a binary search is performed in a range from the code "0x0100" to "0x0101" (the maximum child node code of the current node) for a node satisfying a condition "the parent node code = 0x0041, and the character code = 0x41". As a result, it is found that the code "0x0100" is the code of the node satisfying the condition, so "0x0100" is set as the current node ("5" in <figref idrefs="f0052">FIG. 55</figref>). With that, all of the characters in the input character string have been processed, so the code "0x0100" of the current node is outputted, and the processing ends ("6" in <figref idrefs="f0052">FIG. 55</figref>).</p><p id="p0130" num="0130">As described above, it is seen that even in this detailed example as well, the search range is narrowed down.</p><heading id="h0003">[Embodiment 3]</heading><p id="p0131" num="0131">In this third embodiment, the processing speed of the decompression processing is improved. In the processing illustrated in <figref idrefs="f0053">FIG. 56</figref>, nodes are traced back to the root node (i.e. root in figure), so node searches are performed many times. Therefore, in this embodiment, together with changing the data structure of the compression map, hierarchy level information (or layer information) and decompression map are newly generated, and stored. Even when additional data is stored in this way, the additional storage capacity is only about 800 K bytes, so the increased load is not so large. The compression map<!-- EPO <DP n="32"> --> is about 446 KB.</p><p id="p0132" num="0132"><figref idrefs="f0064">FIG. 72</figref> illustrates an example of a compression map of this embodiment. As illustrated in <figref idrefs="f0064">FIG. 72</figref>, the basic structure is the same as that in the first embodiment, however, the parent node code, the character code of its own node, and the layer number or layer identifier of a layer to which its own node belongs are correlated and stored.</p><p id="p0133" num="0133">Moreover, <figref idrefs="f0065">FIG. 73</figref> depicts layer information, and in this layer information, the number of nodes within the layer, the start code within the layer, and the offset value of the top decompressed character string in the layer from the beginning of the decompression map are correlated for each layer starting from the first layer. The example in <figref idrefs="f0065">FIG. 73</figref> is based on the phrase tree in <figref idrefs="f0060">FIG. 67</figref>, however, by using the layer information, it can be seen that there are four nodes "0x0100", "0x0101", "0x0102" and "0x0103" in the second layer, and these nodes represent character strings each containing two characters. Moreover, these character strings use a total 2 * 4 = 8 bytes. Furthermore, in the third layer, it can be seen that there are four nodes "0x0104", "0x0105", "0x0106", and "0x0107", and these nodes represent character strings each containing 3 characters. It is also seen that these character strings use a total of 3 * 4 = 12 bytes. The offset value of the top decompressed character string in the layer represents how far the character or character string of the start code in the identified layer is separated from the top of the decompression map, when the layer is identified.</p><p id="p0134" num="0134">Furthermore, <figref idrefs="f0065">FIG. 74</figref> illustrates an example of a decompression map relating to this embodiment. The decompression map relating to this embodiment is an associative array in which characters that correspond to the codes of the nodes belonging to each layer are stored in order of the code. In the case of the phrase tree in <figref idrefs="f0060">FIG. 67</figref>, in the second layer, "AA" is registered in the 0-th area, "AB" is registered in the "1st" area, "BC" is registered in the "2nd" area and "CB" is registered in the "3rd" area. Moreover, in the third layer, "ABC" is registered in the "0"-th area, "CBA" is registered in the "1st" area, "CBB" is registered in the "2nd" area and "CBC" is registered in the "3rd" area.</p><p id="p0135" num="0135">The processing for generating data such as the aforementioned compression map and the like will be explained using <figref idrefs="f0066 f0067 f0068">FIG. 75 to FIG. 77</figref>.</p><p id="p0136" num="0136">The compression map generator 120 adds correlation data that correlates data "root" that represents the root node, character codes that correspond to codes of the nodes "0x0000" to "0x00FF" and a layer number "1" to the compression map in sequence, as the data of the nodes "0x0000" to "0x00FF" in the first layer (<figref idrefs="f0066">FIG. 75</figref>: step S181).</p><p id="p0137" num="0137">The compression map generator 120 then sets information about the<!-- EPO <DP n="33"> --> first layer in the layer information (step S183). In other words, there are 256 nodes in the first layer, so "256" is set as the number of nodes in the layer, "0x0000" is set as the code for the start code within the layer, and "0" is set as the offset value of the top decompressed character string. These are fixed values.</p><p id="p0138" num="0138">Furthermore, the compression map generator 120 sets information of the first layer in the decompression map (step S185). Because the first layer includes one character code for each character, the character codes "0x00" to "0xFF" are set. There are fixed values.</p><p id="p0139" num="0139">The compression map generator 120 then adds the codes of the nodes "0x0000" to "0x00FF" in the first layer to the sorting area in sequence (step S187). Moreover, the compression map generator 120 sets "0x0100" as the start code within the next layer (step S189). The start code within the next layer is a variable that is used in the following. Furthermore, the compression map generator 120 initializes a layer counter (step S190).</p><p id="p0140" num="0140">After that, the compression map generator 120 reads one unprocessed code from the sorting area in ascending order of the code after sorting (step S191). Here, when it is not possible to read an unprocessed code (step S193: NO route), the compression map generator 120 sets the value of a node counter that will be explained below as the number of nodes in the final layer in the layer information (step S195). The processing then returns to the processing of the calling source.</p><p id="p0141" num="0141">After that, the compression map generator 120 reads one unprocessed code from the sorting area in ascending order of the code after sorting (step S191). Here, when it is not possible to read an unprocessed code (step S193: NO route), the compression map generator 120 sets the value of a node counter that will be explained below as the number of nodes in the final layer in the layer information (step S195). The processing then returns to the processing of the calling source.</p><p id="p0142" num="0142">On the other hand, when it is possible to read any unprocessed code (step S193: YES route), the compression map generator 120 references a data block for a node of the read code in the phrase tree (step S197). The compression map generator 120 then performs a third entry addition processing relating to this embodiment (step S199). This third entry addition processing will be explained using <figref idrefs="f0067">FIG. 76</figref>. After the third entry addition processing, the compression map generator 120 performs a setting processing (step S201). The setting processing will be explained using <figref idrefs="f0068">FIG. 77</figref>. The processing then returns to step S191.</p><p id="p0143" num="0143">Next, the third entry addition processing will be explained using<!-- EPO <DP n="34"> --> <figref idrefs="f0067">FIG. 76. FIG. 76</figref> is nearly the same as <figref idrefs="f0050">FIG. 52</figref>, however, step S133 has been changed to step S133b, and steps S137 and S139 have been added.</p><p id="p0144" num="0144">In other words, at the step S133b, the compression map generator 120 adds correlation data that correlates an array index (i.e. the parent node code) ta be processed in the sorting area, an array index to be processed (i.e. character code of the child node) in the array for character appearance numbers, and a value of the layer counter (i.e. layer) to the compression map (step S133b).</p><p id="p0145" num="0145">Moreover, the compression map generator 120 sets the character string of the parent node and the array index in the array for character appearance numbers (i.e. character code of the child node) as the character string corresponding to the child node in the layer corresponding to the value of the layer counter in the decompression map (step S137). The character string of the parent node (i.e. character string of the code being processed) is identified by, for example, tracing the compression map using the code identified at the step S95. Moreover, the character string of the parent node can be obtained by identifying the layer number of the layer to which the current node belongs in the compression map, and referencing the position obtained by ("the offset value of the top decompressed character string" in the layer to which the current node belongs in the layer information + (code of the current node - start code within the layer) * layer number) in the decompression map.</p><p id="p0146" num="0146">Furthermore, the compression map generator 120 increments the value of the node counter by "1" (step S139). The processing then returns to the step S111.</p><p id="p0147" num="0147">By performing the processing described above, the compression map, layer information and part of the decompression map can be generated.</p><p id="p0148" num="0148">Next the setting processing will be explained using <figref idrefs="f0068">FIG. 77</figref>.</p><p id="p0149" num="0149">The compression map generator 120 determines whether the start code within the next layer, which has been set up to this point, is the code of the current node (step S211). The initial value of the start code within the next layer is "0x0100". When the start code within the next layer is not the code of the current node, the processing moves to step S219. However, when the start code within the next layer is the code of the current node, the compression map generator 120 determines whether a child node was identified in the third entryadditionpracessing (step S213). When there is no childnode, the compression map generator 120 sets (the code of the current node + 1) as the start code within the next layer (step S217). The processing then returns to the processing of the calling source.</p><p id="p0150" num="0150">On the other hand, when there is a child node, the compression map generator 120 sets the least child node code among codes of child nodes that<!-- EPO <DP n="35"> --> were identified in the third entry addition processing as the start code within the next layer (step S215). The processing then moves to step S219.</p><p id="p0151" num="0151">After moving to the processing of the step S219, the compression map generator 120 determines whether (the code of the current node + 1) is the start code within the next layer (step S219). In other words, the compression map generator 120 determines whether the node being processed is the last node within the current layer. When (the code of the current node +1) is the start code of the next layer, the compression map generator 120 sets the value of the node counter as the number of nodes within the layer in the layer information (step S221). The compression map generator 120 then sets (the code of the current node + 1) as the start code within the layer for the next layer in the layer information (step S223). Furthermore, the compression map generator 120 sets (the offset value of the top decompressed character string within the current layer + the node counter value * layer number (value of the layer counter)) as the offset value of the top decompressed character string for the next layer in the layer information (step S225).</p><p id="p0152" num="0152">The compression map generator 120 then initializes the node counter to "0" (step S227), and increments the value of the layer counter by "1" (step S229). The processing then returns to the processing of the calling source.</p><p id="p0153" num="0153">By performing such a processing, it is possible to generate a compression map, layer information and a decompression map as described above.</p><p id="p0154" num="0154">Next, the third compression processing relating to this embodiment will be explained using <figref idrefs="f0069">FIG. 78</figref>. The third compression processing relating to this embodiment is nearly the same as the compression processing relating to the first embodiment, and differs in that step S151c is executed instead of the steps S147 to S151.</p><p id="p0155" num="0155">In other words, the compression processing unit 140 performs a binary search for a node satisfying a condition that "the parent node code = the code of the current node, and the character code = the obtained character" in a range from the start code Z within the layer for the layer next to the layer of the current node (data within the layer information) to (Z + the number of nodes within the layer for the next layer (data in the layer information)) in the compression map (step S151c).</p><p id="p0156" num="0156">In doing so, the search range is narrowed compared to that in the compression processing relating to the first embodiment.</p><p id="p0157" num="0157">For example, a detailed example of the processing for the case in which "ABCAA", which is a character string to be compressed, is inputted will be explained.</p><p id="p0158" num="0158">First, when processing "A" in the inputted character string "'A' BCAA",<!-- EPO <DP n="36"> --> "0x0041" is set as the current node ("1" in <figref idrefs="f0052">FIG. 55</figref>). Next, when processing "B" in "A 'B' CAA", the current layer number is "1", so a binary search is performed in a range from codes "0x0100" to "0x0103" within the second layer for a node satisfying a condition that "the parent node code = 0x0041, and the character code = 0x42". As a result, it is found that the code "0x0101" is the corresponding node, so "0x0101" is set as the current node ("2" in <figref idrefs="f0052">FIG. 55</figref>).</p><p id="p0159" num="0159">Furthermore, when processing "C" in "AB `C' AA", the current layer number is "2", so a binary search is performed in a range from code "0x0104" to "0x0107" within the third layer for a node satisfying a condition that "the parent node code = 0x0101, and the character code = 0x43". As a result, it is found that the code "0x0104" is the corresponding node, so "0x0104" is set as the current node ("3" in <figref idrefs="f0052">FIG. 55</figref>).</p><p id="p0160" num="0160">Furthermore, when processing second "A" in "ABC'A'A", the current layer number is "3", there is no next layer, so it can be seen that there is no corresponding node without the search for a node satisfying a condition that "the parent node code = 0x0104, and the character code = 0x41". Therefore, the code "0x0104" of the current node is added to the compression result ("4" in <figref idrefs="f0052">FIG. 55</figref>). The node of the code "0x0041" that corresponds to the character code "0x41" is set as the current node.</p><p id="p0161" num="0161">Moreover, when third "A" in "ABCA'A'" is processed, the current layer number is "1", so a binary search is performed in a range of codes "0x0100" to "0x0103" within the second layer for a node satisfying a condition that "the parent node code = 0x0041, and the character code = 0x41". As a result, the code "0x0100" is the corresponding node, so "0x0100" is set as the current node ("5" in <figref idrefs="f0052">FIG. 55</figref>). Here, all of the characters in the input character string have been processed, so the code "0x0100" of the current node is outputted, and the processing ends ("6" in <figref idrefs="f0052">FIG. 55</figref>).</p><p id="p0162" num="0162">In this way, it is possible to perform the compression processing.</p><p id="p0163" num="0163">Next, the processing of the second decompression processing relating to this embodiment will be explained using <figref idrefs="f0070">FIG. 79</figref> and <figref idrefs="f0071">FIG. 80</figref>.</p><p id="p0164" num="0164">First, the decompression processing unit 150 obtains one code from the compression data, and positions the current node at the corresponding node in the compression map (step S231). When any code could not be read from the compression data (step S233 : NO route), the processing returns to the processing of the calling source. On the other hand, when any code can be read from the compression data (step S233 : YES route), the decompression processing unit 150 references a position of ("the offset value of the top decompressed character string" + (the current node code - start code within the layer) * layer number) for the layer to which the current node belongs in the layer information, in<!-- EPO <DP n="37"> --> the decompression map, and outputs codes by the amount of bytes of the layer number (step S235). The processing then returns to the step S231. The offset value of the top decompressed character string and the start code within the layer are obtained by reading from the layer information.</p><p id="p0165" num="0165">In this way, by using the layer information and decompression map, the speed of the processing can be enhanced.</p><p id="p0166" num="0166">For example, processing for the case of decompressing "0x0104" and "0x0100" will be explained using <figref idrefs="f0071">FIG. 80</figref>.</p><p id="p0167" num="0167">First, when the code "0x0104" is read, the layer is identified from the compression map as being the third layer, so the offset value of the top decompressed character string within the third layer "264" + (the code of the current node "0x0104" - the start code within the layer "0x0104") * 3 becomes "264", so 3 bytes are read from the 264 bytes from the top of the decompression map. As a result, "ABC" is outputted ("1" in <figref idrefs="f0071">FIG. 80</figref>). Furthermore, when the next code "0x0100" is read, the layer is identified from the compression map as being the second layer, so the offset value of the top decompressed character string within the second layer "256" + (the current node code "0x0100" - the start code within the layer "0x0100") * 2 becomes "256", so 2 bytes are read from the 256 bytes from the top of the decompression map. As a result, "AA" is further outputted ("2" in <figref idrefs="f0071">FIG. 80</figref>).</p><p id="p0168" num="0168">As described above, decompression is performed by two steps, so the processing becomes faster.</p><heading id="h0004">[Embodiment 4]</heading><p id="p0169" num="0169">This embodiment combines the second and third embodiments. Moreover, in the decompression map and layer information, the amount of memory used is decreased by omitting information that is fixed and that is obtained from the data of the compression map.</p><p id="p0170" num="0170"><figref idrefs="f0071">FIG. 81</figref> illustrates an example of the compression map relating to this embodiment. In this embodiment, the character code of its own node, the maximum child node code, and the layer number of the layer to which its own node belongs are correlated in order of the code after sorting. As for the parent node code, when there is layer information and a decompression map, that code is not used, so is omitted.</p><p id="p0171" num="0171">Furthermore, <figref idrefs="f0072">FIG. 82</figref> illustrates layer information relating to this embodiment. The layer information relating to this embodiment differs from the third embodiment in that the data of the first layer is omitted. For the second layer and subsequent layers, the number of nodes within the layer, the start code within the layer, and the offset value of the top decompressed character string are registered. The data for the first layer is omitted, so the offset<!-- EPO <DP n="38"> --> value of the top decompressed character string is changed.</p><p id="p0172" num="0172">Moreover, <figref idrefs="f0072">FIG. 83</figref> illustrates a decompression map relating to this embodiment. The decompression map relating to this embodiment differs from that in the third embodiment in that the data of the first layer is omitted. The decompression map is an associative array in which corresponding character strings are stored in ascending order of the code in the second layer and the subsequent layers.</p><p id="p0173" num="0173"><figref idrefs="f0073">FIG. 84</figref> illustrates the processing flow of the third compression map generation processing relating to this embodiment. This processing differs from the second compressionmap generationprocessing relating to the third embodiment in that there are no steps S183 and S185, instead of the step S199 for the third entry addition processing, step S199b for a fourth entry addition processing is performed, and instead of the step S201 for the setting processing, step S201b for a second setting processing is performed.</p><p id="p0174" num="0174">Next, <figref idrefs="f0074">FIG. 85</figref> illustrates the processing flow of the fourth entry addition processing. This processing differs from the third entry addition processing relating to the third embodiment in that step S135 that is executed at the end of the array (the processing explained in the second entry addition processing) is additionally performed, and instead of the step S133b, step S133c is performed.</p><p id="p0175" num="0175">At step S133c, the compression map generator 120 adds correlation data that correlates the array index being processed in the array for character appearance numbers (i.e. character code of the child node) with the value of the layer counter (i.e. layer number) (step S133c). This differs in that the array index being processed in the sorting area (i.e. the code of the parent node) is not registered.</p><p id="p0176" num="0176">The second setting processing that is included in the third compression map generation processing differs from that in <figref idrefs="f0068">FIG. 77</figref>, and the processing flow thereof is as illustrated in <figref idrefs="f0075">FIG. 86</figref>. However, the difference with that illustrated in <figref idrefs="f0068">FIG. 77</figref> is that steps S220 and S222 are added, and instead of steps S223 and S225, steps S223b and S225b are performed.</p><p id="p0177" num="0177">In this second setting processing, when it is determined at the step S219 that (the code of the current node + 1) is the start code within the next layer, in other words, in case of the last node within the layer, the compression map generator 120 determines whether the current value of the layer counter is "1" (step S220). When the current value of the layer counter is "1", data will not be added to the layer information, so the compression map generator 120 sets the offset value of the top decompressed character string within the next layer in the layer information to "0" (step S222). The processing then<!-- EPO <DP n="39"> --> moves to step S225b.</p><p id="p0178" num="0178">On the other hand, when the current value of the layer counter is not "1", the compression map generator 120 sets the value of the node counter as the number of nodes within the layer in the layer information (step S221). The compression map generator 120 also sets {the offset value of the top decompressed character string within the current layer + the node counter * the number of layers (i.e. value of the layer counter)} as the offset value of the top decompressed character string within the next layer in the layer information (step S223b). This processing is the same as the step S225. Furthermore, the compression map generator 120 sets (the code of the current node + 1) as the start code within the layer for the next layer in the layer information (step S225b). This step is the same as the step S223. The processing after this is the same as that illustrated in <figref idrefs="f0068">FIG. 77</figref>.</p><p id="p0179" num="0179">Next, <figref idrefs="f0076">FIG. 87</figref> illustrates the processing flow of the fourth compression processing relating to this embodiment. This processing differs from the second compression processing relating to the second embodiment in that the step S149b and step S151b are changed to step S149d and step S151d.</p><p id="p0180" num="0180">More specifically, the compression processing unit 140 determines whether or not the code of the current node is "0x0000" (step S147b). This is because only the node of "0x0000" is not able to obtain the maximum child node code of the node immediately before the current node. When the code of the current node is "0x0000", the compression processing unit 140 performs a binary search in a range in the compression map from the code "0x0100" to the maximum child node code for a node satisfying a condition that the character code = the read character code (step S149d). This processing is performed because the data for the parent node has been deleted from the compression map.</p><p id="p0181" num="0181">On the other hand, when the current node is not "0x0000", the compression processing unit 140 performs a binary search in a range of the compression map from (the maximum child node code of the node immediately before the current node + 1) to the maximum child node code for a node satisfying a condition that the character code = the read character code (step S151d). The processing then moves to the step S153.</p><p id="p0182" num="0182">For the decompression processing, the third decompression processing illustrated in <figref idrefs="f0077">FIG. 88</figref> is performed instead of the second decompression processing illustrated in <figref idrefs="f0070">FIG. 79</figref>. The difference between <figref idrefs="f0077">FIG. 88</figref> and <figref idrefs="f0070">FIG. 79</figref> is that steps S237 and S239 have been added. More specifically, the decompression processing unit 150 determines whether the value of the layer to which the current node belongs in the compression map is "1" (step S237). When the value of the layer is "1", the decompression processing unit 150 outputs the character code at<!-- EPO <DP n="40"> --> the current node in the compression map (step S239), and then the processing moves to the step S231. On the other hand, when the value of the layer is "2" or greater, the processing moves to the step S235. By performing such a processing, the decompression processing is speeded up even though the amount of layer information and data of the decompression map are reduced.</p><p id="p0183" num="0183">Although the embodiments were explained, this technique is not limited to those embodiments.</p><p id="p0184" num="0184">For example, the aforementioned functional block diagrams do not correspond to program module configurations. Moreover, as long as the processing result does not change, in the processing flows, the order of steps may be changed or plural steps may be executed in parallel.</p><p id="p0185" num="0185">The aforementioned processing may be executed by plural computers, though an example in which one computer executes the processing was explained.</p><p id="p0186" num="0186">In addition, the aforementioned information processing apparatus 100 is computer device as illustrated in <figref idrefs="f0078">FIG. 89</figref>. That is, a memory 2501 (storage device), aCPU2503 (processor), aharddiskdrive (HDD) 2505, adisplaycontroller 2507 connected to a display device 2509, a drive device 2513 for a removable disk 2511, an input device2515, and a communication controller 2517 for connection with a network are connected through a bus 2519 as illustrated in <figref idrefs="f0078">FIG.89</figref>. An operating system (OS) and an application program for carrying out the foregoing processing in the embodiment, are stored in the HDD 2505, and when executed by the CPU 2503, they are read out from the HDD 2505 to the memory 2501. As the need arises, the CPU 2503 controls the display controller 2507, the communication controller 2517, and the drive device 2513, and causes them to perform predetermined operations. Moreover, intermediate processing data is stored in the memory 2501, and if necessary, it is stored in the HDD 2505. In this embodiment of this technique, the application program to realize the aforementioned functions is stored in the computer-readable, non-transitory removable disk 2511 and distributed, and then it is installed into the HDD 2505 from the drive device 2513. It may be installed into the HDD 2505 via the network such as the Internet and the communication controller 2517. In the computer as stated above, the hardware such as the CPU 2503 and the memory 2501, the OS and the application programs systematically cooperate with each other, so that various functions as described above in details are realized.</p><p id="p0187" num="0187">The aforementioned embodiments are outlines as follows:
<ul><li>A data structure generation method includes: (A) first generating, for each character that will be used, a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential number of a second<!-- EPO <DP n="41"> --> character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, the number of appearances or a code corresponding to a character string including the character or the character string and the second character when the number of appearances exceeds a threshold; (B) upon detecting that, in a second area of a data block for a character or a character string being processed among plural characters included in an input character string, an appearance sequential number for a next character of the character or the character string being processed in the input character string is held, that, in a third area of the data block, a number of appearances is held as data in the appearance sequential number, and that the number of appearances after increment exceeds the threshold, storing a code corresponding to a second character string including the character or the character string being processed and the next character; and (C) generating a data block for the second character string, which has a same structure as the data block generated in the first generating.</li></ul></p><p id="p0188" num="0188">By using the plural data blocks obtained by carrying out such a processing, the memory capacity used for this data blocks can be reduced.</p><p id="p0189" num="0189">The aforementioned data structure generation method may further include: (D) upon detecting that, in the second area of the data block for the character or the character string being processed, the appearance sequential number for the next character of the character or the character string being processed in the input character string is held, that, in the third area of the data block, the number of appearances is held as data in the appearance sequential number, and that the number of appearances after the increment does not exceeds the threshold even, setting the next character as a character being processed.</p><p id="p0190" num="0190">Furthermore, the aforementioned data structure generation method may further include: (E) upon detecting that, in the second area of the data block for the character being processed, the appearance sequential number for the next character of the character or the character string being processed in the input character string is held, that, in the third area of the data block, the code corresponding to the second character string is held as the data in the appearance sequential number, setting the second character string as a character string being processed.</p><p id="p0191" num="0191">In addition, the number of third areas may be limited to a predetermined number, and the data block may further include a fourth area for holding data representing an extended area for the third area. Thus, a case where the number of data blocks in a lower level is greater can be handled.</p><p id="p0192" num="0192">Moreover, the aforementioned data structure generation method may<!-- EPO <DP n="42"> --> further include: (F) generating, from plural data blocks generated for the input character string, correlation data to correlate, for each data block of data blocks in a second layer and subsequent layers of a tree structure represented by the plural data blocks in a specific state, a code for a parent data block of the data block with a character code corresponding to an added character for the data block, wherein the specific state is a state where first codes held in the first area and the third area of the plural data blocks are reassigned to second codes based on order of characters or character strings that correspond to the first codes.</p><p id="p0193" num="0193">According to this processing, a data structure that can be stored in a disk unit and is favorable for a compression processing and decompression processing (e.g. compression map in the embodiments) can be obtained.</p><p id="p0194" num="0194">Moreover, in the first correlation data and the second correlation data, a greatest code among codes of child data blocks of the data block may further be correlated. For example, it is possible to enhance the speed of the search processing included in the compression processing.</p><p id="p0195" num="0195">The aforementioned data structure generation method may further include: (G) setting, as a processing target, each of the first data blocks for the characters that will be used among the plural data blocks generated for the inputted character string in ascending order of the code of the first data blocks; (H) reading an appearance sequential number in the second area of the first data block of the processing target in order of the code of the character, and when a code is held, as data of the appearance sequential number, in the third area of the first data block of the processing target, adding a data block for a code held as data of the appearance sequential number to second data blocks to be processed after the first data blocks, and first storing correlation data to correlate a second code corresponding to a processing ranking of the first data block of the processing target with the code of the character in sequence; (I) setting each of second data blocks to be processed after the first data block in order of addition of the data blocks; (J) reading the appearance sequential number in the second area of a second data block of a processing target in order of the code of the character, and when a code is held as data of the appearance sequential number in the third area of the second data block of the processing target, adding a data block of a code held as data of the appearance sequential number to the second data block to be processed later, and second storing correlation data to correlate a second code corresponding to a processing ranking of the second data block of the processing target with the code of the character in sequence.</p><p id="p0196" num="0196">Furthermore, the aforementioned data structure generation method may<!-- EPO <DP n="43"> --> further include (K) storing, for each of the first data blocks for the characters that will be used among plural data blocks generated for the inputted character string, correlation data to correlate data representing a highest-level data block and a code of a character for the first data block in order of the code of the character. In such a case, in the first storing or the second storing, a second code when finally storing the aforementioned correlation data may be stored so as to correlate a code of a character for the first data block of the processing target or a code of a final character in the character string for the second data block of the processing target.</p><p id="p0197" num="0197">A data structure generation method relating to a second aspect of the embodiments includes: (A) first generating a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, a number of appearances or a code corresponding to a character string including the character or the character string and the second character when the number of appearances exceeds a threshold, for each character that will be used, and each character that appears a predetermined number of times or more next to a character or a character string in an input character string, for which the data block has already been generated; (B) second generating, from plural data blocks generated for the input character string, first correlation data to correlate data representing a root in a tree structure represented by the plural data blocks in a specific state or a greatest code among codes of child data blocks for each data block of data blocks in a first layer in the tree structure with a character code for each data block of the data blocks in the first layer in the tree structure and a layer number of the data block, and second correlation data to correlate, for each data block of data blocks in a second layer and subsequent layers of the tree structure, a code for a parent data block of the data block or a greatest code among codes of child data blocks of the data block with a character code corresponding to an added character for the data block and a layer number of the data block, wherein the specific state is a state where first codes held in the first area and the third area of the plural data blocks are reassigned to second codes based on order of characters or character strings that correspond to the first codes; (C) third generating first data including, for each data block in each layer of the second layer and the subsequent layers of the tree structure, a code for a character string corresponding to the second code held in the first area of the data block; and (D) fourth generating layer information to correlate,<!-- EPO <DP n="44"> --> for each layer of the second layer and the subsequent layers of the tree structure, a number of data blocks in the layer with a least second code of the second codes held in the first areas of the data blocks in the layer and an offset value of a position of a character or a character string corresponding to the least second code in the first data from a beginning of the first data.</p><p id="p0198" num="0198">By using the data generated by this processing, it is possible to enhance the processing speed of the compression processing and decompression processing.</p><p id="p0199" num="0199">A data structure of a phrase tree, which relates to a third aspect of the embodiments, includes, as data of each node in the phrase tree, a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, a number of appearances or a code corresponding to a character string including the character or the character string and the second character when the number of appearances exceeds a threshold. Thus, it is possible to largely reduce the memory capacity used for the data structure.</p><p id="p0200" num="0200">A data structure corresponding to a phrase tree, which relates to a fourth aspect of the embodiments, includes, for each node of the phrase tree, correlation data to correlate a code for a parent node of the node with a code for a character, which is represented by the node, wherein the correlation data is arranged in ascending order of a code assigned to the node. When such data is generated, it is possible to store the data structure in the disk unit as it is and use it later.</p><p id="p0201" num="0201">In the data structure relating to the fourth aspect of the embodiments, the aforementioned correlation data may further correlate a greatest code among codes of child nodes of the node. Thus, it is possible to enhance the processing efficiency of the compression processing.</p><p id="p0202" num="0202">Moreover, a data structure relating to the fifth aspect of the embodiments includes: first data corresponding to a phrase tree; second data for a character or a character string, which corresponds to each node in the phrase tree; and third data for layers of the phrase tree. The first data includes, for each node of the phrase tree, correlation data to correlate a code for a parent node of the node or a greatest code among codes of child nodes of the node with a code for a character, which is represented by the node, and a layer identifier of a layer to which the node belongs, wherein the correlation data is arranged in order of a code assigned to the node. Moreover, the second data includes, for each node in each layer of a second layer and subsequent layers<!-- EPO <DP n="45"> --> in the phrase tree, a code for a character or a character string, which corresponds to the node, in order of the code assigned to the node. Furthermore, the third data includes, for each layer of the second layer and the subsequent layers in the phrase tree, a number of nodes belonging to the layer, a least code among codes of nodes belonging to the layer, and an offset value of a position of a character or a character string corresponding to the least code in the second data from a beginning of the second data.</p><p id="p0203" num="0203">According to this data structure, it is possible to improve the processing speed of the compression processing and decompression processing.</p><p id="p0204" num="0204">Furthermore, a compression method relating to a sixth aspect of the embodiments includes: (A) first referencing, in a data structure corresponding to a phrase tree, which includes, for each node in the phrase tree, correlation data to correlate a code for a parent node of the node with a code for a character, which is represented by the node, in order of a code assigned to the node, correlation data of a node corresponding to a code for a first character included in an input character string; (B) searching the data structure for correlation data whose code for a parent node is a code assigned to a node corresponding to the referenced correlation data and whose code for a character is a code for a second character that appears next in the input character string; (C) upon detecting that the correlation data is found in the searching, second referencing the found correlation data; (D) upon detecting that the correlation data is not found in the searching, outputting a code for a node of the referenced correlation data, and third referencing correlation data of a node corresponding to the code for the second character; (E) performing the searching, the second referencing and the outputting and third referencing until a final character in the input character string while shifting the second character in the input character string in appearance order of the character in the input character string; and (F) outputting a code for a node of the referenced correlation data after the final character in the input character string was processed.</p><p id="p0205" num="0205">Thus, it is possible to carry out the compression processing using the aforementioned data structure.</p><p id="p0206" num="0206">The aforementioned searching in the sixth aspect of the embodiments may include: searching correlation data for nodes in a second layer and subsequent layers in the phase tree, upon detecting that the correlation data for any node in a first layer is referenced; and searching correlation data for codes after the code for the node of the referenced correlation data, upon detecting that correlation data for any node in the second layer and subsequent layers is referenced.</p><p id="p0207" num="0207">Moreover, the correlation data may further correlate a greatest code<!-- EPO <DP n="46"> --> among codes for child nodes of the node. In such a case, the aforementioned searching may include: upon detecting that correlation data for any node in a first layer in the phrase tree is referenced, searching a range from correlation data for a first node belonging to a second layer to correlation data for the greatest code in the referenced correlation data; and upon detecting that correlation data for any node in the second layer and subsequent layers is referenced, searching a range from correlation data immediately after correlation data for a greatest code in correlation data immediately before the referenced correlation data to correlation data for a greatest code in the referenced correlation data. Because the search range is narrowed, the speed-up of the compression processing is enabled.</p><p id="p0208" num="0208">Moreover, the correlation data may further correlate a layer number of a layer to which the node belongs. In such a case, the searching may include: searching correlation data whose layer number is a layer number next to a layer number in the referenced correlation data. Even when the aforementioned configuration is adopted, the search range is narrowed, so it is possible to enhance the speed of the compression processing.</p><p id="p0209" num="0209">A compression method relating to a seventh aspect of the embodiments includes: (A) first referencing, in first data included in a data structure having the first data corresponding to a phrase tree and second data concerning layers in the phrase tree, correlation data of a node corresponding to a code for a first character included in an input character string, wherein the first data includes, for each node in the phrase tree, correlation data to correlate a code for a parent node of the node with a code for a character, which is represented by the node, and a layer identifier of a layer to which the node belongs, in order of a code assigned to the node, and the second data includes, for each layer of the phrase tree, correlation data to correlate a number of nodes belonging to the layer with a least code among code for nodes belonging to the layer; (B) searching a range in the first data for correlation data whose code for a parent node is a code assigned to a node corresponding to the referenced correlation data and whose code for a character is a code for a second character that appears next in the input character string, wherein the range is identified in the second data based on the number of nodes in a certain layer immediately lower than a layer to which a node corresponding to the referenced correlation data belongs and the least code in the certain layer; (C) upon detecting that the correlation data is found in the searching, second referencing the found correlation data; (D) upon detecting that the correlation data is not found in the searching, outputting a code for a node of the referenced correlation data, and third referencing correlation data of a node corresponding to the<!-- EPO <DP n="47"> --> code for the second character; (E) performing the searching, the second referencing and the outputting and third referencing until a final character in the input character string while shifting the second character in the input character string in appearance order of the character in the input character string; and (F) outputting a code for a node of the referenced correlation data after the final character in the input character string was processed. Even by such a processing, it is possible to enhance the speed of the compression processing.</p><p id="p0210" num="0210">Furthermore, a decompression method relating to an eighth aspect of the embodiment includes (A) identifying, in a data structure corresponding to a phrase tree, which includes, for each node in the phrase tree, correlation data to correlate a code for a parent node of the node with a code for a character, which is represented by the node, in order of a code assigned to the node, correlation data ranked by a first code in inputted codes; (B) storing a code for a character, which is included in the identified correlation data, into a memory; (C) upon detecting that a code for a parent node in the identified correlation data represents a code for a node other than a root node in the phrase tree, referencing correlation data for the code for the parent node; (D) upon detecting that a code for a parent node in the identified correlation data represents a root node in the phrase tree, outputting a code or codes for a character or characters, which are stored in the memory, in reverse order; and (E) performing the storing, the referencing and the outputting in sequence for each code after the first code in the inputted codes.</p><p id="p0211" num="0211">Thus, it is possible to execute a decompression processing using the aforementioned data structure.</p><p id="p0212" num="0212">A compression method relating to a ninth aspect of the embodiments includes: (A) first referencing, in a data structure corresponding to a phrase tree, which includes, for each node in the phrase tree, correlation data to correlate a greatest code among codes for child nodes of the node with a code for a character, which is represented by the node, in order of a code assigned to the node, correlation data of a node corresponding to a code for a first character included in an input character string; (B) searching the data structure for correlation data whose code for a character, which is represented by a node, is a code for a second character that appears next in the input character string; (C) upon detecting that the correlation data is found in the searching, second referencing the found correlation data; (D) upon detecting that the correlation data is not found in the searching, outputting a code for a node of the referenced correlation data, and third referencing correlation data of a node corresponding to the code for the second character; (E) performing the searching, the second<!-- EPO <DP n="48"> --> referencing and the outputting and third referencing until a final character in the input character string while shifting the second character in the input character string in appearance order of the character in the input character string; and (F) outputting a code for a node of the referenced correlation data after the final character in the input character string was processed. Then, the aforementioned searching includes: upon detecting that correlation data for any node in a first layer in the phrase tree is referenced, searching a range from correlation data for a first node belonging to a second layer to correlation data for the greatest code in the referenced correlation data; and upon detecting that correlation data for any node in the second layer and subsequent layers is referenced, searching a range from correlation data immediately after correlation data for a greatest code in correlation data immediately before the referenced correlation data to correlation data for a greatest code in the referenced correlation data. Thus, because the search range is narrowed, it is possible to compress a character string at high-speed.</p><p id="p0213" num="0213">Moreover, a decompression method relating to a tenth aspect of the embodiments includes: (A) first identifying, in first data included in a data structure including the first data corresponding to a phrase tree, second data for a character or a character string, which corresponds to each node in the phrase tree, and third data concerning layers of the phrase tree, an entry ranked by a first code in inputted codes, wherein an entry for each node in the phrase tree is arranged in order of a code for each node, the entry includes a layer number of a layer to which the node belongs, the second data includes, for each node in each layer in the phrase tree, a character or a character string, which corresponds to the node, in order of the code for the node, and the third data includes, for each layer in the phrase tree, a least code among codes of nodes belonging to the layer, and a offset value of a position of a character or a character string, which corresponds to the least code, in the second data from a beginning of the second data; (B) second identifying the least code and the offset value in the third data based on the layer number included in the identified entry; (C) reading, from the second data, a character or a character string by an amount of the layer number included in the identified entry, from a position obtained by adding a value calculated by multiplying the layer number and a difference between a code for the identified entry and the identified least code to the identified offset value; and (D) performing, for each code after the second code after the first code in the inputted codes, identifying an entry ranked by the code, the second identifying and the reading.</p><p id="p0214" num="0214">According to this processing, it is possible to enhance the speed of the decompression processing.<!-- EPO <DP n="49"> --></p><p id="p0215" num="0215">In addition, a decompression method relating to a eleventh aspect of the embodiments includes (A) first identifying, in first data included in a data structure including the first data corresponding to a phrase tree, second data for a character or a character string, which corresponds to each node in the phrase tree, and third data concerning layers of the phrase tree, an entry ranked by a first code in inputted codes, wherein an entry for each node in the phrase tree is arranged in order of a code for each node, the entry includes a layer number of a layer to which the node belongs, the second data includes, for each node in each layer of a second layer and subsequent layers in the phrase tree, a character string, which corresponds to the node, in order of the code for the node, and the third data includes, for each layer of the second layer and subsequent layers in the phrase tree, a least code among codes of nodes belonging to the layer, and a offset value of a position of a character or a character string, which corresponds to the least code, in the second data from a beginning of the second data; (B) upon detecting that the identified entry is an entry in a first layer in the phrase tree, outputting a character corresponding to a code for the identified entry; (C) upon detecting that the identified entry is an entry in any layer of the second layer and the subsequent layers, second identifying, in the third data, the least code and the offset value based on a layer number included in the identified entry; (D) reading, from the second data, a character or a character string by an amount of the layer number included in the identified entry, from a position obtained by adding a value calculated by multiplying the layer number and a difference between a code for the identified entry and the identified least code to the identified offset value; and (E) performing, for each code after the second code after the first code in the inputted codes, identifying an entry ranked by the code, the outputting, the second identifying and the reading.</p><p id="p0216" num="0216">Even when the data amount of the data structure is reduced as described above, it is possible to enhance the speed of the decompression processing.</p><p id="p0217" num="0217">Incidentally, it is possible to create a program causing a computer to execute the aforementioned processing, and such a program is stored in a computer readable storage medium or storage device such as a flexible disk, CD-ROM, DVD-ROM, magneto-optic disk, a semiconductor memory, and hard disk. In addition, the intermediate processing result is temporarily stored in a storage device such as a main memory or the like.</p><p id="p0218" num="0218">All examples and conditional language recited herein are intended for pedagogical purposes to aid the reader in understanding the invention and the concepts contributed by the inventor to furthering the art, and are to be construed as being without limitation to such specifically recited examples and conditions,<!-- EPO <DP n="50"> --> nor does the organization of such examples in the specification relate to a showing of the superiority and inferiority of the invention. Although the embodiments of the present inventions have been described in detail, it should be understood that the various changes, substitutions, and alterations could be made hereto without departing from the spirit and scope of the invention.</p><heading id="h0005">[Appendix]</heading><p id="p0219" num="0219"><ol><li>(1) A computer-readable, non-transitory storage medium storing a program for causing a computer to execute a process, the process including:
<ul><li>first generating, for each character that will be used, a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, the number of appearances or a code corresponding to a character string including the character or the character string and the second character when the number of appearances exceeds a threshold;</li><li>upon detecting that, in a second area of a data block for a character or a character string being processed among plural characters included in an input character string, an appearance sequential number for a next character of the character or the character string being processed in the input character string is held, that, in a third area of the data block, the number of appearances is held as data in the appearance sequential number, and that the number of appearances after increment exceeds the threshold, storing a code corresponding to a second character string including the character or the character string being processed and the next character; and</li><li>generating a data block for the second character string, which has a same structure as the data block generated in the first generating.</li></ul></li><li>(2) The computer-readable, non-transitory storage medium as set forth in item (1), wherein the process further includes:
<ul><li>upon detecting that, in the second area of the data block for the character or the character string being processed, the appearance sequential number for the next character of the character or the character string being processed in the input character string is held, that, in the third area of the data block, the number of appearances is held as data in the appearance sequential number, and that the number of appearances after the increment does not exceeds the threshold even, setting the next character as a character being processed.</li></ul></li><li>(3) The computer-readable, non-transitory storage medium as set forth<!-- EPO <DP n="51"> --> in item (2), wherein the process further includes:
<ul><li>upon detecting that, in the second area of the data block for the character being processed, the appearance sequential number for the next character of the character or the character string being processed in the input character string is held, that, in the third area of the data block, the code corresponding to the second character string is held as the data in the appearance sequential number, setting the second character string as a character string being processed.</li></ul></li><li>(4) The computer-readable, non-transitory storage medium as set forth in item (1), wherein the number of third areas are limited to a predetermined number, and the data block further includes a fourth area for holding data representing an extended area for the third area.</li><li>(5) The computer-readable, non-transitory storage medium as set forth in item (1), wherein the process further includes:
<ul><li>generating, from plural data blocks generated for the input character string, correlation data to correlate, for each data block of data blocks in a second layer and subsequent layers of a tree structure represented by the plural data blocks in a specific state, a code for a parent data block of the data block with a character code corresponding to an added character for the data block, wherein the specific state is a state where first codes held in the first area and the third area of the plural data blocks are reassigned to second codes based on order of characters or character strings that correspond to the first codes.</li></ul></li><li>(6) The computer-readable, non-transitory storage medium as set forth in item (5), wherein, in the first correlation data and the second correlation data, a greatest code among codes of child data blocks of the data block is further correlated.</li><li>(7) A computer-readable, non-transitory storage medium storing a program for causing a computer to execute a process, the process including:
<ul><li>first generating a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, the number of appearances or a code corresponding to a character string including the character or the character string and the second character when the number of appearances exceeds a threshold, for each character that will be used, and each character that appears a predetermined number of times or more next to a character or a character string in an input character string, for which the data block has<!-- EPO <DP n="52"> --> already been generated;</li><li>second generating, from plural data blocks generated for the input character string, first correlation data to correlate data representing a root in a tree structure represented by the plural data blocks in a specific state or a greatest code among codes of child data blocks for each data block of data blocks in a first layer in the tree structure with a character code for each data block of the data blocks in the first layer in the tree structure and a layer number of the data block, and second correlation data to correlate, for each data block of data blocks in a second layer and subsequent layers of the tree structure, a code for a parent data block of the data block or a greatest code among codes of child data blocks of the data block with a character code corresponding to an added character for the data block and a layer number of the data block, wherein the specific state is a state where first codes held in the first area and the third area of the plural data blocks are reassigned to second codes based on order of characters or character strings that correspond to the first codes;</li><li>third generating first data including, for each data block in each layer of the second layer and the subsequent layers of the tree structure, a code for a character string corresponding to the second code held in the first area of the data block; and</li><li>fourth generating layer information to correlate, for each layer of the second layer and the subsequent layers of the tree structure, the number of data blocks in the layer with a least second code of the second codes held in the first areas of the data blocks in the layer and an offset value of a position of a character or a character string corresponding to the least second code in the first data from a beginning of the first data.</li></ul></li><li>(8) A computer-readable, non-transitory storage medium storing a data structure of a phrase tree, which is used by a computer, the data structure including, as data of each node in the phrase tree, a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, the number of appearances or a code corresponding to a character string including the character or the character string and the second character when the number of appearances exceeds a threshold.</li><li>(9) A computer-readable, non-transitory storage medium storing a data structure corresponding to a phrase tree, which is used by a computer, the data structure including for each node of the phrase tree, correlation data to correlate<!-- EPO <DP n="53"> --> a code for a parent node of the node with a code for a character, which is represented by the node, wherein the correlation data is arranged in ascending order of a code assigned to the node.</li><li>(10) The computer-readable, non-transitory storage medium as set forth in claim 9, wherein the correlation data further correlates a greatest code among codes of child nodes of the node.</li><li>(11) A computer-readable, non-transitory storage medium storing a data structure, which is used by a computer, the data structure including:
<ul><li>first data corresponding to a phrase tree;</li><li>second data for a character or a character string, which corresponds to each node in the phrase tree; and</li><li>third data for layers of the phrase tree,</li><li>wherein the first data includes, for each node of the phrase tree, correlation data to correlate a code for a parent node of the node or a greatest code among codes of child nodes of the node with a code for a character, which is represented by the node, and a layer identifier of a layer to which the node belongs, wherein the correlation data is arranged in order of a code assigned to the node,</li><li>the second data includes, for each node in each layer of a second layer and subsequent layers in the phrase tree, a code for a character or a character string, which corresponds to the node, in order of the code assigned to the node, and</li><li>the third data includes, for each layer of the second layer and the subsequent layers in the phrase tree, the number of nodes belonging to the layer, a least code among codes of nodes belonging to the layer, and an offset value of a position of a character or a character string corresponding to the least code in the second data from a beginning of the second data.</li></ul></li><li>(12) A computer-readable, non-transitory storage medium storing a compression program for causing a computer to execute a process, the process including:
<ul><li>first referencing, in a data structure corresponding to a phrase tree, which includes, for each node in the phrase tree, correlation data to correlate a code for a parent node of the node with a code for a character, which is represented by the node, in order of a code assigned to the node, correlation data of a node corresponding to a code for a first character included in an input character string;</li><li>searching the data structure for correlation data whose code for a parent node is a code assigned to a node corresponding to the referenced correlation data and whose code for a character is a code for a second character that appears<!-- EPO <DP n="54"> --> next in the input character string;</li><li>upon detecting that the correlation data is found in the searching, second referencing the found correlation data;</li><li>upon detecting that the correlation data is not found in the searching, outputting a code for a node of the referenced correlation data, and third referencing correlation data of a node corresponding to the code for the second character;</li><li>performing the searching, the second referencing and the outputting and third referencing until a final character in the input character string while shifting the second character in the input character string in appearance order of the character in the input character string; and</li><li>outputting a code for a node of the referenced correlation data after the final character in the input character string was processed.</li></ul></li><li>(13) The computer-readable, non-transitory storage medium as set forth in item (12), wherein the searching includes:
<ul><li>searching correlation data for nodes in a second layer and subsequent layers in the phase tree, upon detecting that the correlation data for any node in a first layer is referenced; and</li><li>searching correlation data for codes after the code for the node of the referenced correlation data, upon detecting that correlation data for any node in the second layer and subsequent layers is referenced.</li></ul></li><li>(14) The computer-readable, non-transitory storage medium as set forth in item (12), wherein the correlation data further correlates a greatest code among codes for child nodes of the node, and<br/>
wherein the searching includes:
<ul><li>upon detecting that correlation data for any node in a first layer in the phrase tree is referenced, searching a range from correlation data for a first node belonging to a second layer to correlation data for the greatest code in the referenced correlation data; and</li><li>upon detecting that correlation data for any node in the second layer and subsequent layers is referenced, searching a range from correlation data immediately after correlation data for a greatest code in correlation data immediately before the referenced correlation data to correlation data for a greatest code in the referenced correlation data.</li></ul></li><li>(15) The computer-readable, non-transitory storage medium as set forth in item (12), wherein the correlation data further correlates a layer number of a layer to which the node belongs, and<br/>
wherein the searching includes:
<ul><li>searching correlation data whose layer number is a layer number next<!-- EPO <DP n="55"> --> to a layer number in the referenced correlation data.</li></ul></li><li>(16) A computer-readable, non-transitory storage medium storing a compression program for causing a computer to execute a process, the process including:
<ul><li>first referencing, in first data included in a data structure having the first data corresponding to a phrase tree and second data concerning layers in the phrase tree, correlation data of a node corresponding to a code for a first character included in an input character string, wherein the first data includes, for each node in the phrase tree, correlation data to correlate a code for a parent node of the node with a code for a character, which is represented by the node, and a layer identifier of a layer to which the node belongs, in order of a code assigned to the node, and the second data includes, for each layer of the phrase tree, correlation data to correlate the number of nodes belonging to the layer with a least code among code for nodes belonging to the layer;</li><li>searching a range in the first data for correlation data whose code for a parent node is a code assigned to a node corresponding to the referenced correlation data and whose code for a character is a code for a second character that appears next in the input character string, wherein the range is identified in the second data based on the number of nodes in a certain layer immediately lower than a layer to which a node corresponding to the referenced correlation data belongs and the least code in the certain layer;</li><li>upon detecting that the correlation data is found in the searching, second referencing the found correlation data;</li><li>upon detecting that the correlation data is not found in the searching, outputting a code for a node of the referenced correlation data, and third referencing correlation data of a node corresponding to the code for the second character;</li><li>performing the searching, the second referencing and the outputting and third referencing until a final character in the input character string while shifting the second character in the input character string in appearance order of the character in the input character string; and</li><li>outputting a code for a node of the referenced correlation data after the final character in the input character string was processed.</li></ul></li><li>(17) A computer-readable, non-transitory storage medium storing a compression program for causing a computer to execute a process, the process including:
<ul><li>first referencing, in a data structure corresponding to a phrase tree, which includes, for each node in the phrase tree, correlation data to correlate<!-- EPO <DP n="56"> --> a greatest code among codes for child nodes of the node with a code for a character, which is represented by the node, in order of a code assigned to the node, correlation data of a node corresponding to a code for a first character included in an input character string;</li><li>searching the data structure for correlation data whose code for a character, which is represented by a node, is a code for a second character that appears next in the input character string;</li><li>upon detecting that the correlation data is found in the searching, second referencing the found correlation data;</li><li>upon detecting that the correlation data is not found in the searching, outputting a code for a node of the referenced correlation data, and third referencing correlation data of a node corresponding to the code for the second character;</li><li>performing the searching, the second referencing and the outputting and third referencing until a final character in the input character string while shifting the second character in the input character string in appearance order of the character in the input character string; and</li><li>outputting a code for a node of the referenced correlation data after the final character in the input character string was processed,</li><li>wherein the searching includes:
<ul><li>upon detecting that correlation data for any node in a first layer in the phrase tree is referenced, searching a range from correlation data for a first node belonging to a second layer to correlation data for the greatest code in the referenced correlation data; and</li><li>upon detecting that correlation data for any node in the second layer and subsequent layers is referenced, searching a range from correlation data immediately after correlation data for a greatest code in correlation data immediately before the referenced correlation data to correlation data for a greatest code in the referenced correlation data.</li></ul></li></ul></li><li>(18) A computer-readable, non-transitory storage medium storing a decompression program for causing a computer to execute a process, the process including:
<ul><li>identifying, in a data structure corresponding to a phrase tree, which includes, for each node in the phrase tree, correlation data to correlate a code for a parent node of the node with a code for a character, which is represented by the node, in order of a code assigned to the node, correlation data ranked by a first code in inputted codes;</li><li>storing a code for a character, which is included in the identified correlation data, into a memory;<!-- EPO <DP n="57"> --></li><li>upon detecting that a code for a parent node in the identified correlation data represents a code for a node other than a root node in the phrase tree, referencing correlation data for the code for the parent node;</li><li>upon detecting that a code for a parent node in the identified correlation data represents a root node in the phrase tree, outputting a code or codes for a character or characters, which are stored in the memory, in reverse order; and</li><li>performing the storing, the referencing and the outputting in sequence for each code after the first code in the inputted codes.</li></ul></li><li>(19) A computer-readable, non-transitory storage medium storing a decompression program for causing a computer to execute a process, the process including:
<ul><li>first identifying, in first data included in a data structure including the first data corresponding to a phrase tree, second data for a character or a character string, which corresponds to each node in the phrase tree, and third data concerning layers of the phrase tree, an entry ranked by a first code in inputted codes, wherein an entry for each node in the phrase tree is arranged in order of a code for each node, the entry includes a layer number of a layer to which the node belongs, the second data includes, for each node in each layer in the phrase tree, a character or a character string, which corresponds to the node, in order of the code for the node, and the third data includes, for each layer in the phrase tree, a least code among codes of nodes belonging to the layer, and a offset value of a position of a character or a character string, which corresponds to the least code, in the second data from a beginning of the second data;</li><li>second identifying the least code and the offset value in the third data based on the layer number included in the identified entry;</li><li>reading, from the second data, a character or a character string by an amount of the layer number included in the identified entry, from a position obtained by adding a value calculated by multiplying the layer number and a difference between a code for the identified entry and the identified least code to the identified offset value; and</li><li>performing, for each code after the second code after the first code in the inputted codes, identifying an entry ranked by the code, the second identifying and the reading.</li></ul></li><li>(20) A computer-readable, non-transitory storage medium storing a decompression program for causing a computer to execute a process, the process including:
<ul><li>first identifying, in first data included in a data structure including<!-- EPO <DP n="58"> --> the first data corresponding to a phrase tree, second data for a character or a character string, which corresponds to each node in the phrase tree, and third data concerning layers of the phrase tree, an entry ranked by a first code in inputted codes, wherein an entry for each node in the phrase tree is arranged in order of a code for each node, the entry includes a layer number of a layer to which the node belongs, the second data includes, for each node in each layer of a second layer and subsequent layers in the phrase tree, a character string, which corresponds to the node, in order of the code for the node, and the third data includes, for each layer of the second layer and subsequent layers in the phrase tree, a least code among codes of nodes belonging to the layer, and a offset value of a position of a character or a character string, which corresponds to the least code, in the second data from a beginning of the second data;</li><li>upon detecting that the identified entry is an entry in a first layer in the phrase tree, outputting a character corresponding to a code for the identified entry;</li><li>upon detecting that the identified entry is an entry in any layer of the second layer and the subsequent layers, second identifying, in the third data, the least code and the offset value based on a layer number included in the identified entry;</li><li>reading, from the second data, a character or a character string by an amount of the layer number included in the identified entry, from a position obtained by adding a value calculated by multiplying the layer number and a difference between a code for the identified entry and the identified least code to the identified offset value; and</li><li>performing, for each code after the second code after the first code in the inputted codes, identifying an entry ranked by the code, the outputting, the second identifying and the reading.</li></ul></li><li>(21) An information processing method, including:
<ul><li>first generating, by using a computer, for each character that will be used, a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, the number of appearances or a code corresponding to a character string including the character or the character string and the second character when the number of appearances exceeds a threshold;</li><li>upon detecting that, in a second area of a data block for a character or a character string being processed among plural characters included in an input character string, an appearance sequential number for a next character<!-- EPO <DP n="59"> --> of the character or the character string being processed in the input character string is held, that, in a third area of the data block, the number of appearances is held as data in the appearance sequential number, and that the number of appearances after increment exceeds the threshold, storing, by using the computer, a code corresponding to a second character string including the character or the character string being processed and the next character; and</li><li>generating, by using the computer, a data block for the second character string, which has a same structure as the data block generated in the first generating.</li></ul></li><li>(22) An information processing apparatus, including:
<ul><li>a memory; and</li><li>a processor configured to use the memory and execute a process, the process including:
<ul><li>first generating, for each character that will be used, a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, the number of appearances or a code corresponding to a character string including the character or the character string and the second character when the number of appearances exceeds a threshold;</li><li>upon detecting that, in a second area of a data block for a character or a character string being processed among plural characters included in an input character string, an appearance sequential number for a next character of the character or the character string being processed in the input character string is held, that, in a third area of the data block, the number of appearances is held as data in the appearance sequential number, and that the number of appearances after increment exceeds the threshold, storing a code corresponding to a second character string including the character or the character string being processed and the next character; and</li><li>generating a data block for the second character string, which has a same structure as the data block generated in the first generating.</li></ul></li></ul></li><li>(23) An information processing method, including:
<ul><li>first generating, by using a computer, a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential<!-- EPO <DP n="60"> --> number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, the number of appearances or a code corresponding to a character string including the character or the character string and the second character when the number of appearances exceeds a threshold, for each character that will be used, and each character that appears a predetermined number of times or more next to a character or a character string in an input character string, for which the data block has already been generated;</li><li>second generating, by using the computer, from plural data blocks generated for the input character string, first correlation data to correlate data representing a root in a tree structure represented by the plural data blocks in a specific state or a greatest code among codes of child data blocks for each data block of data blocks in a first layer in the tree structure with a character code for each data block of the data blocks in the first layer in the tree structure and a layer number of the data block, and second correlation data to correlate, for each data block of data blocks in a second layer and subsequent layers of the tree structure, a code for a parent data block of the data block or a greatest code among codes of child data blocks of the data block with a character code corresponding to an added character for the data block and a layer number of the data block, wherein the specific state is a state where first codes held in the first area and the third area of the plural data blocks are reassigned to second codes based on order of characters or character strings that correspond to the first codes;</li><li>third generating, by using the computer, first data including, for each data block in each layer of the second layer and the subsequent layers of the tree structure, a code for a character string corresponding to the second code held in the first area of the data block; and</li><li>fourth generating, by using the computer, layer information to correlate, for each layer of the second layer and the subsequent layers of the tree structure, the number of data blocks in the layer with a least second code of the second codes held in the first areas of the data blocks in the layer and an offset value of a position of a character or a character string corresponding to the least second code in the first data from a beginning of the first data.</li></ul></li><li>(24) An information processing apparatus, including:
<ul><li>a memory; and</li><li>a processor configured to use the memory and executed a process, the process including:
<ul><li>first generating a data block including a first area for holding a code for a character or a character string, a second area<!-- EPO <DP n="61"> --> for holding, for each character that will be used, an appearance sequential number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, the number of appearances or a code corresponding to a character string including the character or the character string and the second character when the number of appearances exceeds a threshold, for each character that will be used, and each character that appears a predetermined number of times or more next to a character or a character string in an input character string, for which the data block has already been generated;</li><li>second generating, from plural data blocks generated for the input character string, first correlation data to correlate data representing a root in a tree structure represented by the plural data blocks in a specific state or a greatest code among codes of child data blocks for each data block of data blocks in a first layer in the tree structure with a character code for each data block of the data blocks in the first layer in the tree structure and a layer number of the data block, and second correlation data to correlate, for each data block of data blocks in a second layer and subsequent layers of the tree structure, a code for a parent data block of the data block or a greatest code among codes of child data blocks of the data block with a character code corresponding to an added character for the data block and a layer number of the data block, wherein the specific state is a state where first codes held in the first area and the third area of the plurality of data blocks are reassigned to second codes based on order of characters or character strings that correspond to the first codes;</li><li>third generating first data including, for each data block in each layer of the second layer and the subsequent layers of the tree structure, a code for a character string corresponding to the second code held in the first area of the data block; and</li><li>fourth generating layer information to correlate, for each layer of the second layer and the subsequent layers of the tree structure, the number of data blocks in the layer with a least second code of the second codes held in the first areas of the data blocks in the layer and an offset value of a position of a character or a character string corresponding to the least second code in the first data from a beginning of the first data.</li></ul></li></ul><!-- EPO <DP n="62"> --></li><li>(25) A compression method, including:
<ul><li>first referencing, by using a computer, in a data structure corresponding to a phrase tree, which includes, for each node in the phrase tree, correlation data to correlate a code for a parent node of the node with a code for a character, which is represented by the node, in order of a code assigned to the node, correlation data of a node corresponding to a code for a first character included in an input character string;</li><li>searching, by using the computer, the data structure for correlation data whose code for a parent node is a code assigned to a node corresponding to the referenced correlation data and whose code for a character is a code for a second character that appears next in the input character string;</li><li>upon detecting that the correlation data is found in the searching, second referencing, by using the computer, the found correlation data;</li><li>upon detecting that the correlation data is not found in the searching, outputting, by using the computer, a code for a node of the referenced correlation data, and third referencing correlation data of a node corresponding to the code for the second character;</li><li>performing, by using the computer, the searching, the second referencing and the outputting and third referencing until a final character in the input character string while shifting the second character in the input character string in appearance order of the character in the input character string; and</li><li>outputting, by using the computer, a code for a node of the referenced correlation data after the final character in the input character string was processed.</li></ul></li><li>(26) An information processing apparatus, including:
<ul><li>a memory;</li><li>a processor configured to use the memory and execute a process, the process including:
<ul><li>first referencing, in a data structure corresponding to a phrase tree, which includes, for each node in the phrase tree, correlation data to correlate a code for a parent node of the node with a code for a character, which is represented by the node, in order of a code assigned to the node, correlation data of a node corresponding to a code for a first character included in an input character string;</li><li>searching the data structure for correlation data whose code for a parent node is a code assigned to a node corresponding to the referenced correlation data and whose code for a character is a code<!-- EPO <DP n="63"> --> for a second character that appears next in the input character string;</li><li>upon detecting that the correlation data is found in the searching, second referencing the found correlation data;</li><li>upon detecting that the correlation data is not found in the searching, outputting a code for a node of the referenced correlation data, and third referencing correlation data of a node corresponding to the code for the second character;</li><li>performing the searching, the second referencing and the outputting and third referencing until a final character in the input character string while shifting the second character in the input character string in appearance order of the character in the input character string; and</li><li>outputting a code for a node of the referenced correlation data after the final character in the input character string was processed.</li></ul></li></ul></li><li>(27) A compression method, including:
<ul><li>first referencing, by using a computer, in first data included in a data structure having the first data corresponding to a phrase tree and second data concerning layers in the phrase tree, correlation data of a node corresponding to a code for a first character included in an input character string, wherein the first data includes, for each node in the phrase tree, correlation data to correlate a code for a parent node of the node with a code for a character, which is represented by the node, and a layer identifier of a layer to which the node belongs, in order of a code assigned to the node, and the second data includes, for each layer of the phrase tree, correlation data to correlate the number of nodes belonging to the layer with a least code among code for nodes belonging to the layer;</li><li>searching, by using the computer, a range in the first data for correlation data whose code for a parent node is a code assigned to a node corresponding to the referenced correlation data and whose code for a character is a code for a second character that appears next in the input character string, wherein the range is identified in the second data based on the number of nodes in a certain layer immediately lower than a layer to which a node corresponding to the referenced correlation data belongs and the least code in the certain layer;</li><li>upon detecting that the correlation data is found in the searching, second referencing, by using the computer, the found correlation data;</li><li>upon detecting that the correlation data is not found in the searching, outputting, by using the computer, a code for a node of the referenced correlation<!-- EPO <DP n="64"> --> data, and third referencing correlation data of a node corresponding to the code for the second character;</li><li>performing, by using the computer, the searching, the second referencing and the outputting and third referencing until a final character in the input character string while shifting the second character in the input character string in appearance order of the character in the input character string; and</li><li>outputting, by using the computer, a code for a node of the referenced correlation data after the final character in the input character string was processed.</li></ul></li><li>(28) An information processing apparatus, including:
<ul><li>a memory;</li><li>a processor configured to use the memory and execute a process, the process including:
<ul><li>first referencing, in first data included in a data structure having the first data corresponding to a phrase tree and second data concerning layers in the phrase tree, correlation data of a node corresponding to a code for a first character included in an input character string, wherein the first data includes, for each node in the phrase tree, correlation data to correlate a code for a parent node of the node with a code for a character, which is represented by the node, and a layer identifier of a layer to which the node belongs, in order of a code assigned to the node, and the second data includes, for each layer of the phrase tree, correlation data to correlate the number of nodes belonging to the layer with a least code among code for nodes belonging to the layer;</li><li>searching a range in the first data for correlation data whose code for a parent node is a code assigned to a node corresponding to the referenced correlation data and whose code for a character is a code for a second character that appears next in the input character string, wherein the range is identified in the second data based on the number of nodes in a certain layer immediately lower than a layer to which a node corresponding to the referenced correlation data belongs and the least code in the certain layer;</li><li>upon detecting that the correlation data is found in the searching, second referencing the found correlation data;</li><li>upon detecting that the correlation data is not found in the searching, outputting a code for a node of the referenced correlation data, and third referencing correlation data of a node corresponding<!-- EPO <DP n="65"> --> to the code for the second character;</li><li>performing the searching, the second referencing and the outputting and third referencing until a final character in the input character string while shifting the second character in the input character string in appearance order of the character in the input character string; and</li><li>outputting a code for a node of the referenced correlation data after the final character in the input character string was processed.</li></ul></li></ul></li><li>(29) A compression method, including:
<ul><li>first referencing, by using a computer, in a data structure corresponding to a phrase tree, which includes, for each node in the phrase tree, correlation data to correlate a greatest code among codes for child nodes of the node with a code for a character, which is represented by the node, in order of a code assigned to the node, correlation data of a node corresponding to a code for a first character included in an input character string;</li><li>searching the data structure for correlation data whose code for a character, which is represented by a node, is a code for a second character that appears next in the input character string;</li><li>upon detecting that the correlation data is found in the searching, second referencing, by using the computer, the found correlation data;</li><li>upon detecting that the correlation data is not found in the searching, outputting, by using the computer, a code for a node of the referenced correlation data, and third referencing correlation data of a node corresponding to the code for the second character;</li><li>performing, by using the computer, the searching, the second referencing and the outputting and third referencing until a final character in the input character string while shifting the second character in the input character string in appearance order of the character in the input character string; and</li><li>outputting, by using the computer, a code for a node of the referenced correlation data after the final character in the input character string was processed,</li><li>wherein the searching comprises:
<ul><li>upon detecting that correlation data for any node in a first layer in the phrase tree is referenced, searching a range from correlation data for a first node belonging to a second layer to correlation data for the greatest code in the referenced correlation data; and</li><li>upon detecting that correlation data for any node in the second layer<!-- EPO <DP n="66"> --> and subsequent layers is referenced, searching a range from correlation data immediately after correlation data for a greatest code in correlation data immediately before the referenced correlation data to correlation data for a greatest code in the referenced correlation data.</li></ul></li></ul></li><li>(30) An information processing apparatus, including:
<ul><li>a memory; and</li><li>a processor configured to use the memory and execute a process, the process including:
<ul><li>first referencing, in a data structure corresponding to a phrase tree, which includes, for each node in the phrase tree, correlation data to correlate a greatest code among codes for child nodes of the node with a code for a character, which is represented by the node, in order of a code assigned to the node, correlation data of a node corresponding to a code for a first character included in an input character string;</li><li>searching the data structure for correlation data whose code for a character, which is represented by a node, is a code for a second character that appears next in the input character string;</li><li>upon detecting that the correlation data is found in the searching, second referencing the found correlation data;</li><li>upon detecting that the correlation data is not found in the searching, outputting a code for a node of the referenced correlation data, and third referencing correlation data of a node corresponding to the code for the second character;</li><li>performing the searching, the second referencing and the outputting and third referencing until a final character in the input character string while shifting the second character in the input character string in appearance order of the character in the input character string; and</li><li>outputting a code for a node of the referenced correlation data after the final character in the input character string was processed,</li></ul></li><li>wherein the searching includes:
<ul><li>upon detecting that correlation data for any node in a first layer in the phrase tree is referenced, searching a range from correlation data for a first node belonging to a second layer to correlation data for the greatest code in the referenced correlation data; and</li><li>upon detecting that correlation data for any node in the second layer and subsequent layers is referenced, searching a range from correlation data<!-- EPO <DP n="67"> --> immediately after correlation data for a greatest code in correlation data immediately before the referenced correlation data to correlation data for a greatest code in the referenced correlation data.</li></ul></li></ul></li><li>(31) A decompression method, including:
<ul><li>identifying, by using a computer, in a data structure corresponding to a phrase tree, which includes, for each node in the phrase tree, correlation data to correlate a code for a parent node of the node with a code for a character, which is represented by the node, in order of a code assigned to the node, correlation data ranked by a first code in inputted codes;</li><li>storing, by using the computer, a code fora character, which is included in the identified correlation data, into a memory;</li><li>upon detecting that a code for a parent node in the identified correlation data represents a code for a node other than a root node in the phrase tree, referencing, by using the computer, correlation data for the code for the parent node;</li><li>upon detecting that a code for a parent node in the identified correlation data represents a root node in the phrase tree, outputting, by using the computer, a code or codes for a character or characters, which are stored in the memory, in reverse order; and</li><li>performing, by using the computer, the storing, the referencing and the outputting in sequence for each code after the first code in the inputted codes.</li></ul></li><li>(32) An information processing apparatus, including:
<ul><li>a memory;</li><li>a processor configured to use the memory and execute a process, the process including:
<ul><li>identifying, in a data structure corresponding to a phrase tree, which includes, for each node in the phrase tree, correlation data to correlate a code for a parent node of the node with a code for a character, which is represented by the node, in order of a code assigned to the node, correlation data ranked by a first code in inputted codes;</li><li>storing a code for a character, which is included in the identified correlation data, into the memory;</li><li>upon detecting that a code for a parent node in the identified correlation data represents a code for a node other than a root node in the phrase tree, referencing correlation data for the code for the parent node;</li><li>upon detecting that a code for a parent node in the identified<!-- EPO <DP n="68"> --> correlation data represents a root node in the phrase tree, outputting a code or codes for a character or characters, which are stored in the memory, in reverse order; and</li><li>performing the storing, the referencing and the outputting in sequence for each code after the first code in the inputted codes.</li></ul></li></ul></li><li>(33) A decompression method, including:
<ul><li>first identifying, by using a computer, in first data included in a data structure including the first data corresponding to a phrase tree, second data for a character or a character string, which corresponds to each node in the phrase tree, and third data concerning layers of the phrase tree, an entry ranked by a first code in inputted codes, wherein an entry for each node in the phrase tree is arranged in order of a code for each node, the entry includes a layer number of a layer to which the node belongs, the second data includes, for each node in each layer in the phrase tree, a character or a character string, which corresponds to the node, in order of the code for the node, and the third data includes, for each layer in the phrase tree, a least code among codes of nodes belonging to the layer, and a offset value of a position of a character or a character string, which corresponds to the least code, in the second data from a beginning of the second data;</li><li>second identifying, by using the computer, the least code and the offset value in the third data based on the layer number included in the identified entry;</li><li>reading, by using the computer, from the second data, a character or a character string by an amount of the layer number included in the identified entry, from a position obtained by adding a value calculated by multiplying the layer number and a difference between a code for the identified entry and the identified least code to the identified offset value; and</li><li>performing, by using the computer, for each code after the second code after the first code in the inputted codes, identifying an entry ranked by the code, the second identifying and the reading.</li></ul></li><li>(34) An information processing apparatus, including:
<ul><li>a memory; and</li><li>a processor configured to use the memory and execute a process, the process including:
<ul><li>first identifying, in first data included in a data structure including the first data corresponding to a phrase tree, second data for a character or a character string, which corresponds to each node in the phrase tree, and third data concerning layers of the phrase tree, an entry ranked by a first code in inputted codes, wherein an<!-- EPO <DP n="69"> --> entry for each node in the phrase tree is arranged in order of a code for each node, the entry includes a layer number of a layer to which the node belongs, the second data includes, for each node in each layer in the phrase tree, a character or a character string, which corresponds to the node, in order of the code for the node, and the third data includes, for each layer in the phrase tree, a least code among codes of nodes belonging to the layer, and a offset value of a position of a character or a character string, which corresponds to the least code, in the second data from a beginning of the second data;</li><li>second identifying the least code and the offset value in the third data based on the layer number included in the identified entry;</li><li>reading, from the second data, a character or a character string by an amount of the layer number included in the identified entry, from a position obtained by adding a value calculated by multiplying the layer number and a difference between a code for the identified entry and the identified least code to the identified offset value; and</li><li>performing, for each code after the second code after the first code in the inputted codes, identifying an entry ranked by the code, the second identifying and the reading.</li></ul></li></ul></li><li>(35) A decompression method, including:
<ul><li>first identifying, by using a computer, in first data included in a data structure including the first data corresponding to a phrase tree, second data for a character or a character string, which corresponds to each node in the phrase tree, and third data concerning layers of the phrase tree, an entry ranked by a first code in inputted codes, wherein an entry for each node in the phrase tree is arranged in order of a code for each node, the entry includes a layer number of a layer to which the node belongs, the second data includes, for each node in each layer of a second layer and subsequent layers in the phrase tree, a character string, which corresponds to the node, in order of the code for the node, and the third data includes, for each layer of the second layer and subsequent layers in the phrase tree, a least code among codes of nodes belonging to the layer, and a offset value of a position of a character or a character string, which corresponds to the least code, in the second data from a beginning of the second data;</li><li>upon detecting that the identified entry is an entry in a first layer in the phrase tree, outputting, by using the computer, a character corresponding<!-- EPO <DP n="70"> --> to a code for the identified entry;</li><li>upon detecting that the identified entry is an entry in any layer of the second layer and the subsequent layers, second identifying, by using the computer, in the third data, the least code and the offset value based on a layer number included in the identified entry;</li><li>reading, by using the computer, from the second data, a character or a character string by an amount of the layer number included in the identified entry, from a position obtained by adding a value calculated by multiplying the layer number and a difference between a code for the identified entry and the identified least code to the identified offset value; and</li><li>performing, by using the computer, for each code after the second code after the first code in the inputted codes, identifying an entry ranked by the code, the outputting, the second identifying and the reading.</li></ul></li><li>(36) An information processing apparatus, including:
<ul><li>a memory; and</li><li>a processor configured to use the memory and execute a process, the process including:
<ul><li>first identifying, in first data included in a data structure including the first data corresponding to a phrase tree, second data for a character or a character string, which corresponds to each node in the phrase tree, and third data concerning layers of the phrase tree, an entry ranked by a first code in inputted codes, wherein an entry for each node in the phrase tree is arranged in order of a code for each node, the entry includes a layer number of a layer to which the node belongs, the second data includes, for each node in each layer of a second layer and subsequent layers in the phrase tree, a character string, which corresponds to the node, in order of the code for the node, and the third data includes, for each layer of the second layer and subsequent layers in the phrase tree, a least code among codes of nodes belonging to the layer, and a offset value of a position of a character or a character string, which corresponds to the least code, in the second data from a beginning of the second data;</li><li>upon detecting that the identified entry is an entry in a first layer in the phrase tree, outputting a character corresponding to a code for the identified entry;</li><li>upon detecting that the identified entry is an entry in any layer of the second layer and the subsequent layers, second identifying, in the third data, the least code and the offset value based on a<!-- EPO <DP n="71"> --> layer number included in the identified entry;</li><li>reading, from the second data, a character or a character string by an amount of the layer number included in the identified entry, from a position obtained by adding a value calculated by multiplying the layer number and a difference between a code for the identified entry and the identified least code to the identified offset value; and</li><li>performing, for each code after the second code after the first code in the inputted codes, identifying an entry ranked by the code, the outputting, the second identifying and the reading.</li></ul></li></ul></li></ol></p></description><claims mxw-id="PCLM56976259" lang="EN" load-source="patent-office"><!-- EPO <DP n="72"> --><claim id="c-en-0001" num="0001"><claim-text>An information processing method, comprising:
<claim-text>first generating, for each character that will be used, a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, the number of appearances or a code corresponding to a character string comprising the character or the character string and the second character when the number of appearances exceeds a threshold;</claim-text>
<claim-text>upon detecting that, in a second area of a data block for a character or a character string being processed among a plurality of characters included in an input character string, an appearance sequential number for a next character of the character or the character string being processed in the input character string is held, that, in a third area of the data block, the number of appearances is held as data in the appearance sequential number, and that the number of appearances after increment exceeds the threshold, storing a code corresponding to a second character string comprising the character or the character string being processed and the next character; and</claim-text>
<claim-text>generating a data block for the second character string, which has a same structure as the data block generated in the first generating.</claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The information processing method as set forth in claim 1, further comprising:
<claim-text>upon detecting that, in the second area of the data block for the character or the character string being processed, the appearance sequential number for the next character of the character or the character string being processed in the input character string is held, that, in the third area of the data block, the number of appearances is held as data in the appearance sequential number, and that the number of appearances after the increment does not exceeds the threshold even, setting the next character as a character being processed.</claim-text></claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The information processing method as set forth in claim 2, further comprising:
<claim-text>upon detecting that, in the second area of the data block for the character being processed, the appearance sequential number for the next character of the character or the character string being processed in the input character string is held, that, in the third area of the data block, the code corresponding to the second character string is held as the data in the appearance<!-- EPO <DP n="73"> --> sequential number, setting the second character string as a character string being processed.</claim-text></claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The information processing method as set forth in claim 1, wherein a number of third areas are limited to a predetermined number, and the data block further includes a fourth area for holding data representing an extended area for the third area.</claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The information processing method as set forth in claim 1, further comprising:
<claim-text>generating, from a plurality of data blocks generated for the input character string, correlation data to correlate, for each data block of data blocks in a second layer and subsequent layers of a tree structure represented by the plurality of data blocks in a specific state, a code for a parent data block of the data block with a character code corresponding to an added character for the data block, wherein the specific state is a state where first codes held in the first area and the third area of the plurality of data blocks are reassigned to second codes based on order of characters or character strings that correspond to the first codes.</claim-text></claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The information processing method as set forth in claim 5, wherein, in the first correlation data and the second correlation data, a greatest code among codes of child data blocks of the data block is further correlated.</claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>An information processing method, comprising:
<claim-text>first generating a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, a number of appearances or a code corresponding to a character string comprising the character or the character string and the second character when the number of appearances exceeds a threshold, for each character that will be used, and each character that appears a predetermined number of times or more next to a character or a character string in an input character string, for which the data block has already been generated;</claim-text>
<claim-text>second generating, from a plurality of data blocks generated for the input character string, first correlation data to correlate data representing a root in a tree structure represented by the plurality of data blocks in a specific state or a greatest code among codes of child data blocks for each<!-- EPO <DP n="74"> --> data block of data blocks in a first layer in the tree structure with a character code for each data block of the data blocks in the first layer in the tree structure and a layer number of the data block, and second correlation data to correlate, for each data block of data blocks in a second layer and subsequent layers of the tree structure, a code for a parent data block of the data block or a greatest code among codes of child data blocks of the data block with a character code corresponding to an added character for the data block and a layer number of the data block, wherein the specific state is a state where first codes held in the first area and the third area of the plurality of data blocks are reassigned to second codes based on order of characters or character strings that correspond to the first codes;</claim-text>
<claim-text>third generating first data including, for each data block in each layer of the second layer and the subsequent layers of the tree structure, a code for a character string corresponding to the second code held in the first area of the data block; and</claim-text>
<claim-text>fourth generating layer information to correlate, for each layer of the second layer and the subsequent layers of the tree structure, a number of data blocks in the layer with a least second code of the second codes held in the first areas of the data blocks in the layer and an offset value of a position of a character or a character string corresponding to the least second code in the first data from a beginning of the first data.</claim-text></claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>An information processing apparatus, comprising:
<claim-text>a memory; and</claim-text>
<claim-text>a processor configured to use the memory and execute a process, the process comprising:
<claim-text>first generating, for each character that will be used, a data block including a first area for holding a code for a character or a character string, a second area for holding, for each character that will be used, an appearance sequential number of a second character that appears next to the character or the character string, and a third area for holding, according to the appearance sequential number, a number of appearances or a code corresponding to a character string comprising the character or the character string and the second character when the number of appearances exceeds a threshold;</claim-text>
<claim-text>upon detecting that, in a second area of a data block for a character or a character string being processed among a plurality of characters included in an input character string, an appearance sequential number for a next character of the character or the character<!-- EPO <DP n="75"> --> string being processed in the input character string is held, that, in a third area of the data block, a number of appearances is held as data in the appearance sequential number, and that the number of appearances after increment exceeds the threshold, storing a code corresponding to a second character string comprising the character or the character string being processed and the next character; and</claim-text>
<claim-text>generating a data block for the second character string, which has a same structure as the data block generated in the first generating.</claim-text></claim-text></claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>A program for causing a computer to execute an information processing method as set forth in any one of claims 1 to 7.</claim-text></claim></claims><drawings mxw-id="PDW16667041" load-source="patent-office"><!-- EPO <DP n="76"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="154" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="77"> --><figure id="f0002" num="2,5"><img id="if0002" file="imgf0002.tif" wi="146" he="220" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="78"> --><figure id="f0003" num="3,4"><img id="if0003" file="imgf0003.tif" wi="125" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="79"> --><figure id="f0004" num="6,8"><img id="if0004" file="imgf0004.tif" wi="165" he="207" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="80"> --><figure id="f0005" num="7"><img id="if0005" file="imgf0005.tif" wi="165" he="207" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="81"> --><figure id="f0006" num="9"><img id="if0006" file="imgf0006.tif" wi="139" he="232" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="82"> --><figure id="f0007" num="10"><img id="if0007" file="imgf0007.tif" wi="96" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="83"> --><figure id="f0008" num="11"><img id="if0008" file="imgf0008.tif" wi="95" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="84"> --><figure id="f0009" num="12"><img id="if0009" file="imgf0009.tif" wi="127" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="85"> --><figure id="f0010" num="13,18"><img id="if0010" file="imgf0010.tif" wi="165" he="161" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="86"> --><figure id="f0011" num="14"><img id="if0011" file="imgf0011.tif" wi="156" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="87"> --><figure id="f0012" num="15"><img id="if0012" file="imgf0012.tif" wi="161" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="88"> --><figure id="f0013" num="16"><img id="if0013" file="imgf0013.tif" wi="161" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="89"> --><figure id="f0014" num="17"><img id="if0014" file="imgf0014.tif" wi="161" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="90"> --><figure id="f0015" num="19"><img id="if0015" file="imgf0015.tif" wi="136" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="91"> --><figure id="f0016" num="20A"><img id="if0016" file="imgf0016.tif" wi="149" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="92"> --><figure id="f0017" num="20B"><img id="if0017" file="imgf0017.tif" wi="149" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="93"> --><figure id="f0018" num="20C"><img id="if0018" file="imgf0018.tif" wi="149" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="94"> --><figure id="f0019" num="20D"><img id="if0019" file="imgf0019.tif" wi="151" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="95"> --><figure id="f0020" num="20E"><img id="if0020" file="imgf0020.tif" wi="139" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="96"> --><figure id="f0021" num="20F"><img id="if0021" file="imgf0021.tif" wi="119" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="97"> --><figure id="f0022" num="21"><img id="if0022" file="imgf0022.tif" wi="92" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="98"> --><figure id="f0023" num="22A"><img id="if0023" file="imgf0023.tif" wi="149" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="99"> --><figure id="f0024" num="22B"><img id="if0024" file="imgf0024.tif" wi="149" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="100"> --><figure id="f0025" num="23"><img id="if0025" file="imgf0025.tif" wi="150" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="101"> --><figure id="f0026" num="24A"><img id="if0026" file="imgf0026.tif" wi="150" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="102"> --><figure id="f0027" num="24B"><img id="if0027" file="imgf0027.tif" wi="150" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="103"> --><figure id="f0028" num="24C"><img id="if0028" file="imgf0028.tif" wi="134" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="104"> --><figure id="f0029" num="24D"><img id="if0029" file="imgf0029.tif" wi="146" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="105"> --><figure id="f0030" num="24E"><img id="if0030" file="imgf0030.tif" wi="146" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="106"> --><figure id="f0031" num="24F"><img id="if0031" file="imgf0031.tif" wi="146" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="107"> --><figure id="f0032" num="25"><img id="if0032" file="imgf0032.tif" wi="143" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="108"> --><figure id="f0033" num="26A"><img id="if0033" file="imgf0033.tif" wi="154" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="109"> --><figure id="f0034" num="26B"><img id="if0034" file="imgf0034.tif" wi="76" he="89" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="110"> --><figure id="f0035" num="27"><img id="if0035" file="imgf0035.tif" wi="165" he="179" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="111"> --><figure id="f0036" num="28,29"><img id="if0036" file="imgf0036.tif" wi="165" he="199" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="112"> --><figure id="f0037" num="30"><img id="if0037" file="imgf0037.tif" wi="138" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="113"> --><figure id="f0038" num="31"><img id="if0038" file="imgf0038.tif" wi="150" he="215" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="114"> --><figure id="f0039" num="32,33"><img id="if0039" file="imgf0039.tif" wi="135" he="109" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="115"> --><figure id="f0040" num="34,36"><img id="if0040" file="imgf0040.tif" wi="149" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="116"> --><figure id="f0041" num="35,37"><img id="if0041" file="imgf0041.tif" wi="156" he="145" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="117"> --><figure id="f0042" num="38,39"><img id="if0042" file="imgf0042.tif" wi="152" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="118"> --><figure id="f0043" num="40,42"><img id="if0043" file="imgf0043.tif" wi="142" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="119"> --><figure id="f0044" num="41,44,46"><img id="if0044" file="imgf0044.tif" wi="90" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="120"> --><figure id="f0045" num="43,45"><img id="if0045" file="imgf0045.tif" wi="139" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="121"> --><figure id="f0046" num="47"><img id="if0046" file="imgf0046.tif" wi="87" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="122"> --><figure id="f0047" num="48,50"><img id="if0047" file="imgf0047.tif" wi="101" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="123"> --><figure id="f0048" num="49"><img id="if0048" file="imgf0048.tif" wi="93" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="124"> --><figure id="f0049" num="51"><img id="if0049" file="imgf0049.tif" wi="109" he="175" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="125"> --><figure id="f0050" num="52"><img id="if0050" file="imgf0050.tif" wi="164" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="126"> --><figure id="f0051" num="53"><img id="if0051" file="imgf0051.tif" wi="164" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="127"> --><figure id="f0052" num="54,55"><img id="if0052" file="imgf0052.tif" wi="164" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="128"> --><figure id="f0053" num="56"><img id="if0053" file="imgf0053.tif" wi="165" he="178" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="129"> --><figure id="f0054" num="57"><img id="if0054" file="imgf0054.tif" wi="130" he="79" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="130"> --><figure id="f0055" num="58,59"><img id="if0055" file="imgf0055.tif" wi="113" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="131"> --><figure id="f0056" num="60,61"><img id="if0056" file="imgf0056.tif" wi="118" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="132"> --><figure id="f0057" num="62,63"><img id="if0057" file="imgf0057.tif" wi="107" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="133"> --><figure id="f0058" num="64,66"><img id="if0058" file="imgf0058.tif" wi="165" he="156" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="134"> --><figure id="f0059" num="65"><img id="if0059" file="imgf0059.tif" wi="52" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="135"> --><figure id="f0060" num="67,68"><img id="if0060" file="imgf0060.tif" wi="165" he="193" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="136"> --><figure id="f0061" num="69"><img id="if0061" file="imgf0061.tif" wi="157" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="137"> --><figure id="f0062" num="70"><img id="if0062" file="imgf0062.tif" wi="165" he="232" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="138"> --><figure id="f0063" num="71"><img id="if0063" file="imgf0063.tif" wi="162" he="145" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="139"> --><figure id="f0064" num="72"><img id="if0064" file="imgf0064.tif" wi="162" he="145" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="140"> --><figure id="f0065" num="73,74"><img id="if0065" file="imgf0065.tif" wi="162" he="167" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="141"> --><figure id="f0066" num="75"><img id="if0066" file="imgf0066.tif" wi="145" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="142"> --><figure id="f0067" num="76"><img id="if0067" file="imgf0067.tif" wi="165" he="227" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="143"> --><figure id="f0068" num="77"><img id="if0068" file="imgf0068.tif" wi="161" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="144"> --><figure id="f0069" num="78"><img id="if0069" file="imgf0069.tif" wi="160" he="210" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="145"> --><figure id="f0070" num="79"><img id="if0070" file="imgf0070.tif" wi="165" he="116" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="146"> --><figure id="f0071" num="80,81"><img id="if0071" file="imgf0071.tif" wi="165" he="170" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="147"> --><figure id="f0072" num="82,83"><img id="if0072" file="imgf0072.tif" wi="165" he="155" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="148"> --><figure id="f0073" num="84"><img id="if0073" file="imgf0073.tif" wi="152" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="149"> --><figure id="f0074" num="85"><img id="if0074" file="imgf0074.tif" wi="165" he="228" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="150"> --><figure id="f0075" num="86"><img id="if0075" file="imgf0075.tif" wi="155" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="151"> --><figure id="f0076" num="87"><img id="if0076" file="imgf0076.tif" wi="162" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="152"> --><figure id="f0077" num="88"><img id="if0077" file="imgf0077.tif" wi="165" he="146" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="153"> --><figure id="f0078" num="89"><img id="if0078" file="imgf0078.tif" wi="165" he="97" img-content="drawing" img-format="tif"/></figure></drawings><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
