<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2682878-A1" country="EP" doc-number="2682878" kind="A1" date="20140108" family-id="46545627" file-reference-id="317082" date-produced="20180824" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146584874" ucid="EP-2682878-A1"><document-id><country>EP</country><doc-number>2682878</doc-number><kind>A1</kind><date>20140108</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-12174908-A" is-representative="YES"><document-id mxw-id="PAPP154847066" load-source="docdb" format="epo"><country>EP</country><doc-number>12174908</doc-number><kind>A</kind><date>20120704</date><lang>EN</lang></document-id><document-id mxw-id="PAPP200340168" load-source="docdb" format="original"><country>EP</country><doc-number>12174908.9</doc-number><date>20120704</date></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140557969" ucid="EP-12174908-A" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>12174908</doc-number><kind>A</kind><date>20120704</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1989318289" load-source="docdb">G06F  17/30        20060101AFI20130605BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1915461457" load-source="docdb" scheme="CPC">G06F  17/30498     20130101 LI20160727BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1915461645" load-source="docdb" scheme="CPC">G06F  17/30321     20130101 FI20160727BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1915461872" load-source="docdb" scheme="CPC">G06F  17/30501     20130101 LI20160727BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1955212926" load-source="docdb" scheme="CPC">G06F  17/30424     20130101 LI20160325BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132359255" lang="DE" load-source="patent-office">Verfahren zum Verarbeiten von relationalen Datenbankabfragen und entsprechendes Datenbanksystem</invention-title><invention-title mxw-id="PT132359256" lang="EN" load-source="patent-office">Method of processing relational queries in a database system and corresponding database system</invention-title><invention-title mxw-id="PT132359257" lang="FR" load-source="patent-office">Procédé de traitement de requêtes relationnelles dans un système de base de données et système de base de données correspondante</invention-title><citations><patent-citations><patcit mxw-id="PCIT242942512" load-source="docdb" ucid="US-6167399-A"><document-id format="epo"><country>US</country><doc-number>6167399</doc-number><kind>A</kind><date>20001226</date></document-id><sources><source name="SEA" category="I" created-by-npl="N"/></sources></patcit></patent-citations><non-patent-citations><nplcit><text>BLAKELEY J A ET AL: "Join index, materialized view, and hybrid-hash join: a performance analysis", PROCEEDINGS OF THE INTERNATIONAL CONFERENCE ON DATA ENGINEERING. LOS ANGELES, FEB. 5 - 9, 1990; [PROCEEDINGS OF THE INTERNATIONAL CONFERENCE ON DATA ENGINEERING], LOS ALAMITOS, IEEE. COMP. SOC. PRESS, US, vol. CONF. 6, 5 February 1990 (1990-02-05), pages 256 - 263, XP010018213, ISBN: 978-0-8186-2025-6, DOI: 10.1109/ICDE.1990.113476</text><sources><source mxw-id="PNPL62802439" load-source="docdb" name="SEA" category="I"/></sources></nplcit><nplcit><text>None</text><sources><source mxw-id="PNPL45210599" load-source="docdb" name="APP"/></sources></nplcit><nplcit><text>O'NEIL P ET AL: "Multi-table joins through bitmapped join indices", SIGMOD RECORD, ACM, NEW YORK, NY, US, vol. 24, no. 3, 1 September 1995 (1995-09-01), pages 8 - 11, XP002141931, ISSN: 0163-5808, DOI: 10.1145/211990.212001</text><sources><source mxw-id="PNPL62802440" load-source="docdb" name="SEA" category="I"/></sources></nplcit><nplcit><text>VALDURIEZ PATRICK: "Join Indices", ACM, 2 PENN PLAZA, SUITE 701 - NEW YORK USA, June 1987 (1987-06-01), XP040097447</text><sources><source mxw-id="PNPL62802441" load-source="docdb" name="SEA" category="XI"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR919542465" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>SOFTWARE AG</last-name><address><country>DE</country></address></addressbook></applicant><applicant mxw-id="PPAR919531239" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>SOFTWARE AG</last-name></addressbook></applicant><applicant mxw-id="PPAR919011770" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Software AG</last-name><iid>100224181</iid><address><street>Uhlandstrasse 12</street><city>64297 Darmstadt</city><country>DE</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR919538781" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>POPPITZ MICHAEL</last-name><address><country>DE</country></address></addressbook></inventor><inventor mxw-id="PPAR919514965" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>Poppitz, Michael</last-name></addressbook></inventor><inventor mxw-id="PPAR919009108" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Poppitz, Michael</last-name><address><street>Herbergsgasse 4</street><city>66111 Saarbrücken</city><country>DE</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR919007380" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Wegner, Hans</last-name><iid>101259466</iid><address><street>Bardehle Pagenberg Partnerschaft mbB Patentanwälte, Rechtsanwälte Prinzregentenplatz 7</street><city>81675 München</city><country>DE</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS549739375" load-source="docdb">AL</country><country mxw-id="DS549740029" load-source="docdb">AT</country><country mxw-id="DS549739377" load-source="docdb">BE</country><country mxw-id="DS549813785" load-source="docdb">BG</country><country mxw-id="DS549741117" load-source="docdb">CH</country><country mxw-id="DS549812593" load-source="docdb">CY</country><country mxw-id="DS549740030" load-source="docdb">CZ</country><country mxw-id="DS549739378" load-source="docdb">DE</country><country mxw-id="DS549812598" load-source="docdb">DK</country><country mxw-id="DS549812599" load-source="docdb">EE</country><country mxw-id="DS549907398" load-source="docdb">ES</country><country mxw-id="DS549813814" load-source="docdb">FI</country><country mxw-id="DS549741118" load-source="docdb">FR</country><country mxw-id="DS549739379" load-source="docdb">GB</country><country mxw-id="DS549812600" load-source="docdb">GR</country><country mxw-id="DS549739380" load-source="docdb">HR</country><country mxw-id="DS549740031" load-source="docdb">HU</country><country mxw-id="DS549907399" load-source="docdb">IE</country><country mxw-id="DS549812601" load-source="docdb">IS</country><country mxw-id="DS549813815" load-source="docdb">IT</country><country mxw-id="DS549812606" load-source="docdb">LI</country><country mxw-id="DS549813816" load-source="docdb">LT</country><country mxw-id="DS549741930" load-source="docdb">LU</country><country mxw-id="DS549813817" load-source="docdb">LV</country><country mxw-id="DS549813826" load-source="docdb">MC</country><country mxw-id="DS549741931" load-source="docdb">MK</country><country mxw-id="DS549741932" load-source="docdb">MT</country><country mxw-id="DS549813827" load-source="docdb">NL</country><country mxw-id="DS549741119" load-source="docdb">NO</country><country mxw-id="DS549813828" load-source="docdb">PL</country><country mxw-id="DS549907400" load-source="docdb">PT</country><country mxw-id="DS549739382" load-source="docdb">RO</country><country mxw-id="DS549907401" load-source="docdb">RS</country><country mxw-id="DS549813829" load-source="docdb">SE</country><country mxw-id="DS549738358" load-source="docdb">SI</country><country mxw-id="DS549741120" load-source="docdb">SK</country><country mxw-id="DS549741121" load-source="docdb">SM</country><country mxw-id="DS549812607" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA128673046" lang="EN" load-source="patent-office"><p id="pa01" num="0001">The present invention concerns a computer-implemented method of processing a relational query (20) in a database system (1), wherein the relational query (20) addresses a plurality of data objects linked by one or more relationships, wherein the method comprises the following steps:<br/>
a. for each data object addressed by the relational query (20), computing (210) at least one result in accordance with at least one index structure (45), the index structure (45) being stored in a storage device (40) of the database system (1); and<br/>
b. merging (240, 250) the results computed in step a. in accordance with at least one translation data structure (55) to produce a final result of the relational query (20), the translation data structure (55) representing the one or more relationships between the data objects and being stored in a memory (50) of the database system (1).
<img id="iaf01" file="imgaf001.tif" wi="78" he="95" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA128737191" lang="EN" source="EPO" load-source="docdb"><p>The present invention concerns a computer-implemented method of processing a relational query (20) in a database system (1), wherein the relational query (20) addresses a plurality of data objects linked by one or more relationships, wherein the method comprises the following steps: 
a. for each data object addressed by the relational query (20), computing (210) at least one result in accordance with at least one index structure (45), the index structure (45) being stored in a storage device (40) of the database system (1); and 
b. merging (240, 250) the results computed in step a. in accordance with at least one translation data structure (55) to produce a final result of the relational query (20), the translation data structure (55) representing the one or more relationships between the data objects and being stored in a memory (50) of the database system (1).</p></abstract><description mxw-id="PDES63959034" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><b><u>1. Technical Field</u></b></heading><p id="p0001" num="0001">The present invention relates to a method of processing relational queries in a database system, as well as to a corresponding database system.</p><heading id="h0002"><b><u>2. The Prior Art</u></b></heading><p id="p0002" num="0002">Nowadays, data-intensive computer systems typically store their data in databases and database systems are provided which allow storing the data into the database, as well as accessing the stored data.</p><p id="p0003" num="0003">Accessing data of a database is typically performed by formulating queries in a query language and having the database system process the query. Since complex databases typically store excessive amounts of data, sometimes even millions of individual data objects, many approaches have been developed for increasing the performance of the query processing to allow users to retrieve the searched data as fast as possible.</p><p id="p0004" num="0004">The most common conventional database systems are so-called relational database management systems (RDBMS). A common language for interacting with data stored in such RDMBS is the Structured Query Language (SQL) commonly known in the art. The theoretical concept of a relational database is based on a set of mathematical terms, wherein the most important is called relation. A relation is a mathematical description of a table and a relational database may be considered as a set of tables. Each row (also referred to as tuple) of a table comprises a data record (hereinafter also referred to as "data object" or "database object"), wherein the record comprises one<!-- EPO <DP n="2"> --> or more attributes. The attributes correspond to the columns of the table. <figref idrefs="f0006">Fig. 7</figref> shows a simple example of a relational database having a table "Book". As can be seen, the table "Book" stores in this example five data objects (rows) representing five books. Each book has an ID, a name and a genre code, which are stored in the columns of the table.</p><p id="p0005" num="0005">In order to retrieve data from such a relational database, queries are typically formulated in a declarative manner. This means that the query does not specify the steps the RDBMS is supposed to perform in order to retrieve the desired result. Rather, the query only specifies, in the form of a pattern, the properties of the desired result by means of one or more search conditions. A simple example of a query would thus be <i>"Give me all books which have the term 'history' in their name".</i> As known in the art, more complex queries can be formulated on multiple attributes, which may be combined using logical operators.</p><p id="p0006" num="0006">Besides simple queries involving search conditions directed only to one type of object (i.e. to one single database table), more complex queries oftentimes involve multiple objects having relations defined therebetween. As an example, consider the query <i>"Give me all books which have the term 'history' in their name and the genre 'Science' ".</i> As can be seen, this query involves two separate tables of the exemplary database of <figref idrefs="f0006">Fig. 7</figref> (namely the tables "Book" and "Genre"), wherein each data object in "Book" is related to one or more data objects in "Genre" and vice versa. Such queries involving multiple objects and the relations therebetween are hereinafter referred to as "relational queries" (cf. also http://encyclopedia2.thefreedictionary.com/relational+query for a more comprehensive definition of the term "relational query").</p><p id="p0007" num="0007">Large databases are typically stored on hard drives or other suitable permanent storage devices. As a result, traditional relational databases typically suffer from the relatively slow disk storage access for processing queries to the database. One main reason for the hard drive access being so slow is the random access to the tables. In other words, entries of the<!-- EPO <DP n="3"> --> tables are typically not accessed in sequence, but rather in random order (depending on the information searched), which requires many movements of the head of the hard disk.</p><p id="p0008" num="0008">Some traditional relational databases try to improve performance by reading entire blocks from disk to a cache memory, hoping other entries in the block might be needed later on. However, because following relations in a query typically results in random access to the database tables, this strategy performs poorly on larger databases with many small rows.</p><p id="p0009" num="0009">Other commercially available products employ so-called No-SQL databases. Most vendors of such databases do not offer any support for relational queries at all. Others try to resolve relationships by creating special indexes for each relational query which can possibly be performed. This approach, however, is limited to scenarios with a small and fixed set of conceivable relational queries and is hardly practical in more complex scenarios.</p><p id="p0010" num="0010">Lastly, also in-memory databases exist, which can quickly process relationships because all data is loaded in a fast memory, such as a cache or random access memory (RAM). However, this approach requires large quantities of memory, which greatly limits the scalability do to the hardware limitations in modern computer systems.</p><p id="p0011" num="0011">Relational database systems (RDBMS) can be considered to be the most prominent architecture used nowadays. While RDBMS are generally able to perform complex relational queries, there are scenarios in which they deliver poor results. In particular, performance breaks down as soon as the system has to perform random disk access(es). This is typically the case when the following criteria are met: data involved in querying does not fit into memory (e.g. RAM), queries operate on many rows, and/or queries use joins across multiple tables.<!-- EPO <DP n="4"> --></p><p id="p0012" num="0012">Under these conditions, the person skilled in the art will appreciate that a RDBMS will have to resolve many foreign keys using row lookups in a non-cached table, causing a large number of random disk accesses. On mechanical hard drives, this will cause slow head movements, resulting in long query execution times and poor disk access efficiency.</p><p id="p0013" num="0013">It is therefore the technical problem underlying the present invention to provide an approach for processing queries (in particular relational queries which take into account relationships between the data objects to be retrieved) which is more efficient and allows a faster retrieval of the searched data, thereby at least partly overcoming the above explained disadvantages of the prior art.</p><heading id="h0003"><b><u>3. Summary of the Invention</u></b></heading><p id="p0014" num="0014">This problem is according to one aspect of the invention solved by a computer-implemented method of processing a relational query. In the embodiment of claim 1, the relational query addresses a plurality of data objects linked by one or more relationships and the method comprises the following steps:
<ol><li>a. for each data object addressed by the relational query, computing at least one result in accordance with at least one index structure, the index structure being stored in a storage device of the database system; and</li><li>b. merging the results computed in step a. in accordance with at least one translation data structure to produce a final result of the relational query, the translation data structure representing the one or more relationships between the data objects and being stored in a memory of the database system.</li></ol></p><p id="p0015" num="0015">Accordingly, the embodiment defines a particularly efficient approach for processing relational queries, which is on the one hand based on<!-- EPO <DP n="5"> --> traditional indexing technologies. Such index technologies are used in the invention for computing the results of the individual data objects addressed by the relational query. Preferably, the at least one index structure of the invention is an inverted index, which is used to store attributes of data objects and allows a quick retrieval of all objects which have specific values in specific attributes. Such inverted indexes are known in the prior art (cf. e.g. Wikipedia "Inverted index" at http://en.wikipedia.org/wiki/Inverted_index). Furthermore, each data object stored in the database preferably comprises a unique identifier (ID), which is returned as result of the index lookup operation.</p><p id="p0016" num="0016">The above-described indexing technologies allow performing search queries with conditions on multiple attributes of a single data object which can be combined using logical operators. These queries are typically resolved by splitting them up into individual index lookups. Object identifiers returned by the individual lookups are then merged, as indicated by the logical operators in the query to get the final result (e.g. if the query connects two search conditions with a logical "AND", the merged result is the intersecting set of the partial results of the index lookups, a logical "OR" corresponds to union set of the partial results, and so on).</p><p id="p0017" num="0017">As the skilled person will appreciate, these queries can be executed with good performance, since indexes can quickly produce all object identifiers for a given value and the merging of object identifiers according to the query structure requires no additional disk access. However, these search queries are limited to combinations of attributes of one single object. They especially cannot handle scenarios where a plurality of objects which have relationships between them are involved and wherein these relationships have to be considered in the query, i.e. they cannot handle relational queries, as concerned by the present invention.<!-- EPO <DP n="6"> --></p><p id="p0018" num="0018">The mechanism proposed by the present invention solves this problem by combining, i.e. merging, multiple search queries as described above by defining relational conditions between them, thus allowing to perform sub-graph searches heeding the relationships as well as object attributes.</p><p id="p0019" num="0019">This is achieved by introducing a translation mechanism which can translate object identifiers across relations. This translation mechanism is used in the merging step of the invention, where the computed results corresponding to the individual data objects are combined/merged in accordance with special translation data structures, which represent the relationships between the data objects stored in the database. As the person skilled in the art in database programming will appreciate, the term "computing at least one result" also encompasses the "empty set" as a result, since a database query might well produce no results for any query node or even the entire query.</p><p id="p0020" num="0020">Translation allows converting results from query conditions across relationships defined in the query, making them easily comparable and therefore searchable. Importantly, the translation data structures are kept in memory of the database system and only describe which object is related to which other object. Preferably, the translation data structures utilize primitive and compact identifiers and space efficient lookup techniques, such as binary search. Because no object data is kept in memory (note that the corresponding index structures are stored in a storage device of the database system), the translation structure is much smaller than the on-disk index in many scenarios.</p><p id="p0021" num="0021">In summary, the present invention advantageously combines the advantages of storage devices (e.g. a hard disk of the underlying computer system, or any other type of permanent storage) and memory (i.e. fast memory, such as a random access memory (RAM) of the underlying computer system) while at the same time avoiding the disadvantages of both types of storage/memory. As the person skilled in the art of computer science will appreciate, the advantage of storage<!-- EPO <DP n="7"> --> devices is its huge capacity and decent data streaming performance. Its disadvantage is its slow seek time, delivering poor random I/O performance. Memory, on the other hand, has limited capacity, but outstanding random I/O performance. In the present invention, object data only exists on the storage device (by means of the index structures) and all random access is moved to the memory at the same time.</p><p id="p0022" num="0022">Accordingly, during processing the relational query, data on disk is only accessed in its indexed form for reading results for individual query conditions. This means that disk data access cost is almost linear to the number of query conditions, just like in conventional index search algorithms (good disk data streaming performance greatly reduces the impact of larger data graphs where each index entry has more result object identifiers stored). On the other hand, the handling of the random access pattern caused by following relationships is completely left to the translation mechanism. This mechanism is isolated from any object data and solely performs object ID translations according to the translation data held in memory.</p><p id="p0023" num="0023">In one aspect of the present invention, the method comprises the further step of representing the relational query as a query tree, wherein each data object addressed by the relational query is represented as a node of the query tree and wherein each relationship between the data objects is represented by an edge in the query tree. Representing the relational query in a tree format is a prerequisite of particularly advantageous aspects for processing the query, as will be explained further below. Most relational queries can be directly represented as query trees. However, if the relational query corresponds to a more generic connected graph, the method preferably produces a spanning tree based on the connected graph, as will be explained in the detailed description further below.</p><p id="p0024" num="0024">Preferably, the method further comprises the step of performing the above-described computing step and/or the merging step as part of a first pass of processing the query tree, wherein the first pass is<!-- EPO <DP n="8"> --> performed recursively for each node of the query tree. During the first processing pass, the merging step preferably comprises merging the results of the current node with the results of the child node(s) of the current node. Most preferably, the method also comprises performing a second merging step as part of a second pass of processing the query tree, wherein the second pass is performed recursively for each node of the query tree, and wherein the second merging step preferably comprises merging the results of the current node with the results of the parent node of the current node. Accordingly, in a preferred embodiment of the invention, the query tree is traversed two times (i.e. in a first and a second pass), wherein the partial results of the individual data objects are first merged in the direction of the parent node and then in the direction of the respective child nodes. Moreover, the first pass and optionally the second pass of processing the query tree may traverse the query tree starting at the root node in a depth-first manner. This approach guarantees that at first, valid results are obtained for parent nodes of leaf nodes and afterwards for their parent and so forth all the way to the root node during the first pass. Determining the result for a parent based on its children delivers a result which is only missing the relation from the parent of the parent. Once the root node is reached, however, the result for it is complete and correct, because the root node has no parent of its own. The second pass will simply apply the missing parent relation to the children going downward from the root node. It is noted that the second pass may be performed equally well in a depth-first manner or a breadth-first manner.</p><p id="p0025" num="0025">Alternatively or additionally, for two given data objects which are addressed by the relational query and which are linked by a relationship, the translation data structure may comprise a mapping of an identifier of the first data object to an identifier of the second data object in accordance with the relationship. If the relationship is represented as a data object in a database of the database system, the translation data structure may comprise a mapping of an identifier of the first data object to an identifier of the second data object and to an identifier of the<!-- EPO <DP n="9"> --> relationship. As already mentioned above, the provided translation data structures, by means of mapping the identifiers (IDs) of the respective data objects and/or relationships, is particularly compact, yet efficient.</p><p id="p0026" num="0026">The present invention also concerns a computer program comprising instructions for implementing any of the above-described methods. Lastly, also a database system is provided, the database system comprising an interface, adapted for receiving relational queries which address a plurality of data objects linked by one or more relationships; a storage device, adapted for storing at least one index structure; a memory, adapted for storing at least one translation data structure, the translation data structure representing the one or more relationships between the data objects; and a control logic, adapted for, for each data object addressed by the relational query, computing at least one result in accordance with the at least one index structure, and for merging the computed results in accordance with the at least one translation data structure to produce a final result of the relational query.</p><p id="p0027" num="0027">Further advantageous modifications of embodiments of the database system of the invention are defined in further dependent claims.</p><heading id="h0004"><b><u>4. Short Description of the Drawings</u></b></heading><p id="p0028" num="0028">In the following detailed description, presently preferred embodiments of the invention are further described with reference to the following figures:
<dl id="dl0001"><dt>Fig. 1:</dt><dd>A flow chart illustrating a query processing method in accordance with an embodiment of the invention;</dd><dt>Fig. 2:</dt><dd>A flow chart illustrating the first pass comprised in a query processing method in accordance with an embodiment of the invention;<!-- EPO <DP n="10"> --></dd><dt>Fig. 3:</dt><dd>A flow chart illustrating the second pass comprised in a query processing method in accordance with an embodiment of the invention;</dd><dt>Figs. 4a-c:</dt><dd>Schematic representations of types of queries which can be processed by embodiments of the invention;</dd><dt>Fig. 5:</dt><dd>A schematic view of the data flow involved in the merge step in accordance with an embodiment of the invention;</dd><dt>Figs. 6a-b:</dt><dd>Schematic illustrations of translation data structures used in an embodiment of the invention;</dd><dt>Fig. 7:</dt><dd>A schematic view of data stored in an exemplary database;</dd><dt>Fig. 8:</dt><dd>A query tree representing an exemplary relational query;</dd><dt>Fig. 9:</dt><dd>Translation tables generated for the exemplary database of <figref idrefs="f0006">Fig. 7</figref> in accordance with an embodiment of the invention;</dd><dt>Figs. 10a-c:</dt><dd>Schematic views of a result tree generated when the exemplary query tree of <figref idrefs="f0006">Fig. 8</figref> is processed in the database of <figref idrefs="f0006">Fig. 7</figref> in accordance with an embodiment of the invention;</dd><dt>Figs. 11a-b:</dt><dd>Schematic views of intermediate results generated when the exemplary query tree of <figref idrefs="f0006">Fig. 8</figref> is processed in the database of <figref idrefs="f0006">Fig. 7</figref> in accordance with the prior art; and</dd><dt>Fig. 12:</dt><dd>A block diagram illustrating a database system in accordance with an embodiment of the invention.</dd></dl></p><heading id="h0005"><b><u>5. Detailed Description</u></b></heading><p id="p0029" num="0029">In the following, a presently preferred embodiment of the invention is described with respect to a method as schematically shown in <figref idrefs="f0001">Fig. 1</figref>,<!-- EPO <DP n="11"> --> which illustrates the steps of the query processing (including preprocessing steps (cf. the steps 100 and 150) and post-processing steps (300 and 400)). The described method is preferably performed by a processing logic 60 within a database system 1 schematically shown in <figref idrefs="f0009">Fig. 12</figref>. As can be seen, the database system 1 comprises an interface 10 for receiving relational queries 20, as well as a database 30, in which the data objects to be searched are stored. Further, the inventive database system 1 comprises two helper structures, namely index structures 45 and translation data structures 55, the purpose of which will be described in more detail further below. Importantly, the index structures 45 are stored in a storage device 40 of the database system 1, whereas the translation data structures 55 are stored in a memory 50 of the database system 1.</p><p id="p0030" num="0030">Returning to <figref idrefs="f0001">Fig. 1</figref>, the relational query 20 is initially analysed in step 100 to determine whether it already is in tree form.</p><p id="p0031" num="0031">Generally, a query (such as queries formulated in a declarative language, as used herein) can be represented as a graph in the mathematical sense, i.e. as a set of objects where some pairs of the objects are connected by links. The interconnected objects are referred to as vertices or nodes of the graph, and the links that connect pairs of nodes are called edges. A graph may comprise any number of nodes and edges.</p><p id="p0032" num="0032">When a query is represented as a graph, zero or more search conditions may be attached to each node and edge. Preferably, each node and edge also has a unique name. On a single node/edge, multiple search conditions may be combined using logical operators (such as AND, OR, XOR, and the like). The search conditions describe which data object(s) stored in the database should be considered as result(s) for the individual nodes and edges. The way in which the edges connect the nodes defines the relations which must also be fulfilled by the result.<!-- EPO <DP n="12"> --></p><p id="p0033" num="0033">As used herein, a query 20 received by the database system 1 of the invention may have one of three typical appearances which are relevant to the search implementation. The three appearances are schematically shown in <figref idrefs="f0004">Figs. 4a-c</figref>, and include an exemplary query with only a single node in <figref idrefs="f0004">Fig. 4a</figref> (called "simple/non-relational"), an exemplary query with three nodes A, B, C and edges between A-B and A-C, respectively in <figref idrefs="f0004">Fig. 4b</figref> (called "tree"), and an exemplary query with three nodes A, B, C and edges between A-B, A-C and B-C in <figref idrefs="f0004">Fig. 4c</figref> (called "connected graph").</p><p id="p0034" num="0034">Returning to step 100 in <figref idrefs="f0001">Fig. 1</figref>, the analysis of the query 20 would result in the determination that the query in <figref idrefs="f0004">Fig. 4b</figref> already is in tree form (in mathematical graph theory, a tree is a connected graph without cycles). Simple queries without any relations, such as the one shown in <figref idrefs="f0004">Fig. 4a</figref>, are also treated as tree (namely a tree with only one node, the root node, and zero edges). Thus, if the query has a tree structure, the method proceeds to step 200 (relational search; see below).</p><p id="p0035" num="0035">The query in <figref idrefs="f0004">Fig. 4c</figref> is not in tree form, but forms a more generic connected graph. In this case, the method proceeds to step 150, where the query graph is converted into a spanning tree, which is then used for the actual relational search in step 200 (see below). Ideally, the generated spanning tree has many leaves with highly selective criteria and therefore few results, as this reduces the number of translations needed in the first pass of the algorithm. Unconnected query graphs, i.e. queries comprising multiple sub-graphs which are not connected by an edge (in the mathematical sense of a forest) can be handled by performing a separate search for each individual connected graph.</p><p id="p0036" num="0036">In step 200, the actual relational search takes place. Generally speaking, a result tree is in this step filled with matching objects using the mechanisms described further below. The result tree has the same node and edge structure as the query and preferably also uses the same unique name(s) as specified in the query. Each node and edge is equipped with a<!-- EPO <DP n="13"> --> set of result items which reflect the matching objects for this node or edge. The result item comprises the object identifier and a reference to all related nodes including the edge through which this relation is established.</p><p id="p0037" num="0037">The relational search on the query tree (step 200) is preferably performed in two passes, which are described in the following with reference to <figref idrefs="f0002">Figs. 2</figref> and <figref idrefs="f0003">3</figref>. Both passes preferably process the query tree recursively, depth first (in the mathematical sense of a Depth-First Search; DFS) and start at the root node of the query tree. Alternatively, the second pass may be performed in a Breadth-First manner. The respective node which is currently investigated (i.e. the root node in the first processing iteration, the first child of the root node in the second processing iteration, etc.) is hereinafter referred to as "current node" or "context node".</p><p id="p0038" num="0038">The steps of the first pass are schematically shown in <figref idrefs="f0002">Fig. 2</figref>. Step 210 involves finding the result(s) for the condition(s) which the query defines for the current node. The object identifiers of database objects matching the condition(s) of the current query node are computed, preferably using traditional inverted index 45 search technologies. As the person skilled in the art will appreciate, the matching database objects could alternatively also be determined by scanning the database, however, at the cost of efficiency. In the subsequent step 220, the child node(s) of the current node is/are identified. If the current node does not have any child nodes (i.e. it is a leaf node of the query tree), the first pass ends. If, on the other hand, the current node has one or more child nodes, the first pass is now performed for each child node (step 230) - hence the recursivity of the relational search of the invention. In step 240, the results from the search on the current node are merged with the results from the children, which is performed using object identifier translation techniques described further below.<!-- EPO <DP n="14"> --></p><p id="p0039" num="0039">The steps of the second pass are schematically shown in <figref idrefs="f0003">Fig. 3</figref>. In step 250, the results for the current node which were obtained in the first pass are now merged with the results for its parent node using object identifier translation techniques described further below. This step is skipped for the root node (since by definition the root node has no parent node). In the subsequent step 260, the child node(s) of the current node is/are identified. If the current node does not have any child nodes (i.e. it is a leaf node of the query tree), the second pass ends. If, on the other hand, the current node has one or more child nodes, the second pass is now performed for each child node (step 270) - hence the recursivity of the relational search of the invention.</p><p id="p0040" num="0040">In summary, a preferred embodiment of the present search method traverses the query tree two times starting from the root node in a recursive depth-first manner. In the first pass, the merging operation is performed in the direction from the leave nodes to the root node. In the second pass, the merging is performed in the direction from the root node to the child nodes.</p><p id="p0041" num="0041">Referring again to <figref idrefs="f0001">Fig. 1</figref>, if the query was originally not in tree form (see above), missing relations are added in step 300. By using the object translator mechanisms disclosed herein, matching relations are added to the result for all relations from the original query which are not part of the spanning tree created above. Subsequently, the method proceeds to step 400, where unwanted results are filtered, i.e. all objects which do not match the original query are removed from the result. Note that this operation can be performed completely in-memory 50, as all necessary data was already put together by the relational search and the previous step.</p><heading id="h0006"><u>Merge and Translation</u></heading><!-- EPO <DP n="15"> --><p id="p0042" num="0042">The merging steps (cf. step 240 in the first pass of <figref idrefs="f0002">Fig. 2</figref> and step 250 in the second pass of <figref idrefs="f0003">Fig. 3</figref>) are crucial steps in the above-described two query processing passes.</p><p id="p0043" num="0043">Each edge in the query graph defines a relation between two nodes. The impact such relations have on the results for the nodes they connect can be controlled. For both nodes in relation, the query may define whether the existence of a relation for an object in the result is either required or optional. This way, the following behaviours can be achieved for two connected nodes A and B:
<tables id="tabl0001" num="0001"><table frame="all"><tgroup cols="4"><colspec colnum="1" colname="col1" colwidth="16mm"/><colspec colnum="2" colname="col2" colwidth="16mm"/><colspec colnum="3" colname="col3" colwidth="27mm"/><colspec colnum="4" colname="col4" colwidth="107mm"/><thead><row><entry valign="middle"><b>Node A</b></entry><entry valign="middle"><b>Node B</b></entry><entry valign="middle"><b>SQL equivalent</b></entry><entry valign="middle"><b>Description</b></entry></row></thead><tbody><row><entry>required</entry><entry>required</entry><entry>inner join</entry><entry>Only those objects will be in node A and B which are related to at least one object in the other node</entry></row><row><entry>optional</entry><entry>required</entry><entry>left outer join</entry><entry>Results of node A are not affected. Only those results remain for node B which are related to an object in the result of node A</entry></row><row><entry>required</entry><entry>optional</entry><entry>right outer join</entry><entry>Results of node B are not affected. Only those results remain for node A which are related to an object in the result of node B</entry></row><row><entry>optional</entry><entry>optional</entry><entry>full outer join</entry><entry>Results for node A and B are not affected by the relation (difference to not defining a relation at all: relations will be added to the result for those objects which have them)</entry></row></tbody></tgroup><!-- EPO <DP n="16"> --></table></tables></p><p id="p0044" num="0044">The merge step is always performed in the context of a single node. It is based on the current results of this node, which originate from the results for the node condition(s). It only considers those relations which are marked as required for the context node.</p><p id="p0045" num="0045">In order to be able to process results of related nodes together with results for the context node, the results of the related nodes have to be translated. In this step, the translator looks up matching relations using the result object identifiers from a related node. Using these relations it can easily find out the object identifier on the other side of the relation. These identifiers are passed on to the merger.</p><p id="p0046" num="0046">The merger removes all object identifiers from the result of the context node which do not appear in all translator results. As a result of this, only those results remain which fulfil all required relations. The respective dataflow of this process is schematically shown in <figref idrefs="f0004">Fig. 5</figref>.</p><p id="p0047" num="0047">In order to look up matching relations, the translator uses certain translation data structures 55 provided by the present invention. Here, two cases have to be looked at: relations which are not explicitly represented by objects in the database (e.g. relations defined by using foreign key techniques), and relations which are explicitly represented in the database by means of dedicated objects.</p><p id="p0048" num="0048">The translation data structure 55 for relations which are not represented by objects is schematically shown in <figref idrefs="f0005">Fig. 6a</figref>. As can be seen, a relation table is created, which couples the object identifiers of the respective source and target objects, thereby, providing a "helper" data structure in the database which explicitly represents the relation between the objects.<!-- EPO <DP n="17"> --> If the relation itself is already represented by an object in the data graph, the translation data structure 55 is generated as schematically shown in <figref idrefs="f0005">Fig. 6b</figref>. As can be seen, each source/target object ID couple is also correlated with the identifier of the respective relation involved.</p><p id="p0049" num="0049">The above-described translation data structures 55 (also referred to as "lookup data structures" or "relation tables") allow to quickly identify in which rows of the relation table relations involving a specific object identifier can be found. Depending on the nature of the object identifiers, they may be implemented as lookup tables, hash tables, using binary search or any other suitable mechanism.</p><p id="p0050" num="0050">As shown in <figref idrefs="f0005">Figs. 6a and 6b</figref>, the relation table 55 comprises an entry for every relation which exists in the data graph. This entry only comprises the object identifiers of the objects involved in this relation. The columns used in the relation tables 55 shown in <figref idrefs="f0005">Figs. 6a and 6b</figref> are:
<tables id="tabl0002" num="0002"><table frame="all"><tgroup cols="2"><colspec colnum="1" colname="col1" colwidth="20mm"/><colspec colnum="2" colname="col2" colwidth="79mm"/><thead><row><entry valign="middle"><b>Name</b></entry><entry valign="middle"><b>Description</b></entry></row></thead><tbody><row><entry valign="middle">RelationID</entry><entry valign="middle">Object identifier of object representing the relation data</entry></row><row><entry valign="middle">SourceID</entry><entry valign="middle">Object identifier of object on source side of relation</entry></row><row><entry valign="middle">TargetID</entry><entry valign="middle">Object identifier of object on target side of relation</entry></row></tbody></tgroup></table></tables></p><heading id="h0007"><u>Comparative example</u></heading><p id="p0051" num="0051">In the following, the concepts of the present invention are explained along a simple example involving a concrete search query 20. Further, it will be described how this search query 20 would be handled in the prior art, thereby highlighting the especially advantageous technical effects of the present invention.</p><p id="p0052" num="0052">The example involves a database 30 comprising the tables shown in <figref idrefs="f0006">Fig. 7</figref>. As the person skilled in the art will appreciate, a relational database<!-- EPO <DP n="18"> --> generally stores any number of tables, which can be understood as "datatypes" of the data stored in the database. Each table may store any number of rows, wherein each row corresponds to an individual database object (i.e. a data record). Further, each table has a number of columns, which represent the attributes of the data objects.</p><p id="p0053" num="0053">As can be seen in <figref idrefs="f0006">Fig. 7</figref>, the exemplary database 30 comprises a table "Book", which stores data objects representing books. Each individual book data object is represented in a row of the table. The table "Book" has three columns, which represent the attributes of the books, namely an ID (identifier) a name and a genre code. The different genres are stored in a table called "Genre", wherein each genre is defined by an ID (identifier), name and genre code. The database 30 further comprises a table "Publisher" storing data objects representing publishers with the attributes ID (identifier) and name. Lastly, a table "BookByPublisher" is provided, which stores tuples of BookID and PublisherID elements along with an ID (identifier).</p><p id="p0054" num="0054">The tables "Book" and "Genre" show an example of a relationship which is not explicitly defined by an own table in the database. Rather, the "Book" objects store a GenreCode attribute, thus relating the respective "Book" object to a corresponding "Genre" object. For example, the "Book" object with the name "Chemistry Cookbook" is related to the "Genre" object with the Name "Science" (due to the matching GenreCode attributes).</p><p id="p0055" num="0055">Furthermore the table "BookByPublisher" is an example of a junction table which relates to two other tables ("Book" and "Publisher") by containing references to their ids ("BookID" and "PublisherID"). "BookByPublisher" allows for instance to link "Chemistry Cookbook" and "Random Books" using a row containing "BookID" "1" and "PublisherID" "1".<!-- EPO <DP n="19"> --></p><p id="p0056" num="0056">In the present example, a search query 20 is to be processed against the above-described database. The question to be answered by the query is:
<ul><li><i>"Which books (including genre and publisher) of the genres "Crime" and "Science" have been published by a publisher who has the word "books" in his name?"</i></li></ul></p><p id="p0057" num="0057">As can be seen, this query 20 searches for data which is distributed across multiple tables of the database 30, wherein the relationships between the individual objects (e.g. books, genres and publishers) have to be taken into account. Therefore, this query is a so-called relational query.</p><p id="p0058" num="0058">Using the commonly known Structured Query Language (SQL), the above question could be expressed as follows:
<pre listing-type="program-listing"> select B.ID, G.ID, P.ID
 from Book B
 inner join Genre G on B.GenreCode = G.GenreCode
 inner join BookByPublisher BBP on B.ID = BBP.BookID
 inner join Publisher P on BBP.PublisherID = P.ID
 where G.Name in ('Crime', 'Science') and
    P.Name like '%Books%'</pre></p><p id="p0059" num="0059">If the tables and references (relations) between them are expressed as a data graph as described further above, the query graph for this question would look as schematically shown in <figref idrefs="f0006">Fig. 8</figref> (using the same aliases as in the SQL statement). As can be seen, in accordance with the conceptual description further above, each object in the query is represented by a node in the query graph and each relation is represented by an edge in the query graph.</p><p id="p0060" num="0060">Importantly, the node requirement is assumed to be "required" in this example (see the explanations concerning the merge and translation techniques above) for all edges and their nodes in order to achieve an "inner join" behavior. This simplifies the merge step in this example to<!-- EPO <DP n="20"> --> be a simple AND operation for the different translation and condition results.</p><heading id="h0008"><u>Execution of the comparative example by an embodiment of the invention</u></heading><p id="p0061" num="0061">When the exemplary database 30 shown above is handled by a preferred embodiment of the present invention, certain indexes 45 and translation tables 55 are defined in a preparatory step, i.e. before the query is actually processed.</p><p id="p0062" num="0062">More precisely, inverted indexes 45 are defined for the following table columns, wherein the indexes 45 are stored on the permanent storage 40 (e.g. a hard disk) of the database system 1: Book.Name, Book.GenreCode, Publisher.Name, Genre.Name, Genre.GenreCode. Generally speaking, the table columns to be indexed may be configured, i.e. preferably all columns on which certain criteria are to be applied should be indexed.</p><p id="p0063" num="0063">In addition to the above indexes, the database system 1 creates certain translation tables 55, which are stored in a fast memory 50 (e.g. a cache or the random access memory; RAM) of the database system 1. These translation tables are schematically shown in <figref idrefs="f0007">Fig. 9</figref>. Similar to foreign key definitions in conventional databases, also the relations and thus the translation tables to be generated are configurable in certain embodiments.</p><p id="p0064" num="0064">As already described further above, these translation tables 55 can be navigated in both directions. For example, the translation table 55 "Book.GenreCode &lt;-&gt; Genre.GenreCode" allows to determine which "Book" objects are related to a specific "Genre" object based on the "GenreCode" attribute. The same table 55 also allows determining the "Genre" object relating to a specific "Book" object.<!-- EPO <DP n="21"> --></p><p id="p0065" num="0065">Once the above-described "helper" data structures (i.e. the indexes 45 and the translation data structures 55) are provided in the database system 1, the actual query processing can take place.</p><p id="p0066" num="0066">For the provided example, the pre and post processing is rather simple. Accordingly, the "Analyze Query" step (cf. step 100 in <figref idrefs="f0001">Fig. 1</figref>) determines that the query 20 (see above) already is in tree form and thus the method can proceed directly to the "Relational Search" step (cf. step 200 in the left branch of <figref idrefs="f0001">Fig. 1</figref>), more precisely to the first pass shown in <figref idrefs="f0002">Fig. 2</figref>.</p><p id="p0067" num="0067">As already described above, the first pass starts with the root node, which is for the given exemplary query graph the node B (cf. <figref idrefs="f0006">Fig. 8</figref>). Step 210 ("Find results for conditions of current node ") does not need to do anything because node B has no conditions attached. Step 220 ("Identify child node") finds the child nodes of node B, which are the nodes G and BBP. Because there are child nodes, step 230 ("Child nodes pass 1") is now started for these child nodes one by one.</p><p id="p0068" num="0068">Accordingly, the first pass now starts for node G. Step 210 ("Find results for conditions of current node ") determines that node G has the condition "Name in 'Crime', 'Science'" attached and thus, the genres with ID "1" and "3" are the results of this step, since these genres match the condition of having either the name "Crime" or "Science". Further, step 220 ("Identify child nodes") finds that there are no child nodes to be processed for node G. Therefore, the first pass ends for node G.</p><p id="p0069" num="0069">The first pass now starts for node BBP. Step 210 "(Find results for conditions of current node ") does not need to do anything because node BBP has no conditions attached. Step 220 ("Identify child nodes") finds the child node P. Because there are child nodes, step 230 ("Child nodes pass 1") is now started for these child nodes one by one.</p><p id="p0070" num="0070">Accordingly, the first pass now starts for node P. Step 210 ("Find results for conditions of current node ") finds the publishers with ID "1" and "3",<!-- EPO <DP n="22"> --> which match the condition attached to node P, namely the condition of containing the word "Books". Step 220 ("Identify child nodes") finds that there are no child nodes to be processed. Therefore, the first pass ends for node P.</p><p id="p0071" num="0071">At this point, the first pass (cf. <figref idrefs="f0002">Fig. 2</figref>) has been started for all nodes in the query tree and all initialization was done. The result graph currently looks as shown in <figref idrefs="f0008">Fig. 10a</figref> (note that bold result elements in the Figure indicate values changed in the respective pass and "*" indicates that all objects match). As can be seen, the structure of the result tree resembles that of the query tree (as explained further above) and the intermediate results of the individual node conditions defined in the query tree are attached to the respective nodes of the result tree. For example, since the genres "1" and "3" were found to be results for node G (see above), node G of the result tree contains "(1; 3)", and so on.</p><p id="p0072" num="0072">The first pass now continues for node BBP. Step 240 ("Merge with results from children using translation"; cf. <figref idrefs="f0002">Fig. 2</figref>) does the following: The results for P (which is a child of BBP) are translated into results for BBP using the translation table 55 for the relation "BookByPublisher.PublisherID &lt;-&gt; Publisher.ID" (cf. <figref idrefs="f0007">Fig. 9</figref>), which was defined in the query. This yields the entries 1, 2, 4 and 6. These entries are also the new result for BBP, because the node did not have any results restrictions yet. This ends the first pass for node BBP.</p><p id="p0073" num="0073">The first pass now continues for node B. Step 240 ("Merge with results from children using translation") now does the following: The translation table "Book.GenreCode &lt;-&gt; Genre.GenreCode" used for the edge between G and B yields 1, 2, 4 and 5. The translation table "Book.ID &lt;-&gt; BookByPublisher.BookID" used for the edge between B and BBP yields 1, 3 and 5. The current result is not restricted, and thus the new results for B are all those entries which are contained in both translation results, namely 1 and 5. The first pass has now been completed and the<!-- EPO <DP n="23"> --> current result graph looks as shown in <figref idrefs="f0008">Fig. 10b</figref>. The result for the root node B is already final, all child nodes, however, can still change.</p><p id="p0074" num="0074">The second pass (cf. <figref idrefs="f0003">Fig. 3</figref>) now starts for the root node B. Because there is no parent node for the root node B, step 250 ("Merge with results from parent using translation") does not do anything. Step 260 ("Identify child nodes") finds two child nodes G and BBP. Thus, step 270 ("Child nodes pass 2") is now started for these child nodes one by one.</p><p id="p0075" num="0075">Accordingly, the second pass now starts for node G. Step 250 ("Merge with results from parent using translation") now does the following: The translation table "Book.GenreCode &lt;-&gt; Genre.GenreCode" used for the edge between B and G, which yields 3. Merged with the current result for G, this creates the new result 3. Step 260 ("Identify child nodes") finds that there are no child nodes to be processed. Therefore, the second pass ends for node G.</p><p id="p0076" num="0076">The second pass now starts for node BBP. Step 250 ("Merge with results from parent using translation") now does the following: The translation table 55 "Book.ID &lt;-&gt; BookByPublisher.BookID" is used for the edge between B and BBP, which yields 1, 2 and 6. Merged with the current result for BBP, this creates the new result 1, 2 and 6. Step 260 ("Identify child nodes") finds that there is one child node P. Because there are child nodes, step 270 ("Child nodes pass 2") is now started for this child node.</p><p id="p0077" num="0077">Accordingly, the second pass now starts for node P. Step 250 ("Merge with results from parent using translation") now does the following: The translation table 55 "BookByPublisher.PublisherID &lt;-&gt; Publisher.ID" is used for the edge between BBP and P, which yields 1 and 3. Merged with the current result for P, this creates the unchanged result 1, 3. Step 260 ("Identify child nodes") finds that there are no child nodes to be processed. Therefore, the second pass ends for node G.<!-- EPO <DP n="24"> --></p><p id="p0078" num="0078">The second pass now continues and ends for node BBP. The second pass now continues for node B and ends. At this point, the final result of the relational search has been calculated, which is shown in <figref idrefs="f0008">Fig. 10c</figref>. Accordingly, the result tree in <figref idrefs="f0008">Fig. 10c</figref> shows that the result of the exemplary query 20 explained above ("which books of the genres "Crime" and "Science" have been published by a publisher who has the word "books" in his name?") is the books with IDs 1 and 5, i.e. the books "Chemistry Cookbook" and "History of Mankind".</p><p id="p0079" num="0079">It is important to note that using the invention, the given example only performs three index lookups in the first pass, namely two index lookups to find results matching the conditions for node G (one for each word) and one more for node P. All the other results are computed using only the translation tables 55. As described above, since these translation tables 55 are stored in a fast memory 50 of the database system 1, the query processing in accordance with the invention is exceptionally fast, in particular faster than executing the query 20 in accordance with conventional techniques known from the prior art, which will be shown in the following.</p><heading id="h0009"><u>Execution of the comparative example using conventional techniques</u></heading><p id="p0080" num="0080">In the following, the exemplary query shown further above is processed using a conventional SQL database.</p><p id="p0081" num="0081">It is assumed that all columns used for lookups are indexed. Furthermore, it is assumed that row keys are used for internal data handling. These row keys are assumed to start from 1 and increase by one for each row given in the example table above (therefore, they correspond to the numeric value of the ID column by chance).</p><p id="p0082" num="0082">The execution plan described hereinafter is only an example. The plan built by actual database servers depends on many factors and varies<!-- EPO <DP n="25"> --> between vendors. However, the problem of the many random disk accesses remains.</p><p id="p0083" num="0083">Step 1 - Determine Books for Genres: At first, two index lookups are performed on the "Genre" table (cf. <figref idrefs="f0006">Fig. 7</figref>) for the genres "Crime" and "Science". The resulting rows 1 and 3 are read to determine the "GenreCode" for each found genre C and S. Furthermore, two index lookups are performed on the "Book" table to resolve the "GenreCodes" into rows 1, 2, 4 and 5 of the "Book" table. The intermediate result looks like shown in <figref idrefs="f0009">Fig. 11a</figref>.</p><p id="p0084" num="0084">Step 2 - Determine Books for Publishers: An index lookup is now performed on the "Publisher" table to obtain rows matching "books". The resulting rows 1 and 3 are read to obtain the IDs 1 and 3. Now, two index lookups are performed on the "BookByPublisher" table for PublisherID 1 and 3. The resulting rows 1, 2, 4 and 6 are read to obtain the BookIDs 1, 3 and 5. On the "Book" table, three lookups are used to find the rows containing the IDs. These rows are 1, 3 and 5.</p><p id="p0085" num="0085">Step 3 - Join Results: Finally, the rows for the "Book" table are merged together. The end result looks like shown in <figref idrefs="f0009">Fig. 11b</figref>.</p><p id="p0086" num="0086">As the person skilled in the art of database programming will appreciate, the above-described prior art approach of handling the exemplary query needs 3 lookups again to resolve the conditions. In addition, 7 index lookups and 8 read operations are required to perform the joins on the tables. Because the relations from other tables can typically not be reflected in the order of rows of a table, these additional lookups are randomly distributed across the index and data space and therefore show poor disk access behavior.</p><heading id="h0010"><u>Summary</u></heading><!-- EPO <DP n="26"> --><p id="p0087" num="0087">In conclusion, it can be seen in the example that the approach proposed by the present invention delivers improved performance even in this simple example. It is noted that the more data is actually processed, the bigger the advantage gets. This is because the inventive approach only needs index lookups to resolve query conditions. In other words, it only needs to stream more data per condition on large databases, but it does not need more disk seeks (note that streaming is fast, but seeking is slow). On the other hand, the traditional prior art approach typically needs an additional index lookup and row read per additional row to be considered in a relation.</p><p id="p0088" num="0088">While the concepts of the invention have been described in the context of an exemplary database storing books, it will be appreciated that the invention is not limited to this exemplary application scenario. Rather, the invention may well be used e.g. in the context of analyzing and searching business process modeling data. In addition, the same approach can be applied in many different areas where data can be represented in a relational model and relational queries need to be carried out. The invention allows to quickly identify all contents including relations which match a certain pattern. The pattern itself is represented as related items. Each item in the query can have criteria defined, and only matching contents are considered as instances of this item. Some example use cases include process models, which can be transformed into different representations on-the-fly by identifying all item instances which have specific relation patterns to a context node, indicating a certain semantic, users doing complex process data analysis by finding all sub-graphs which match a certain pattern graph, or relational queries performed on a NoSQL data store.</p><p id="p0089" num="0089">As disclosed herein, one of the core concepts of the present invention is that an efficient translation mechanism is provided for handling the random access patterns involved in processing relational queries. The mechanism is isolated from the actual object data and is performed on accumulated translation data held in quickly accessible memory.</p></description><claims mxw-id="PCLM56982057" lang="EN" load-source="patent-office"><!-- EPO <DP n="27"> --><claim id="c-en-0001" num="0001"><claim-text>A computer-implemented method of processing a relational query (20) in a database system (1), wherein the relational query (20) addresses a plurality of data objects linked by one or more relationships, wherein the method comprises the following steps:
<claim-text>a. for each data object addressed by the relational query (20), computing (210) at least one result in accordance with at least one index structure (45), the index structure (45) being stored in a storage device (40) of the database system (1); and</claim-text>
<claim-text>b. merging (240, 250) the results computed in step a. in accordance with at least one translation data structure (55) to produce a final result of the relational query (20), the translation data structure (55) representing the one or more relationships between the data objects and being stored in a memory (50) of the database system (1).</claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The method of claim 1, further comprising the step of representing (100, 150) the relational query (20) as a query tree, wherein each data object addressed by the relational query (20) is represented as a node of the query tree and wherein each relationship between the data objects is represented by an edge in the query tree.</claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The method of the preceding claim 2, further comprising the step of performing the computing step (210) and/or the merging step (240) as part of a first pass of processing the query tree, wherein the first pass is performed recursively (230) for each node of the query tree.<!-- EPO <DP n="28"> --></claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The method of the preceding claim 3, wherein the merging step (240) comprises merging the results of the current node with the results of the child node(s) of the current node.</claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The method of any of the preceding claims 2 - 4, further comprising the step of performing a second merging step (250) as part of a second pass of processing the query tree, wherein the second pass is performed recursively (270) for each node of the query tree.</claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The method of the preceding claim 5, wherein the second merging step (250) comprises merging the results of the current node with the results of the parent node of the current node.</claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>The method of any of the preceding claims 3 - 6, wherein the first pass and / or the second pass of processing the query tree traverses the query tree starting at the root node in a depth-first manner.</claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>The method of any of the preceding claims, wherein for two given data objects which are addressed by the relational query (20) and which are linked by a relationship, the translation data structure (55) comprises a mapping of an identifier of the first data object to an identifier of the second data object in accordance with the relationship.</claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>The method of the preceding claim 8, wherein, if the relationship is represented as a data object in a database (30) of the database system (1), the translation data structure (55) comprises a mapping of an identifier of the first data object to an identifier of the second data object and to an identifier of the relationship.</claim-text></claim><claim id="c-en-0010" num="0010"><claim-text>A computer program comprising instructions for implementing a method of any of the preceding claims 1 - 9.<!-- EPO <DP n="29"> --></claim-text></claim><claim id="c-en-0011" num="0011"><claim-text>A database system (1), comprising:
<claim-text>a. an interface (10), adapted for receiving relational queries (20) which address a plurality of data objects linked by one or more relationships;</claim-text>
<claim-text>b. a storage device (40), adapted for storing at least one index structure (45);</claim-text>
<claim-text>c. a memory (50), adapted for storing at least one translation data structure (55), the translation data structure (55) representing the one or more relationships between the data objects;</claim-text>
<claim-text>d. control logic (60), adapted for:
<claim-text>- for each data object addressed by the relational query (20), computing (210) at least one result in accordance with the at least one index structure (45); and</claim-text>
<claim-text>- merging (240, 250) the computed results in accordance with the at least one translation data structure (55) to produce a final result of the relational query (20).</claim-text></claim-text></claim-text></claim><claim id="c-en-0012" num="0012"><claim-text>The database system (1) of claim 11, wherein the control logic (60) is further adapted for representing (100, 150) the relational query (20) as a query tree, wherein each data object addressed by the relational query (20) is represented as a node of the query tree and wherein each relationship between the data objects is represented by an edge in the query tree.</claim-text></claim><claim id="c-en-0013" num="0013"><claim-text>The database system (1) of the preceding claim 12, wherein the control logic (60) is further adapted for performing the computing step (210) and/or the merging step (240) as part of a first pass of<!-- EPO <DP n="30"> --> processing the query tree, wherein the first pass is performed recursively (230) for each node of the query tree.</claim-text></claim><claim id="c-en-0014" num="0014"><claim-text>The database system (1) of any of the preceding claims 12 or 13, wherein the control logic (60) is further adapted for performing a second merging step (250) as part of a second pass of processing the query tree, wherein the second pass is performed recursively (270) for each node of the query tree.</claim-text></claim><claim id="c-en-0015" num="0015"><claim-text>The database system (1) of any of the preceding claims 13 or 14, wherein the first pass and / or the second pass of processing the query tree traverses the query tree starting at the root node in a depth-first manner.</claim-text></claim></claims><amended-claims mxw-id="PCLM56982056" lang="EN" load-source="patent-office" amended-claim-type="EPC"><heading id="h0011">Amended claims in accordance with Rule 137(2) EPC.</heading><claim id="ac-en-0001" num="1"><claim-text><b>1.</b> A computer-implemented method of processing a relational query (20) in a database system (1), wherein the relational query (20) addresses a plurality of data objects linked by one or more relationships, wherein the method comprises the following steps:
<claim-text>a. for each data object addressed by the relational query (20), computing (210) at least one result in accordance with at least one index structure (45); and</claim-text>
<claim-text>b. merging (240, 250) the results computed in step a. in accordance with at least one translation data structure (55) to produce a final result of the relational query (20), the translation data structure (55) representing the one or more relationships between the data objects;<br/>
<b>characterized in that:</b></claim-text>
<claim-text>c. the index structure (45) used in step a. is stored in a storage device (40) of the database system (1) and the translation data structure (55) used in step b. is stored in a memory (50) of the database system (1).</claim-text></claim-text></claim><claim id="ac-en-0002" num="2"><claim-text><b>2.</b> The method of claim 1, further comprising the step of representing (100, 150) the relational query (20) as a query tree, wherein each data object addressed by the relational query (20) is represented as a node of the query tree and wherein each relationship between the data objects is represented by an edge in the query tree.</claim-text></claim><claim id="ac-en-0003" num="3"><claim-text><b>3.</b> The method of the preceding claim 2, further comprising the step of performing the computing step (210) and/or the merging step (240) as part of a first pass of processing the query tree, wherein the first pass is performed recursively (230) for each node of the query tree.</claim-text></claim><claim id="ac-en-0004" num="4"><claim-text><b>4.</b> The method of the preceding claim 3, wherein the merging step (240) comprises merging the results of the current node with the results of the child node(s) of the current node.</claim-text></claim><claim id="ac-en-0005" num="5"><claim-text><b>5.</b> The method of any of the preceding claims 2 - 4, further comprising the step of performing a second merging step (250) as part of a second pass of processing the query tree, wherein the second pass is performed recursively (270) for each node of the query tree.</claim-text></claim><claim id="ac-en-0006" num="6"><claim-text><b>6.</b> The method of the preceding claim 5, wherein the second merging step (250) comprises merging the results of the current node with the results of the parent node of the current node.</claim-text></claim><claim id="ac-en-0007" num="7"><claim-text><b>7.</b> The method of any of the preceding claims 3 - 6, wherein the first pass and / or the second pass of processing the query tree traverses the query tree starting at the root node in a depth-first manner.</claim-text></claim><claim id="ac-en-0008" num="8"><claim-text><b>8.</b> The method of any of the preceding claims, wherein for two given data objects which are addressed by the relational query (20) and which are linked by a relationship, the translation data structure (55) comprises a mapping of an identifier of the first data object to an identifier of the second data object in accordance with the relationship.</claim-text></claim><claim id="ac-en-0009" num="9"><claim-text><b>9.</b> The method of the preceding claim 8, wherein, if the relationship is represented as a data object in a database (30) of the database system (1), the translation data structure (55) comprises a mapping of an identifier of the first data object to an identifier of the second data object and to an identifier of the relationship.</claim-text></claim><claim id="ac-en-0010" num="10"><claim-text><b>10.</b> A computer program comprising instructions for implementing a method of any of the preceding claims 1- 9.</claim-text></claim><claim id="ac-en-0011" num="11"><claim-text><b>11.</b> A database system (1), comprising:
<claim-text>a. an interface (10), adapted for receiving relational queries (20) which address a plurality of data objects linked by one or more relationships;</claim-text>
<claim-text>b. means (40), adapted for storing at least one index structure (45);</claim-text>
<claim-text>c. means (50), adapted for storing at least one translation data structure (55), the translation data structure (55) representing the one or more relationships between the data objects;</claim-text>
<claim-text>d. control logic (60), adapted for:
<claim-text>- for each data object addressed by the relational query (20), computing (210) at least one result in accordance with the at least one index structure (45); and</claim-text>
<claim-text>- merging (240, 250) the computed results in accordance with the at least one translation data structure (55) to produce a final result of the relational query (20);</claim-text>
<b>characterized in that:</b></claim-text>
<claim-text>e. the means (40) for storing at least one index structure (45) is a storage device (40) and the means (50) for storing at least one translation data structure (55) is a memory (50).</claim-text></claim-text></claim><claim id="ac-en-0012" num="12"><claim-text><b>12.</b> The database system (1) of claim 11, wherein the control logic (60) is further adapted for representing (100, 150) the relational query (20) as a query tree, wherein each data object addressed by the relational query (20) is represented as a node of the query tree and wherein each relationship between the data objects is represented by an edge in the query tree.</claim-text></claim><claim id="ac-en-0013" num="13"><claim-text><b>13.</b> The database system (1) of the preceding claim 12, wherein the control logic (60) is further adapted for performing the computing step (210) and/or the merging step (240) as part of a first pass of processing the query tree, wherein the first pass is performed recursively (230) for each node of the query tree.</claim-text></claim><claim id="ac-en-0014" num="14"><claim-text><b>14.</b> The database system (1) of any of the preceding claims 12 or 13, wherein the control logic (60) is further adapted for performing a second merging step (250) as part of a second pass of processing the query tree, wherein the second pass is performed recursively (270) for each node of the query tree.</claim-text></claim><claim id="ac-en-0015" num="15"><claim-text><b>15.</b> The database system (1) of any of the preceding claims 13 or 14, wherein the first pass and / or the second pass of processing the query tree traverses the query tree starting at the root node in a depth-first manner.</claim-text></claim></amended-claims><drawings mxw-id="PDW16670449" load-source="patent-office"><!-- EPO <DP n="31"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="165" he="192" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="32"> --><figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="118" he="192" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="33"> --><figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="121" he="168" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="34"> --><figure id="f0004" num="4a,4b,4c,5"><img id="if0004" file="imgf0004.tif" wi="165" he="180" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="35"> --><figure id="f0005" num="6a,6b"><img id="if0005" file="imgf0005.tif" wi="165" he="214" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="36"> --><figure id="f0006" num="7,8"><img id="if0006" file="imgf0006.tif" wi="165" he="221" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="37"> --><figure id="f0007" num="9"><img id="if0007" file="imgf0007.tif" wi="165" he="161" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="38"> --><figure id="f0008" num="10a,10b,10c"><img id="if0008" file="imgf0008.tif" wi="109" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="39"> --><figure id="f0009" num="11a,11b,12"><img id="if0009" file="imgf0009.tif" wi="165" he="210" img-content="drawing" img-format="tif"/></figure></drawings><search-report-data><doc-page id="srep0001" file="srep0001.tif" wi="159" he="233" type="tif"/><doc-page id="srep0002" file="srep0002.tif" wi="163" he="233" type="tif"/><doc-page id="srep0003" file="srep0003.tif" wi="165" he="233" type="tif"/></search-report-data><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
