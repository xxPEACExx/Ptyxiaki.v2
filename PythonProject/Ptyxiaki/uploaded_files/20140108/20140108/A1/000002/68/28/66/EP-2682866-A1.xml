<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2682866-A1" country="EP" doc-number="2682866" kind="A1" date="20140108" family-id="48672383" file-reference-id="301318" date-produced="20180824" status="corrected" lang="DE"><bibliographic-data><publication-reference fvid="146584886" ucid="EP-2682866-A1"><document-id><country>EP</country><doc-number>2682866</doc-number><kind>A1</kind><date>20140108</date><lang>DE</lang></document-id></publication-reference><application-reference ucid="EP-13171595-A" is-representative="YES"><document-id mxw-id="PAPP154847078" load-source="docdb" format="epo"><country>EP</country><doc-number>13171595</doc-number><kind>A</kind><date>20130612</date><lang>DE</lang></document-id><document-id mxw-id="PAPP196971927" load-source="docdb" format="original"><country>EP</country><doc-number>13171595.5</doc-number><date>20130612</date></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140550671" ucid="DE-102012105981-A" load-source="docdb"><document-id format="epo"><country>DE</country><doc-number>102012105981</doc-number><kind>A</kind><date>20120704</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1989320220" load-source="docdb">G06F   9/45        20060101AFI20130930BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL1989650400" load-source="docdb" scheme="CPC">G06F   8/51        20130101 FI20130919BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132359291" lang="DE" load-source="patent-office">Verfahren zur Umsetzung von Datenformaten</invention-title><invention-title mxw-id="PT132359292" lang="EN" load-source="patent-office">Methods for the implementation of data formats</invention-title><invention-title mxw-id="PT132359293" lang="FR" load-source="patent-office">Procédé de conversion de formats de données</invention-title><citations><patent-citations><patcit mxw-id="PCIT242942525" load-source="docdb" ucid="US-20100082706-A1"><document-id format="epo"><country>US</country><doc-number>20100082706</doc-number><kind>A1</kind><date>20100401</date></document-id><sources><source name="APP" created-by-npl="N"/></sources></patcit></patent-citations><non-patent-citations><nplcit><text>DEREK WALKER DOMINIQUE , DOMINIQUE PETITPIERRE , SUSAN ARMSTRONG: "XMLTrans: a Java-based XML Transformation Language for Structured Data", PROC. OF COLING 2000, 1 January 2000 (2000-01-01), pages 1136 - 1140, XP002713258, Retrieved from the Internet &lt;URL:http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.28.1625&gt; [retrieved on 20130919]</text><sources><source mxw-id="PNPL58567097" load-source="docdb" name="SEA" category="XA"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR919519731" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>TRIPLE S GMBH</last-name><address><country>DE</country></address></addressbook></applicant><applicant mxw-id="PPAR919512542" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>TRIPLE-S GMBH</last-name></addressbook></applicant><applicant mxw-id="PPAR919008975" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Triple-S GmbH</last-name><iid>101386832</iid><address><street>Zur Drexlerschleife 9</street><city>93152 Nittendorf</city><country>DE</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR919518462" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>HUEBL JOSEF</last-name><address><country>DE</country></address></addressbook></inventor><inventor mxw-id="PPAR919524887" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>HUEBL, JOSEF</last-name></addressbook></inventor><inventor mxw-id="PPAR919018799" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Hübl, Josef</last-name><address><street>Zur Drexlerschleife 9</street><city>93152 Nittendorf</city><country>DE</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR919008648" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Graf Glück Kritzenberger</last-name><iid>101354497</iid><address><street>Hermann-Köhl-Strasse 2a</street><city>93049 Regensburg</city><country>DE</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS549907453" load-source="docdb">AL</country><country mxw-id="DS549739431" load-source="docdb">AT</country><country mxw-id="DS549809436" load-source="docdb">BE</country><country mxw-id="DS549738417" load-source="docdb">BG</country><country mxw-id="DS549742041" load-source="docdb">CH</country><country mxw-id="DS549809437" load-source="docdb">CY</country><country mxw-id="DS549814099" load-source="docdb">CZ</country><country mxw-id="DS549907455" load-source="docdb">DE</country><country mxw-id="DS549809438" load-source="docdb">DK</country><country mxw-id="DS549809439" load-source="docdb">EE</country><country mxw-id="DS549740121" load-source="docdb">ES</country><country mxw-id="DS549738418" load-source="docdb">FI</country><country mxw-id="DS549738419" load-source="docdb">FR</country><country mxw-id="DS549907456" load-source="docdb">GB</country><country mxw-id="DS549809440" load-source="docdb">GR</country><country mxw-id="DS549907457" load-source="docdb">HR</country><country mxw-id="DS549814100" load-source="docdb">HU</country><country mxw-id="DS549742042" load-source="docdb">IE</country><country mxw-id="DS549809441" load-source="docdb">IS</country><country mxw-id="DS549738420" load-source="docdb">IT</country><country mxw-id="DS549809442" load-source="docdb">LI</country><country mxw-id="DS549738421" load-source="docdb">LT</country><country mxw-id="DS549739432" load-source="docdb">LU</country><country mxw-id="DS549738422" load-source="docdb">LV</country><country mxw-id="DS549738423" load-source="docdb">MC</country><country mxw-id="DS549739433" load-source="docdb">MK</country><country mxw-id="DS549739434" load-source="docdb">MT</country><country mxw-id="DS549740122" load-source="docdb">NL</country><country mxw-id="DS549812750" load-source="docdb">NO</country><country mxw-id="DS549740123" load-source="docdb">PL</country><country mxw-id="DS549739435" load-source="docdb">PT</country><country mxw-id="DS549742043" load-source="docdb">RO</country><country mxw-id="DS549739436" load-source="docdb">RS</country><country mxw-id="DS549740124" load-source="docdb">SE</country><country mxw-id="DS549814101" load-source="docdb">SI</country><country mxw-id="DS549812751" load-source="docdb">SK</country><country mxw-id="DS549812752" load-source="docdb">SM</country><country mxw-id="DS549738424" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA128673058" lang="DE" load-source="patent-office"><p id="pa01" num="0001">Die Erfindung bezieht sich auf ein computerimplementiertes Verfahren zur Umsetzung zumindest eines ersten Datenblocks (1) mit einem ersten Datenformat in zumindest einen zweiten Datenblock (2) mit einem zweiten Datenformat mittels einer Rechnereinheit, die zumindest einen Prozessor und zumindest eine Speichereinheit aufweist.
<img id="iaf01" file="imgaf001.tif" wi="156" he="76" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA128737203" lang="DE" source="EPO" load-source="docdb"><p>Die Erfindung bezieht sich auf ein computerimplementiertes Verfahren zur Umsetzung zumindest eines ersten Datenblocks (1) mit einem ersten Datenformat in zumindest einen zweiten Datenblock (2) mit einem zweiten Datenformat mittels einer Rechnereinheit, die zumindest einen Prozessor und zumindest eine Speichereinheit aufweist.</p></abstract><abstract mxw-id="PA168713410" lang="EN" source="transcript" load-source="docdb"><p>The computer implemented method involves reading a data block (1), particularly a data structure type (3) and a data format pattern (7), by a processor. The data format is mapped by the data structure type, which defines the fixed data structure elements and variable data structure elements. Each variable data structure element is assigned a data type and a name. A data structure instance (6) with a data structure instance element is generated from the former data block by the processor. The data structure instance is generated through the fixed data structure elements and the data types of the variable data structure elements. An independent claim is included for a computer program product for performing a computer implemented method.</p></abstract><description mxw-id="PDES63959046" lang="DE" load-source="patent-office"><!-- EPO <DP n="1"> --><p id="p0001" num="0001">Die Erfindung betrifft ein Verfahren zur Umsetzung zumindest eines ersten Datenblocks mit einem ersten Datenformat in zumindest einen zweiten Datenblock mit einem zweiten Datenformat gemäß dem Oberbegriff des Patentanspruchs 1.</p><p id="p0002" num="0002">Verfahren zur Umsetzung von Datenformaten sind bereits bekannt, beispielsweise die Programmiersprache XSLT zur Transformation von XML-Dokumenten oder die Beschreibungssprache ASN.1 Ferner ist aus der Druckschrift <patcit id="pcit0001" dnum="US20100082706A1"><text>US 2010/0082706 A1</text></patcit> ein Verfahren zur Umsetzung von Daten mittels eines Transformationsmakros bekannt geworden.</p><p id="p0003" num="0003">Die grundsätzliche Aufgabe in der Softwareentwicklung besteht darin, in vielen Arbeitschritten aus von Menschen lesbaren Spezifikationen einen von einer Prozessoreinheit ausführbaren Maschinencode zu erzeugen. Ein einzelner Arbeitsschritt besteht dabei darin, den Inhalt von ein oder mehreren Dateien in ein oder mehrere andere Dateien umzusetzen, wobei sich das Datenformat immer mehr einer Norm annähert und damit automatisiert bearbeitbar wird. Zum Beispiel bestehen die letzten Schritte in dieser Prozesskette darin, sogenannten Quellcode in einer normierten Programmiersprache zu erstellen und diesen wiederum in den, von einer Prozessoreinheit ausführbaren Maschinencode zu überführen. Gerade dieser letzte Schritt wird bereits seit den Anfängen der Informatik automatisiert mittels Computer durchgeführt, wobei schon bei einem kleinen Softwareprojekt hunderte bis tausende Dateien verarbeitet werden müssen. Die letzten zehn bis fünfzehn Jahre der Informatikbranche waren stark davon geprägt Dateiformate immer mehr branchenübergreifend oder wenn möglich international zu normieren oder zumindest innerbetrieblich zu standardisieren, um damit auch entsprechende Arbeitsschritte bzw. komplette innerbetriebliche Abläufe routinebasiert durchführen zu können.</p><p id="p0004" num="0004">Sobald jedoch die Dateiformate der Eingangsdateien und Ausgangsdateien eines Arbeitsschrittes im Bezug auf diesen Arbeitsschritt normiert sind, bietet es sich geradezu an diesen Arbeitsschritt automatisiert mittels Computer durchzuführen. Dies erfordert es aber, dass ein spezielles Computerprogramm bzw. eine spezielle Software erstellt wird, mit der<!-- EPO <DP n="2"> --> die Eingangsdateien im vorgegebenen Format gelesen und daraus die Ausgangsdateien im vorgegebenen Format erzeugt werden können.</p><p id="p0005" num="0005">Nach Stand der Technik erfordert das Erstellen einer solchen Software seinerseits ein Softwareprojekt mit all seinen Prozessschritten ins Leben zu rufen und abschießend durchzuführen, welches in den meisten Fällen jedoch so aufwendig ist, dass man von einer automatisierten Durchführung eines Arbeitsschrittes durch den Computer wieder Abstand nimmt, auch wenn dieser Arbeitsschritt aus dem für den Menschen nervenaufreibenden, weil nicht selten hundertfach zu wiederholendem gleichem Vorgang besteht, Daten aus einer Datei zu kopieren und in eine andere Datei wieder einzufügen. Darunter leidet selbstredend auch die Qualität der Ausgangsdateien.</p><p id="p0006" num="0006">Es besteht somit ein grundsätzlicher Bedarf darin, ein computerimplementiertes Verfahren zur Verfügung zu stellen, das es erlaubt Eingangsdateien mit einem bestimmten Format in Ausgangsdateien mit einem bestimmten anderen Format umzusetzen, ohne auf bestimmte Datenformate spezialisiert zu sein.</p><p id="p0007" num="0007">Wird eine Datei bzw. ein Dateiinhalt verallgemeinert als Datenblock betrachtet, so besteht die Aufgabe der Erfindung darin, ein computerimplementiertes Verfahren zur Umsetzung mindestens eines ersten Datenblocks mit einem ersten Datenformat in zumindest einen zweiten Datenblock mit einem zweiten Datenformat bereitzustellen, wobei der Anwender die Datenformate weitestgehend frei bestimmen kann und damit das aufwendige und kostenintensive Entwickeln einer speziellen Software zur Umsetzung der gerade gegebenen Datenformate entfällt. Die Aufgabe wird ausgehend vom Oberbegriff des unabhängigen Patentanspruchs 1 durch dessen kennzeichnende Merkmale gelöst.</p><p id="p0008" num="0008">Unter dem Begriff "Datentyp" wird nachfolgend entweder ein regulärer Datentyp, ein elementarer Datentyp oder ein komplexer Datentyp verstanden, wobei
<ol><li>a) ein regulärer Datentyp durch einen regulären Ausdruck definiert wird,</li><li>b) ein elementarer Datentyp durch einen vordefinierten regulären Ausdruck definiert wird wie er beispielsweise für INTEGER, FLOAT, BOOL, STRING etc. vorausgesetzt wird und</li><li>c) ein komplexer Datentyp mit seinem Namen auf die Definition eines Datenstrukturtypen verweist.</li></ol><!-- EPO <DP n="3"> --></p><p id="p0009" num="0009">Bei dem speziellen elementaren Datentypen WHITESPACES handelt es sich um eine beliebig lange Zeichenkette, die ausschließlich die Zeichen &lt;Zwischenraum&gt;, &lt;Tabulator&gt;, &lt;Wagenrücklauf&gt; und &lt;NeueZeile&gt; enthalten darf.</p><p id="p0010" num="0010">Bei dem Begriff "Datenstrukturelement" wird zwischen festen oder variablen Datenstrukturelementen unterschieden, wobei feste Datenstrukturelemente durch eine konstante Zeichenkette wie zum Beispiel ,Dies ist ein festes Datenstrukturelement' gegeben sind. Variable Datenstrukturelemente dagegen können verschiedene Werte annehmen, die Wertemenge ist aber über einen gegeben Datentypen eingeschränkt. Variablen Datenstrukturelementen kann auch ein Name zugewiesen sein, über den auf den Wert des Datenstrukturelements referenziert werden kann.</p><p id="p0011" num="0011">Unter dem Begriff "Datenstrukturtyp" wird ein Konstrukt zur Abbildung einer Datenstruktur verstanden, wobei dieses Konstrukt aus dem Namen des Datenstrukturtypen und dem Namen einer Strukturkategorie mit deren Parametern besteht, es sich bei diesen Strukturparametern entweder um feste oder variable Datenstrukturelemente mit, falls vorhanden, eindeutigem Namen handelt und die Strukturkategorie festlegt, wie die Strukturparameter zur Analyse des Datenblocks angewendet werden.</p><p id="p0012" num="0012">Beispielsweise legt die Strukturkategorie "SEQUENCE" fest, dass die Datenstruktur aus den als Strukturparameter gegebenen Datenstrukturelementen in genau in der gegebenen Reihenfolge gebildet wird, wogegen beispielsweise die Strukturkategorie "CHOICE" festlegt, dass die Datenstruktur aus genau einem der als Strukturparameter gegebenen Datenstrukturelemente besteht. Über den Datenstrukturtypen kann beispielsweise das erste Datenformat des ersten Datenblocks abgebildet werden. Dabei wird über dessen Strukturkategorie festgelegt, wo sich im ersten Datenblock die festen Datenstrukturelement mit ihrem gegeben festen Wert befinden und wo sich im ersten Datenblock die konkreten Werte für die variablen Datenstrukturelemente befinden. Diese können extrahiert und zur Weiterverarbeitung in einer Datenstrukturinstanz gespeichert werden.</p><p id="p0013" num="0013">Unter dem Begriff "Datenstrukturinstanz" wird nachfolgend ein Satz konkreter Datenwerte mit eindeutigem Namen verstanden, wobei innerhalb des Datensatzes jedem variablen Datenstrukturelement mit Namen genau ein konkreter Wert aus dem Datensatz zugeordnet<!-- EPO <DP n="4"> --> ist und dieser konkrete Wert ein zulässiger Wert im Bezug auf den Datentypen des zugeordneten variablen Datenstrukturelements ist.</p><p id="p0014" num="0014">Da jede Datenstrukturinstanz einen eindeutigen Namen besitzt und innerhalb der Definition eines komplexen Datentypen jedes benannte variable Datenstrukturelement wiederum einen eindeutigen Namen besitzt, kann jedem benannten variablen Datenstrukturelement einer Datenstrukturinstanz eine eindeutige ID (Identifier) zugeordnet werden, die aus der sequenziellen Anordnung des Namen der Datenstrukturinstanz und den Namen aller Datenstrukturelementen besteht, in denen das anzusprechende Datenstrukturelement enthalten ist. Vorzugsweise werden in dieser sequenziellen Anordnung die Namen durch ein spezifisches Zeichen (z.B. ':') getrennt, das nicht Bestandteil eines Namen sein kann. Ist beispielsweise XXX der Name einer Datenstrukturinstanz, in deren komplexen Datenstrukturtypen ein variables Datenstrukturelement mit dem Namen YYY existiert, so kann auf dieses mit der eindeutigen ID XXX:YYY zugegriffen werden. Ist diesem Datenstrukturelement XXX:YYY wiederum ein komplexer Datenstrukturtyp zugeordnet, der seinerseits ein variables Datenstrukturelement mit Namen ZZZ besitzt, so kann auf dieses mit der eindeutigen ID XXX:YYY:ZZZ zugegriffen werden, usw.</p><p id="p0015" num="0015">Unter dem Begriff "Datenformatmuster" wird nachfolgend ein Konstrukt aus zumindest einem festen Datenformatelement und/oder zumindest einem variablen Datenformatelement verstanden. Mittels der festen Datenformatelemente wird unmittelbar eine entsprechende Ausgabe an gegebener Stelle im zweiten Datenblock erreicht. Die variablen Datenformatelemente verweisen über die ID eines variablen Datenstrukturelements einer Datenstrukturinstanz auf dessen Wert, der an gleicher Stelle statt des variablen Datenformatelements in den zweiten Datenblock ausgegeben wird.</p><p id="p0016" num="0016">Zusätzlich kann ein Datenformatmuster Anweisungen enthalten, die bestimmen, unter welchen Bedingungen bestimmte Teile des Datenformatmusters keine Ausgabe oder eine wiederholte Ausgabe in den zweiten Datenblock erzeugen.</p><p id="p0017" num="0017">Des weiteren kann ein Datenformatmuster Anweisungen enthalten, mit denen vergleichbar zu einer herkömmlichen Programmiersprache die Werte von Datenstrukturinstanzen bzw. deren Datenstrukturelemente mittels Operationen kombiniert und verändert werden<!-- EPO <DP n="5"> --> können. Mittels des Datenformatmusters wird das zweite Datenformat und damit insbesondere der strukturelle Aufbau des zweiten Datenblocks festgelegt.</p><p id="p0018" num="0018">Der wesentliche Aspekt des erfindungsgemäßen Verfahrens zur Umsetzung zumindest eines ersten Datenblocks mit einem ersten Datenformat in zumindest einen zweiten Datenblock mit einem zweiten Datenformat mittels einer Rechnereinheit, die zumindest einen Prozessor und zumindest eine Speichereinheit aufweist, besteht darin, dass der erste Datenblock durch den Prozessor eingelesen wird, dass das erste Datenformat durch zumindest einen Datenstrukturtypen abgebildet wird, der feste Datenstrukturelemente und variable Datenstrukturelemente definiert, wobei den variablen Datenstrukturelementen des Datenstrukturtypen jeweils ein Datentyp und mindestens einem variablen Datenstrukturelement auch ein Name zugewiesen wird, dass unter Verwendung der festen Datenstrukturelemente und der Datentypen der variablen Datenstrukturelemente durch den Prozessor aus dem ersten Datenblock zumindest eine erste Datenstrukturinstanz mit zumindest einem Datenstrukturinstanzelement erzeugt und in der Speichereinheit abgelegt wird, wobei auf den Wert des Datenstrukturinstanzelements über seine ID direkt zugegriffen werden kann, dass der zweite Datenblock aus einem Datenformatmuster unter Verwendung der ersten Datenstrukturinstanz oder zumindest einer aus der ersten Datenstrukturinstanz abgeleiteten zweiten Datenstrukturinstanz mittels des Prozessors erzeugt wird, wobei das Datenformatmuster feste Datenformatelemente und variable Datenformatelemente aufweist und die variablen Datenformatelemente über genau eine ID auf die in der Speichereinheit abgelegten Werte der Datenstrukturinstanzelemente der ersten oder zweiten Datenstrukturinstanz verweisen und dass der zweite Datenblock entsprechend den im Datenformatmuster hinterlegten Anweisungen durch den Prozessor ausgegeben wird.</p><p id="p0019" num="0019">Das erfindungsgemäße Verfahren bietet den entscheidenden Vorteil, dass der erste Datenblock anhand zumindest eines Datenstrukturtypen analysiert und daraus eine korrespondierende Datenstrukturinstanz erstellt wird, wobei durch den Datenstrukturtypen festgelegt ist, welche den variablen Datenstrukturelementen des Datenstrukturtypen entsprechende Datenblockbereiche als Werte den Datenstrukturelementen der Datenstrukturinstanz zugewiesen werden sollen. Auf diese Werte kann zu einem späteren Zeitpunkt über die ID eines Datenstrukturelements zugegriffen werden.<!-- EPO <DP n="6"> --></p><p id="p0020" num="0020">Ein weiterer Vorteil des erfindungsgemäßen Verfahrens ist es, dass nach diesem Analyseschritt anhand des Datenformatmusters und unter Zugriff auf die zuvor generierte Datenstrukturinstanz der zweite Datenblock erzeugt wird, wobei dessen Datenformat unmittelbar von dem bei der Erzeugung des zweiten Datenblocks verwendeten Datenformatmusters abhängt. Das Datenformatmuster weist hierbei neben festen Datenformatelementen, die unmittelbar und unverändert im zweiten Datenblock eingefügt werden, variable Datenformatelemente auf, die über den Zugriff auf Werte der Datenstrukturinstanzelemente der in der Speichereinheit abgelegten Datenstrukturinstanz befüllt werden. Dadurch wird ein äußerst flexibles und anpassbares Verfahren zur Umsetzung von einem ersten Datenformat in ein zweites Datenformat geschaffen. Insbesondere wird durch das erfindungsgemäße Verfahren eine Verbindung zwischen den mit der Metasprache EBNF (extended Backhaus-Naur-Form) spezifizierten Dateiformaten und den mit einer herkömmlichen Programmiersprache spezifizierten Datenstrukturinstanzen hergestellt.</p><p id="p0021" num="0021">Besonders bevorzugt wird anhand vorausgehender fester Datenstrukturelemente des Datenstrukturtyps zumindest einem Datenstrukturinstanzelement ein Wert aus dem ersten Datenblock zugewiesen. Die festen Datenstrukturelemente des Datenstrukturtypen dienen damit als Orientierungshilfe sowohl für die die Analyse des ersten Datenblocks vornehmende Rechnereinheit als auch als Orientierungshilfe für den jeweiligen Benutzer, insbesondere bei der Entwicklung eines ersten Datenformats aus einem gegeben ersten Beispieldatenblock, wobei die Position der variablen Datenstrukturelemente anhand der festen Datenstrukturelemente leichter bestimmt werden kann.</p><p id="p0022" num="0022">In einem bevorzugten Ausführungsbeispiel werden mehrere erste Datenblöcke unter Verwendung ein oder mehrerer Datenstrukturtypen und ein oder mehrere Datenformatmuster in ein oder mehrere zweite Datenblöcke umgewandelt. Dadurch kann das unnötige mehrmalige Einlesen bzw. Analysieren erster Datenblöcke zur Umsetzung in mehrere verschiedene zweite Datenblöcke vermieden werden.</p><p id="p0023" num="0023">Besonders bevorzugt werden mehrere formatgleiche erste Datenblöcke unter Verwendung eines einzigen Datenstrukturtypen in ein oder mehrere zweite Datenblöcke umgewandelt. Durch die Umwandlung mehrerer formatgleicher erster Datenblöcke durch einen einzigen Datenstrukturtypen ist eine zeit- und kostensparende Umwandlung der ersten Datenblöcke<!-- EPO <DP n="7"> --> in den zumindest einen Datenblock möglich, da es lediglich einer Anpassung eines einzigen Datenstrukturtypen an das erste Datenformat der formatgleichen ersten Datenblöcke bedarf.</p><p id="p0024" num="0024">Weiterhin bevorzugt wird zur Erzeugung mehrerer formatgleicher zweiter Datenblöcke ein einziges Datenformatmuster verwendet. Auch hier ist eine zeit- und kostengünstige Umwandlung in die formatgleichen zweiten Datenblöcke möglich, da lediglich ein einziges Datenformatmuster an das zweite Datenformat dieser formatgleichen zweiten Datenblöcke anzupassen ist.</p><p id="p0025" num="0025">Besonders bevorzugt werden mehrere veränderte, aber formatgleiche erste Datenblöcke unter Verwendung des erfindungsgemäßen Verfahrens in ein oder mehrere veränderte, aber formatgleiche zweite Datenblöcke umgewandelt.</p><p id="p0026" num="0026">Dies stellt den in der Praxis den häufigsten Anwendungsfall des erfindungsgemäßen Verfahrens dar, der darin besteht, dass der Inhalt der zweiten Datenblöcke entsprechend den geänderten Inhalten erster Datenblöcke aktualisiert werden muss, wobei alle gegeben Datenformate gleich bleiben. In diesen Fall bewirkt ein Knopfdruck, der das erfindungsgemäße Verfahren zur Ausführung bringt, die Durchführung eines gesamten Prozessschrittes in Sekundenschnelle.</p><p id="p0027" num="0027">In einem bevorzugten Ausführungsbeispiel wird der zumindest eine erste Datenblock aus einer in der Speichereinheit abgelegten Eingangsdatei eingelesen und der zumindest eine zweite Datenblock nach seiner Erzeugung in eine Ausgangsdatei in der Speichereinheit geschrieben, wobei in einer Anweisungsliste festgelegt wird, welcher erster Datenblock aus welcher Eingangsdatei eingelesen und welcher zweiter Datenblock in welche Ausgangsdatei geschrieben wird und der zumindest eine Datenstrukturtyp bzw. das zumindest eine Datenformatmuster, die zur Umwandlung der Datenformate benötigt werden, referenziert sind. Alternativ hierzu kann der erste Datenblock auch als Datenstrom mit zeitlich aufeinanderfolgenden Datenblockbereichen vorliegen, der an einer Eingangsschnittstelle der Rechnereinheit eingelesen wird. Weiterhin kann auch der zweite Datenblock als Datenstrom an einer Ausgangsschnittstelle ausgegeben werden.</p><p id="p0028" num="0028">Besonders bevorzugt wird der zumindest eine Datenstrukturtyp und das zumindest eine Datenformatmuster vor ihrer Verwendung jeweils aus zumindest einer in der<!-- EPO <DP n="8"> --> Speichereinheit abgelegten Datei geladen und wird in einer Anweisungsliste festgelegt, welcher Datenstrukturtyp und/oder welches Datenformatmuster aus welcher Datei einzulesen ist. Das Einlesen des Datenformatmusters bzw. des Datenstrukturtypen aus der Speichereinheit der Rechnereinheit birgt den Vorteil, dass die Rechnereinheit erst zur Laufzeit des Programms instruiert wird, auf welche Art und Weise die Umwandlung des ersten Datenformats in das zweite Datenformat zu erfolgen hat. Dadurch ist eine äußerst flexible Anpassung des Verfahrens an die Gegebenheiten möglich. Ebenfalls kann die Anweisungsliste vor ihrer Ausführung aus einer in der Speichereinheit abgelegten Datei geladen werden.</p><p id="p0029" num="0029">In einem bevorzugten Ausführungsbeispiel ist jeder Datenstrukturinstanz genau ein korrespondierender Datenstrukturtyp zugeordnet. Damit wird eine Datenstrukturinstanz genau durch einen Datenstrukturtypen, und zwar durch deren variable Datenstrukturelemente gebildet, wobei in einer Datenstrukturinstanz jeweils nur Datenstrukturinstanzelemente bzw. Werte vorhanden sein können, die aus einem ersten Datenblock stammen.</p><p id="p0030" num="0030">Ebenso wird bevorzugt jeder zweite Datenblock durch genau ein korrespondierendes Datenformatmuster erzeugt. Dabei ist es auch hier möglich, dass mehrere zweite formatgleiche Datenblöcke durch ein einziges Datenformatmuster erzeugt werden.</p><p id="p0031" num="0031">Bei der Umwandlung des ersten Datenblocks in den zweiten Datenblock kann bevorzugt zumindest ein Wert eines Datenstrukturinstanzelements der zumindest einen ersten Datenstrukturinstanz durch zumindest eine Operation verändert werden, wobei die Operation Werte verschiedener Datenstrukturelemente verschiedener erster Datenstrukturinstanzen kombinieren kann. Insbesondere kann es sich dabei um arithmetische Operationen handeln oder Operationen, die eine Datentypumwandlung an Werten der Datenstrukturinstanzelemente vornehmen. Die so veränderte Datenstrukturinstanz kann anschließend zur Erzeugung des zweiten Datenblock verwendet werden.</p><p id="p0032" num="0032">Besonders bevorzugt können aus ein oder mehreren ersten Datenstrukturinstanzen durch ein oder mehrere Operationen ein oder mehrere zweite Datenstrukturinstanzen gebildet werden, die anschließend zur Erzeugung des zweiten Datenblocks verwendet werden.<!-- EPO <DP n="9"> --> Vergleichbar zu einer herkömmlichen Programmiersprache können diese Operationen zu einer wiederholt aufrufbaren Prozedur zusammengefasst werden, deren Parameter die Datenstrukturtypen der ersten und zweiten Datenstrukturinstanzen wiedergeben.</p><p id="p0033" num="0033">Besonders bevorzugt wird bei den einer Strukturkategorie als Strukturparameter übergebenen Datenstrukturelementen statt des Namen eines komplexen Datentypen unmittelbar die Definition eines komplexen Datenstrukturtypen angegeben. Somit kann innerhalb der Definition eines komplexen Datenstrukturtypen, und zwar insbesondere innerhalb der der Strukturkategorie übergebenen Strukturparameter ein weiterer komplexer Datenstrukturtyp definiert werden. Dies ist insbesondere dann vorteilhaft, wenn der komplexe Datenstrukturtyp nur einmalig verwendet werden soll.</p><p id="p0034" num="0034">In besondere Weise unterstützt das erfindungsgemäße Verfahren die Verarbeitung von sogenannten Whitespace-Zeichen, welches die Zeichen &lt;Zwischenraum&gt;, &lt;Tabulator&gt;, &lt;Wagenrücklauf&gt; und &lt;NeueZeile&gt; sind, in dem, wenn nicht extra ausgeschlossen, alle im ersten Datenblock einen Whitespace-Zeichen nachfolgenden Whitespace-Zeichen ignoriert werden.</p><p id="p0035" num="0035">Die Analyse eines ersten Datenblocks mittels eines ersten Datenstrukturtypen erfolgt sequenziell ab einer aktuellen Leseposition, wobei die aktuelle Leseposition die dem ersten Zeichen im ersten Datenblock nach dem zuletzt erkannten festen oder variablen Datenstrukturelement folgende Position ist. Dabei gelten feste Datenstrukturelemente als erkannt, wenn die Zeichenkette nach der Leseposition, unter oben genannter Sonderbehandlung von Whitespace-Zeichen, genau dem gegebenen Wert des festen Datenstrukturelements entspricht. Ein variables Datenstrukturelemente dagegen gilt als erkannt, wenn die Zeichenkette nach der Leseposition, unter oben genannter Sonderbehandlung von Whitespace-Zeichen, einen Wert repräsentiert, der dem Datentypen des variablen Datenstrukturelements entspricht.</p><p id="p0036" num="0036">Insbesondere wird vorteilhaft durch eine erste Strukturkategorie (SEQUENCE) festgelegt, dass sämtliche, als Strukturparameter übergebene Datenstrukturelemente, unter oben genannter Sonderbehandlung von Whitespace-Zeichen, nacheinander und in genau der angegeben Reihenfolge im ersten Datenblock an der aktuellen Einleseposition vorkommen müssen.<!-- EPO <DP n="10"> --></p><p id="p0037" num="0037">Weiterhin kann durch eine zweite Strukturkategorie (STREAM) festgelegt werden, dass sämtliche, als Strukturparameter übergebene Datenstrukturelemente, unter oben genannter Sonderbehandlung von Whitespace-Zeichen, nacheinander und in genau der angegeben Reihenfolge im ersten Datenblock nach der aktuellen Leseposition vorkommen müssen, wobei sich der Wert des Datenstrukturinstanzelements aus den Zeichen des ersten Datenblocks zwischen der aktuellen Leseposition und dem ersten nach der aktuellen Leseposition erkannten Datenstrukturelement ergibt. Durch die Verwendung der zweiten Strukturkategorie (STREAM) wird aus dem ersten Datenblock eine Zeichenkette ab der Leseposition gewonnen, der alle angegebenen Strukturparameter nacheinander und in genau der angegebenen Reihenfolge nachfolgen.</p><p id="p0038" num="0038">Ferner kann durch eine dritte Strukturkategorie (LIST) festgelegt werden, dass sämtliche als Strukturparameter übergebene Datenstrukturelemente, unter oben genannter Sonderbehandlung von Whitespace-Zeichen, nacheinander und in genau der angegeben Reihenfolge im ersten Datenblock an der aktuellen Leseposition mindestens einmal vorkommen müssen, aber wiederholt vorkommen können. Somit ist über diese dritte Strukturkategorie eine Abarbeitung von Listen möglich, deren Listenstruktur an sich bekannt ist, jedoch die Länge der Liste, d.h. die Anzahl der Listeneinträge unbekannt bzw. variabel ist.</p><p id="p0039" num="0039">Weiterhin kann durch eine vierte Strukturkategorie (OPTION) festgelegt werden, dass sämtliche, als Strukturparameter übergebene Datenstrukturelemente, unter oben genannter Sonderbehandlung von Whitespace-Zeichen, nacheinander in genau der angegeben Reihenfolge im ersten Datenblock an der aktuellen Leseposition höchstens einmal oder gar nicht vorkommen dürfen, wobei in der korrespondierenden Datenstrukturinstanz über eine Marke festgehalten wird, ob die Datenstrukturelemente im ersten Datenblock vorhanden sind oder nicht. Durch diese vierte Strukturkategorie ist es damit möglich, den ersten Datenblock daraufhin zu untersuchen, ob bestimmte Datenblockbereiche darin vorhanden sind oder nicht, wobei in der Datenstrukturinstanz durch die Marken, die insbesondere boolesche Variablen sind, feststellbar ist, ob der betreffende Datenblockbereich im ersten Datenblock enthalten war oder nicht.<!-- EPO <DP n="11"> --></p><p id="p0040" num="0040">Ferner kann durch eine fünfte Strukturkategorie (PERMUTATION) festgelegt werden, dass sämtliche als Strukturparameter übergebene Datenstrukturelemente eines komplexen Datenstrukturtypen, unter oben genannter Sonderbehandlung von Whitespace-Zeichen, im ersten Datenblock an der aktuellen Leseposition nacheinander genau einmal vorkommen müssen, die Reihenfolge aber beliebig ist. Durch diese fünfte Strukturkategorie ist es möglich, variablen Datenstrukturelementen einen bestimmten Datenblockbereich als Wert zuzuweisen, wobei die Positionen der Blockbereiche zwar grundsätzlich bekannt sind, jedoch nicht die Reihenfolge, in der diese im ersten Datenblock auftreten.</p><p id="p0041" num="0041">Des Weiteren kann durch eine sechste Strukturkategorie (CHOICE) festgelegt werden, dass unter vorgenannter Sonderbehandlung von Whitespace-Zeichen, genau eines der als Strukturparameter übergebenen Datenstrukturelemente des Datenstrukturtypen im ersten Datenblock an der aktuellen Leseposition vorkommen muss, wobei nur diesem ein Wert zugewiesen wird, und alle andern in der ersten Datenstrukturinstanz als nicht vorhanden markiert werden. Über diese sechste Strukturkategorie kann damit festgestellt werden, welches Datenstrukturelement einer Auswahl von als Strukturparameter übergebenen Datenstrukturelementen in dem ersten Datenblock vorhanden war.</p><p id="p0042" num="0042">Zudem kann durch eine siebte Strukturkategorie (NESTED), der als Strukturparameter ein erstes, optional ein mittleres und ein letztes Datenstrukturelement übergeben wird, festgelegt werden, dass unter vorgenannter Sonderbehandlung von Whitespace-Zeichen, der mit dem ersten Datenstrukturelement beginnende, das sofern vorhandene, mittlere, unmittelbar folgende und mit dem eventuell mit Abstand folgenden letzten Datenstrukturelement endende Datenblockbereich gesucht und als Wert einem Datenstrukturinstanzelement zugewiesen wird, wobei die Anzahl des auftretenden ersten Datenstrukturelements mit der Anzahl des Auftreten des letzten Datenstrukturelements identisch sein muss. Damit können Blöcke gefunden werden, die durch das erste und letzte Datenstrukturelement geklammert sind und ihrerseits solche Blöcke als Unterblock enthalten können, wobei nicht notwendigerweise die Struktur des gesamten Datenblockbereichs bekannt sein muss, sondern nur dessen Beginn und Ende. Dies ist insbesondere bei Klammerausdrücken vorteilhaft.</p><p id="p0043" num="0043">Insbesondere wird vorteilhaft durch eine achte Strukturkategorie (LINE) festgelegt, dass sämtliche, als Strukturparameter übergebene Datenstrukturelemente, unter vorgenannter<!-- EPO <DP n="12"> --> Sonderbehandlung von Whitespace-Zeichen, nacheinander und in genau der angegeben Reihenfolge im ersten Datenblock an der aktuellen Leseposition vorkommen müssen, und zwar innerhalb einer Zeile. Somit darf im ersten Datenblock nach der Lesesposition kein &lt;NeueZeile&gt;-Zeichen zwischen dem ersten und letzten als Strukturparameter übergebenen Datenstrukturelement auftreten. Damit wird in besonderer Weise ein zeilenorientiertes Datenformat des ersten Datenblocks unterstützt.</p><p id="p0044" num="0044">In einem bevorzugten Ausführungsbeispiel werden Teile des Datenformatmusters mittels Bedingungsanweisungen von der Erzeugung des zweiten Datenblocks ausgeschlossen. Dadurch ist es möglich, dass abhängig von Werten von Datenstrukturinstanzelementen oder dem Vorhandensein bestimmter Datenstrukturinstanzelemente bestimmte Ausgaben im zweiten Datenblock erzeugt werden. Ebenso können Wiederholungsanweisungen im Datenformatmuster vorgesehen sein, über die eine Verarbeitung von Elementen einer Liste erfolgt. So kann beispielsweise in der Datenstrukturinstanz eine Liste mit mehreren Listeneinträgen vorgesehen sein, die anschließend mittels der Wiederholungsanweisungen im Datenformatmuster zu entsprechenden Ausgaben im zweiten Datenblock führen.</p><p id="p0045" num="0045">In einem bevorzugten Ausführungsbeispiel wird in einem Datenformatmuster auf selbiges oder ein oder mehrere andere Datenformatmuster referenziert. So ist es möglich, dass aus einem Datenformatmuster heraus dasselbe Datenformatmuster erneut zur Erzeugung eines Datenblockabschnitts des zweiten Datenblocks verwendet wird. Dies setzt jedoch voraus, dass bei der Selbstreferenzierung eine Abbruchbedingung vorhanden ist, sodass keine unendliche Schleife entsteht. Die Referenzierung auf weitere Datenformatmuster birgt den Vorteil, dass das Ursprungs-Datenformatmuster, aus dem heraus die Referenzierung auf weitere Datenformatmuster erfolgt, übersichtlich bleibt und damit eine hohe Benutzerfreundlichkeit für den jeweiligen Softwareprogrammierer erreicht wird.</p><p id="p0046" num="0046">In einem bevorzugten Ausführungsbeispiel werden in einem Datenformatmuster lokal bekannte zweite Datenstrukturinstanzen erzeugt, deren Werte verändert und anschließend zur Generierung des zweiten Datenblocks weiterverwendet werden. So ist es beispielsweise möglich, die ursprünglich erzeugte erste Datenstrukturinstanz in der Speichereinheit zu erhalten und die Werteveränderung in der neu generierten, zweiten Datenstrukturinstanz vorzunehmen.<!-- EPO <DP n="13"> --></p><p id="p0047" num="0047">Besonders bevorzugt wird durch das zweite Datenformatmuster das zweite Datenformat des zweiten Datenblocks vorgegeben. Dadurch wird das sogenannte WYSIWYG-Prinzip (what you see is what you get) unterstützt. Insbesondere besteht das Datenformatmuster aus festen Datenformatelementen, die zumeist normaler Text sind, wobei diese festen Datenformatelemente unverändert und in der im Datenformatmuster angegebenen Reihenfolge in dem zweiten Datenblock ausgegeben werden. Insbesondere sind die festen Datenformatelemente nicht besonders gekennzeichnet, sondern ergeben sich aus den Zeichen zwischen den besonders gekennzeichneten variablen Datenformatelementen oder Befehlssequenzen. Die Unterscheidung der variablen Datenstrukturelemente und Befehlssequenzen von den festen Datenstrukturelementen erfolgt durch definierte, das variable Datenformatelement bzw. die Befehlssequenz einleitende und abschließende Zeichen, z.B. $. Dadurch wird eine äußerst benutzerfreundliche Umgebung geschaffen, da der Benutzer aus dem Datenformatmuster die Form des zweiten Datenblocks im Wesentlichen erkennen kann.</p><p id="p0048" num="0048">Eine weitere Besonderheit des erfindungsgemäßen Verfahrens besteht darin, dass IDs von Datenstrukturelementen über sogenannte Namens-Shortcuts angesprochen werden können. Dabei können am Anfang einer ID beliebig viele Namen weggelassen bzw. durch ein Sonderzeichen (z.B. '∼') ersetzt werden, solange aus den verbleibenden Namen die ID noch rekonstruierbar ist. Ist beispielsweise XXX:YYY:ZZZ eine ID, so wären :ZZZ, :YYY:ZZZ und XXX: ∼ :ZZZ gültige Namens-Shortcuts, sofern keine zweite ID existiert, mit der ein Namenskonflikt auftreten könnte.</p><p id="p0049" num="0049">Zur verbesserten Handhabung des Verfahrens ist bevorzugt ein graphischer Editor zur Erstellung bzw. Veränderung von Datenstrukturtypen vorgesehen, wobei in einem ersten Ausgabefenster ein erster Datenblock und in einem zweiten Ausgabefenster der zu bearbeitende Datenstrukturtyp dargestellt wird, wobei die mit den variablen Datenstrukturelementen des im zweiten Ausgabefenster dargestellten Datenstrukturtyps korrespondierenden variablen Datenblockbereiche des ersten Datenblocks im ersten Ausgabefenster durch Markierungen graphisch hervorgehoben werden. Mittels des graphischen Editors wird erreicht, dass ein Benutzer durch grafische Kenntlichmachung, beispielsweise durch farbige Hinterlegung der entsprechenden Bereiche erkennt, welche variablen Datenstrukturelemente des Datenstrukturtypen mit den entsprechenden<!-- EPO <DP n="14"> --> Datenblockbereichen des ersten Datenblocks in Verbindung stehen. Dadurch wird eine erhebliche Erleichterung in der Erstellung von Datenstrukturtypen erreicht.</p><p id="p0050" num="0050">Bevorzugt wird ein im zweiten Ausgabefenster markiertes Datenstrukturelement gleichzeitig mit dem korrespondierenden Datenblockbereich des ersten Datenblocks im ersten Ausgabefenster markiert und umgekehrt. So kann beispielsweise ein Benutzer ein variables Datenstrukturelement im zweiten Ausgabefenster durch eine entsprechende Benutzerinteraktion auswählen und erfährt über diese Auswahl und die dadurch angestoßene Markierung im ersten Datenblock, welcher Datenblockbereich desselben mit dem markierten Datenstrukturelement korrespondiert. Dadurch wird eine erleichterte Zuordnung der sich entsprechenden Bereiche in den unterschiedlichen Ausgabefenstern erreicht.</p><p id="p0051" num="0051">Des Weiteren führt eine Veränderung am Datenstrukturtypen im zweiten Ausgabefenster unmittelbar zur geänderten Darstellung der Markierungen im ersten Ausgabefenster. Dadurch werden die Markierungen automatisch an die entsprechenden Änderungen im Datenstrukturtypen angepasst.</p><p id="p0052" num="0052">Bevorzugt wird auch ein graphischer Editor zur Erstellung bzw. Veränderung von Datenformatmustern bereitgestellt, wobei in einem ersten Ausgabefenster das zu bearbeitende Datenformatmuster, in einem zweiten Ausgabefenster die den variablen Datenformatelementen des Datenformatmusters zugeordneten Werte von Datenstrukturinstanzelementen und in einem dritten Ausgabefenster der durch das Datenformatmuster erzeugte zweite Datenblock dargestellt wird, wobei im ersten Ausgabefenster die variablen Datenformatelemente und im dritten Ausgabefenster die mit diesen variablen Datenformatelementen korrespondierenden Datenblockbereiche des zweiten Datenblocks hervorgehoben werden. Dadurch kann der Benutzer unmittelbar durch die graphische Hervorhebung die jeweils miteinander korrespondierenden Datenformatelemente bzw. Datenblockbereiche des zweiten Datenblocks erkennen, was die Benutzerfreundlichkeit wiederum deutlich erhöht.</p><p id="p0053" num="0053">In einem bevorzugten Ausführungsbeispiel wird ein im ersten Ausgabefenster markiertes Datenformat gleichzeitig mit dem korrespondierenden Datenstrukturinstanzelement der Datenstrukturinstanz im zweiten Ausgabefenster und gleichzeitig mit dem<!-- EPO <DP n="15"> --> korrespondierenden Datenblockbereich des zweiten Datenblocks im dritten Ausgabefenster markiert und umgekehrt. Somit kann beispielsweise durch eine Benutzerinteraktion, die zu einer Markierung eines Datenformatelements im ersten Ausgabefenster führt, sowohl das von dem markierten Datenformatelement aufgegriffene Datenstrukturinstanzelement als auch der durch dieses Datenformatelement generierte korrespondierende Datenblockbereich auf der graphischen Benutzeroberfläche erkannt werden.</p><p id="p0054" num="0054">Weiterhin führt bevorzugt die Veränderung eines Wertes eines</p><p id="p0055" num="0055">Datenstrukturinstanzelements einer Datenstrukturinstanz in einem zweiten Ausgabefenster unmittelbar zur Veränderung des korrespondierenden Datenblockbereichs im zweiten Datenblock im dritten Ausgabefenster und umgekehrt. Damit werden die einander entsprechenden Bereiche bzw. der Datenblockbereich, der durch das veränderte Datenstrukturinstanzelement befüllt wird, an diese Veränderung des</p><p id="p0056" num="0056">Datenstrukturinstanzelements angepasst.</p><p id="p0057" num="0057">Der Ausdruck "im Wesentlichen" bedeutet im Sinne der Erfindung Abweichungen von jeweils exakten Werten um +/- 10%, bevorzugt um +/- 5% und/oder Abweichungen in Form von für die Funktion unbedeutenden Änderungen.</p><p id="p0058" num="0058">Weiterbildungen, Vorteile und Anwendungsmöglichkeiten der Erfindung ergeben sich auch aus der nachfolgenden Beschreibung von Ausführungsbeispielen und aus den Figuren. Dabei sind alle beschriebenen und/oder bildlich dargestellten Merkmale für sich oder in beliebiger Kombination grundsätzlich Gegenstand der Erfindung, unabhängig von ihrer Zusammenfassung in den Ansprüchen oder deren Rückbeziehung. Auch wird der Inhalt der Ansprüche zu einem Bestandteil der Beschreibung gemacht.</p><p id="p0059" num="0059">Die Erfindung wird nachfolgend anhand eines Ausführungsbeispiels im Zusammenhang mit den Figuren näher erläutert werden. Es zeigen
<dl id="dl0001" compact="compact"><dt>Fig. 1</dt><dd>beispielhaft das erfindungsgemäße Verfahren in einem ersten Ausführungsbeispiel in einer schematischen Blockbilddarstellung;<!-- EPO <DP n="16"> --></dd><dt>Fig. 2</dt><dd>beispielhaft das erfindungsgemäße Verfahren in einem zweiten Ausführungsbeispiel in einer schematischen Blockbilddarstellung;</dd><dt>Fig. 3</dt><dd>beispielhaft die Darstellung eines ersten Datenblocks als Text-Datei;</dd><dt>Fig. 4</dt><dd>beispielhaft die Darstellung eines Datenstrukturtypen als Text-Datei;</dd><dt>Fig. 5</dt><dd>beispielhaft die schematische Darstellung einer ersten Datenstrukturinstanz;</dd><dt>Fig. 6</dt><dd>beispielhaft die Darstellung eines Datenformatmusters als Text-Datei;</dd><dt>Fig. 7</dt><dd>beispielhaft die Darstellung einer Anweisungsliste als Text-Datei;</dd><dt>Fig. 8</dt><dd>beispielhaft die Darstellung eines zweiten Datenblocks als Text-Datei;</dd><dt>Fig. 9</dt><dd>beispielhaft die Verarbeitung mehrerer erster Datenblöcke in mehrere zweite Datenblöcke mittels des erfindungsgemäßen Verfahrens in einer schematischen Blockbilddarstellung;</dd><dt>Fig. 10</dt><dd>beispielhaft ein Datenstrukturtyp enthaltend die Strukturkategorie STREAM;</dd><dt>Fig. 11</dt><dd>beispielhaft die schematische Darstellung der durch den Datenstrukturtyp gemäß <figref idrefs="f0005">Fig. 10</figref> entstehenden Datenstrukturinstanz;</dd><dt>Fig. 12</dt><dd>beispielhaft ein Datenformatmuster zur Generierung eines zweiten Datenblocks fußend auf der Datenstrukturinstanz gemäß <figref idrefs="f0005">Fig. 11</figref>;</dd><dt>Fig. 13</dt><dd>beispielhaft der durch das Datenformatmuster gemäß <figref idrefs="f0005">Fig. 12</figref> generierte zweite Datenblock;</dd><dt>Fig. 14</dt><dd>beispielhaft ein erster Datenblock enthaltend eine Liste mit mehreren strukturell identisch aufgebauten Listenelementen;</dd><dt>Fig. 15</dt><dd>beispielhaft ein Datenstrukturtyp enthaltend die Strukturkategorie LIST zur Analyse des ersten Datenblocks gemäß <figref idrefs="f0006">Fig. 14</figref>;</dd><dt>Fig. 16</dt><dd>beispielhaft die durch den Datenstrukturtyp gemäß <figref idrefs="f0006">Fig. 15</figref> entstehende Datenstrukturinstanz;</dd><dt>Fig. 17</dt><dd>beispielhaft ein Datenformatmuster zur Generierung eines zweiten Datenblocks fußend auf der Datenstrukturinstanz gemäß <figref idrefs="f0006">Fig. 16</figref>;</dd><dt>Fig. 18</dt><dd>beispielhaft der durch das Datenformatmuster gemäß <figref idrefs="f0007">Fig. 17</figref> generierte zweite Datenblock;<!-- EPO <DP n="17"> --></dd><dt>Fig. 19</dt><dd>beispielhaft eine Anweisungsliste enthaltend arithmetische Operationen zur Veränderung der Werte der ersten Datenstrukturinstanz;</dd><dt>Fig. 20</dt><dd>beispielhaft der durch das Datenformatmuster gemäß <figref idrefs="f0007">Fig. 17</figref> und die Anweisungsliste gemäß <figref idrefs="f0008">Fig. 19</figref> generierte zweite Datenblock;</dd><dt>Fig. 21</dt><dd>beispielhaft ein im Datenformat umzuwandelnder erster Datenblock;</dd><dt>Fig. 22</dt><dd>beispielhaft ein Datenstrukturtyp enthaltend die Strukturkategorie OPTION zur Analyse des ersten Datenblocks gemäß <figref idrefs="f0009">Fig. 21</figref>;</dd><dt>Fig. 23</dt><dd>beispielhaft die durch den Datenstrukturtyp gemäß <figref idrefs="f0009">Fig. 22</figref> entstehende Datenstrukturinstanz;</dd><dt>Fig. 24</dt><dd>beispielhaft ein Datenformatmuster zur Generierung eines zweiten Datenblocks fußend auf der Datenstrukturinstanz gemäß <figref idrefs="f0009">Fig. 23</figref>;</dd><dt>Fig. 25</dt><dd>beispielhaft der durch das Datenformatmuster gemäß <figref idrefs="f0010">Fig. 24</figref> generierte zweite Datenblock;</dd><dt>Fig. 26</dt><dd>beispielhaft ein weiterer im Datenformat umzuwandelnder erster Datenblock;</dd><dt>Fig. 27</dt><dd>beispielhaft ein Datenstrukturtyp enthaltend die Strukturkategorie CHOICE zur Analyse des ersten Datenblocks gemäß <figref idrefs="f0011">Fig. 26</figref>;</dd><dt>Fig. 28</dt><dd>beispielhaft die durch den Datenstrukturtyp gemäß <figref idrefs="f0011">Fig. 27</figref> entstehende Datenstrukturinstanz;</dd><dt>Fig. 29</dt><dd>beispielhaft ein Datenformatmuster zur Generierung eines zweiten Datenblocks fußend auf der Datenstrukturinstanz gemäß <figref idrefs="f0012">Fig. 28</figref>;</dd><dt>Fig. 30</dt><dd>beispielhaft der durch das Datenformatmuster gemäß <figref idrefs="f0012">Fig. 29</figref> generierte zweite Datenblock;</dd><dt>Fig. 31</dt><dd>beispielhaft ein weiterer im Datenformat umzuwandelnder erster Datenblock;</dd><dt>Fig. 32</dt><dd>beispielhaft ein Datenstrukturtyp enthaltend einen rekursiven Selbstverweis zur Analyse des ersten Datenblocks gemäß <figref idrefs="f0013">Fig. 31</figref>;</dd><dt>Fig. 33</dt><dd>beispielhaft ein weiterer Datenstrukturtyp, aus dem heraus der Aufruf des Datenstrukturtypen gemäß <figref idrefs="f0013">Fig. 32</figref> erfolgt;</dd><dt>Fig. 34</dt><dd>beispielhaft die durch die Datenstrukturtypen gemäß <figref idrefs="f0013">Fig. 32 und Fig. 33</figref> entstehende Datenstrukturinstanz;<!-- EPO <DP n="18"> --></dd><dt>Fig. 35</dt><dd>beispielhaft ein Datenformatmuster zur Generierung eines zweiten Datenblocks fußend auf der Datenstrukturinstanz gemäß <figref idrefs="f0014">Fig. 34</figref>;</dd><dt>Fig. 36</dt><dd>beispielhaft ein weiteres Datenformatmuster, aus dem heraus der Aufruf des Datenformatmusters gemäß <figref idrefs="f0014">Fig. 35</figref> erfolgt;</dd><dt>Fig. 37</dt><dd>beispielhaft das durch die Datenformatmuster gemäß <figref idrefs="f0014">Fig. 35 und Fig. 36</figref> entstehende zweite Datenformat;</dd><dt>Fig. 38</dt><dd>beispielhaft die verwendete Anweisungsliste zur Erzeugung des zweiten Datenblocks gemäß <figref idrefs="f0015">Fig. 37</figref> aus dem ersten Datenblock gemäß <figref idrefs="f0013">Fig. 31</figref> unter Verwendung der Datenstrukturtypen gemäß <figref idrefs="f0013">Fig. 32 und Fig. 33</figref>, sowie den Datenformatmustern gemäß <figref idrefs="f0014">Fig. 35 und Fig. 36</figref>.</dd><dt>Fig. 39</dt><dd>beispielhaft die Darstellung eines grafischen Editors zur Bearbeitung eines Datenstrukturtypen;</dd><dt>Fig. 40</dt><dd>beispielhaft die Darstellung eines grafischen Editors zur Bearbeitung eines Datenformatmusters;</dd></dl></p><p id="p0060" num="0060"><figref idrefs="f0001">Figur 1</figref> zeigt in einer schematischen Blockdarstellung das erfindungsgemäße Verfahren zur Umsetzung zumindest eines ersten Datenblocks 1, der ein erstes Datenformat aufweist, in zumindest einen zweiten Datenblock 2, der ein zweites Datenformat aufweist, wobei der erste Datenblock 1 in einem ersten Schritt unter Verwendung eines Datenstrukturtypen 3 in eine erste Datenstrukturinstanz 6 und in einem zweiten Schritt diese unter Verwendung eines Datenformatmusters 7 in den zweiten Datenblock 2 umgesetzt wird. Die Implementierung des Verfahrens erfolgt vorzugsweise in einer Rechnereinheit mit zumindest einer Prozessoreinheit und einer Speichereinheit, wobei durch diese Rechnereinheit der erste Datenblock 1 eingelesen und nach der Umsetzung in den zweiten Datenblock dieser zweite Datenblock 2 durch die Rechnereinheit ausgegeben wird. Der erste Datenblock 1 kann hierbei aus einer Datei eingelesen werden, es kann aber auch ein Datenstrom sein, der beispielsweise der Rechnereinheit an einer Schnittstelle zugeführt wird. Ebenso kann der zweite Datenblock 2 in eine Datei geschrieben werden oder als Datenstrom ausgegeben werden.</p><p id="p0061" num="0061">Die Umsetzung des ersten Datenblocks 1 in eine Datenstrukturinstanz 3 erfolgt durch Abbildung des ersten Datenformats des ersten Datenblocks 1 durch zumindest einen<!-- EPO <DP n="19"> --> Datenstrukturtypen 3, durch den im ersten Datenblock 1 feste Datenstrukturelemente 3.1 und variable Datenstrukturelemente 3.2 definiert werden. Den durch den Datenstrukturtypen 3 definierten variablen Datenstrukturelementen 3.2 wird hierbei im Datenstrukturtypen 3 jeweils ein Datentyp 4 zugewiesen. Ferner wird mindestens einem variablen Datenstrukturelement 3.2 zudem ein Elementname 5 zugewiesen. Anschließend wird in der Rechnereinheit, insbesondere im Prozessor, der erste Datenblock 1 analysiert, wobei unter Verwendung bzw. orientiert an den festen Datenstrukturelementen 3.1 und unter Verwendung des Datentypen 4 der variablen Datenstrukturelemente 3.2 aus dem ersten Datenblock 1 zumindest eine erste Datenstrukturinstanz 6 erzeugt wird. Diese erste Datenstrukturinstanz 6 enthält nach dem Analysevorgang die dem Datenstrukturtypen 3 entsprechenden Datenstrukturinstanzelemente 6.1 mit den Werten aus Datenblock 1. Auf die einzelnen Werte der Datenstrukturinstanzelemente 6.1 kann über den jeweiligen Elementnamen 5 bzw. die ID direkt zugegriffen werden kann.</p><p id="p0062" num="0062">Anschließend wird durch die Rechnereinheit der zweite Datenblock 2 aus einem Datenformatmuster 7, durch das die Struktur des zweiten Datenblocks 2 vorgegeben wird, unter Verwendung der ersten Datenstrukturinstanz 6 erzeugt. Das Datenformatmuster weist hierbei feste Datenformatelemente 7.1 und variable Datenformatelemente 7.2 auf, wobei die variablen Datenformatelemente 7.2 über den Elementnamen 5 oder die ID auf einen Wert eines Datenstrukturinstanzelements 6.1 der ersten Datenstrukturinstanz 6 verweisen. Die festen Datenformatelemente 7.1 hingegen erscheinen unverändert im zweiten Datenblock 2.</p><p id="p0063" num="0063">In <figref idrefs="f0001">Figur 2</figref> ist ein zweites Ausführungsbeispiel des erfindungsgemäßen Verfahrens gezeigt. Der wesentliche Unterschied zu dem in <figref idrefs="f0001">Figur 1</figref> gezeigten Verfahren besteht darin, dass die erste Datenstrukturinstanz 6 in eine zweite, von der ersten Datenstrukturinstanz 6 abgeleitete Datenstrukturinstanz 8 überführt wird und zwar durch Zusammenwirken mit einer Anweisungsliste 9, mittels der beispielsweise aus den Werten der Datenstrukturinstanzelemente 6.1 der ersten Datenstrukturinstanz 6 die Werte der Datenstrukturinstanzelemente der zweiten Datenstrukturinstanz 8 berechnet werden. Der zweite Datenblock 2 wird anschließend aus der zweiten Datenstrukturinstanz 8 unter Verwendung eines Datenformatmusters 7 erzeugt. Ferner kann in der Anweisungsliste 9 festgelegt werden, aus welcher Eingangsdatei oder welcher Eingangsschnittstelle der erste Datenblock1 einzulesen ist oder in welche Ausgangsdatei der zweite Datenblock 2<!-- EPO <DP n="20"> --> geschrieben werden soll bzw. an welcher Ausgangsschnittstelle der zweite Datenblock 2 auszugeben ist.</p><p id="p0064" num="0064">Im Folgenden soll anhand der <figref idrefs="f0002 f0003 f0004">Figuren 3 bis 8</figref> das erfindungsgemäße Verfahren anhand eines grundlegenden Beispiels veranschaulicht werden, bei dem ein in <figref idrefs="f0002">Figur 3</figref> gezeigter erster Datenblock 1 in einen in <figref idrefs="f0004">Figur 8</figref> gezeigten, zweiten Datenblock 2 umgewandelt wird.</p><p id="p0065" num="0065">In <figref idrefs="f0002">Figur 4</figref> ist ein Ausführungsbeispiel eines Datenstrukturtypen 3 zu dem in <figref idrefs="f0002">Figur 3</figref> dargestellten ersten Datenblock 1 gezeigt. Durch den Datenstrukturtypen 3 werden feste, Datenstrukturelemente 3.1, die sowohl in <figref idrefs="f0002">Figur 3</figref> als auch in <figref idrefs="f0002">Figur 4</figref> als schraffierte Felder eingezeichnet sind und variable Datenstrukturelemente 3.2 definiert, die in <figref idrefs="f0002">Figuren 3 und 4</figref> durch Umrahmungen hervorgehoben sind.</p><p id="p0066" num="0066">Mittels des Datenstrukturtypen 3 wird das erste Datenformat des ersten Datenblocks 1 abgebildet, wobei die festen Datenstrukturelemente 3.1 dazu dienen, mittelbar den Ort der variablen Datenstrukturelementen 3.2 im ersten Datenblock 1 zu definieren und diese variablen Datenstrukturelemente 3.2 beim Analysieren des ersten Datenblocks 1 aufzufinden. Beispielsweise beginnt der erste Datenblock 1, wie im Datenstrukturtypen 3 definiert mit einem Block von festen Datenstrukturelementen 3.1 ("# Begin of file ... graphical editor"). Anschließend wird im Datenstrukturtypen 3 definiert, dass ein weiteres, festes Datenstrukturelement 3.1, beispielsweise die Zeichenkette "Name=" folgt. Daran schließt sich ein variables Datenstrukturelement 3.2 an, und zwar im gezeigten Ausführungsbeispiel vom elementaren Datentypen 4 "STRING", d.h. einer Zeichenkette, wobei der Zeichenkette der Elementname 5 "NAME" zugeordnet wird. Damit wird beispielsweise die im ersten Datenblock 1 enthaltene, nach dem festen Datenstrukturelement 3.1 'Name=' folgende Zeichenkette "BlinkingSymbol" in der Datenstrukturinstanz 6 dem variablen Datenstrukturelement "NAME" 5 als konkreter Wert zugeordnet.</p><p id="p0067" num="0067">Im gezeigten Ausführungsbeispiel werden im ersten Datenblock 1 weitere Werte für variable Datenstrukturelemente 3.2 durch den ersten Datenstrukturtypen 3 definiert und zwar beispielsweise das Datenstrukturelement mit Namen 5 'FIGURE' und elementaren Datentyp "STRING" dem in der Datenstrukturinstanz 6 die Zeichenkette "circle" als Wert<!-- EPO <DP n="21"> --> zugewiesen wird, sowie das Datenstrukturelement mit Namen 5 'TOP' und elementaren Datentyp "INTEGER", dem in der Datenstrukturinstanz 6 die Zahl "0" als Wert zugewiesen wird usw..</p><p id="p0068" num="0068">Beim Analysieren des ersten Datenblocks 1 unter Verwendung des Datenstrukturtypen 3 wird die in <figref idrefs="f0003">Figur 5</figref> gezeigte erste Datenstrukturinstanz 6 gebildet, die im gezeigten Ausführungsbeispiel sechs Datenstrukturinstanzelemente 6.1 aufweist, wobei jedes dieser Datenstrukturinstanzelemente 6.1 jeweils einen Elementnamen 5 und einen diesem Elementnamen 5 zugeordneten Wert aufweist. So enthält beispielsweise die erste Datenstrukturinstanz 6 das Datenstrukturinstanzelement 6.1 mit dem Elementnamen 5 "LEFT", dem der Integer-Wert "0" zugeordnet ist. Auf die einzelnen Werte der Datenstrukturinstanzelemente kann über den jeweiligen Elementnamen 5 eindeutig zugegriffen werden.</p><p id="p0069" num="0069">Der in <figref idrefs="f0004">Figur 8</figref> gezeigte zweite Datenblock 2 wird unter Verwendung des in <figref idrefs="f0003">Figur 6</figref> gezeigten Datenformatmusters 7 und unter Verwendung der ersten Datenstrukturinstanz 6 (<figref idrefs="f0003">Figur 5</figref>) erzeugt. Das Datenformatmuster 7 (<figref idrefs="f0003">Figur 6</figref>) definiert feste, durch Schraffierungen gekennzeichnete Datenformatelemente 7.1 und variable, durch Umrahmungen gekennzeichnete Datenformatelemente 7.2, wobei den variablen Datenformatelementen 7.2 unter Verwendung einer Datenstrukturinstanz, beispielsweise der ersten Datenstrukturinstanz 6 (<figref idrefs="f0003">Figur 5</figref>) über den Elementnamen 5 Werte zugewiesen werden. Das Datenformatmuster 7 legt hierbei über die festen und variablen Datenformatelemente 7.1, 7.2 das zweite Datenformat des zweiten Datenblocks 2 fest. Den variablen Datenformatelementen 7.2 werden Werte aus der ersten Datenstrukturinstanz 6 oder einer davon abgeleiteten zweiten Datenstrukturinstanz 8 zugeordnet, wobei die Wertezuweisung über den Elementnamen 5 eines Datenstrukturinstanzelements 6.1 erfolgt. So wird beispielsweise dem in <figref idrefs="f0003">Figur 6</figref> gezeigten Datenformatmuster 7 eine erste Datenstrukturinstanz 6 des Datenstrukturtypen "Example_Type" übergeben, wobei dieser Datenstrukturinstanz 6 der Name "DataStruct2" zugeordnet wird. Innerhalb des Datenformatmusters 7 erfolgt anschließend die Belegung der variablen Datenformatelemente 7.2 mit Werten durch Verweis auf den Elementnamen 5 des jeweiligen Datenstrukturinstanzelements 6.1 der übergebenen Datenstrukturinstanz 6. Dadurch werden den in <figref idrefs="f0003">Figur 6</figref> durch Umrahmungen gekennzeichneten, variablen<!-- EPO <DP n="22"> --> Datenformatelementen 7.2 Werte der ersten Datenstrukturinstanz 6 oder einer davon abgeleiteten, zweiten Datenstrukturinstanz 8 zugewiesen.</p><p id="p0070" num="0070"><figref idrefs="f0003">Figur 7</figref> zeigt eine Anweisungsliste 9, in der Anweisungen zur Umsetzung des ersten Datenblocks 1 in den zweiten Datenblock 2 enthalten sind. Nach einer Dateiverzeichnispfadfestlegung wird zunächst der Datenstrukturtyp 3 "Example_Type" und das Datenformatmuster 7 "Example_Pattern" geladen. Anschließend wird der erste Datenblock 1 eingelesen und daraus die erste Datenstrukturinstanz 6 "DataStruct1" durch Analysieren des ersten Datenblocks 1 erzeugt. Anschließend wird der zweite Datenblock 2 erzeugt, und zwar gemäß dem im Datenformatmuster 7 definierten zweiten Datenformat, wobei dazu die erste Datenstrukturinstanz 6 'DataStruct1' verwendet wird und, wie zuvor beschrieben, die variablen Datenformatelemente 7.2 mit Werten aus der ersten Datenstrukturinstanz 6 befüllt werden. Zuletzt erfolgt die Ausgabe des zweiten Datenblocks 2, und zwar im gezeigten Ausführungsbeispiel in eine Textdatei 'DataBlock2.txt', deren abschließender Inhalt in <figref idrefs="f0004">Figur 8</figref> dargestellt ist.</p><p id="p0071" num="0071">In <figref idrefs="f0004">Figur 9</figref> ist ein weiteres Ausführungsbeispiel des erfindungsgemäßen Verfahrens gezeigt, bei dem mehrere erste Datenblöcke 1 in mehrere zweite Datenblöcke 2 umgewandelt werden. Im gezeigten Ausführungsbeispiel werden drei erste Datenblöcke 1 eingelesen und zwar vorzugsweise parallel. Zwei dieser ersten Datenblöcke 1 weisen dabei dasselbe Datenformat auf und werden durch einen einzigen Datenstrukturtypen 3 beschrieben. Der weitere erste Datenblock 1 wird durch einen weiteren Datenstrukturtyp 3 beschrieben, sodass lediglich zwei Datenstrukturtypen 3 bei der Umwandlung der ersten Datenblöcke 1 in die zweiten Datenblöcke 2 Verwendung finden. Anschließend werden die ersten Datenblöcke 1 mittels der ihnen zugeordneten Datenstrukturtypen 3 analysiert und die mittels des Datenstrukturtypen 3 ermittelten Werte der variablen Datenstrukturelemente 3.2 in den ersten Datenstrukturinstanzen 6 abgelegt. Hierbei ist jedem ersten Datenblock 1 eine derartige Datenstrukturinstanz 6 zugeordnet. Anschließend werden unter Verwendung von drei Datenformatmustern 7 die drei zweiten Datenblöcke 2 generiert, wobei diese Datenblöcke 2 jeweils unterschiedliche zweite Datenformate aufweisen. Diese zweiten Datenformate werden in den jeweiligen Datenformatmustern 7 beschrieben und durch Zugriff auf die Werte der Datenstrukturinstanzelemente 6.1 der jeweiligen ersten Datenstrukturinstanzen 6 generiert. Somit können parallel mehrere erste Datenblöcke 1 in mehrere zweite Datenblöcke 2 umgesetzt werden, wobei in Abhängigkeit der Anzahl der<!-- EPO <DP n="23"> --> unterschiedlichen ersten bzw. zweiten Datenformate die Anzahl der Datenstrukturtypen 3 bzw. der Datenformatmuster 7 variiert. Dabei ist jeder Datenstrukturinstanz 6 genau ein korrespondierender Datenstrukturtyp 3 zugeordnet, wobei mehreren Datenstrukturinstanzen 6 der gleiche Datenstrukturtyp 3 zugeordnet sein kann, und zwar dann, wenn mehrere parallel zu verarbeitende erste Datenblöcke 1 ein identisches erstes Datenformat aufweisen und dadurch durch einen identischen Datenstrukturtypen 3 abgebildet werden können. Ebenso ist jedem zweiten Datenblock 2 genau ein korrespondierendes Datenformatmuster 7 zugeordnet, das quasi als Bildungsvorschrift für das zweite Datenformat des zweiten Datenblocks 2 dient. Wie zuvor dargelegt, kann ein einziges Datenformatmuster 7 zur Erzeugung mehrerer zweiter Datenblöcke 2 dienen, wenn das zweite Datenformat dieser zweiten Datenblöcke 2 identisch ist.</p><p id="p0072" num="0072">Die variablen Datenstrukturelemente 3.2 können, wie beispielsweise in <figref idrefs="f0002">Figur 4</figref> gezeigt elementare Datentypen, die aus herkömmlichen Programmiersprachen hinlänglich bekannt sind, beispielsweise ganze Zahlen (INTEGER), natürliche Zahlen (NATURAL), Zeichenketten (STRING), boolesche Werte (BOOL) etc. sein. Jedoch können die variablen Datenstrukturelemente 3.2 auch eine komplexere Struktur bzw. einen komplexeren Aufbau aufweisen, der durch reguläre Datentypen oder komplexe Datenstrukturtypen beschrieben werden kann. Ein regulärer Datentyp wird hierbei über einen regulären Ausdruck beschrieben, der als Filterkriterium bei der Analyse des ersten Datenblocks 1 dient. Dabei wird ein Bereich des ersten Datenblocks 1 mit dem regulären Ausdruck geprüft und bei Auffinden einer zum regulären Ausdruck passenden Zeichenkette diese dem Datenstrukturelement als Wert zugewiesen. So kann beispielsweise ein erster Datenblock 1 nach fünf Ziffern aufweisenden Zahlen durchsucht werden, wobei der Zahlenwert selbst zunächst keine Bedeutung hat. Derartige fünfziffrige Zahlen können beispielsweise Postleitzahlen sein. Diese im ersten Datenblock 1 gefundene, fünfziffrige Zahl wird anschließend beispielsweise einem Datenstrukturelement 3.2 mit Namen 5 "PLZ" in der ersten Datenstrukturinstanz als Wert zugewiesen.</p><p id="p0073" num="0073">Zudem kann der Datentyp 4, der einem variablen Datenstrukturelement 3.2 zugeordnet ist, ein komplexer Datenstrukturtyp sein. Den komplexen Datenstrukturtypen ist jeweils eine Strukturkategorie SK zugeordnet. Derartige vordefinierte Strukturkategorien SK sind beispielsweise die Strukturkategorien SEQUENCE, STREAM, LIST, OPTION, PERMUTATION, CHOICE etc.. Der jeweiligen Strukturkategorie SK werden zumindest ein<!-- EPO <DP n="24"> --> festes oder ein variables Datenstrukturelement 3.1, 3.2 oder eine Anordnung aus festen und/oder variablen Datenstrukturelementen 3.1, 3.2 als Strukturparameter SP übergeben,. Die als Strukturparameter SP übergebenen variablen Datenstrukturelemente 3.2 sind entweder von einem elementaren Datentyp, einem regulären Datentyp oder einem komplexen Datenstrukturtypen. Über die Strukturkategorie SK wird dabei festgelegt, wie als übergebene Strukturparameter zur Analyse des ersten Datenblocks 1 und Erzeugung zumindest eines Datenstrukturinstanzelements 6.1 verwendet werden. Die Strukturkategorie SK gibt damit ein Kriterium vor, auf welche Art und Weise, in welcher Anordnung bzw. in welcher Reihenfolge die übergebenen Strukturparameter SP im Datenblock 1 vorkommen.</p><heading id="h0001">Nachfolgend werden unterschiedliche, vordefinierte Strukturkategorien SK anhand der Figuren 3 ― 38 näher erläutert:</heading><p id="p0074" num="0074">Der gemäß <figref idrefs="f0002">Figur 4</figref> definierte Datenstrukturtyp 3verwendet die Strukturkategorie SK SEQUENCE. Dieser Strukturkategorie SK werden in geschweiften Klammern als Strukturparameter SP eine Anordnung von festen und variablen Datenstrukturelementen 3.1, 3.2 übergeben, und zwar die mit Apostroph geklammerten festen Datenstrukturelemente '#Begin of file,' ...,'#End of file'. Über die Strukturkategorie SK SEQUENCE wird definiert, dass in dem eingelesenen ersten Datenblock 1 die als Strukturparameter SP übergebenen festen und variablen Datenstrukturelemente 3.1, 3.2 exakt in dieser Form und dieser Anordnung im ersten Datenblock 1 enthalten sein müssen. Durch die Strukturkategorie SK SEQUENCE kann damit ein erster Datenblock 1 nach einer sequentiellen Anordnung aus festen und variablen Datenstrukturelementen 3.1, 3.2 durchsucht werden.</p><p id="p0075" num="0075">Im Folgenden soll anhand der <figref idrefs="f0005">Figuren 10</figref> ― 13 die Verwendung der Strukturkategorie SK STREAM beschrieben werden. Dieser wird, wie in <figref idrefs="f0005">Figur 10</figref> gezeigt, das feste Datenstrukturelement '#End of file' als Strukturparameter SP übergeben.. Die Strukturkategorie SK STREAM legt fest, dass beim Analysieren des ersten Datenblocks 1 ab der aktuellen Leseposition sämtliche Zeichen bis zum erstmaligen Auftreten des festen Datenstrukturelement '#End of file' eingelesen und die Zeichenkette ab der aktuellen Lesesposition bis zum Begin der Zeichenkette '#End of file' dem variablen Datenstrukturelement,TEXT' als Wert zugewiesen wird. Dabei ist die aktuelle Leseposition<!-- EPO <DP n="25"> --> stets durch das erste Zeichen nach dem zuletzt gelesenen gültigen Datenstrukturelement bestimmt.</p><p id="p0076" num="0076">Im gezeigten Ausführungsbeispiel wird die Anweisungsliste gemäß <figref idrefs="f0003">Fig. 7</figref> verwendet und dabei der in <figref idrefs="f0002">Figur 3</figref> gezeigte erste Datenblock 1 unter Verwendung des Datenstrukturtypen aus <figref idrefs="f0005">Figur 10</figref> gelesen, wobei das vor dem variablen Datenstrukturelement 3.2 'TEXT' mit Strukturkategorie SK STREAM stehende feste Datenstrukturelement 3.1 ('#This file is exported by a graphical editor') die aktuelle Leseposition auf das erste nachfolgende Zeichen setzt und damit den Anfang für den Wert des nachfolgend zu lesenden Datenstrukturelements festlegt. Das als Strukturparameter SP übergebene feste Datenstrukturelement 3.1 ('#End of file') dagegen definiert das Ende des Lesens. Somit wird durch den STREAM-Befehl der zwischen den genannten festen Datenstrukturelementen 3.1 liegende Bereich des ersten Datenblocks 1 als Wert in der ersten Datenstrukturinstanz 6 dem variablen Datenstrukturelement mit Namen 5 ("TEXT") zugewiesen (<figref idrefs="f0005">Figur 11</figref>).</p><p id="p0077" num="0077">Anschließend wird der in <figref idrefs="f0005">Figur 13</figref> gezeigte Datenblock 2 unter Verwendung des Datenformatmusters 7 (<figref idrefs="f0005">Fig. 12</figref>) und der in <figref idrefs="f0003">Figur 7</figref> gezeigten Anweisungsliste 9 erzeugt, wobei die in der ersten Datenstrukturinstanz 6 abgelegten Datenstrukturinstanzelemente Verwendung finden.. Beispielsweise wird über das Datenformatelement $DataStruct2:TEXT$ auf den Wert des Datenstrukturelements mit dem Namen 5 "TEXT" der ersten Datenstrukturinstanz 6 zugegriffen. Dieser Wert ist eine Zeichenkette, die an der entsprechenden Stelle im zweiten Datenblock 2 eingefügt wird. Über die Strukturkategorie SK STREAM ist es damit möglich, bestimmte, zwischen Datenstrukturelementen liegende Bereiche des Datenblocks herauszugreifen und variablen Datenstrukturinstanzelementen der ersten Datenstrukturinstanz 6 als Wert zuzuweisen.</p><p id="p0078" num="0078">Nachfolgend soll anhand der <figref idrefs="f0006">Figuren 14</figref> ― 18 die Verwendung der Strukturkategorie SK LIST zur Abarbeitung von Listen mit einer definierten Listenstruktur beschrieben werden.</p><p id="p0079" num="0079">In <figref idrefs="f0006">Figur 14</figref> ist der einzulesende erste Datenblock 1 gezeigt. Dieser enthält im Mittelteil eine Liste 30 bestehend aus mehreren Listenelementen 31, 31', 31 ". Die einzelnen Listenelemente 31, 31', 31" enthalten jeweils mehrere Listenunterelemente, die anschließend weiter verwendet werden sollen. Dieser erste Datenblock 1 wird mittels des Datenstrukturtypen 3 gemäß <figref idrefs="f0006">Figur 15</figref> analysiert. Der Datenstrukturtyp 3 verwendet hierbei<!-- EPO <DP n="26"> --> die Strukturkategorie SK LIST, wobei dieser als Strukturparameter SP der strukturelle Aufbau der Listenelemente 31, 31', 31" übergeben wird, wobei jeweils die nach den festen Datenstrukturelementen 3.1 folgenden variablen Datenstrukturelemente 3.2 aus einem Datentyp 4 und einem Namen 5 bestehen. Beim Analysieren des ersten Datenblocks 1 anhand des Datenstrukturtypen 3 wird mittels der Strukturkategorie SK "LIST" nach einer Liste von Elementen gesucht, die die durch die Strukturparameter SP definierte Form aufweisen. Dabei wird eine in <figref idrefs="f0006">Figur 16</figref> gezeigte erste Datenstrukturinstanz 6 erzeugt, die ebenfalls listenförmig ist und die beim Analysieren ermittelten Werte der variablen Datenstrukturelemente 3.2 des ersten Datenblocks 1 aufzeigt. Der wesentliche Aspekt der Strukturkategorie LIST besteht dabei darin, dass die Länge der einzulesenden Liste 30 nicht definiert sein muss. Dies ist ein wesentlicher Unterschied zu herkömmlichen Programmiersprachen und den darin verwendeten sogenannten Array-Befehl. Die einzulesende Liste 30 kann eine beliebige, zuvor nicht festzulegende Länge aufweisen, wobei jeweils beim Auffinden eines neuen Listenelements 31, 31', 31" der benötigte Speicherplatz allokiert wird.</p><p id="p0080" num="0080">Die Umsetzung des ersten Datenblocks 1 in den zweiten Datenblock 2 (<figref idrefs="f0007">Figur 18</figref>) erfolgt mittels dem in <figref idrefs="f0007">Figur 17</figref> gezeigten Datenformatmuster 7 sowie der in <figref idrefs="f0003">Figur 7</figref> gezeigten Anweisungsliste 9. Der Zugriff auf die einzelnen Werte der ersten Datenstrukturinstanz 6 erfolgt jeweils über eine Verkettung der Namen der Datenstrukturelemente zu einer eindeutigen ID, beispielsweise $DataStruct2:OBJECT:NAME$, wobei "DataStruct2" die übergebene Datenstrukturinstanz, "OBJECT" der Name der Gesamtliste und "NAME" der Name des ersten Datenstrukturelements darin ist. Wie in <figref idrefs="f0007">Figur 17</figref> gezeigt, findet in dem Datenformatmuster 7 ein sogenannter BEGIN-ALL-Befehl Verwendung, wobei durch diesen Befehl nacheinander sämtliche Zeilen der Liste abgearbeitet werden. Damit wird der zweite Datenblock 2 mit den entsprechenden Werten der Datenstrukturinstanzelemente 6.1 gefüllt.</p><p id="p0081" num="0081">Das Ausführungsbeispiel gemäß <figref idrefs="f0008">Figur 19 und 20</figref> greift das zuvor beschriebene Ausführungsbeispiel auf und verwendet insbesondere den in <figref idrefs="f0006">Figur 14</figref> dargestellten ersten Datenblock 1, das in <figref idrefs="f0006">Figur 15</figref> dargestellte Datenstrukturmuster 3 und die in <figref idrefs="f0006">Figur 16</figref> dargestellte erste Datenstrukturinstanz 6. Der wesentliche Unterschied zu dem zuvor beschriebenen Ausführungsbeispiel besteht darin, dass die Anweisungsliste 9 den durch die Umrahmung gekennzeichneten Befehlsblock 40 enthält, der eine Veränderung der in<!-- EPO <DP n="27"> --> der ersten Datenstrukturinstanz 6 beinhalteten Werte hervorruft. Somit kann innerhalb der Anweisungsliste 9 durch Operationen, insbesondere arithmetische Operationen ein Wert eines Datenstrukturinstanzelements 6.1 verändert werden, sodass nicht nur eine Umsetzung des Formats des ersten Datenblocks 1 in das Format des zweiten Datenblocks 2 erfolgt, sondern gleichzeitig eine Veränderung der Werte von Datenstrukturinstanzelementen 6.1. Wie in <figref idrefs="f0008">Figur 20</figref> im Vergleich zu <figref idrefs="f0007">Figur 18</figref> ersichtlich, wird im gezeigten Ausführungsbeispiel durch die arithmetische Operation eine Wertveränderung an der Position eines graphischen Objekts durch Addition des Wertes 1000 vorgenommen.</p><p id="p0082" num="0082">Das Ausführungsbeispiel der <figref idrefs="f0009">Figuren 21</figref> ― 25 dient der Erklärung der Strukturkategorie SK OPTION. Die Strukturkategorie SK OPTION dient zur Feststellung, ob die als Strukturparameter SP übergebenen Datenstrukturelemente 3.1, 3.2 an der Leseposition im ersten Datenblock 1 nacheinander in genau der angegebenen Reihenfolge im vorkommen oder nicht. In dem in <figref idrefs="f0009">Figur 22</figref> gezeigten Datenstrukturtyp 3 ist die Strukturkategorie SK OPTION enthalten, der mehrere Datenstrukturelemente 3.1, 3.2 als Strukturparameter SP übergeben werden. Der Strukturkategorieaufruf ist zwischen zwei festen Datenstrukturelementen 3.1 angeordnet, und zwar zwischen '#This file is exported by a graphical editor' und '#End of file'.</p><p id="p0083" num="0083">Beim Analysieren des ersten Datenblocks (<figref idrefs="f0009">Figur 21</figref>) wird festgestellt, ob an der Leseposition, die als Strukturparameter SP übergebenen Datenstrukturelemente 3.1, 3.2 nacheinander und in genau der angegebenen Reihenfolge im ersten Datenblock 1 vorkommen. Da der in <figref idrefs="f0009">Figur 21</figref> gezeigte erste Datenblock 1 nicht die als Strukturparameter SP übergebenen Datenstrukturelemente 3.1, 3.2 aufweist, wird in der ersten Datenstrukturinstanz 6 über eine Marke 6.2 (FALSE) festgehalten, dass die über die Strukturkategorie SK "OPTION" definierte Anordnung von Datenstrukturelementen 3.1, 3.2 im ersten Datenblock 1 an der Leseposition nicht vorhanden war. Die Generierung des zweiten Datenblocks 2 erfolgt unter Verwendung des Datenformatmusters 7 (<figref idrefs="f0010">Fig. 24</figref>) sowie der Anweisungsliste 9 gemäß <figref idrefs="f0003">Figur 7</figref>. In dem Datenformatmuster 7 (<figref idrefs="f0010">Fig. 24</figref>) wird über eine sogenannte IF-Abfrage überprüft, ob die in der ersten Datenstruktur 6 enthaltene Marke 6.2 den Wert "TRUE" oder "FALSE" aufweist. Abhängig vom Wert der Marke 6.2 werden die durch die IF-Abfrage geklammerten Ausgaben beim zweiten Datenblock erzeugt oder eben<!-- EPO <DP n="28"> --> nicht erzeugt. Im gezeigten Ausführungsbeispiel ist der Wert der Marke 6.2 "FALSE", sodass die Ausgabe "There are no graphical objects given." generiert wird.</p><p id="p0084" num="0084"><figref idrefs="f0011 f0012">Figuren 26 - 30</figref> dienen der Erläuterung der Strukturkategorie SK "CHOICE". Der CHOICE-Befehl dient dazu, festzustellen, welches der als Strukturparameter SP übergebenen Datenstrukturelemente 3.1, 3.2 im zu analysierenden ersten Datenblock 1 vorkommen. Im in <figref idrefs="f0011">Figur 27</figref> gezeigten Datenstrukturtypen 3 ist wiederum zwischen den festen Datenstrukturelementen 3.1 "#This file is exported by a graphical editor' und '#End of file' eine derartige CHOICE-Anweisung verwendet, wobei als Strukturparameter SP zwei SEQUENCE-Anweisungen übergeben werden, die selbst wiederum eine Vielzahl von Strukturparametern SP enthalten, die aus festen und variablen Datenstrukturelementen 3.1, 3.2 bestehen. Mittels der CHOICE-Anweisung wird dabei abgefragt, ob das mit dem Namen "ELLIPSE" bezeichnete Datenstrukturelement oder das mit dem Namen "CIRCLE" bezeichnete Datenstrukturelement im ersten Datenblock 1 vorkommt, und zwar an der Leseposition, die durch die Position des CHOICE-Befehls definiert wird. Wie anhand des ersten Datenblocks 1 gemäß <figref idrefs="f0011">Figur 26</figref> ersichtlich enthält dieser Datenblock an eben dieser Leseposition einen Datenblockabschnitt mit einer Struktur, die der mit dem Namen 5 "CIRCLE" bezeichneten Struktur aus festen und variablen Datenstrukturelementen 3.1, 3.2 gleicht. Die aus dem Analysieren des ersten Datenblocks 1 anhand des Datenstrukturtypen 3 generierte erste Datenstrukturinstanz 6 enthält zum Namen "ELLIPSE" die boolesche Variable "FALSE" und zum Namen "CIRCLE die boolesche Variable "TRUE", da eben diese im ersten Datenblock ermittelt wurde. Zudem enthält die erste Datenstrukturinstanz 6 mehrere Datenstrukturinstanzelemente 6.1, die den in dem entsprechenden SEQUENCE-Befehl als Strukturparameter SP übergebenen variablen Datenstrukturelementen 3.2 bestehend aus Namen 5 und Datentyp 4 entsprechen.</p><p id="p0085" num="0085">Die Generierung des zweiten Datenblocks 2 (<figref idrefs="f0012">Figur 30</figref>) aus der ersten Datenstrukturinstanz 6 erfolgt mittels dem in <figref idrefs="f0012">Figur 29</figref> gezeigten Datenformatmuster 7. Abweichend von den zuvor beschriebenen Ausführungsbeispielen erfolgt hier eine Umrechnung der in der ersten Datenstrukturinstanz 6 enthaltenen Werte der Datenstrukturinstanzelemente 6.1, und zwar unter Verwendung von Werten von Datenstrukturinstanzelementen 6.1 und damit verbundener arithmetischer Operationen. So z.B. wird von dem über die Namenskette CIRCLE:CENTER_Y definierten Wert der über die Namenskette CIRCLE:RADIUS definierte Wert abgezogen wird und damit der daraus<!-- EPO <DP n="29"> --> entstehende Wert beispielsweise einem neuen Datenstrukturinstanzelement mit einem eindeutigen Namen 5, hier TOP, zugeordnet. Ein weiterer Unterschied des hier gezeigten Datenformatmusters 7 besteht darin, dass dieses Datenformatmuster 7 Bedingungsbefehle (IF-Befehle) enthält, mittels denen die in der ersten Datenstrukturinstanz 6 enthaltenen booleschen Variablen abgefragt werden. Dadurch ist es möglich, abhängig von der durch die Strukturkategorie SK CHOICE im ersten Datenblock 1 ermittelten Datenblockbereiche entsprechende Ausgaben im zweiten Datenblock 2 zu erzeugen.</p><p id="p0086" num="0086"><figref idrefs="f0013 f0014 f0015">Figuren 31 - 38</figref> zeigen ein Ausführungsbeispiel, das zwei Datenstrukturtypen 3, 3' zur Abbildung des ersten Datenformats des ersten Datenblocks 1 verwendet. Der Datenstrukturtyp 3', Example_Type (<figref idrefs="f0013">Fig. 33</figref>) referenziert hierbei auf den Datenstrukturtypen 3, Graphic_Type, (<figref idrefs="f0013">Fig. 32</figref>). Im Datenstrukturtypen 3, Graphic_Type, (<figref idrefs="f0013">Fig. 32</figref>) erfolgt eine rekursive Referenzierung dieses Datenstrukturtypen 3 in sich selbst. Der als "Graphic_Type" bezeichnete Datenstrukturtyp 3 ruft hierbei in dem Strukturkategoriebefehl LIST {SUBGRAPHIC::Graphic_Type} diesen Datenstrukturtypen 3 erneut auf, und zwar solange, wie die durch die Strukturkategorie SK SEQUENCE bzw. deren übergebene Strukturparameter SP im ersten Datenblock 1 (<figref idrefs="f0013">Figur 31</figref>) vorkommen. Dieser Aufruf eines Datenstrukturtypen 3 aus sich selbst heraus ist jedoch lediglich bei Strukturkategorien SK möglich, die einen endlichen Selbstaufruf mit einem eindeutigen Abbruchskriterium bewirken, d.h. solchen, die keine unendliche Schleife generieren. Dies ist insbesondere die Strukturkategorie LIST oder OPTION.</p><p id="p0087" num="0087">In <figref idrefs="f0014">Figur 34</figref> ist die erste Datenstrukturinstanz 6 gezeigt, die beim Einlesen des ersten Datenblocks 1 (<figref idrefs="f0013">Figur 31</figref>) unter Verwendung der Datenstrukturtypen 3, 3' gemäß <figref idrefs="f0013">Figuren 32 und 33</figref> generiert wird. Die erste Datenstrukturinstanz 6 weist im gezeigten Ausführungsbeispiel mehrere Hierarchiestufen auf, und zwar die weitere Hierarchiestufe SUBOBJECT und die darunter liegende weitere Hierarchiestufe SUBELEMENT.</p><p id="p0088" num="0088">Aus dieser ersten Datenstrukturinstanz 6 wird mittels der beiden Datenformatmuster 7, 7' (<figref idrefs="f0014">Figuren 35, 36</figref>) und unter Verwendung der Anweisungsliste 9 gemäß <figref idrefs="f0015">Figur 38</figref> der zweite Datenblock 2 (<figref idrefs="f0015">Figur 37</figref>) erzeugt. Aus dem Datenformatmuster 7' heraus wird das weitere Datenformatmuster 7 aufgerufen, wobei auch dieses Datenformatmuster 7 einen rekursiven Selbstaufruf beinhaltet. Dieser rekursive Selbstaufruf erfolgt innerhalb der IF-Abfrage, sodass das Datenformatmuster 7 (Graphic_Pattern) solange aufgerufen wird, wie in der<!-- EPO <DP n="30"> --> ersten Datenstrukturinstanz 6 Einträge vom Typ SUBELEMENT enthalten sind. Die durch diese IF-Abfrage kontrollierte Schleife ist nicht endlos, da die Datenmenge in einer Datenstrukturinstanz endlich ist.</p><p id="p0089" num="0089">Eine weitere Besonderheit des erfindungsgemäßen Verfahrens besteht darin, dass Werte der ersten und/oder zweiten Datenstrukturinstanzen 6 über Kurzformen einer Kette von Namen, sogenannten Identifizierungs-Shortcuts angesprochen werden können. Eine derartige Namenskette kann beispielsweise, wie in <figref idrefs="f0014">Figur 35</figref> gezeigt durch GRAPHIC:NAME, oder GRAPHIC:SUBOBJECT:SUBELEMENT:NAME etc. gebildet sein. Solange der letzte Name der Namenskette in der Datenstrukturinstanz 6 eindeutig ist, kann dieser Name zum Zugriff auf den Wert des Datenstrukturinstanzelements 6.1 benutzt werden. Ist der letzte Name der Namenskette aber nicht eindeutig innerhalb der Datenstrukturinstanz 6 ist, so ist es auch möglich, dass Teile der Namenskette also beispielsweise SUBELEMENT:NAME zum Zugriff auf den Wert des Datenstrukturinstanzelements 6.1 verwendet werden. D.h. der Namensraum ist in Namensunterräume aufgeteilt werden und es kann über einen Teil der Namenskette auf bestimmte Werte der Datenstrukturinstanzelemente 6.1 zugegriffen werden, solange dieser Teil der Namenskette in dem Namensunterraum eindeutig ist.</p><p id="p0090" num="0090">Die <figref idrefs="f0016">Figuren 39</figref> und <figref idrefs="f0017">40</figref> zeigen jeweils graphische Editoren 20, 21, die zur benutzerfreundlichen Bedienbarkeit des erfindungsgemäßen Verfahrens dienen. In <figref idrefs="f0016">Figur 39</figref> ist ein graphischer Editor 20 zur Erstellung bzw. Veränderung von Datenstrukturtypen 3 gezeigt, wobei in einem ersten Ausgabefenster 20.1 das auf einer graphischen Benutzerschnittstelle, insbesondere einem Monitor angezeigt wird, ein erster Datenblock 1 und in einem zweiten Ausgabefenster 20.2 der zu bearbeitende Datenstrukturtyp 3 dargestellt wird. Zur erleichterten Bearbeitung des Datenstrukturtypen 3 werden die mit den variablen Datenstrukturelementen 3.2 des im zweiten Ausgabefenster 20.2 dargestellten Datenstrukturtyps 3 korrespondierenden variablen Datenblockbereiche 1.1 des ersten Datenblocks 1 im ersten Ausgabefenster 20.1 durch Markierungen graphisch hervorgehoben. Die Markierungen können beispielsweise eine farbige Hinterlegung der variablen Datenblockbereiche 1.1 sein. Vorteilhaft wird mit dem Hervorheben eines ausgewählten variablen Datenstrukturelements 3.2 im zweiten Ausgabefenster 20.2 der damit korrespondierende variable Datenblockbereich 1.1 hervorgehoben. Gleiches gilt auch in umgekehrter Weise für das Auswählen eines variablen Datenblockbereichs 1.1 im<!-- EPO <DP n="31"> --> ersten Ausgabefenster 20.1. Auch können Veränderungen am ersten Datenblock 1 und/oder an dem Datenstrukturtypen 3 zu einer geänderten Darstellung der Markierungen in den Ausgabefenstern 20.1, 20.2 führen. Dies kann insbesondere bei Veränderungen an Strukturkategorien SK oder Strukturparametern SP dieser Strukturkategorien SK auftreten.</p><p id="p0091" num="0091"><figref idrefs="f0017">Figur 40</figref> zeigt den graphischen Editor 21 zur Erstellung bzw. Veränderung von Datenformatmustern 7. Dieser graphische Editor 21 weist drei Ausgabefenster 21.1, 21.2, 21.3 auf, wobei im ersten Ausgabefenster 21.1 das zu bearbeitende Datenformatmuster 7, im zweiten Ausgabefenster 21.2 die den variablen Datenformatelementen 7.2 des Datenformatmusters 7 zugeordneten Werte von Datenstrukturinstanzelementen 6.1 und im dritten Ausgabefenster 21.3 der durch das Datenformatmuster 7 erzeugte zweite Datenblock 2 dargestellt wird. Zur benutzerfreundlichen Bearbeitung des Datenformatmusters 7 werden jeweils die variablen Datenformatelemente 7.2 im ersten Ausgabefenster 21.1 und die mit diesen variablen Datenformatelementen 7.2 korrespondierenden Datenblockbereiche 2.1 des zweiten Datenblocks 2 graphisch hervorgehoben. Diese Hervorhebung kann wiederum durch farbige Hinterlegung der entsprechenden Bereiche erfolgen. Ebenso kann gleichzeitig eine Markierung des entsprechenden korrespondierenden Datenstrukturinstanzelements 6.1 der im zweiten Ausgabefenster 21.2 dargestellten ersten Datenstrukturinstanz 6 erfolgen. Ferner sind die graphischen Ausgaben in den jeweiligen Ausgabefenstern derart miteinander verknüpft, dass beispielsweise eine Veränderung eines Werts eines Datenstrukturinstanzelements 6.1 zu einer Veränderung des korrespondierenden Datenblockbereichs 2.1 des zweiten Datenblocks 2 führt. Ebenso können Veränderungen in dem Datenformatmuster 7 zu korrespondierenden Veränderungen im zweiten Datenblock 2 führen.</p><p id="p0092" num="0092">Die Erfindung wurde voranstehend an einem Ausführungsbeispiel beschrieben. Es versteht sich, dass zahlreiche Modifikationen und Änderungen möglich sind, ohne dass hierdurch der Erfindungsgedanke verlassen wird.<!-- EPO <DP n="32"> --></p><heading id="h0002"><b>Bezugszeichenliste</b></heading><p id="p0093" num="0093"><dl id="dl0002" compact="compact"><dt>1</dt><dd>erster Datenblock</dd><dt>1.1</dt><dd>Datenblockbereich</dd><dt>2</dt><dd>zweiter Datenblock</dd><dt>2.1</dt><dd>Datenblockbereich</dd><dt>3, 3'</dt><dd>Datenstrukturtyp</dd><dt>3.1</dt><dd>feste Datenstrukturelemente</dd><dt>3.2</dt><dd>variable Datenstrukturelemente</dd><dt>4</dt><dd>Datentyp</dd><dt>5</dt><dd>Elementname</dd><dt>6</dt><dd>erste Datenstrukturinstanz</dd><dt>6.1</dt><dd>Datenstrukturinstanzelement</dd><dt>6.2</dt><dd>Marke</dd><dt>7, 7'</dt><dd>Datenformatmuster</dd><dt>7.1</dt><dd>feste Datenformatelemente</dd><dt>7.2</dt><dd>variable Datenformatelemente</dd><dt>8</dt><dd>zweite Datenstrukturinstanz</dd><dt>9</dt><dd>Anweisungsliste</dd><dt>20</dt><dd>grafischer Editor</dd><dt>21</dt><dd>grafischer Editor</dd><dt>30</dt><dd>Liste</dd><dt>31, 31', 31"</dt><dd>Listenelement</dd><dt>40</dt><dd>Befehlsblock</dd><dt>SK</dt><dd>Strukturkategorie</dd><dt>SP</dt><dd>Strukturparameter</dd></dl></p></description><claims mxw-id="PCLM56982069" lang="DE" load-source="patent-office"><!-- EPO <DP n="33"> --><claim id="c-de-0001" num="0001"><claim-text>Computerimplementiertes Verfahren zur Umsetzung zumindest eines ersten Datenblocks (1) mit einem ersten Datenformat in zumindest einen zweiten Datenblock (2) mit einem zweiten Datenformat mittels einer Rechnereinheit, die zumindest einen Prozessor und zumindest eine Speichereinheit aufweist, <b>dadurch gekennzeichnet,</b><br/>
<b>dass</b> der erste Datenblock (1), zumindest ein erster Datenstrukturtyp (3) und zumindest ein Datenformatmuster (7) durch den Prozessor eingelesen wird,<br/>
<b>dass</b> das erste Datenformat durch den zumindest einen Datenstrukturtypen (3) abgebildet wird, der feste Datenstrukturelemente (3.1) und variable Datenstrukturelemente (3.2) definiert, dass den variablen Datenstrukturelementen (3.2) des Datenstrukturtypen (3) jeweils ein Datentyp (4) zugewiesen wird und mindestens einem variablen Datenstrukturelement (3.2) auch ein Name (5) zugewiesen wird, dass unter Verwendung der festen Datenstrukturelemente (3.1) und der Datentypen (4) der variablen Datenstrukturelemente (3.2) durch den Prozessor aus dem ersten Datenblock (1) zumindest eine erste Datenstrukturinstanz (6) mit zumindest einem Datenstrukturinstanzelement (6.1) erzeugt wird, wobei auf den Wert des Datenstrukturinstanzelements (6.1) über den Namen (5) direkt zugegriffen werden kann, wobei die erste Datenstrukturinstanz (6) in der Speichereinheit abgelegt wird,<br/>
<b>dass</b> der zweite Datenblock (2) aus dem Datenformatmuster (7) unter Verwendung der ersten Datenstrukturinstanz (6) oder zumindest einer aus der ersten Datenstrukturinstanz (6) abgeleiteten zweiten Datenstrukturinstanz (8) mittels des Prozessors erzeugt wird, wobei das Datenformatmuster (7) feste Datenformatelemente (7.1) und variable Datenformatelemente (7.2) aufweist und die variablen Datenformatelemente (7.2) über den Namen (5) auf die in der Speichereinheit abgelegten Werte der Datenstrukturinstanzelemente (6.1) der ersten oder zweiten Datenstrukturinstanz (6, 8) verweisen<br/>
und <b>dass</b> der zweite Datenblock (2) durch den Prozessor ausgegeben wird.<!-- EPO <DP n="34"> --></claim-text></claim><claim id="c-de-0002" num="0002"><claim-text>Verfahren nach Anspruch 1, <b>dadurch gekennzeichnet, dass</b> anhand vorausgehender fester Datenstrukturelemente (3.1) des Datenstrukturtyps (3) zumindest einem Datenstrukturinstanzelement (6.1) ein Wert aus dem ersten Datenblock (1) zugewiesen wird und/oder dass mehrere erste Datenblöcke (1) unter Verwendung ein oder mehrerer Datenstrukturtypen (3) und ein oder mehrerer Datenformatmuster (7) in ein oder mehrere zweite Datenblöcke (2) umgewandelt werden.</claim-text></claim><claim id="c-de-0003" num="0003"><claim-text>Verfahren nach Anspruch 2, <b>dadurch gekennzeichnet, dass</b> mehrere formatgleiche erste Datenblöcke (1) unter Verwendung eines einzigen Datenstrukturtypen (3) in ein oder mehrere zweite Datenblöcke (2) umgewandelt werden und/oder dass zur Erzeugung mehrerer formatgleicher zweiter Datenblöcke (2) ein einziges Datenformatmuster (7) verwendet wird.</claim-text></claim><claim id="c-de-0004" num="0004"><claim-text>Verfahren nach einem der vorhergehenden Ansprüche, <b>dadurch gekennzeichnet, dass</b> der zumindest eine erste Datenblock (1) aus einer in der Speichereinheit abgelegten Eingangsdatei eingelesen wird und der zumindest eine zweite Datenblock (2) nach seiner Erzeugung in eine Ausgangsdatei in der Speichereinheit geschrieben wird und in einer Anweisungsliste (9) festgelegt wird, welcher erster Datenblock (1) aus welcher Eingangsdatei eingelesen und welcher zweiter Datenblock (2) in welche Ausgangsdatei geschrieben wird und/oder dass der zumindest eine Datenstrukturtyp (3) und das zumindest eine Datenformatmuster (7) vor ihrer Verwendung jeweils aus zumindest einer in der Speichereinheit abgelegten Datei geladen werden und in einer Anweisungsliste (9) festgelegt wird, welcher Datenstrukturtyp (3) und/oder welches Datenformatmuster (7) aus welcher Datei eingelesen wird.</claim-text></claim><claim id="c-de-0005" num="0005"><claim-text>Verfahren nach Anspruch 4, <b>dadurch gekennzeichnet, dass</b> die Anweisungsliste (9) vor ihrer Ausführung aus einer in der Speichereinheit abgelegten Datei geladen wird.</claim-text></claim><claim id="c-de-0006" num="0006"><claim-text>Verfahren nach einem der vorhergehenden Ansprüche, <b>dadurch gekennzeichnet, dass</b> jeder Datenstrukturinstanz (6) genau ein korrespondierender Datenstrukturtyp (3) zugeordnet wird und/oder dass jeder zweite Datenblock (2) durch genau ein korrespondierendes Datenformatmuster (7) erzeugt wird.<!-- EPO <DP n="35"> --></claim-text></claim><claim id="c-de-0007" num="0007"><claim-text>Verfahren nach Anspruch 6, <b>dadurch gekennzeichnet, dass</b> zumindest ein Wert eines Datenstrukturinstanzelements (6.1) der zumindest einen ersten Datenstrukturinstanz (6) durch zumindest eine Operation verändert wird und dass die durch die Operation veränderte erste Datenstrukturinstanz (6) als zweite Datenstrukturinstanz (8) bei der Erzeugung des zweiten Datenblocks (2) verwendet wird.</claim-text></claim><claim id="c-de-0008" num="0008"><claim-text>Verfahren nach einem der vorhergehenden Ansprüche, <b>dadurch gekennzeichnet, dass</b> es sich bei einem Datentyp (4) entweder einen regulären Datentyp, einen elementaren Datentyp oder einen komplexen Datentyp handelt, wobei
<claim-text>a) ein regulärer Datentyp durch einen regulären Ausdruck definiert wird,</claim-text>
<claim-text>b) ein elementarer Datentyp durch einen vordefinierten regulären Ausdruck definiert wird, wie er beispielsweise für INTEGER, FLOAT, BOOL, STRING vorausgesetzt wird und</claim-text>
<claim-text>c) ein komplexer Datentyp mit seinem Namen auf die Definition eines Datenstrukturtypen verweist, wobei einem Datenstrukturtyp eine Strukturkategorie (SK) zugeordnet ist, der als Strukturparameter (SP) zumindest ein festes oder variables Datenstrukturelement (3.1, 3.2) oder eine Anordnung aus festen und/oder variablen Datenstrukturelementen (3.1, 3.2) übergeben wird, wobei ein als Strukturparameter (SP) übergebenes variables Datenstrukturelement (3.2) entweder von einem elementaren Datentyp, einem regulären oder einem komplexen Datentypen ist und wobei über die Strukturkategorie (SK) festgelegt wird, wie die Strukturparameter (SP) zur Analyse des ersten Datenblocks und der Erzeugung zumindest eines Datenstrukturinstanzelements verwendet werden.</claim-text></claim-text></claim><claim id="c-de-0009" num="0009"><claim-text>Verfahren nach Anspruch 8, <b>dadurch gekennzeichnet, dass</b> einer Strukturkategorie (SK) als Strukturparameter (SP) statt des Namen (5) eines komplexen Datentypen unmittelbar die Definition eines komplexen Datenstrukturtypen übergeben werden.</claim-text></claim><claim id="c-de-0010" num="0010"><claim-text>Verfahren nach Anspruch 8 oder 9, <b>dadurch gekennzeichnet, dass</b> durch eine erste Strukturkategorie (SEQUENCE) festgelegt wird, dass sämtliche, als Strukturparameter (SP) übergebene Datenstrukturelemente (3.1, 3.2) nacheinander und in genau der angegeben Reihenfolge im ersten Datenblock (1) an der aktuellen Leseposition vorkommen müssen und/oder dass durch eine zweite Strukturkategorie (STREAM) festgelegt wird, dass sämtliche, als Strukturparameter (SP) übergebenen<!-- EPO <DP n="36"> --> Datenstrukturelemente (3.1, 3.2) nacheinander und in genau der angegeben Reihenfolge im ersten Datenblock (1) nach der aktuellen Leseposition vorkommen müssen, wobei sich der Wert des Datenstrukturinstanzelements (6.1) aus den Zeichen des ersten Datenblocks (1) zwischen der aktuellen Leseposition und dem ersten übergebenen Datenstrukturelement (3.1, 3.2) ergibt und/oder dass durch eine dritte Strukturkategorie (LIST) festgelegt wird, dass sämtliche als Strukturparameter (SP) übergebene Datenstrukturelemente (3.1, 3.2) nacheinander und in genau der angegeben Reihenfolge im ersten Datenblock (1) an der aktuellen Leseposition mindestens einmal vorkommen müssen, aber wiederholt vorkommen können und/oder dass durch eine vierte Strukturkategorie (OPTION) festgelegt wird, dass sämtliche, als Strukturparameter (SP) übergebene Datenstrukturelemente (3.1, 3.2) nacheinander in genau der angegeben Reihenfolge im ersten Datenblock (1) an der aktuellen Leseposition höchstens einmal oder gar nicht vorkommen dürfen, wobei in der korrespondierenden Datenstrukturinstanz (6) über eine Marke (6.2) festgehalten wird, ob die Datenstrukturelemente (3.1, 3.2) im ersten Datenblock (1) vorhanden sind oder nicht und/oder dass durch eine fünfte Strukturkategorie (PERMUTATION) festgelegt wird, dass sämtliche als Strukturparameter (SP) übergebene Datenstrukturelemente (3.1, 3.2) eines komplexen Datenstrukturtypen im ersten Datenblock (1) an der aktuellen Leseposition nacheinander genau einmal vorkommen müssen, die Reihenfolge aber beliebig ist und/oder dass durch eine sechste Strukturkategorie (CHOICE) festgelegt wird, dass genau eines der als Strukturparameter (SP) übergebenen Datenstrukturelemente (3.1, 3.2) des Datenstrukturtypen (3) im ersten Datenblock (1) an der aktuellen Leseposition vorkommen muss, wobei im korrespondieren Datenstrukturinstanzelement (6.1) festgehalten wird, welches Datenstrukturelement (3.1, 3.2) im ersten Datenblock vorhanden ist und/oder dass durch eine achte Strukturkategorie (LINE) festgelegt wird, dass sämtliche, als Strukturparameter SP übergebene Datenstrukturelemente (3.1, 3.2) nacheinander und in genau der angegeben Reihenfolge im ersten Datenblock (1) an der aktuellen Leseposition vorkommen müssen, und zwar innerhalb einer Zeile.</claim-text></claim><claim id="c-de-0011" num="0011"><claim-text>Verfahren nach einem der vorhergehenden Ansprüche, <b>dadurch gekennzeichnet, dass</b> alle im ersten Datenblock einem Whitespace-Zeichen nachfolgenden Whitespace-Zeichen ignoriert und sämtliche Whitespace-Zeichen wie das Zeichen<!-- EPO <DP n="37"> --> &lt;Zwischenraum&gt; behandelt werden, wobei ein Whitespace-Zeichen das Zeichen &lt;Zwischenraum&gt;, &lt;Tabulator&gt;, &lt;Wagenrücklauf&gt; oder &lt;NeueZeile&gt; ist.</claim-text></claim><claim id="c-de-0012" num="0012"><claim-text>Verfahren nach einem der vorhergehenden Ansprüche, <b>dadurch gekennzeichnet, dass</b> mittels Bedingungsanweisungen Teile des Datenformatmusters (7) von der Erzeugung des zweiten Datenblocks (2) ausgeschlossen werden und/oder dass mittels Wiederholungsanweisungen Teile des Datenformatmusters (7) definiert werden, die zur Verarbeitung von Elementen einer Liste vorgesehen sind und/oder dass in einem Datenformatmuster (7) auf selbiges oder ein oder mehrere andere Datenformatmuster (7) referenziert wird und/oder dass in einem Datenformatmuster (7) lokal bekannte Datenstrukturinstanzen (8) erzeugt und deren Werte verändert und weiterverwendet werden.</claim-text></claim><claim id="c-de-0013" num="0013"><claim-text>Verfahren nach einem der vorhergehenden Ansprüche, <b>dadurch gekennzeichnet, dass</b> ein graphischer Editor (20) zur Erstellung bzw. Veränderung von Datenstrukturtypen (3) vorgesehen ist, wobei in einem ersten Ausgabefenster (20.1) ein erster Datenblock (1) und in einem zweiten Ausgabefenster (20.2) der zu bearbeitende Datenstrukturtyp (3) dargestellt wird und dass die mit den variablen Datenstrukturelementen (3.2) des im zweiten Ausgabefenster (20.2) dargestellten Datenstrukturtyps (3) korrespondierenden variablen Datenblockbereiche des ersten Datenblocks (1) im ersten Ausgabefenster (20.1) durch Markierungen graphisch hervorgehoben werden und dass ein im zweiten Ausgabefenster (20.2) markiertes Datenstrukturelement (3.1, 3.2) gleichzeitig mit dem korrespondierenden Datenblockbereich des ersten Datenblocks (1) im ersten Ausgabefenster (20.1) markiert wird und umgekehrt und/oder dass eine Veränderung am Datenstrukturtypen (3) im zweiten Ausgabefenster (20.2) unmittelbar zur geänderten Darstellung der Markierungen im ersten Ausgabefenster (20.1) führt.</claim-text></claim><claim id="c-de-0014" num="0014"><claim-text>Verfahren nach einem der vorhergehenden Ansprüche, <b>dadurch gekennzeichnet, dass</b> ein graphischer Editor (21) zur Erstellung bzw. Veränderung von Datenformatmuster (7) bereitgestellt wird, wobei in einem ersten Ausgabefenster (21.1) das zu bearbeitende Datenformatmuster (7), einem zweiten Ausgabefenster (21.2) die den variablen Datenformatelementen (7.2) des Datenformatmusters (7.2) zugeordneten Werte von Datenstrukturinstanzelementen (6.1) und in einem dritten Ausgabefenster (21.3) der durch das Datenformatmuster (7) erzeugte zweite<!-- EPO <DP n="38"> --> Datenblock (2) dargestel lt wird, wobei im ersten Ausgabefenster (21.1) die variablen Datenformatelemente (7.2) und im dritten Ausgabefenster (21.3) die mit diesen variablen Datenformatelementen (7.2) korrespondierenden Datenblockbereiche des zweiten Datenblocks (2) hervorgehoben werden und/oder dass ein im ersten Ausgabefenster (21.1) markiertes Datenformatelement (7.1, 7.2) gleichzeitig mit dem korrespondierenden Datenstrukturinstanzelement (6.1) der Datenstrukturinstanz (6) im zweiten Ausgabefenster (21.2) und gleichzeitig mit dem korrespondierenden Datenblockbereich des zweiten Datenblocks (2) im dritten Ausgabefenster (21.3) markiert wird und umgekehrt und/oder dass die Veränderung eines Wertes eines Datenstrukturinstanzelements (6.1) einer Datenstrukturinstanz (6) in zweitem Ausgabefenster (21.2) unmittelbar zur Veränderung des korrespondierenden Datenblockbereichs im zweiten Datenblock (2) im dritten Ausgabefenster (21.3) führt und umgekehrt.</claim-text></claim><claim id="c-de-0015" num="0015"><claim-text>Computerprogrammprodukt ausgebildet zur Durchführung eines Verfahrens nach einem der vorhergehenden Ansprüche.</claim-text></claim></claims><drawings mxw-id="PDW16670461" load-source="patent-office"><!-- EPO <DP n="39"> --><figure id="f0001" num="1,2"><img id="if0001" file="imgf0001.tif" wi="165" he="212" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="40"> --><figure id="f0002" num="3,4"><img id="if0002" file="imgf0002.tif" wi="165" he="185" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="41"> --><figure id="f0003" num="5,6,7"><img id="if0003" file="imgf0003.tif" wi="151" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="42"> --><figure id="f0004" num="8,9"><img id="if0004" file="imgf0004.tif" wi="162" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="43"> --><figure id="f0005" num="10,11,12,13"><img id="if0005" file="imgf0005.tif" wi="160" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="44"> --><figure id="f0006" num="14,15,16"><img id="if0006" file="imgf0006.tif" wi="160" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="45"> --><figure id="f0007" num="17,18"><img id="if0007" file="imgf0007.tif" wi="165" he="225" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="46"> --><figure id="f0008" num="19,20"><img id="if0008" file="imgf0008.tif" wi="155" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="47"> --><figure id="f0009" num="21,22,23"><img id="if0009" file="imgf0009.tif" wi="155" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="48"> --><figure id="f0010" num="24,25"><img id="if0010" file="imgf0010.tif" wi="155" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="49"> --><figure id="f0011" num="26,27"><img id="if0011" file="imgf0011.tif" wi="155" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="50"> --><figure id="f0012" num="28,29,30"><img id="if0012" file="imgf0012.tif" wi="153" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="51"> --><figure id="f0013" num="31,32,33"><img id="if0013" file="imgf0013.tif" wi="153" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="52"> --><figure id="f0014" num="34,35,36"><img id="if0014" file="imgf0014.tif" wi="153" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="53"> --><figure id="f0015" num="37,38"><img id="if0015" file="imgf0015.tif" wi="153" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="54"> --><figure id="f0016" num="39"><img id="if0016" file="imgf0016.tif" wi="165" he="162" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="55"> --><figure id="f0017" num="40"><img id="if0017" file="imgf0017.tif" wi="165" he="120" img-content="drawing" img-format="tif"/></figure></drawings><search-report-data><doc-page id="srep0001" file="srep0001.tif" wi="159" he="233" type="tif"/></search-report-data><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
