<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2681917-A1" country="EP" doc-number="2681917" kind="A1" date="20140108" family-id="46753074" file-reference-id="252638" date-produced="20180823" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146586371" ucid="EP-2681917-A1"><document-id><country>EP</country><doc-number>2681917</doc-number><kind>A1</kind><date>20140108</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-12708229-A" is-representative="NO"><document-id mxw-id="PAPP154848563" load-source="docdb" format="epo"><country>EP</country><doc-number>12708229</doc-number><kind>A</kind><date>20120301</date><lang>EN</lang></document-id><document-id mxw-id="PAPP220440077" load-source="docdb" format="original"><country>EP</country><doc-number>12708229.5</doc-number><date>20120301</date></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140550562" ucid="US-201161449411-P" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201161449411</doc-number><kind>P</kind><date>20110304</date></document-id></priority-claim><priority-claim mxw-id="PPC140551391" ucid="US-2012027227-W" linkage-type="W" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>2012027227</doc-number><kind>W</kind><date>20120301</date></document-id></priority-claim><priority-claim mxw-id="PPC140556476" ucid="US-201213406613-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201213406613</doc-number><kind>A</kind><date>20120228</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1989316573" load-source="docdb">H04N   7/26        20060101AFI20120925BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989317378" load-source="docdb">H04N   7/36        20060101ALI20120925BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989317746" load-source="docdb">H04N   7/50        20060101ALI20120925BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-2137522815" load-source="docdb" scheme="CPC">H04N  19/61        20141101 LI20141108BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2137523824" load-source="docdb" scheme="CPC">H04N  19/523       20141101 LI20141108BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2137532263" load-source="docdb" scheme="CPC">H04N  19/82        20141101 LI20141108BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989641460" load-source="docdb" scheme="CPC">G06T   3/4007      20130101 FI20130815BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132363746" lang="DE" load-source="patent-office">VERFAHREN UND SYSTEM ZUR INTERPOLATION FRAKTIONIERTER VIDEOPIXEL</invention-title><invention-title mxw-id="PT132363747" lang="EN" load-source="patent-office">METHOD AND SYSTEM FOR INTERPOLATING FRACTIONAL VIDEO PIXELS</invention-title><invention-title mxw-id="PT132363748" lang="FR" load-source="patent-office">PROCÉDÉ ET SYSTÈME POUR INTERPOLER DES PIXELS VIDÉO FRACTIONNELS</invention-title><citations><non-patent-citations><nplcit><text>See references of WO 2012121965A1</text><sources><source mxw-id="PNPL67455911" load-source="docdb" name="SEA"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR919505903" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>MOTOROLA MOBILITY LLC</last-name><address><country>US</country></address></addressbook></applicant><applicant mxw-id="PPAR919507084" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>MOTOROLA MOBILITY LLC</last-name></addressbook></applicant><applicant mxw-id="PPAR919014198" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Motorola Mobility LLC</last-name><iid>101323621</iid><address><street>600 North US Highway 45</street><city>Libertyville, IL 60048</city><country>US</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR919527538" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>LOU JIAN</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919540990" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>LOU, JIAN</last-name></addressbook></inventor><inventor mxw-id="PPAR919008201" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>LOU, JIAN</last-name><address><street>5240 Fiore Terrace Apt. 413</street><city>San Diego, California 92122</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919526369" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>BAYLON DAVID M</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919523591" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>BAYLON, DAVID M.</last-name></addressbook></inventor><inventor mxw-id="PPAR919011911" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>BAYLON, DAVID M.</last-name><address><street>11413 Miro Circle</street><city>San Diego, California 92131</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919539616" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>MINOO KOOHYAR</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919520796" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>MINOO, KOOHYAR</last-name></addressbook></inventor><inventor mxw-id="PPAR919017587" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>MINOO, KOOHYAR</last-name><address><street>4147 Camino Ticino</street><city>San Diego, California 92122</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919508411" load-source="docdb" sequence="4" format="epo"><addressbook><last-name>PANUSOPONE KRIT</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919530321" load-source="docdb" sequence="4" format="intermediate"><addressbook><last-name>PANUSOPONE, KRIT</last-name></addressbook></inventor><inventor mxw-id="PPAR919018468" load-source="patent-office" sequence="4" format="original"><addressbook><last-name>PANUSOPONE, KRIT</last-name><address><street>10725 Calle Mar De Mariposa</street><city>San Diego, California 92130</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919519220" load-source="docdb" sequence="5" format="epo"><addressbook><last-name>WANG LIMIN</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919545352" load-source="docdb" sequence="5" format="intermediate"><addressbook><last-name>WANG, LIMIN</last-name></addressbook></inventor><inventor mxw-id="PPAR919016178" load-source="patent-office" sequence="5" format="original"><addressbook><last-name>WANG, LIMIN</last-name><address><street>13641 Shoal Summit Drive</street><city>San Diego, California 92128</city><country>US</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR919013445" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Openshaw, Paul Malcolm</last-name><iid>100044454</iid><address><street>Openshaw &amp; Co. 8 Castle Street</street><city>Farnham Surrey GU9 7HR</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="US-2012027227-W"><document-id><country>US</country><doc-number>2012027227</doc-number><kind>W</kind><date>20120301</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2012121965-A1"><document-id><country>WO</country><doc-number>2012121965</doc-number><kind>A1</kind><date>20120913</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS549837714" load-source="docdb">AL</country><country mxw-id="DS549837615" load-source="docdb">AT</country><country mxw-id="DS549837715" load-source="docdb">BE</country><country mxw-id="DS549769994" load-source="docdb">BG</country><country mxw-id="DS549914563" load-source="docdb">CH</country><country mxw-id="DS549837332" load-source="docdb">CY</country><country mxw-id="DS549837616" load-source="docdb">CZ</country><country mxw-id="DS549837716" load-source="docdb">DE</country><country mxw-id="DS549837333" load-source="docdb">DK</country><country mxw-id="DS549837338" load-source="docdb">EE</country><country mxw-id="DS549759788" load-source="docdb">ES</country><country mxw-id="DS549769995" load-source="docdb">FI</country><country mxw-id="DS549769996" load-source="docdb">FR</country><country mxw-id="DS549837717" load-source="docdb">GB</country><country mxw-id="DS549837339" load-source="docdb">GR</country><country mxw-id="DS549837750" load-source="docdb">HR</country><country mxw-id="DS549837617" load-source="docdb">HU</country><country mxw-id="DS549914564" load-source="docdb">IE</country><country mxw-id="DS549837340" load-source="docdb">IS</country><country mxw-id="DS549770001" load-source="docdb">IT</country><country mxw-id="DS549837341" load-source="docdb">LI</country><country mxw-id="DS549851346" load-source="docdb">LT</country><country mxw-id="DS549837638" load-source="docdb">LU</country><country mxw-id="DS549851347" load-source="docdb">LV</country><country mxw-id="DS549851348" load-source="docdb">MC</country><country mxw-id="DS549760233" load-source="docdb">MK</country><country mxw-id="DS549760234" load-source="docdb">MT</country><country mxw-id="DS549759793" load-source="docdb">NL</country><country mxw-id="DS549770002" load-source="docdb">NO</country><country mxw-id="DS549760235" load-source="docdb">PL</country><country mxw-id="DS549914565" load-source="docdb">PT</country><country mxw-id="DS549759794" load-source="docdb">RO</country><country mxw-id="DS549914566" load-source="docdb">RS</country><country mxw-id="DS549760236" load-source="docdb">SE</country><country mxw-id="DS549914567" load-source="docdb">SI</country><country mxw-id="DS549770003" load-source="docdb">SK</country><country mxw-id="DS549760241" load-source="docdb">SM</country><country mxw-id="DS549837346" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><abstract mxw-id="PA100066208" ref-ucid="WO-2012121965-A1" lang="EN" load-source="patent-office"><p num="0000">A method and system for interpolating video pixels is described, in which the value of a first fractional pixel is calculated based on the values of the first set of integer pixels, while the value of a second fractional pixel is calculated based on the values of the second set of integer pixels. The first set of integer pixels is not equal to the second set of integer pixels. For example, the first and second set may contain different integer pixels and may contain different numbers of integer pixels.</p></abstract><abstract mxw-id="PA100335316" ref-ucid="WO-2012121965-A1" lang="EN" source="national office" load-source="docdb"><p>A method and system for interpolating video pixels is described, in which the value of a first fractional pixel is calculated based on the values of the first set of integer pixels, while the value of a second fractional pixel is calculated based on the values of the second set of integer pixels. The first set of integer pixels is not equal to the second set of integer pixels. For example, the first and second set may contain different integer pixels and may contain different numbers of integer pixels.</p></abstract><abstract mxw-id="PA100066209" ref-ucid="WO-2012121965-A1" lang="FR" load-source="patent-office"><p num="0000">La présente invention se rapporte à un procédé et à un système adaptés pour interpoler des pixels vidéo. Selon la présente invention, la valeur d'un premier pixel fractionnel est calculée sur la base des valeurs du premier ensemble de pixels entiers tandis que la valeur d'un second pixel fractionnel est calculée sur la base des valeurs du second ensemble de pixels entiers. Le premier ensemble de pixels entiers n'est pas égal au second ensemble de pixels entiers. Par exemple, les premier et second ensembles peuvent contenir différents pixels entiers ou bien ils peuvent contenir différents nombres de pixels entiers.</p></abstract><abstract mxw-id="PA100335317" ref-ucid="WO-2012121965-A1" lang="FR" source="national office" load-source="docdb"><p>La présente invention se rapporte à un procédé et à un système adaptés pour interpoler des pixels vidéo. Selon la présente invention, la valeur d'un premier pixel fractionnel est calculée sur la base des valeurs du premier ensemble de pixels entiers tandis que la valeur d'un second pixel fractionnel est calculée sur la base des valeurs du second ensemble de pixels entiers. Le premier ensemble de pixels entiers n'est pas égal au second ensemble de pixels entiers. Par exemple, les premier et second ensembles peuvent contenir différents pixels entiers ou bien ils peuvent contenir différents nombres de pixels entiers.</p></abstract><description mxw-id="PDES51372760" ref-ucid="WO-2012121965-A1" lang="EN" load-source="patent-office"><!-- EPO <DP n="2"/>--><p id="p0001" num="0001"> METHOD AND SYSTEM FOR INTERPOLATING FRACTIONAL VIDEO PIXELS </p><p id="p0002" num="0002">TECHNICAL FIELD </p><p id="p0003" num="0003"> [001] The present invention relates generally to video image processing and, more particularly, to methods and systems for interpolating video pixels. </p><p id="p0004" num="0004">CROSS REFERENCE TO RELATED APPLICATIONS </p><p id="p0005" num="0005"> [002] The present application claims the benefit of priority to U.S.</p><p id="p0006" num="0006">Provisional Patent Application Serial No. 61/44941 1 , filed on March 4, 201 1 , entitled "High Efficiency Low Complexity Fractional Pixel Interpolation Filters," by Lou, et al., which is hereby incorporated by reference in its entirety. </p><p id="p0007" num="0007"> [003] The present application is related to U.S. Patent Application No.</p><p id="p0008" num="0008">13/408609 filed on 29 FEB 2012, entitled "METHOD AND SYSTEM FOR INTERPOLATING FRACTIONAL VIDEO PIXELS," by Lou, et al (Attorney Docket #CS38434). </p><p id="p0009" num="0009">BACKGROUND </p><p id="p0010" num="0010"> [004] One of the major characteristics of conventional motion compensated hybrid video codecs is use of translational model for motion description. Pixel value of a digital video sequence represents the light intensity from certain object that falls into the detection range of some discrete sensor. Since an object motion is completely unrelated to the sampling grid, sometimes the object motion is more like a fractional-pel motion than a full-pel one. Therefore, most modern hybrid video coding standards use fractional-pel displacement vector resolution of 1/2-pel or 1/4-pel. </p><p id="p0011" num="0011"> [005] In order to estimate and compensate fractional-pel displacements, the image signal on these fractional-pel positions has to be generated by interpolation process. The taps of an interpolation filter weight the integer pixels in order to generate the fractional-pel signals. The simplest filter for fractional-pel 
<!-- EPO <DP n="3"/>-->
 signal interpolation is bilinear filter, but there is no improvement beyond 1/8-pel (See Cliff Reader, "History of MPEG Video Compression", JVT of ISO/IEC MPEG and ITU-T VCEG, Docs. JVT-E066, Oct. 2002). Therefore, only 1/2-pel resolution using bilinear interpolation is adopted in MPEG-2 and H.263. </p><p id="p0012" num="0012"> [006] Werner supposes the reason for poor performance of bilinear filter is that the Nyquist Sampling Theorem is not fulfilled and aliasing disturbs the motion compensated prediction. He proposes Wiener interpolation filters for reducing the impact of aliasing (See O. Werner, "Drift analysis and, drift reduction for multiresolution hybrid video coding," Signal Processing: Image Commun., vol. 8, no. 5, July 1996). Thus, recent video coding standards like MPEG-4 part 2 and H.264 apply 8-tap and 6-tap Wiener interpolation filters respectively. These filters are obtained by solving the Wiener-Hopf equations. The equations should be specified for filters with different filter length and the resultant taps are limited within a range while different video sequences are used as the input signals. </p><p id="p0013" num="0013"> [007] Generally, the interpolation process is realized by using weighted sum of the integer pixels to calculate the target fractional pixel values. A practical implementation is to use non-zero integer values as the weighting factors and apply right shift to save computational complexity with added shift offset. Clip operation might also be applied to keep the interpolated pixel values within the normal dynamic range. </p><p id="p0014" num="0014"> [008] Traditionally, the half-pel interpolation process uses an even number of integer pixels symmetric around a current half-pel position. The interpolation process for nearby quarter-pel or eighth-pel pixels employs the same set of integer pixels. This constraint on fractional-pel interpolation process is actually not necessary. Releasing this constraint can make the filter design more flexible, thus achieving better performance and/or lower complexity. 
<!-- EPO <DP n="4"/>-->
 BRIEF DESCRIPTION OF THE DRAWINGS </p><p id="p0015" num="0015">[009] Various embodiments of the present invention will be described below in more detail, with reference to the accompanying drawings. </p><p id="p0016" num="0016"> [0010] It is to be noted, however, that the appended drawings illustrate embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments. </p><p id="p0017" num="0017"> [0011] FIG. 1A is a video system in which the various embodiments of the invention may be used; </p><p id="p0018" num="0018"> [0012] FIG. 1 B is a computer system on which embodiments of the invention may be implemented; </p><p id="p0019" num="0019"> [0013] FIGS. 2A, 2B, 3A and 3B illustrate certain video encoding principles according to an embodiment of the invention; </p><p id="p0020" num="0020"> [0014] FIGS. 4A and 4B show possible architectures for an encoder and a decoder according to an embodiment of the invention; </p><p id="p0021" num="0021"> [0015] FIGS. 5A and 5B illustrate further video coding principles according to an embodiment of the invention; and </p><p id="p0022" num="0022"> [0016] FIG. 6 illustrates a pixel line. </p><p id="p0023" num="0023">DETAILED DESCRIPTION </p><p id="p0024" num="0024"> [0017] The invention is generally directed to a method and system for interpolating fractional pixels. According to one embodiment of the invention, a first fractional pixel and a second fractional pixel are located between a pair of adjacent integer pixels. A first set of integer pixels and a second set of integer pixels is selected. The value of the first fractional pixel is calculated based on the values of the first set of integer pixels, while the value of the second fractional pixel is calculated based on the values of the second set of integer pixels. In this embodiment, the first and second set of integer pixels are unequal. For example, 
<!-- EPO <DP n="5"/>-->
 the first and second set may contain different integer pixels and may contain different numbers of pixels. Also, the number of integer pixels in either or both of the first and second set may be odd. </p><p id="p0025" num="0025"> [0018] In another embodiment of the invention, a first fractional pixel (FL), a half pixel (H) and a second fractional pixel (FR) are located between a pair of adjacent integer pixels along a pixel line. The value of the first fractional pixel (FL) is calculated based on the values of a first set of integer pixels along the line. The value of the half pixel (H) is calculated based on the values of a second set of integer pixels along the line. And the value of the second fractional pixel (FR) is calculated based on the values of a third set of integer pixels along the line. In this embodiment, the first, second and third sets of integer pixels are unequal. </p><p id="p0026" num="0026">[0019] In still another embodiment of the invention, the filter coefficients are chosen so that the intermediate data are kept within a specific dynamic range, depending on the bit-depth of input data to the filtering operation. </p><p id="p0027" num="0027">[0020] The embodiments of the invention described herein may support a number of different types of video materials. The most commonly used video materials are 8 bit data, that is, the value of each Luma or Chroma pixel is stored in 8 bit format. However, 10 bit, 12 bit or even higher bit-depth videos are becoming more and more popular these days. Moreover, Internal Bit-depth Increase (IBDI) is introduced in video codecs to maintain higher intermediate data accuracy, thus achieving better performance. On the other hand, lower dynamic range (16 bit, 32 bit) for the processors which video codecs are implemented on is favored to maintain an acceptable complexity. The increased bit-depth of input data to the filtering process might make the dynamic range exceed the favored range if the same interpolation filters used for the 8 bit input data are employed. For example, if the interpolation filter can operate under 16 bit dynamic range with 8 bit input data, it might need 18 bit dynamic range with 10 bit input data or with 10 bit Internal Bit- Depth Increase settings (2 bit up scaling). For general purpose processors, 18 bit dynamic range data needs to be handled under 32 bit settings. </p><p id="p0028" num="0028">[0021] An example of a video system in which an embodiment of the 
<!-- EPO <DP n="6"/>-->
 invention may be used will now be described. It is understood that elements depicted as function blocks in the figures may be implemented as hardware, software, or a combination thereof. Furthermore, embodiments of the invention may also be employed on other systems, such as on a personal computer, smartphone or tablet computer. </p><p id="p0029" num="0029"> [0022] Referring to FIG. 1A, the video system, generally labeled 10, includes a head end 100 of a cable television network. The head end 100 is configured to deliver video content to neighborhoods 129, 130 and 131 . The head end 100 may operate within a hierarchy of head ends, with the head ends higher in the hierarchy generally having greater functionality. The head end 100 is communicatively linked to a satellite dish 1 12 and receives video signals for non-local programming from it. The head end 100 is also communicatively linked to a local station 1 14 that delivers local programming to the head end 100. The head end 100 includes a decoder 104 that decodes the video signals received from the satellite dish 1 12, an off-air receiver 106 that receives the local programming from the local station 114, a switcher 102 that routes data traffic among the various components of the head end 100, encoders 1 16 that encode video signals for delivery to customers, modulators 118 that modulate signals for delivery to customers, and a combiner 120 that combines the various signals into a single, multi-channel transmission. </p><p id="p0030" num="0030">[0023] The head end 100 is also communicatively linked to a hybrid fiber cable (HFC) network 122. The HFC network 122 is communicatively linked to a plurality of nodes 124, 126, and 128. Each of the nodes 124, 126, and 128 is linked by coaxial cable to one of the neighborhoods 129, 130 and 131 and delivers cable television signals to that neighborhood. One of the neighborhoods 130 of FIG. 1A is shown in more detail. The neighborhood 130 includes a number of residences, including a home 132 shown in FIG. 1A. Within the home 132 is a set-top box 134 communicatively linked to a video display 136. The set-top box 134 includes a first decoder 138 and a second decoder 140. The first and second decoders 138 and 140 are communicatively linked to a user interface 142 and a mass storage device 144. The user interface 142 is communicatively linked to the 
<!-- EPO <DP n="7"/>-->
 video display 136. </p><p id="p0031" num="0031"> [0024] During operation, head end 100 receives local and nonlocal programming video signals from the satellite dish 1 12 and the local station 1 14. The non-local programming video signals are received in the form of a digital video stream, while the local programming video signals are received as an analog video stream. In some embodiments, local programming may also be received as a digital video stream. The digital video stream is decoded by the decoder 104 and sent to the switcher 102 in response to customer requests. The head end 100 also includes a server 108 communicatively linked to a mass storage device 1 10. The mass storage device 1 10 stores various types of video content, including video on demand (VOD), which the server 108 retrieves and provides to the switcher 102. The switcher 102 routes local programming directly to the modulators 1 18, which modulate the local programming, and routes the non-local programming (including any VOD) to the encoders 1 16. The encoders 1 16 digitally encode the non-local programming. The encoded non-local programming is then transmitted to the modulators 118. The combiner 120 receives the modulated analog video data and the modulated digital video data, combines the video data and transmits it via multiple radio frequency (RF) channels to the HFC network 122. </p><p id="p0032" num="0032">[0025] The HFC network 122 transmits the combined video data to the nodes 124, 126 and 128, which retransmit the data to their respective neighborhoods 129, 130 and 131 . The home 132 receives this video data at the set-top box 134, more specifically at the first decoder 138 and the second decoder 140. The first and second decoders 138 and 140 decode the digital portion of the video data and provide the decoded data to the user interface 142, which then provides the decoded data to the video display 136. </p><p id="p0033" num="0033"> [0026] The encoders 116 and the decoders 138 and 140 of FIG. 1A (as well as all of the other steps and functions described herein) may be implemented as computer code comprising computer readable instructions stored on a computer readable storage device, such as memory or another type of storage device. The computer code is executed on a computer system by a processor, such as an 
<!-- EPO <DP n="8"/>-->
 application-specific integrated circuit (ASIC), or other type of circuit. For example, computer code for implementing the encoders 116 may be executed on a computer system (such as a server) residing in the headend 100. Computer code for the decoders 138 and 140, on the other hand, may be executed on the set-top box 134, which constitutes a type of computer system. The code may exist as software programs comprised of program instructions in source code, object code, executable code or other formats. </p><p id="p0034" num="0034"> [0027] FIG. 1 B shows an example of a computer system on which computer code for the encoders 116 and the decoders 138 and 140 may be executed. The computer system, generally labeled 400, includes a processor 401 , or processing circuitry, that may implement or execute software instructions performing some or all of the methods, functions and other steps described herein. Commands and data from processor 401 are communicated over a communication bus 403. Computer system 400 also includes a computer readable storage device 402, such as random access memory (RAM), where the software and data for processor 401 may reside during runtime. Storage device 402 may also include non-volatile data storage. Computer system 400 may include a network interface 404 for connecting to a network. Other known electronic components may be added or substituted for the components depicted in the computer system 400. The computer system 400 may reside in the headend 100 and execute the encoders 1 16, and may also be embodied in the set-top box 134 to execute the decoders 138 and 140. Additionally, the computer system 400 may reside in places other than the headend 100 and the set-top box 134, and may be miniaturized so as to be integrated into a smartphone or tablet computer. </p><p id="p0035" num="0035"> [0028] A high-level description of how video data gets encoded and decoded by the encoders 116 and the decoders 138 and 140 in an embodiment of the invention will now be provided. In this embodiment, the encoders and decoders operate according to a High Efficiency Video Coding (HEVC) method. HEVC is a block-based hybrid spatial and temporal predictive coding method. In HEVC, an input picture is first divided into square blocks, called LCUs (largest coding units), 
<!-- EPO <DP n="9"/>-->
 as shown in FIG. 2A. Unlike other video coding standards, in which the basic coding unit is a Macroblock of 16x16 pixels, in HEVC, the LCU can be as large as 128x128 pixels. An LCU can be divided into four square blocks, called CUs (coding units), which are a quarter of the size of the LCU. Each CU can be further split into four smaller CUs, which are a quarter of the size of the original CU. The splitting process can be repeated until certain criteria are met. FIG. 3A shows an example of LCU partitioned into CUs. </p><p id="p0036" num="0036"> [0029] How a particular LCU is split into CUs can be represented by a quadtree. At each node of the quadtree, a flag is set to "1 " if the node is further split into sub-nodes. Otherwise, a the flag is unset at "0." For example, the LCU partition of FIG. 3A can be represented by the quadtree of FIG. 3B. These "split flags" are jointly coded with other flags in the video bitstream, including a skip mode flag, a merge mode flag, and a predictive unit (PU) mode flag. In the case of the quadtree of FIG. 3B, the split flags 10100 would be coded as overhead along with the other flags. </p><p id="p0037" num="0037"> [0030] Each CU can be further divided into predictive units (PUs). Thus, at each leaf of a quadtree, a final CU of 2Nx2N can possess one of four possible patterns (NxN, Nx2N, 2NxN and 2Nx2N), as shown in FIG. 2B. A CU can be either spatially or temporally predictive coded. If a CU is coded in intra mode, each PU of the CU can have its own spatial prediction direction. If a CU is coded in inter mode, each PU of the CU can have its own motion vector(s) and associated reference picture(s). </p><p id="p0038" num="0038"> [0031] Each CU can also be divided into transform units (TUs) by application of a block transform operation. A block transform operation tends to decorrelate the pixels within the block and compact the block energy into the low order coefficients of the transform block. But, unlike other methods where only one transform of 8x8 or 4x4 is applied to a MB, in the present embodiment, a set of block transforms of different sizes may be applied to a CU, as shown in FIG. 5A where the left block is a CU partitioned into PUs and the right block is the 
<!-- EPO <DP n="10"/>-->
 associated set of transform units (TUs). The size and location of each block transform within a CU is described by a separate quadtree, called RQT. FIG. 5B shows the quadtree representation of TUs for the CU in the example of FIG. 5A. In this example, 11000 is coded and transmitted as part of the overhead. </p><p id="p0039" num="0039"> [0032] The TUs and PUs of any given CU may be used for different purposes. TUs are typically used for transformation, quantizing and coding operations, while PUs are typically used for spatial and temporal prediction. There is not necessarily a direct relationship between the number of PUs and the number of TUs for a given CU. </p><p id="p0040" num="0040"> [0033] Each of the encoders 116 (FIG. 1A) is, according to an embodiment of the invention, composed of several functional modules. These modules are depicted in FIG. 4A. It is understood that these modules may be implemented as hardware, software, or any combination of the two. The input to the encoder 1 16 of FIG. 4A is a current PU, x. Given the current PU, x, a prediction PU, x', is first obtained through either spatial prediction or temporal prediction. This spatial or temporal prediction is performed by a spatial prediction module 429 or a temporal prediction module 430 respectively. </p><p id="p0041" num="0041"> [0034] There are several possible spatial prediction directions that the spatial prediction module 429 can perform per PU, including horizontal, vertical, 45- degree diagonal, 135-degree diagonal, DC, Planar, etc. In one embodiment, the number of Luma intra prediction modes for 4x4, 8x8, 16x16, 32x32, and 64x64 blocks is 18, 35, 35, 35, and 4 respectively. Including the Luma intra modes, an additional mode, called IntraFromLuma, may be used for the Chroma intra prediction mode. A syntax indicates the spatial prediction direction per PU. </p><p id="p0042" num="0042"> [0035] The encoder 116 performs temporal prediction through motion estimation operation. In one embodiment, the temporal prediction module 430</p><p id="p0043" num="0043">(FIG. 4A) searches for a best match prediction for the current PU over reference pictures. The best match prediction is described by motion vector (MV) and associated reference picture (refldx). A PU in B pictures can have up to two MVs. 
<!-- EPO <DP n="11"/>-->
 Both MV and refldx are part of the syntax in the bitstream. </p><p id="p0044" num="0044"> [0036] The prediction PU is then subtracted from the current PU, resulting in the residual PU, e. The residual PU, e, is then transformed by a transform module 417, one transform unit (TU) at a time, resulting in the residual PU in the transform domain, E. To accomplish this task, the transform module 417 uses either a square or a non-square block transform. </p><p id="p0045" num="0045"> [0037] Referring back to FIG. 4A, the transform coefficients E, are quantized by a quantizer module 418, converting the high precision transform coefficients into a finite number of possible values. The quantized coefficients are then entropy coded by an entropy coding module 420, resulting in the final compression bits. Two types of entropy coding that may be used are context adaptive variable length coding (CAVLC) and context adaptive binary arithmetic encoding (CABAC). Other types may also be used. </p><p id="p0046" num="0046"> [0038] To facilitate temporal and spatial prediction, the encoder 1 16 also takes the quantized transform coefficients E and dequantizes them with a dequantizer module 422 resulting in the dequantized transform coefficients of E'. The dequantized transform coefficients of E' are then inverse transformed by an inverse transform module 424, resulting in the reconstructed residual PU, e'. The reconstructed residual PU, e', is then added to the corresponding prediction, x', either spatial or temporal, to form a reconstructed PU, x". </p><p id="p0047" num="0047"> [0039] Referring still to FIG. 4A, a loop filter operation is performed on the reconstructed PU, x" by a loop filter module 426. One possible way in which this loop filtering operation may be performed is by a deblocking filter operation , which reduces blocking artifacts. Another possible way is by a sample adaptive offset process. Additionally, an adaptive loop filter function may be conditionally performed, which minimizes the coding distortion between the input and output pictures. Any combination of loop filtering operations may also be performed by the loop filter 426. For example, a sample adaptive offset process may be conditionally performed after the completion of a deblocking filter process for the 
<!-- EPO <DP n="12"/>-->
 decoded picture, which compensates the pixel value offset between reconstructed pixels and original pixels. </p><p id="p0048" num="0048"> [0040] If the reconstructed pictures are reference pictures, they will be stored in a reference buffer 428 for future temporal prediction. From the reference buffer 428, reference pictures are subjected to the operation of an interpolation filter 427. As will be described in more detail, the interpolation filter performs operations that include calculating fractional pixels. The reference pictures are then provided to the temporal prediction module 430. </p><p id="p0049" num="0049"> [0041] In an embodiment of the invention, intra pictures (such as an I picture) and inter pictures (such as P pictures or B pictures) are supported by the encoder 1 16 (FIG. 1A). When implemented according to HEVC, the inter pictures are P or B pictures. An intra picture is coded without referring to other pictures. Hence, spatial prediction is used for a CU/PU inside an intra picture. An intra picture provides a possible point where decoding can begin. On the other hand, an inter picture aims for high compression. Inter picture supports both intra and inter prediction. A CU/PU in inter picture is either spatially or temporally predictive coded. Temporal references are the previously coded intra or inter pictures. </p><p id="p0050" num="0050"> [0042] The bits output by the entropy coding module 420 as well as the entropy encoded signs, significance map and non-zero coefficients are inserted into the bitstream by the encoder 1 16. This bitstream is sent to the decoders 138 and 140 over the HFC network 122 (FIG. 1A). When the decoders 138 and 140 (FIG. 1A) receive the bitstream, they perform the functions shown in FIG. 4B. An entropy decoding module 446 of the decoder 138 decodes the sign values, significance map and non-zero coefficients to recreate the quantized and transformed coefficients. The entropy decoding module 446 then provides the coefficients to a dequantizer module 447, which dequantizes the matrix of coefficients, resulting in E'. The dequantizer module 447 provides the dequantized coefficients to an inverse transform module 448. The inverse transform module 448 performs an inverse transform operation on the coefficients resulting in the 
<!-- EPO <DP n="13"/>-->
 reconstructed residual PU, e'. The reconstructed residual PU, e', is then added to the corresponding spatial prediction, x' to form a reconstructed PU, x". </p><p id="p0051" num="0051">[0043] Referring still to FIG. 4B, a loop filter module 450 performs a loop filtering operation on the reconstructed PU. Possible ways in which the loop filtering operation may be performed are discussed previously in conjunction with the loop filtering module 426 of FIG. 4A. If the reconstructed pictures are reference pictures, they will be stored in a reference buffer 452 for future temporal prediction. From the reference buffer 452, reference pictures are subjected to the operation of an interpolation filter 454. As will be described in more detail, the interpolation filter 454 performs operations that include calculating fractional pixels. </p><p id="p0052" num="0052">[0044] Various methods for interpolating fractional pixels according to embodiments of the invention will now be described. These methods may be carried out on the video system of FIG. 1A, the computer system of FIG. 1 B, or on any similar system. When implemented in conjunction with the encoder 1 16 or decoder 138 depicted in FIGS. 4A and 4B, these methods may be carried out by the interpolation filter 427 (FIG. 4A) and the interpolation filter 454 (FIG. 4B). The methods will be described with reference to FIG. 6, which depicts a pixel line. The pixel line includes a first integer pixel (R0), a second integer pixel (L0), a third integer pixel (L1 ), a fourth integer pixel (R1 ), a fifth integer pixel (L2), a sixth integer pixel (R2), a seventh integer pixel (L3), an eighth integer pixel (R3), a ninth integer pixel (L4), a tenth integer pixel (R4), an eleventh integer pixel (L5) and a twelfth integer pixel (R6). As can be seen in FIG. 6, the L0 and R0 are between L1 and R1 . L1 and R1 are between L2 and R2, L2 and R2 are between L3 and R3, L3 and R3 are between L4 and R4, and L4 and R4 are between L5 and R5. </p><p id="p0053" num="0053">[0045] Between integer pixels L0 and R0 are fractional pixels FL, H and FR. The relative positions of FL, H and FR are not to be taken as limiting. For example, FL and FR may be quarter pixels, eighth pixels, or any other fractional pixel. The pixel line represents pixels of an image that are oriented in a substantially straight line with respect to one another. This line is shown in FIG. 6 as being horizontal. However it is understood that the line may be oriented in any direction, including 
<!-- EPO <DP n="14"/>-->
 vertical or diagonal, and may extend to any dimension. Fractional pixels FL and FR are often referred to as "fractional-pel pixels," while fractional pixel H is sometimes referred to "half-pel pixel." </p><p id="p0054" num="0054">Embodiment I </p><p id="p0055" num="0055"> [0046] In this embodiment, the half-pel pixel, H, and fractional-pel pixels, FL and FR, are interpolated using the values of spatial neighboring full-pel pixels, L5, L4, L3, L2, L1 , L0, R0, R1 , R2, R3, R4, and R5, as follows, </p><p id="p0056" num="0056">[0047] FL = (FLW<sub>L5</sub><sup>*</sup>L5 + FLW<sub>L4</sub><sup>*</sup>L4 + FLW<sub>L3</sub><sup>*</sup>L3 + FLW<sub>L2</sub><sup>*</sup>L2 + FLW<sub>L</sub>i <sup>*</sup>L1 +</p><p id="p0057" num="0057">FLWLO*LO + FLWRO*RO + FLWRI*R1 + FLW<sub>R2</sub><sup>*</sup>R2 + FLW<sub>R3</sub><sup>*</sup>R3 + FLW<sub>R4</sub><sup>*</sup>R4 + FLRoundingOffset) » FLRightShiftBits; </p><p id="p0058" num="0058"> [0048] H = (HWL5*L5 + HW<sub>L4</sub><sup>*</sup>L4 + HW<sub>L3</sub><sup>*</sup>L3 + HW<sub>L2</sub><sup>*</sup>L2 + HW<sub>L</sub>i <sup>*</sup>L1 + </p><p id="p0059" num="0059"> HW<sub>L0</sub><sup>*</sup>L0 + HWRO*RO + HW<sub>R1</sub> <sup>*</sup>R1 + HW<sub>R2</sub><sup>*</sup>R2 + HW<sub>R3</sub><sup>*</sup>R3 + HW<sub>R4</sub><sup>*</sup>R4 + HW<sub>R5</sub><sup>*</sup>R5 + HRoundingOffset) » HRightShiftBits; </p><p id="p0060" num="0060"> [0049] FR = (FRW<sub>L4</sub><sup>*</sup>L4 + FRW<sub>L3</sub><sup>*</sup>L3 + FRW<sub>L2</sub><sup>*</sup>L2 + FRW<sub>L</sub>i <sup>*</sup>L1 + FRW<sub>L0</sub><sup>*</sup>L0</p><p id="p0061" num="0061">+ FRW<sub>R0</sub><sup>*</sup>R0 + FRWRI*R1 + FRW<sub>R2</sub><sup>*</sup>R2 + FRW<sub>R3</sub><sup>*</sup>R3 + FRW<sub>R4</sub><sup>*</sup>R4 + FRW<sub>R5</sub><sup>*</sup>R5 + FRRoundingOffset) » FRRightShiftBits. </p><p id="p0062" num="0062"> [0050] Here, FLW<sub>L</sub>5, FLW<sub>L4</sub>, and FLW<sub>R4</sub> are the weighting factors of L5, L4, and R4 when interpolating FL. FLRoundingOffset is the rounding offset when interpolating FL. FLRightShiftBits is the number of right shift bits when interpolating FL. HW<sub>L</sub>5, HW<sub>L4</sub>, and HW<sub>R5</sub> are the weighting factors of L5, L4, and R5 when interpolating H. HRoundingOffset is the rounding offset when interpolating H. HRightShiftBits is the number of right shift bits when interpolating H. FRW<sub>L4</sub>, FRW<sub>L3</sub>, and FRW<sub>R5</sub> are the weighting factors of L4, L3, and R5 when interpolating FR. FRRoundingOffset is the rounding offset when interpolating FR. FRRightShiftBits is the number of right shift bits when interpolating FR. In this embodiment, 12 integer pixels are used for half-pel interpolation and 11 integer pixels are used for fractional-pel interpolation. </p><p id="p0063" num="0063">Embodiment II 
<!-- EPO <DP n="15"/>-->
 [0051] In this embodiment, the half-pel pixel, H, and fractional-pel pixels, FL and FR, are interpolated using the values of spatial neighboring full-pel pixels, L4, L3, L2, L1 , L0, R0, R1 , R2, R3, and R4, as follows, </p><p id="p0064" num="0064"> [0052] FL = (FLWL4*L4 + FLW<sub>L3</sub><sup>*</sup>L3 + FLW<sub>L2</sub><sup>*</sup>L2 + FLW<sub>L</sub>i <sup>*</sup>L1 + FLW<sub>L0</sub><sup>*</sup>L0 +</p><p id="p0065" num="0065">FLWRO*RO + FLW<sub>R1</sub> <sup>*</sup>R1 + FLW<sub>R2</sub><sup>*</sup>R2 + FLW<sub>R3</sub><sup>*</sup>R3 + FLRoundingOffset) » </p><p id="p0066" num="0066">FLRightShiftBits; </p><p id="p0067" num="0067"> [0053] H = (HWL4*L4 + HW<sub>L3</sub><sup>*</sup>L3 + HW<sub>L2</sub><sup>*</sup>L2 + HW<sub>L</sub>i <sup>*</sup>L1 + HW<sub>L0</sub><sup>*</sup>L0 +</p><p id="p0068" num="0068">HWRO*RO + HWRI *R1 + HW<sub>R2</sub><sup>*</sup>R2 + HW<sub>R3</sub><sup>*</sup>R3 + HW<sub>R4</sub><sup>*</sup>R4 + HRoundingOffset) » HRightShiftBits; </p><p id="p0069" num="0069"> [0054] FR = (FRW<sub>L3</sub><sup>*</sup>L3 + FRW<sub>L2</sub><sup>*</sup>L2 + FRW<sub>L</sub>i <sup>*</sup>L1 + FRW<sub>L0</sub><sup>*</sup>L0 + FRW<sub>R0</sub><sup>*</sup>R0</p><p id="p0070" num="0070">+ FRWRI *R1 + FRW<sub>R2</sub><sup>*</sup>R2 + FRW<sub>R3</sub><sup>*</sup>R3 + FRW<sub>R4</sub><sup>*</sup>R4 + FRRoundingOffset) » FRRightShiftBits. </p><p id="p0071" num="0071"> [0055] Here, FLW<sub>L4</sub>, FLW<sub>L3</sub>, and FLW<sub>R3</sub> are the weighting factors of L4, L3, and R3 when interpolating FL. FLRoundingOffset is the rounding offset when interpolating FL. FLRightShiftBits is the number of right shift bits when interpolating FL. HW<sub>L4</sub>, HW<sub>L3</sub>, and HW<sub>R4</sub> are the weighting factors of L4, L3, and R4 when interpolating H. HRoundingOffset is the rounding offset when interpolating H. HRightShiftBits is the number of right shift bits when interpolating H. FRW<sub>L3</sub>, FRW<sub>L2</sub>, and FRW<sub>R4</sub> are the weighting factors of L3, L2, and R4 when interpolating FR. FRRoundingOffset is the rounding offset when interpolating FR. FRRightShiftBits is the number of right shift bits when interpolating FR. In this embodiment, 10 integer pixels are used for half-pel interpolation and 9 integer pixels are used for fractional-pel interpolation. </p><p id="p0072" num="0072">Embodiment III </p><p id="p0073" num="0073"> [0056] In this embodiment, the half-pel pixel, H, and fractional-pel pixels, FL and FR, are interpolated using the values of spatial neighboring full-pel pixels, L3, L2, L1 , L0, R0, R1 , R2, and R3, as follows, </p><p id="p0074" num="0074"> [0057] FL = (FLW<sub>L3</sub><sup>*</sup>L3 + FLW<sub>L2</sub><sup>*</sup>L2 + FLW<sub>L</sub>i <sup>*</sup>L1 + FLW<sub>L0</sub><sup>*</sup>L0 + FLW<sub>R0</sub><sup>*</sup>R0 + 
<!-- EPO <DP n="16"/>-->
 FLW<sub>R1</sub> <sup>*</sup>R1 + FLW<sub>R2</sub><sup>*</sup>R2 + FLRoundingOffset) » FLRightShiftBits; </p><p id="p0075" num="0075">[0058] H = (HW<sub>L3</sub><sup>*</sup>L3 + HW<sub>L2</sub><sup>*</sup>L2 + HW<sub>L</sub>i <sup>*</sup>L1 + HW<sub>L0</sub><sup>*</sup>L0 + HW<sub>R0</sub><sup>*</sup>R0 +</p><p id="p0076" num="0076">HWRI *R1 + HWR2*R2 + HW<sub>R3</sub><sup>*</sup>R3 + HRoundingOffset) » HRightShiftBits; </p><p id="p0077" num="0077"> [0059] FR = (FRW<sub>L2</sub><sup>*</sup>L2 + FRW<sub>L</sub>i <sup>*</sup>L1 + FRW<sub>L0</sub><sup>*</sup>L0 + FRW<sub>R0</sub><sup>*</sup>R0 + FRW<sub>R</sub>i <sup>*</sup>R1</p><p id="p0078" num="0078">+ FRW<sub>R2</sub><sup>*</sup>R2 + FRW<sub>R3</sub><sup>*</sup>R3 + FRRoundingOffset) » FRRightShiftBits. </p><p id="p0079" num="0079">[0060] Here, FLW<sub>L</sub>3, FLW<sub>L2</sub>, and FLW<sub>R2</sub> are the weighting factors of L3, L2, and R2 when interpolating FL. FLRoundingOffset is the rounding offset when interpolating FL. FLRightShiftBits is the number of right shift bits when interpolating FL. HW<sub>L</sub>3, HW<sub>L2</sub>, and HW<sub>R3</sub> are the weighting factors of L3, L2, and R3 when interpolating H. HRoundingOffset is the rounding offset when interpolating H. HRightShiftBits is the number of right shift bits when interpolating H. FRW<sub>L2</sub>, FRWLI , and FRW<sub>R3</sub> are the weighting factors of L2, L1 , and R3 when interpolating FR. FRRoundingOffset is the rounding offset when interpolating FR. FRRightShiftBits is the number of right shift bits when interpolating FR. In this embodiment, 8 integer pixels are used for half-pel interpolation and 7 integer pixels are used for fractional-pel interpolation. </p><p id="p0080" num="0080">Embodiment IV </p><p id="p0081" num="0081"> [0061] In this embodiment, the half-pel pixel, H, and fractional-pel pixels, FL and FR, are interpolated using the values of spatial neighboring full-pel pixels, L2, L1 , L0, R0, R1 , and R2, as follows, </p><p id="p0082" num="0082"> [0062] FL = (FLW<sub>L2</sub><sup>*</sup>L2 + FLW<sub>L</sub>i <sup>*</sup>L1 + FLW<sub>L0</sub><sup>*</sup>L0 + FLW<sub>R0</sub><sup>*</sup>R0 + FLW<sub>R1</sub> <sup>*</sup>R1 +</p><p id="p0083" num="0083">FLRoundingOffset) » FLRightShiftBits; </p><p id="p0084" num="0084"> [0063] H = (HW<sub>L2</sub><sup>*</sup>L2 + HW<sub>L</sub>i <sup>*</sup>L1 + HW<sub>L0</sub><sup>*</sup>L0 + HW<sub>R0</sub><sup>*</sup>R0 + HW<sub>m</sub> <sup>*</sup>R1 +</p><p id="p0085" num="0085">HW<sub>R2</sub><sup>*</sup>R2 + HRoundingOffset) » HRightShiftBits; </p><p id="p0086" num="0086"> [0064] FR = (FRWLI <sup>*</sup>L1 + FRW<sub>L0</sub><sup>*</sup>L0 + FRW<sub>R0</sub><sup>*</sup>R0 + FRW<sub>R1</sub> <sup>*</sup>R1 + FRW<sub>R2</sub><sup>*</sup>R2</p><p id="p0087" num="0087">+ FRRoundingOffset) » FRRightShiftBits. </p><p id="p0088" num="0088"> [0065] Here, FLW<sub>L2</sub>, FLW<sub>L</sub>i , and FLW<sub>R</sub>i are the weighting factors of L2, L1 , and R1 when interpolating FL. FLRoundingOffset is the rounding offset 
<!-- EPO <DP n="17"/>-->
 when interpolating FL. FLRightShiftBits is the number of right shift bits when interpolating FL. HW<sub>L</sub>2, HW<sub>L</sub>i , and HW<sub>R2</sub> are the weighting factors of L2, L1 , and R2 when interpolating H. HRoundingOffset is the rounding offset when interpolating H. HRightShiftBits is the number of right shift bits when interpolating H. FRWLI , FRWLO, and FRW<sub>R2</sub> are the weighting factors of L1 , LO, and R2 when interpolating FR. FRRoundingOffset is the rounding offset when interpolating FR. FRRightShiftBits is the number of right shift bits when interpolating FR. In this embodiment, 6 integer pixels are used for half-pel interpolation and 5 integer pixels are used for fractional-pel interpolation. </p><p id="p0089" num="0089">Embodiment V </p><p id="p0090" num="0090"> [0066] In this embodiment, the half-pel pixel, H, and fractional-pel pixels, FL and FR, are interpolated using the values of spatial neighboring full-pel pixels, L1 , LO, RO, and R1 , as follows, </p><p id="p0091" num="0091"> [0067] FL = (FLWLI*L1 + FLW<sub>L0</sub><sup>*</sup>L0 + FLW<sub>R0</sub><sup>*</sup>R0 + FLRoundingOffset) »</p><p id="p0092" num="0092">FLRightShiftBits; </p><p id="p0093" num="0093"> [0068] H = (HWLI *L1 + HW<sub>L0</sub><sup>*</sup>L0 + HW<sub>R0</sub><sup>*</sup>R0 + HW<sub>R1</sub> <sup>*</sup>R1 +</p><p id="p0094" num="0094">HRoundingOffset) » HRightShiftBits; </p><p id="p0095" num="0095"> [0069] FR = (FRWLO*LO + FRW<sub>R0</sub><sup>*</sup>R0 + FRW<sub>m</sub> <sup>*</sup>R1 + FRRoundingOffset) »</p><p id="p0096" num="0096">FRRightShiftBits. </p><p id="p0097" num="0097"> [0070] Here, FLW<sub>L</sub>i , FLW<sub>L0</sub>, and FLW<sub>R0</sub> are the weighting factors of L1 , L0, and R0 when interpolating FL. FLRoundingOffset is the rounding offset when interpolating FL. FLRightShiftBits is the number of right shift bits when interpolating</p><p id="p0098" num="0098">FL. HWLI , HWLO, HWRO, and HW<sub>R</sub>i are the weighting factors of L1 , L0, R0, and R1 when interpolating H. HRoundingOffset is the rounding offset when interpolating H.</p><p id="p0099" num="0099">HRightShiftBits is the number of right shift bits when interpolating H. FRW<sub>L</sub>o,</p><p id="p0100" num="0100">FRW<sub>R0</sub>, and FRW<sub>R</sub>i are the weighting factors of L0, R0, and R1 when interpolatig</p><p id="p0101" num="0101">FR. FRRoundingOffset is the rounding offset when interpolating FR.</p><p id="p0102" num="0102">FRRightShiftBits is the number of right shift bits when interpolating FR. In this 
<!-- EPO <DP n="18"/>-->
 embodiment, 4 integer pixels are used for half-pel interpolation and 3 integer pixels are used for fractional-pel interpolation. </p><p id="p0103" num="0103"> [0071] In image and video compression, it might be desirable to have an even symmetric interpolation filter for interpolating half-pel pixels. Also, it might be desirable that the quarter-pel filters are reflections of one other. This may ensure linear (or zero) phase filtering in the overall interpolation. For example, referring to FIG. 6, assuming FL is the quarter pixel between L0 and H, and FR is the quarter pixel between H and R0, applying of the two constraints on Embodiment I makes the relationships between the fractional pixel weighting factors as shown in Table 1 : </p><p id="p0104" num="0104"><img id="imgf000018_0001" he="91" wi="162" file="imgf000018_0001.tif" img-format="tif" img-content="table" orientation="portrait" inline="yes"/></p><p id="p0105" num="0105"> [0072] A specific interpolation filter may work well for certain types of video contents. It might be preferable to adaptively choose the interpolation filter(s). Thus, different interpolation filter(s) may be used for different video sequences. </p><p id="p0106" num="0106"> [0073] In addition, the characteristics of the pixels along the horizontal lines and the vertical lines may be very different. Hence, separable filters may be employed in the horizontal and vertical directions. The separable horizontal and 
<!-- EPO <DP n="19"/>-->
 vertical filters may not necessarily the same, depending upon the video content. For example, a coding unit or a picture with mostly horizontal detail could use a stronger vertical filter, etc. </p><p id="p0107" num="0107"> [0074] The filter selection information can be signaled explicitly, or derived implicitly, at sequence, picture, slice or even CU level. </p><p id="p0108" num="0108"> [0075] Although described specifically throughout the entirety of the instant disclosure, representative examples have utility over a wide range of applications, and the above discussion is not intended and should not be construed to be limiting. The terms, descriptions and figures used herein are set forth by way of illustration only and are not meant as limitations. Those skilled in the art recognize that many variations are possible within the spirit and scope of the examples. While the examples have been described with reference to examples, those skilled in the art are able to make various modifications to the described examples without departing from the scope of the examples as described in the following claims, and their equivalents. 
</p></description><claims mxw-id="PCLM44997329" ref-ucid="WO-2012121965-A1" lang="EN" load-source="patent-office"><claim-statement><!-- EPO <DP n="20"/>-->What is claimed is: </claim-statement><claim id="clm-0001" num="1"><claim-text>1 . A method for interpolating a first fractional pixel (FL), a half pixel (H), and a second fractional pixel (FR) located between a first integer pixel (L0) and a second integer pixel (R0) along a pixel line, wherein the pixel line further includes a third integer pixel (L1 ), a fourth integer pixel (R1 ), a fifth integer pixel (L2), a sixth integer pixel (R2), a seventh integer pixel (L3) and an eighth integer pixel (R3), the method comprising: </claim-text><claim-text> selecting a first set of integer pixels along the pixel line, the first set consisting of the seventh integer pixel (L3), the fifth integer pixel (L2), the third integer pixel (L1 ), the first integer pixel (L0), the second integer pixel (R0), the fourth integer pixel (R1 ) and the sixth integer pixel (R2); </claim-text><claim-text> selecting a second set of integer pixels along the pixel line, the second set consisting of the eighth integer pixel (L3), the fifth integer pixel (L2), the third integer pixel (L1 ), the first integer pixel (L0), the second integer pixel (RO), the fourth integer pixel (R1 ), the sixth integer pixel (R2) and the eighth integer pixel (R3); </claim-text><claim-text> selecting a third set of integer pixels along the pixel line the third set consisting of the fifth integer pixel (L2), the third integer pixel (L1 ), the first integer pixel (LO), the second integer pixel (RO), the fourth integer pixel (R1 ), the sixth integer pixel (R2) and the eighth integer pixel (R3), </claim-text><claim-text> wherein the first integer pixel (LO) and the second integer pixel (RO) are between the third integer pixel (L1 ) and the fourth integer pixel (R1 ), the third integer pixel (L1 ) and the fourth integer pixel (R1 ) are between the fifth integer pixel (L2) and the sixth integer pixel (R2), and the fifth integer pixel (L2) and the sixth integer pixel (R2) are between the seventh integer pixel (L3) and the eighth integer pixel (R3); <!-- EPO <DP n="21"/>--> calculating a value for a first fractional pixel (FL) based on the values of the pixels of the first set; </claim-text><claim-text> calculating a value for the half pixel (H) based on the values of the pixels in the second set; and </claim-text><claim-text> calculating a value for the second fractional pixel (FR) based on the values of the pixels in the third set. </claim-text></claim><claim id="clm-0002" num="2"><claim-text>2. The method of claim 1 , </claim-text><claim-text> wherein the step of calculating a value for the first fractional pixel (FL) comprises applying weighting factors to the values of the integer pixels of the first set, </claim-text><claim-text> wherein the step of calculating a value for the half pixel (H) comprises applying weighting factors to the values of the integer pixels of the second set, the weighting factors being symmetrical about the half pixel (H), and </claim-text><claim-text> wherein the step of calculating a value for the second fractional pixel (FR) comprises applying weighting factors to the values of the integer pixels of the third set, </claim-text><claim-text> wherein the weighting factors applied to the values of the pixels of the first set are reflections about the half pixel of the weighting factors applied to the values of the pixels of the third set. </claim-text></claim><claim id="clm-0003" num="3"><claim-text>3. The method of claim 1 , wherein the steps of calculating a value for a first fractional pixel (FL), a half pixel (H), and a second fractional pixel (FR) comprise calculating FL, H and FR, respectively, based on: </claim-text><claim-text> FL = (FLWL3*L3 + FLWL2*L2 + FLW<sub>L</sub>i <sup>*</sup>L1 + FLW<sub>L0</sub><sup>*</sup>L0 + FLW<sub>R0</sub><sup>*</sup>R0 + FLW<sub>R1</sub> <sup>*</sup>R1 + FLWR2*R2 + FLRoundingOffset) » FLRightShiftBits; </claim-text><claim-text> H = (HWL3*L3 + HWL2*L2 + HW<sub>L</sub>i <sup>*</sup>L1 + HW<sub>L0</sub><sup>*</sup>L0 + HW<sub>R0</sub><sup>*</sup>R0 + HW<sub>R</sub>i <sup>*</sup>R1 + HWR2*R2 + HWR3*R3 + HRoundingOffset) » HRightShiftBits; </claim-text><claim-text> FR = (FRWL2*L2 + FRWLI *L1 + FRW<sub>L0</sub><sup>*</sup>L0 + FRW<sub>R0</sub><sup>*</sup>R0 + FRW<sub>m</sub> <sup>*</sup>R1 + FRWR2*R2 + FRWR3*R3 + FRRoundingOffset) » FRRightShiftBits, <!-- EPO <DP n="22"/>--> wherein FLW<sub>L3</sub>, FLW<sub>L2</sub>, FLW<sub>L</sub>i , FLW<sub>L0</sub>, FLW<sub>R0</sub>, FLW<sub>R1</sub> , and FLW<sub>R2</sub> are the weighting factors of L3, L2, L1 , LO, RO, R1 and R2 respectively, FLRoundingOffset is the rounding offset, and FLRightShiftBits is the number of right shift bits; </claim-text><claim-text> wherein HW<sub>L3</sub>, HW<sub>L2</sub>, HW<sub>L</sub>i, HW<sub>L0</sub>, HW<sub>R0</sub>, HW<sub>R</sub>i„ HW<sub>R2</sub>, and HW<sub>R3</sub> are the weighting factors of L3, L2, L1 , LO, RO, R1 , R2 and R3, HRoundingOffset is the rounding offset, and HRightShiftBits is the number of right shift bits; and </claim-text><claim-text> wherein FRW<sub>L2</sub>, FRW<sub>L</sub>i , FRW<sub>L0</sub>, FRW<sub>R0</sub>, FRWm , FRW<sub>R2</sub>, and FRW<sub>R3</sub> are the weighting factors of L2, L1 , LO, RO, R1 , R2 and R3, FRRoundingOffset is the rounding offset, and FRRightShiftBits is the number of right shift bits. </claim-text></claim><claim id="clm-0004" num="4"><claim-text>4. The method of claim 3, </claim-text><claim-text> wherein HW<sub>L3</sub> = HW<sub>R3</sub>, HW<sub>L2</sub> = HW<sub>R2</sub>, HW<sub>L</sub>i = HW<sub>m &gt;</sub> and HW<sub>L0</sub> = HW<sub>R0</sub>, and wherein FLW<sub>L3</sub> = FRW<sub>R3</sub>, FLW<sub>L2</sub> = FRW<sub>R2</sub>, FLW<sub>L</sub>i = FRW<sub>R1</sub> , FLW<sub>L0</sub> = FRWRO, FLWRO = FRWLO, FLWRI = FRW<sub>L</sub>i, FLW<sub>R2</sub> = FRW<sub>L2</sub> </claim-text></claim><claim id="clm-0005" num="5"><claim-text>5. The method of claim 1 , </claim-text><claim-text> wherein the pixel line further includes a ninth integer pixel (L4) and a tenth integer pixel (R4); </claim-text><claim-text> wherein the seventh integer pixel (L3) and the eighth integer pixel (R3) are between the ninth integer pixel (L4) and the tenth integer pixel (R4), </claim-text><claim-text> wherein the first set of integer pixels further consists of the ninth integer pixel (L4) and the eighth integer pixel (R3), </claim-text><claim-text> wherein the second set of integer pixels further consists of the ninth integer pixel (L4) and the tenth integer pixel (R4), and </claim-text><claim-text> wherein the third set of integer pixels further consists of the seventh integer pixel (L3) and the tenth integer pixel (R4). <!-- EPO <DP n="23"/>--> </claim-text></claim><claim id="clm-0006" num="6"><claim-text>6. The method of claim 5, wherein the steps of calculating a value for a first fractional pixel (FL), a half pixel (H), and a second fractional pixel (FR) comprise calculating FL, H and FR, respectively, based on: </claim-text><claim-text> FL = (FLWL4*L4 + FLWL3*L3 + FLW<sub>L2</sub><sup>*</sup>L2 + FLW<sub>L</sub>i <sup>*</sup>L1 + FLW<sub>L0</sub><sup>*</sup>L0 + FLWRO*RO + FLW<sub>R1</sub> <sup>*</sup>R1 + FLW<sub>R2</sub><sup>*</sup>R2 + FLW<sub>R3</sub><sup>*</sup>R3 + FLRoundingOffset) » FLRightShiftBits; </claim-text><claim-text> H = (HWL4*L4 + HWL3*L3 + HW<sub>L2</sub><sup>*</sup>L2 + HW<sub>L</sub>i <sup>*</sup>L1 + HW<sub>L0</sub><sup>*</sup>L0 + HW<sub>R0</sub><sup>*</sup>R0 + HWRI *R1 + HW<sub>R2</sub><sup>*</sup>R2 + HW<sub>R3</sub><sup>*</sup>R3 + HW<sub>R4</sub><sup>*</sup>R4 + HRoundingOffset) » HRightShiftBits; </claim-text><claim-text> FR = (FRWL3*L3 + FRW<sub>L2</sub><sup>*</sup>L2 + FRW<sub>L</sub>i <sup>*</sup>L1 + FRW<sub>L0</sub><sup>*</sup>L0 + FRW<sub>R0</sub><sup>*</sup>R0 + FRWRI*R1 + FRW<sub>R2</sub><sup>*</sup>R2 + FRW<sub>R3</sub><sup>*</sup>R3 + FRW<sub>R4</sub><sup>*</sup>R4 + FRRoundingOffset) » FRRightShiftBits; </claim-text><claim-text> wherein FLW<sub>L4</sub>, FLW<sub>L3</sub>, FLW<sub>L2</sub>, FLW<sub>L</sub>i , FLW<sub>L0</sub>, FLW<sub>R0</sub>, FLW<sub>R1</sub>, FLW<sub>R2</sub>, and FLW<sub>R3</sub> are the weighting factors of L4, L3, L2, L1 , L0, R0, R1 , R2, and R3 respectively, FLRoundingOffset is the rounding offset, and FLRightShiftBits is the number of right shift bits; </claim-text><claim-text> wherein HW<sub>L4</sub>, HW<sub>L3</sub>, HW<sub>L2</sub>, HW<sub>L1</sub>, HW<sub>L0</sub>, HW<sub>R0</sub>, HW<sub>R1</sub> , HW<sub>R2</sub>, HW<sub>R3</sub> and HW<sub>R4</sub> are the weighting factors of L4, L3, L2, L1 , L0, R0, R1 , R2, R3 and R4 respectively, HRoundingOffset is the rounding offset and HRightShiftBits is the number of right shift bits; and </claim-text><claim-text> wherein FRW<sub>L3</sub>, FRW<sub>L2</sub>, FRW<sub>L</sub>i , FRW<sub>L0</sub>, FRW<sub>R0</sub>, FRW<sub>R</sub>i , FRW<sub>R2</sub>, FRW<sub>R3</sub> and FRW<sub>R4</sub> are the weighting factors of L3, L2, L1 , L0, R0, R1 , R2, R3 and R4 respectively, FRRoundingOffset is the rounding offset, and FRRightShiftBits is the number of right shift bits. </claim-text></claim><claim id="clm-0007" num="7"><claim-text>7. The method of claim 6, </claim-text><claim-text> wherein HW<sub>L4</sub> = HW<sub>R4</sub>, HW<sub>L3</sub> = HW<sub>R3</sub>, HW<sub>L2</sub> = HW<sub>R2</sub>, HW<sub>L</sub>i = HW<sub>R</sub>i , and <img id="imgf000023_0001" he="5" wi="27" file="imgf000023_0001.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="no"/> <!-- EPO <DP n="24"/>--> and wherein FLW<sub>L4</sub> = FRW<sub>R4</sub>, FLW<sub>L3</sub> = FRW<sub>R3</sub>, FLW<sub>L2</sub> = FRW<sub>R2</sub>, FLW<sub>L</sub>i = FRWRI , FLWLO = FRWRO, FLWRO = FRW<sub>L0</sub>, FLWRI = FRW<sub>L</sub>i , FLW<sub>R2</sub> = FRW<sub>L2</sub>,</claim-text><claim-text>FLWRS = FRWLS </claim-text></claim><claim id="clm-0008" num="8"><claim-text>8. The method of claim 1 , </claim-text><claim-text> wherein the pixel line further includes a ninth integer pixel (L4), tenth integer pixel (R4), eleventh integer pixel (L5), and twelfth integer pixel (R5); </claim-text><claim-text> wherein the seventh integer pixel (L3) and the eighth integer pixel (R3) are between the ninth integer pixel (L4) and the tenth integer pixel (R4), </claim-text><claim-text> wherein the ninth integer pixel (L4) and the tenth integer pixel (R4) are between the eleventh integer pixel (L5) and the twelfth integer pixel (R5), </claim-text><claim-text> wherein the first set of integer pixels further consists of the eleventh integer pixel (L5), the ninth integer pixel (L4), the eighth integer pixel (R3) and the tenth integer pixel (R4), </claim-text><claim-text> wherein the second set of integer pixels further consists of the eleventh integer pixel (L5), the ninth integer pixel (L4), the tenth integer pixel (R4) and the twelfth integer pixel (R5), and </claim-text><claim-text> wherein the third set of integer pixels further consists of the ninth integer pixel (L4), the seventh integer pixel (L3), the tenth integer pixel (R4) and the twelfth integer pixel (R5). </claim-text></claim><claim id="clm-0009" num="9"><claim-text>9. The method of claim 8, wherein the steps of calculating a value for a first fractional pixel (FL), a half pixel (H), and a second fractional pixel (FR) comprise calculating FL, H and FR, respectively, based on: </claim-text><claim-text> FL = (FLWL5*L5 + FLW<sub>L4</sub><sup>*</sup>L4 + FLW<sub>L3</sub><sup>*</sup>L3 + FLW<sub>L2</sub><sup>*</sup>L2 + FLW<sub>L</sub>i <sup>*</sup>L1 + FLW<sub>L0</sub><sup>*</sup>L0 + FLWRO*RO + FLW<sub>R1</sub> <sup>*</sup>R1 + FLW<sub>R2</sub><sup>*</sup>R2 + FLW<sub>R3</sub><sup>*</sup>R3 + FLW<sub>R4</sub><sup>*</sup>R4 + FLRoundingOffset) » FLRightShiftBits; </claim-text><claim-text> H = (HWL5*L5 + HW<sub>L4</sub><sup>*</sup>L4 + HW<sub>L3</sub><sup>*</sup>L3 + HW<sub>L2</sub><sup>*</sup>L2 + HW<sub>L</sub>i <sup>*</sup>L1 + HW<sub>L0</sub><sup>*</sup>L0 + HWRO*RO + HWRI *R1 + HW<sub>R2</sub><sup>*</sup>R2 + HW<sub>R3</sub><sup>*</sup>R3 + HW<sub>R4</sub><sup>*</sup>R4 + HW<sub>R5</sub><sup>*</sup>R5 + HRoundingOffset) » HRightShiftBits; <!-- EPO <DP n="25"/>--> FR = (FRWL4*L4 + FRW<sub>L3</sub><sup>*</sup>L3 + FRW<sub>L2</sub><sup>*</sup>L2 + FRW<sub>L</sub>i <sup>*</sup>L1 + FRW<sub>L0</sub><sup>*</sup>L0 + FRWRO*RO + FRWRI*R1 + FRWR2*R2 + FRW<sub>R3</sub><sup>*</sup>R3 + FRW<sub>R4</sub><sup>*</sup>R4 + FRW<sub>R5</sub><sup>*</sup>R5 + FRRoundingOffset) » FRRightShiftBits; </claim-text><claim-text> wherein FLW<sub>L5</sub>, FLW<sub>L4</sub>, FLW<sub>L3</sub>, FLW<sub>L2</sub>, FLWu , FLW<sub>L0</sub>, FLW<sub>R0</sub>, FLW<sub>R</sub>i , FLW<sub>R2</sub>, FLW<sub>R3</sub>, and FLW<sub>R4</sub> are the weighting factors of L5, L4, L3, L2, L1 , L0, R0, R1 , R2, R3 and R4 respectively, FLRoundingOffset is the rounding offset, and FLRightShiftBits is the number of right shift bits; </claim-text><claim-text> wherein HW<sub>L5</sub>, HW<sub>L4</sub>, HW<sub>L3</sub>, HW<sub>L2</sub>, HW<sub>L</sub>i , HW<sub>L0</sub>, HW<sub>R0</sub>, HW<sub>R1</sub>, HW<sub>R2</sub>, HW<sub>R3</sub>, HW<sub>R4</sub>, and HW<sub>R5</sub> are the weighting factors of L5, L4, L3, L2, L1 , L0, R0, R1 , R2, R3, R4 and R5 respectively, HRoundingOffset is the rounding offset, HRightShiftBits is the number of right shift bits; and </claim-text><claim-text> wherein FRW<sub>L4</sub>, FRW<sub>L3</sub>, FRW<sub>L2</sub>, FRW<sub>L</sub>i , FRW<sub>L0</sub>, FRW<sub>R0</sub>, FRW<sub>R</sub>i , FRW<sub>R2</sub>, FRW<sub>R3</sub>, FRW<sub>R4</sub> and FRW<sub>R5</sub> are the weighting factors of L4, L3, L2, L1 , L0, R0, R1 , R2, R3, R4 and R5 respectively, FRRoundingOffset is the rounding offset, FRRightShiftBits is the number of right shift bits. </claim-text></claim><claim id="clm-0010" num="10"><claim-text>10. The method of claim 9, </claim-text><claim-text> wherein HW<sub>L5</sub> = HW<sub>R5</sub>, HW<sub>L4</sub> = HW<sub>R4</sub>, HW<sub>L3</sub> = HW<sub>R3</sub>, HW<sub>L2</sub> = HW<sub>R2</sub>, HW<sub>L</sub>i = HWRI , and HW<sub>L0</sub> = HW<sub>R0</sub>, </claim-text><claim-text> and wherein FLW<sub>L5</sub> = FRW<sub>R5</sub>, FLW<sub>L4</sub> = FRW<sub>R4</sub>, FLW<sub>L3</sub> = FRW<sub>R3</sub>, FLW<sub>L2</sub> = FRW<sub>R2</sub>, FLWLI = FRWRI , FLW<sub>LO</sub> = FRW<sub>R0</sub>, FLW<sub>R0</sub> = FRW<sub>L0</sub>, FLW<sub>R</sub>i = FRW<sub>L</sub>i , FLW<sub>R2</sub> = FRW<sub>L2</sub>, FLW<sub>R3</sub> = FRW<sub>L3</sub>, FLW<sub>R4</sub> = FRW<sub>L4</sub> </claim-text></claim><claim id="clm-0011" num="11"><claim-text>1 1 . A video processing system, the system comprising: </claim-text><claim-text>a processor that executes instructions for performing steps comprising: </claim-text><claim-text> reading a pixel line comprising a first integer pixel (L0), a second integer pixel (R0), a third integer pixel (L1 ), a fourth integer pixel (R1 ), a fifth integer pixel (L2), a sixth integer pixel (R2), a seventh integer pixel (L3) and an eighth integer pixel (R3), <!-- EPO <DP n="26"/>--> selecting a first set of integer pixels along the pixel line, the first set consisting of the seventh integer pixel (L3), the fifth integer pixel (L2), the third integer pixel (L1 ), the first integer pixel (LO), the second integer pixel (RO), the fourth integer pixel (R1 ) and the sixth integer pixel (R2); </claim-text><claim-text> selecting a second set of integer pixels along the pixel line, the second set consisting of the eighth integer pixel (L3), the fifth integer pixel (L2), the third integer pixel (L1 ), the first integer pixel (LO), the second integer pixel (RO), the fourth integer pixel (R1 ), the sixth integer pixel (R2) and the eighth integer pixel (R3); </claim-text><claim-text> selecting a third set of integer pixels along the pixel line the third set consisting of the fifth integer pixel (L2), the third integer pixel (L1 ), the first integer pixel (LO), the second integer pixel (RO), the fourth integer pixel (R1 ), the sixth integer pixel (R2) and the eighth integer pixel (R3), </claim-text><claim-text> wherein the first integer pixel (LO) and the second integer pixel (RO) are between the third integer pixel (L1 ) and the fourth integer pixel (R1 ), the third integer pixel (L1 ) and the fourth integer pixel (R1 ) are between the fifth integer pixel (L2) and the sixth integer pixel (R2), and the fifth integer pixel (L2) and the sixth integer pixel (R2) are between the seventh integer pixel (L3) and the eighth integer pixel (R3); </claim-text><claim-text> calculating a value for a first fractional pixel (FL) located between the first integer pixel (LO) and the second integer pixel (RO) based on the values of the pixels of the first set; </claim-text><claim-text> calculating a value for a half pixel (H) located between the first integer pixel (LO) and the second integer pixel (RO) based on the values of the pixels in the second set; and </claim-text><claim-text> calculating a value for a second fractional pixel (FR) located between the first integer pixel (LO) and the second integer pixel (RO) based on the values of the pixels in the third set. <!-- EPO <DP n="27"/>--> </claim-text></claim><claim id="clm-0012" num="12"><claim-text>12. The system of claim 1 1 , </claim-text><claim-text> wherein the step of calculating a value for the first fractional pixel (FL) comprises applying weighting factors to the values of the integer pixels of the first set, </claim-text><claim-text> wherein the step of calculating a value for the half pixel (H) comprises applying weighting factors to the values of the integer pixels of the second set, the weighting factors being symmetrical about the half pixel (H), and </claim-text><claim-text> wherein the step of calculating a value for the second fractional pixel (FR) comprises applying weighting factors to the values of the integer pixels of the third set, </claim-text><claim-text> wherein the weighting factors applied to the values of the pixels of the first set are reflections about the half pixel of the weighting factors applied to the values of the pixels of the third set. </claim-text></claim><claim id="clm-0013" num="13"><claim-text>13. The system of claim 1 1 , wherein the steps of calculating a value for a first fractional pixel (FL), a half pixel (H), and a second fractional pixel (FR) comprise calculating FL, H and FR, respectively, based on: </claim-text><claim-text> FL = (FLWL3*L3 + FLWL2*L2 + FLW<sub>L</sub>i <sup>*</sup>L1 + FLW<sub>L0</sub><sup>*</sup>L0 + FLW<sub>R0</sub><sup>*</sup>R0 + FLWRI *R1 + FLWR2*R2 + FLRoundingOffset) » FLRightShiftBits; </claim-text><claim-text> H = (HWL3*L3 + HWL2*L2 + HW<sub>L</sub>i <sup>*</sup>L1 + HW<sub>L0</sub><sup>*</sup>L0 + HW<sub>R0</sub><sup>*</sup>R0 + HW<sub>R</sub>i <sup>*</sup>R1 + HWR2*R2 + HWR3*R3 + HRoundingOffset) » HRightShiftBits; </claim-text><claim-text> FR = (FRW<sub>L2</sub><sup>*</sup>L2 + FRWLI *L1 + FRW<sub>L0</sub><sup>*</sup>L0 + FRW<sub>R0</sub><sup>*</sup>R0 + FRW<sub>R1</sub> <sup>*</sup>R1 + FRWR2*R2 + FRWR3*R3 + FRRoundingOffset) » FRRightShiftBits, </claim-text><claim-text> wherein FLW<sub>L3</sub>, FLW<sub>L2</sub>, FLW<sub>L</sub>i , FLW<sub>L0</sub>, FLW<sub>R0</sub>, FLW<sub>R</sub>i , and FLW<sub>R2</sub> are the weighting factors of L3, L2, L1 , LO, RO, R1 and R2 respectively, FLRoundingOffset is the rounding offset, and FLRightShiftBits is the number of right shift bits; </claim-text><claim-text> wherein HW<sub>L3</sub>, HW<sub>L2</sub>, HW<sub>L</sub>i , HW<sub>L0</sub>, HW<sub>R0</sub>, HW<sub>R</sub>i„ HW<sub>R2</sub>, and HW<sub>R3</sub> are the weighting factors of L3, L2, L1 , LO, RO, R1 , R2 and R3, HRoundingOffset is the rounding offset, and HRightShiftBits is the number of right shift bits; and <!-- EPO <DP n="28"/>--> wherein FRW<sub>L2</sub>, FRW<sub>L</sub>i , FRW<sub>L0</sub>, FRW<sub>R0</sub>, FRW<sub>R1</sub> , FRW<sub>R2</sub>, and FRW<sub>R3</sub> are the weighting factors of L2, L1 , LO, RO, R1 , R2 and R3, FRRoundingOffset is the rounding offset, and FRRightShiftBits is the number of right shift bits. </claim-text></claim><claim id="clm-0014" num="14"><claim-text>14. The system of claim 13, wherein HW<sub>L3</sub> = HW<sub>R3</sub>, HW<sub>L2</sub> = HW<sub>R2</sub>, HW<sub>L</sub>i = HW<sub>R</sub>i , and HW<sub>L0</sub> = HW<sub>R0</sub>, and wherein FLW<sub>L3</sub> = FRW<sub>R3</sub>, FLW<sub>L2</sub> = FRW<sub>R2</sub>, FLW<sub>L</sub>i = FRW<sub>R</sub>i , FLW<sub>L0</sub> = FRWRO., FLWRO = FRWLO, FLWRI = FRW<sub>L</sub>i , FLW<sub>R2</sub> = FRW<sub>L2</sub> </claim-text></claim><claim id="clm-0015" num="15"><claim-text>15. The system of claim 1 1 , </claim-text><claim-text> wherein the pixel line further includes a ninth integer pixel (L4) and a tenth integer pixel (R4); </claim-text><claim-text> wherein the seventh integer pixel (L3) and the eighth integer pixel (R3) are between the ninth integer pixel (L4) and the tenth integer pixel (R4), </claim-text><claim-text> wherein the first set of integer pixels further consists of the ninth integer pixel (L4) and the eighth integer pixel (R3), </claim-text><claim-text> wherein the second set of integer pixels further consists of the ninth integer pixel (L4) and the tenth integer pixel (R4), and </claim-text><claim-text> wherein the third set of integer pixels further consists of the seventh integer pixel (L3) and the tenth integer pixel (R4). </claim-text></claim><claim id="clm-0016" num="16"><claim-text>16. The system of claim 15, wherein the steps of calculating a value for a first fractional pixel (FL), a half pixel (H), and a second fractional pixel (FR) comprise calculating FL, H and FR, respectively, based on: </claim-text><claim-text> FL = (FLWL4*L4 + FLW<sub>L3</sub><sup>*</sup>L3 + FLW<sub>L2</sub><sup>*</sup>L2 + FLW<sub>L</sub>i <sup>*</sup>L1 + FLW<sub>L0</sub><sup>*</sup>L0 + FLW<sub>R0</sub><sup>*</sup>R0 + FLW<sub>R1</sub> <sup>*</sup>R1 + FLW<sub>R2</sub><sup>*</sup>R2 + FLW<sub>R3</sub><sup>*</sup>R3 + FLRoundingOffset) » FLRightShiftBits; <!-- EPO <DP n="29"/>--> H = (HWL4*L4 + HW<sub>L3</sub><sup>*</sup>L3 + HW<sub>L2</sub><sup>*</sup>L2 + HW<sub>L</sub>i <sup>*</sup>L1 + HW<sub>L0</sub><sup>*</sup>L0 + HW<sub>R0</sub><sup>*</sup>R0 + HWRI *R1 + HWR2*R2 + HWR3*R3 + HW<sub>R4</sub><sup>*</sup>R4 + HRoundingOffset) » HRightShiftBits; </claim-text><claim-text> FR = (FRWL3*L3 + FRWL2*L2 + FRW<sub>L</sub>i <sup>*</sup>L1 + FRW<sub>L0</sub><sup>*</sup>L0 + FRW<sub>R0</sub><sup>*</sup>R0 + FRW<sub>R1</sub> <sup>*</sup>R1 + FRWR2*R2 + FRW<sub>R3</sub><sup>*</sup>R3 + FRW<sub>R4</sub><sup>*</sup>R4 + FRRoundingOffset) » FRRightShiftBits; </claim-text><claim-text> wherein FLW<sub>L4</sub>, FLW<sub>L3</sub>, FLW<sub>L2</sub>, FLW<sub>L</sub>i , FLW<sub>L0</sub>, FLW<sub>R0</sub>, FLW<sub>R</sub>i , FLW<sub>R2</sub>, and FLW<sub>R3</sub> are the weighting factors of L4, L3, L2, L1 , L0, R0, R1 , R2, and R3 respectively, FLRoundingOffset is the rounding offset, and FLRightShiftBits is the number of right shift bits; </claim-text><claim-text> wherein HW<sub>L4</sub>, HW<sub>L3</sub>, HW<sub>L2</sub>, HW<sub>L</sub>i , HW<sub>L0</sub>, HW<sub>R0</sub>, HW<sub>R</sub>i , HW<sub>R2</sub>, HW<sub>R3</sub> and HW<sub>R4</sub> are the weighting factors of L4, L3, L2, L1 , L0, R0, R1 , R2, R3 and R4 respectively, HRoundingOffset is the rounding offset and HRightShiftBits is the number of right shift bits; and </claim-text><claim-text> wherein FRW<sub>L3</sub>, FRW<sub>L2</sub>, FRW<sub>L</sub>i , FRW<sub>L0</sub>, FRW<sub>R0</sub>, FRW<sub>R</sub>i , FRW<sub>R2</sub>, FRW<sub>R3</sub> and FRW<sub>R4</sub> are the weighting factors of L3, L2, L1 , L0, R0, R1 , R2, R3 and R4 respectively, FRRoundingOffset is the rounding offset, and FRRightShiftBits is the number of right shift bits. </claim-text></claim><claim id="clm-0017" num="17"><claim-text>17. The system of claim 16, </claim-text><claim-text> wherein HW<sub>L4</sub> = HW<sub>R4</sub>, HW<sub>L3</sub> = HW<sub>R3</sub>, HW<sub>L2</sub> = HW<sub>R2</sub>, HW<sub>L</sub>i = HW<sub>R</sub>i , and <img id="imgf000029_0001" he="5" wi="27" file="imgf000029_0001.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="no"/> </claim-text><claim-text> and wherein FLW<sub>L4</sub> = FRW<sub>R4</sub>, FLW<sub>L3</sub> = FRW<sub>R3</sub>, FLW<sub>L2</sub> = FRW<sub>R2</sub>, FLW<sub>L</sub>i = FRWRI , FLWLO = FRWRO, FLWRO = FRW<sub>L0</sub>, FLW<sub>R</sub>i = FRW<sub>L</sub>i , FLW<sub>R2</sub> = FRW<sub>L2</sub>, FLW<sub>R3</sub> = FRW<sub>L3</sub>. </claim-text></claim><claim id="clm-0018" num="18"><claim-text>18. The system of claim 1 1 , </claim-text><claim-text> wherein the pixel line further includes a ninth integer pixel (L4), tenth integer pixel (R4), eleventh integer pixel (L5), and twelfth integer pixel (R5); <!-- EPO <DP n="30"/>--> wherein the seventh integer pixel (L3) and the eighth integer pixel (R3) are between the ninth integer pixel (L4) and the tenth integer pixel (R4), </claim-text><claim-text> wherein the ninth integer pixel (L4) and the tenth integer pixel (R4) are between the eleventh integer pixel (L5) and the twelfth integer pixel (R5), </claim-text><claim-text> wherein the first set of integer pixels further consists of the eleventh integer pixel (L5), the ninth integer pixel (L4), the eighth integer pixel (R3) and the tenth integer pixel (R4), </claim-text><claim-text> wherein the second set of integer pixels further consists of the eleventh integer pixel (L5), the ninth integer pixel (L4), the tenth integer pixel (R4) and the twelfth integer pixel (R5), and </claim-text><claim-text> wherein the third set of integer pixels further consists of the ninth integer pixel (L4), the seventh integer pixel (L3), the tenth integer pixel (R4) and the twelfth integer pixel (R5). </claim-text></claim><claim id="clm-0019" num="19"><claim-text>19. The system of claim 18, wherein the steps of calculating a value for a first fractional pixel (FL), a half pixel (H), and a second fractional pixel (FR) comprise calculating FL, H and FR, respectively, based on: </claim-text><claim-text> FL = (FLWL5*L5 + FLWL4*L4 + FLW<sub>L3</sub><sup>*</sup>L3 + FLW<sub>L2</sub><sup>*</sup>L2 + FLW<sub>L</sub>i <sup>*</sup>L1 + FLWLO*LO + FLWRO*RO + FLWRI *R1 + FLW<sub>R2</sub><sup>*</sup>R2 + FLW<sub>R3</sub><sup>*</sup>R3 + FLW<sub>R4</sub><sup>*</sup>R4 + FLRoundingOffset) » FLRightShiftBits; </claim-text><claim-text> H = (HWL5*L5 + HWL4*L4 + HW<sub>L3</sub><sup>*</sup>L3 + HW<sub>L2</sub><sup>*</sup>L2 + HW<sub>L</sub>i <sup>*</sup>L1 + HW<sub>L0</sub><sup>*</sup>L0 + HWRO*RO + HW<sub>R1</sub> <sup>*</sup>R1 + HW<sub>R2</sub><sup>*</sup>R2 + HW<sub>R3</sub><sup>*</sup>R3 + HW<sub>R4</sub><sup>*</sup>R4 + HW<sub>R5</sub><sup>*</sup>R5 + HRoundingOffset) » HRightShiftBits; </claim-text><claim-text> FR = (FRW<sub>L4</sub><sup>*</sup>L4 + FRW<sub>L3</sub><sup>*</sup>L3 + FRW<sub>L2</sub><sup>*</sup>L2 + FRW<sub>L</sub>i <sup>*</sup>L1 + FRW<sub>L0</sub><sup>*</sup>L0 + FRW<sub>R0</sub><sup>*</sup>R0 + FRWRI*R1 + FRW<sub>R2</sub><sup>*</sup>R2 + FRW<sub>R3</sub><sup>*</sup>R3 + FRW<sub>R4</sub><sup>*</sup>R4 + FRW<sub>R5</sub><sup>*</sup>R5 + FRRoundingOffset) » FRRightShiftBits; </claim-text><claim-text> wherein FLW<sub>L5</sub>, FLW<sub>L4</sub>, FLW<sub>L3</sub>, FLW<sub>L2</sub>, FLW<sub>L</sub>i , FLW<sub>L0</sub>, FLW<sub>R0</sub>, FLW<sub>R</sub>i , FLW<sub>R2</sub>, FLW<sub>R3</sub>, and FLW<sub>R4</sub> are the weighting factors of L5, L4, L3, L2, L1 , L0, R0, R1 , R2, R3 and R4 respectively, FLRoundingOffset is the rounding offset, and FLRightShiftBits is the number of right shift bits; <!-- EPO <DP n="31"/>--> wherein HW<sub>L5</sub>, HW<sub>L4</sub>, HW<sub>L3</sub>, HW<sub>L2</sub>, HW<sub>U l</sub> HW<sub>L0</sub>, HW<sub>R0</sub>, HW<sub>R1</sub>, HW<sub>R2</sub>, HW<sub>R3</sub>, HW<sub>R4</sub>, and HW<sub>R5</sub> are the weighting factors of L5, L4, L3, L2, L1 , LO, RO, R1 , R2, R3, R4 and R5 respectively, HRoundingOffset is the rounding offset, HRightShiftBits is the number of right shift bits; and </claim-text><claim-text> wherein FRW<sub>L4</sub>, FRW<sub>L3</sub>, FRW<sub>L2</sub>, FRW<sub>L</sub>i , FRW<sub>L0</sub>, FRW<sub>R0</sub>, FRW<sub>R1</sub> , FRW<sub>R2</sub>, FRW<sub>R</sub>3, FRW<sub>R4</sub> and FRW<sub>R5</sub> are the weighting factors of L4, L3, L2, L1 , LO, RO, R1 , R2, R3, R4 and R5 respectively, FRRoundingOffset is the rounding offset, FRRightShiftBits is the number of right shift bits. </claim-text></claim><claim id="clm-0020" num="20"><claim-text>20. The system of claim 19, </claim-text><claim-text> wherein HW<sub>L5</sub> = HW<sub>R5</sub>, HW<sub>L4</sub> = HW<sub>R4</sub>, HW<sub>L3</sub> = HW<sub>R3</sub>, HW<sub>L2</sub> = HW<sub>R2</sub>, HW<sub>L</sub>i = HWRI , and HW<sub>L0</sub> = HW<sub>R0</sub>, </claim-text><claim-text> and wherein FLW<sub>L5</sub> = FRW<sub>R5</sub>, FLW<sub>L4</sub> = FRW<sub>R4</sub>, FLW<sub>L3</sub> = FRW<sub>R3</sub>, FLW<sub>L2</sub> = FRW<sub>R2</sub>, FLWLI = FRWRI , FLW<sub>LO</sub> = FRW<sub>R0</sub>, FLW<sub>R0</sub> = FRW<sub>L0</sub>, FLW<sub>M</sub> = FRW<sub>L</sub>i , FLW<sub>R2</sub> = FRW<sub>L2</sub>, FLW<sub>R3</sub> = FRW<sub>L3</sub>, FLW<sub>R4</sub> = FRW<sub>L4.</sub> </claim-text></claim></claims><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
