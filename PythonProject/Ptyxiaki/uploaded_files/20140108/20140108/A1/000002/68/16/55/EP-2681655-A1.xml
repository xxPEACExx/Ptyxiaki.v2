<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2681655-A1" country="EP" doc-number="2681655" kind="A1" date="20140108" family-id="46967122" file-reference-id="260143" date-produced="20180822" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146586151" ucid="EP-2681655-A1"><document-id><country>EP</country><doc-number>2681655</doc-number><kind>A1</kind><date>20140108</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-12711514-A" is-representative="NO"><document-id mxw-id="PAPP154848343" load-source="docdb" format="epo"><country>EP</country><doc-number>12711514</doc-number><kind>A</kind><date>20120316</date><lang>EN</lang></document-id><document-id mxw-id="PAPP220440026" load-source="docdb" format="original"><country>EP</country><doc-number>12711514.5</doc-number><date>20120316</date></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140555185" ucid="US-201161473344-P" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201161473344</doc-number><kind>P</kind><date>20110408</date></document-id></priority-claim><priority-claim mxw-id="PPC140549872" ucid="US-2012029331-W" linkage-type="W" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>2012029331</doc-number><kind>W</kind><date>20120316</date></document-id></priority-claim><priority-claim mxw-id="PPC140552839" ucid="US-201213420691-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201213420691</doc-number><kind>A</kind><date>20120315</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1989320476" load-source="docdb">G06F   9/45        20060101AFI20121023BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL2104291678" load-source="docdb" scheme="CPC">G05B  19/05        20130101 LI20140806BHEP        </classification-cpc><classification-cpc mxw-id="PCL2104292225" load-source="docdb" scheme="CPC">G06F   8/456       20130101 FI20140806BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132363086" lang="DE" load-source="patent-office">PARALLELISIERUNG VON PLC-PROGRAMMEN ZUM BETRIEB IN MULTIPROZESSORUMGEBUNGEN</invention-title><invention-title mxw-id="PT132363087" lang="EN" load-source="patent-office">PARALLELIZATION OF PLC PROGRAMS FOR OPERATION IN MULTI-PROCESSOR ENVIRONMENTS</invention-title><invention-title mxw-id="PT132363088" lang="FR" load-source="patent-office">PARALLÉLISATION DE PROGRAMMES PLC EN VUE D'UN FONCTIONNEMENT DANS DES ENVIRONNEMENTS MULTIPROCESSEUR</invention-title><citations><non-patent-citations><nplcit><text>See references of WO 2012138464A1</text><sources><source mxw-id="PNPL67455819" load-source="docdb" name="SEA"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR919531020" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>SIEMENS AG</last-name><address><country>DE</country></address></addressbook></applicant><applicant mxw-id="PPAR919515375" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>SIEMENS AKTIENGESELLSCHAFT</last-name></addressbook></applicant><applicant mxw-id="PPAR919009437" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Siemens Aktiengesellschaft</last-name><iid>101362070</iid><address><street>Wittelsbacherplatz 2</street><city>80333 München</city><country>DE</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR919541275" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>MARTINEZ CANEDO ARQUIMEDES</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919510007" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>MARTINEZ CANEDO, ARQUIMEDES</last-name></addressbook></inventor><inventor mxw-id="PPAR919017642" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>MARTINEZ CANEDO, ARQUIMEDES</last-name><address><street>10206 Harcross Court</street><city>Princeton, New Jersey 08540</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919515625" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>AL FARUQUE MOHAMMAD ABDULLAH</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919536638" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>AL FARUQUE, MOHAMMAD ABDULLAH</last-name></addressbook></inventor><inventor mxw-id="PPAR919018791" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>AL FARUQUE, MOHAMMAD ABDULLAH</last-name><address><street>5 Kahlo Court</street><city>Irvine, California 92617</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919523873" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>PACKER MITCHELL</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919538890" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>PACKER, Mitchell</last-name></addressbook></inventor><inventor mxw-id="PPAR919017219" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>PACKER, Mitchell</last-name><address><street>6502 Spruce Mill Dr.</street><city>Yardley, Pennsylvania 19067</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919509949" load-source="docdb" sequence="4" format="epo"><addressbook><last-name>FREITAG RICHARD</last-name><address><country>DE</country></address></addressbook></inventor><inventor mxw-id="PPAR919515306" load-source="docdb" sequence="4" format="intermediate"><addressbook><last-name>FREITAG, RICHARD</last-name></addressbook></inventor><inventor mxw-id="PPAR919015047" load-source="patent-office" sequence="4" format="original"><addressbook><last-name>FREITAG, RICHARD</last-name><address><street>Blücherstr. 7</street><city>80634 Munich</city><country>DE</country></address></addressbook></inventor></inventors></parties><international-convention-data><pct-or-regional-filing-data ucid="US-2012029331-W"><document-id><country>US</country><doc-number>2012029331</doc-number><kind>W</kind><date>20120316</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2012138464-A1"><document-id><country>WO</country><doc-number>2012138464</doc-number><kind>A1</kind><date>20121011</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS549913521" load-source="docdb">AL</country><country mxw-id="DS549845824" load-source="docdb">AT</country><country mxw-id="DS549913522" load-source="docdb">BE</country><country mxw-id="DS549757583" load-source="docdb">BG</country><country mxw-id="DS549833598" load-source="docdb">CH</country><country mxw-id="DS549765220" load-source="docdb">CY</country><country mxw-id="DS549845825" load-source="docdb">CZ</country><country mxw-id="DS549756986" load-source="docdb">DE</country><country mxw-id="DS549913523" load-source="docdb">DK</country><country mxw-id="DS549765237" load-source="docdb">EE</country><country mxw-id="DS549833915" load-source="docdb">ES</country><country mxw-id="DS549757584" load-source="docdb">FI</country><country mxw-id="DS549757589" load-source="docdb">FR</country><country mxw-id="DS549756987" load-source="docdb">GB</country><country mxw-id="DS549913524" load-source="docdb">GR</country><country mxw-id="DS549913525" load-source="docdb">HR</country><country mxw-id="DS549765238" load-source="docdb">HU</country><country mxw-id="DS549833599" load-source="docdb">IE</country><country mxw-id="DS549913526" load-source="docdb">IS</country><country mxw-id="DS549757590" load-source="docdb">IT</country><country mxw-id="DS549765239" load-source="docdb">LI</country><country mxw-id="DS549756988" load-source="docdb">LT</country><country mxw-id="DS549845830" load-source="docdb">LU</country><country mxw-id="DS549756993" load-source="docdb">LV</country><country mxw-id="DS549756994" load-source="docdb">MC</country><country mxw-id="DS549834691" load-source="docdb">MK</country><country mxw-id="DS549834692" load-source="docdb">MT</country><country mxw-id="DS549845831" load-source="docdb">NL</country><country mxw-id="DS549833600" load-source="docdb">NO</country><country mxw-id="DS549845832" load-source="docdb">PL</country><country mxw-id="DS549833916" load-source="docdb">PT</country><country mxw-id="DS549845833" load-source="docdb">RO</country><country mxw-id="DS549833917" load-source="docdb">RS</country><country mxw-id="DS549845838" load-source="docdb">SE</country><country mxw-id="DS549756995" load-source="docdb">SI</country><country mxw-id="DS549833601" load-source="docdb">SK</country><country mxw-id="DS549833606" load-source="docdb">SM</country><country mxw-id="DS549834693" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><abstract mxw-id="PA100914147" ref-ucid="WO-2012138464-A1" lang="EN" load-source="patent-office"><p num="0000">A method of identifying and extracting functional parallelism from a PLC program has been developed that results in the ability of the extracted program fragments to be executed in parallel across a plurality of separate resources, and a compiler configured to perform the functional parallelism (i.e., identification and extraction processes) and perform the scheduling of the separate fragments within a given set of resources. The inventive functional parallelism creates a larger number of separable elements than was possible with prior dataflow analysis methodologies.</p></abstract><abstract mxw-id="PA101176083" ref-ucid="WO-2012138464-A1" lang="EN" source="national office" load-source="docdb"><p>A method of identifying and extracting functional parallelism from a PLC program has been developed that results in the ability of the extracted program fragments to be executed in parallel across a plurality of separate resources, and a compiler configured to perform the functional parallelism (i.e., identification and extraction processes) and perform the scheduling of the separate fragments within a given set of resources. The inventive functional parallelism creates a larger number of separable elements than was possible with prior dataflow analysis methodologies.</p></abstract><abstract mxw-id="PA100914148" ref-ucid="WO-2012138464-A1" lang="FR" load-source="patent-office"><p num="0000">Selon l'invention, un procédé d'identification et d'extraction de parallélisme fonctionnel d'un programme PLC a été développé, lequel a pour résultat la capacité des fragments de programme extraits à être exécutés en parallèle sur une pluralité de ressources séparées, et un compilateur configuré pour effectuer le parallélisme fonctionnel (c'est-à-dire, des processus d'identification et d'extraction) et effectuer l'ordonnancement des fragments séparés dans un ensemble donné de ressources. Le parallélisme fonctionnel de l'invention crée un plus grand nombre d'éléments séparables que ce qui était possible à l'aide des méthodologies d'analyse de flux de données antérieures.</p></abstract><abstract mxw-id="PA101176084" ref-ucid="WO-2012138464-A1" lang="FR" source="national office" load-source="docdb"><p>Selon l'invention, un procédé d'identification et d'extraction de parallélisme fonctionnel d'un programme PLC a été développé, lequel a pour résultat la capacité des fragments de programme extraits à être exécutés en parallèle sur une pluralité de ressources séparées, et un compilateur configuré pour effectuer le parallélisme fonctionnel (c'est-à-dire, des processus d'identification et d'extraction) et effectuer l'ordonnancement des fragments séparés dans un ensemble donné de ressources. Le parallélisme fonctionnel de l'invention crée un plus grand nombre d'éléments séparables que ce qui était possible à l'aide des méthodologies d'analyse de flux de données antérieures.</p></abstract><description mxw-id="PDES51853780" ref-ucid="WO-2012138464-A1" lang="EN" load-source="patent-office"><!-- EPO <DP n="2"/>--><p id="p0001" num="0001"> PARALLELIZATION OF PLC PROGRAMS FOR OPERATION IN MULTIPROCESSOR ENVIRONMENTS </p><p id="p0002" num="0002">Cross-Reference to Related Applications </p><p id="p0003" num="0003"> [0001] The application claims the benefit of US Provisional Application No. 61/473,344, filed April 8, 2011 and herein incorporated by reference. </p><p id="p0004" num="0004">Technical Field </p><p id="p0005" num="0005"> [0002] The present invention relates to automatic parallelization of standardized industrial automation languages for execution in multi-core processors and, more particularly, to an automatic parallelization technique that relies on both dataflow analysis and functional analysis to create balanced parallelization across multiple processing resources. </p><p id="p0006" num="0006">Background of the Invention </p><p id="p0007" num="0007"> [0003] An industrial control system often includes a programmable logic controller</p><p id="p0008" num="0008">(PLC) for providing coordinated control of industrial control equipment, which includes various elements that are often either sensors for providing inputs to the PLC, or relays for receiving outputs from the PLC, each under the control of an element controller, and each connected to the PLC over a network via a network I/O device. A PLC generally has a processor, a memory, and a number of separate input/output (I/O) modules coupled to the control equipment. The processor is the heart of the PLC and responsible for many PLC functions, such as input scanning, logic solving and output scanning. </p><p id="p0009" num="0009"> [0004] As the complexity of industrial systems has increased, the associated PLCs have evolved to utilize embedded software for the coordination of the requisite high-volume and high- precision manufacturing. Industries such as pharmaceutical, chemical, energy and others rely on PLCs that are utilized for sensing, planning complex processes and actuating thousands of times per second through high-speed cameras, light sensors, collision avoidance and detection, robotic devices, motors and the like. These PLCs must not only comply with hard real-time </p><p id="p0010" num="0010">requirements, but must also be able to survive in extreme environments of temperature, pressure, vibration and humidity, while remaining operable for decades without interruption or failure. Throughout the years, embedded software for PLCs has been developed by non-computer 
<!-- EPO <DP n="3"/>-->
 experts using domain- specific languages that have been designed and refined by experienced practitioners, manufacturers of automation hardware and software, as well as independent institutions from different industry sectors. </p><p id="p0011" num="0011"> [0005] The IEC 61131-3 standard has been widely adopted as the programming standard for PLCs since about 1993, but its languages have been used since the early 1970' s. The standard provides a total of five different languages: two textual languages (Instruction List or IL, and Structured Text or ST), two graphical languages (Ladder Diagram or LD, and Function Block Diagram or FBD) and one with both textual and graphical representations (Sequence Function Chart or SFC). Different industry sectors use different languages, or combinations of them, simply because each language has special semantics that facilitate certain automation tasks. These programming languages have been designed to satisfy the needs and increase the productivity of non-computer experts such as electrical, mechanical and chemical engineers. </p><p id="p0012" num="0012">[0006] Flexibility is one of the most important features in industrial PLCs inasmuch as the production requirements change significantly between different products, or different generations of the same product. Therefore, there is an economical and technical motivation to shift from custom architectures and programming languages into flexible off-the-shelf architectures and standardized automation languages. </p><p id="p0013" num="0013"> [0007] The adoption of multi-core processors appears to be the next evolutionary step in high-performance control systems, since they offer better energy efficiency, redundancy, consolidation properties and scalable performance than existing systems. Unfortunately, as of today, there is only a very limited understanding on how to compile IEC 61131-3 languages for execution in multi-core processors. US Patent Publication 2011/007749, dated March 31, 2011, describes an initial attempt to introduce PLC systems to the multi-core processor environment. In this arrangement, the various applications associated with the PLC are associated with different processors and operated in parallel. For example, one processor is dedicated to I/O scanning with access to I/O modules, another processor is dedicated to the logic solving that runs the user's program, a third processor is used for communication and a fourth for diagnostics. While this arrangement does utilize multiple processors in parallel, the efficiency of the arrangement is not optimum and there may be considerable periods of time where one or another of the processors is idle while another is over-demanded. 
<!-- EPO <DP n="4"/>-->
 [0008] US Patent Publication 2010/0306733 dated December 2, 2010 describes the use of a controller in the form of a general purpose PC with multiple cores. In this case, an automated technique is applied to the data flow program which scans for iterative functionality that allows for the data flow to be partitioned into separate portions. These portions are then distributed across the multiple set of processors to be executed in parallel. Again, while this automatic parallelization of a data flow program is useful in identifying portions that can be assigned to different processors, this partitioning occurs at a relatively high level (i.e., providing a "coarse grain" division), which results in a relatively unbalanced parallelism across the multiple processors. </p><p id="p0014" num="0014"> [0009] In this type of analysis, the compilers analyze the program to identify, organize and exploit parallelism by searching for data-independent blocks that can be partitioned and executed in parallel. If a program is written in a slightly obscure or different way, the compiler may fail to recognize one or more locations where partitioning may be applied. Normally, compilers must guarantee that the generated code produces the exact same results that were intended by the programmer. This expected behavior is enforced by the traditional dataflow analysis, which is executed on the compiler's internal representation of the program. </p><p id="p0015" num="0015">[0010] Whenever the dataflow analysis cannot determine if there is a true data dependency, it takes a conservative approach and assumes that a dependency exists, in order to guarantee equivalent semantics in the generated code. In some cases, these data dependencies do not exist in the high-level representation of the program, but have been introduced when translating the program into a lower-level representation that simply understands basic instructions and memory locations. </p><p id="p0016" num="0016"> [0011] Thus a need remains for an improved methodology for efficiently implementing</p><p id="p0017" num="0017">PLC programs in a multi-core processor environment. </p><p id="p0018" num="0018">Summary of the Invention </p><p id="p0019" num="0019"> [0012] The needs remaining in the prior art are addressed by the present invention, which relates to automatic parallelization of standardized industrial automation languages for execution in multi-core processors and, more particularly, to an automatic parallelization technique that relies on both dataflow analysis and functional analysis to create balanced parallelization. 
<!-- EPO <DP n="5"/>-->
 [0013] In accordance with the teachings of the present invention, it has been realized that the functional information expressed in the high-level languages associated with IEC 61131-3 (hereinafter simply referred to as "PLC programs" for the sake of clarity and simplicity) can serve as a foundation for uncovering a significant amount of parallelization opportunities for distributing tasks between different resources. Traditional approaches to searching for parallelism in PLC programs have ignored the fact that PLC programs are inherently </p><p id="p0020" num="0020">synchronous, where the concept of "time" can be leveraged to benefit parallel execution. </p><p id="p0021" num="0021">Particularly, there are several library blocks that behave as time delays, where at least one execution cycle is required before the outputs become valid. These blocks therefore effectively break the dependency between input and output. By searching for and recognizing these blocks, the methodology of the present invention creates "slices" within specific function blocks to create distinct segments (fragments), allowing these different fragments to be distributed among the available resources to best utilize the multi-core processor capabilities. </p><p id="p0022" num="0022">[0014] In a preferred embodiment of the present invention, an initial dataflow analysis is performed, similar to the prior art arrangement described above, to ascertain the independent program blocks that do not require inputs or outputs from other blocks. The functional partitioning methodology of the present invention is then applied to each independent program block output from the dataflow analysis process, performing a search of the high-level functional language to find specific function blocks that can be characterized as time delays. </p><p id="p0023" num="0023">[0015] It is another aspect of the present invention to analyze and distribute the fragments across the multiple resources (i.e., across multiple cores in a multi-core processor) in a one-to-many manner that most efficiently utilizes the available resources (i.e., scheduling and load balancing). </p><p id="p0024" num="0024"> [0016] In one specific embodiment, the present invention can be defined as a </p><p id="p0025" num="0025">programmable logic controller (PLC) for executing a program written in one or more high-level functional languages including a plurality of resources for executing various portions of the program, at least one memory coupled to the processors, and a compiler for performing functional parallelism by: parsing the program into a plurality of program organization units (POUs); identifying blocks within the high-level functional languages of each POU that include one or more time delays such that operations before and after the time delays can be executed in 
<!-- EPO <DP n="6"/>-->
 parallel; creating program fragments as partitioned by the identified time delays; and scheduling the program fragments across the plurality of resources to be executed in parallel. </p><p id="p0026" num="0026">[0017] In another embodiment, the present invention defines a method of creating parallelism in a PLC program to provide parallel execution of various segments of the PLC program across a plurality of separate resources comprising the steps of: (1) evaluating a high- level functional representation of the PLC program; (2) performing function block parallelism by identifying locations within the high-level functional representation of a time delay between an input and an output of a function block; and (3) separating the identified locations into program fragments that may be executed in parallel in different resources of the plurality of separate resources. </p><p id="p0027" num="0027"> [0018] Advantageous, the creation of additional occurrences of parallelism and the ability to allocation the program fragments across separate resources provides optimization of the PLC program in terms of one or more of the following: minimizing processing time, minimizing power consumption, maximizing CPU utilization, maximizing throughput and avoiding </p><p id="p0028" num="0028">"starvation" (i.e., idle time of a CPU). </p><p id="p0029" num="0029"> [0019] Other and further aspects of the present invention will become apparent during the course of the following discussion and by reference to the accompanying drawings. </p><p id="p0030" num="0030">Brief Description of the Drawings </p><p id="p0031" num="0031"> [0020] Referring now to the drawings, </p><p id="p0032" num="0032"> [0021] FIG. 1 illustrates an exemplary user application that may be subjected to the automatic parallelization technique of the present invention; </p><p id="p0033" num="0033"> [0022] FIG. 2 shows a specific program organization unit (POU) that has been identified by prior art dataflow analysis as containing two separate network elements; </p><p id="p0034" num="0034">[0023] FIG. 3 is an illustration of the application of functional parallelism in accordance with the present invention to the network elements of FIG. 2, creating a set of four separate program fragments that may be executed in parallel; </p><p id="p0035" num="0035"> [0024] FIG. 4 is a diagram illustrating three separate iterations of an exemplary PLC program that includes five separate tasks, Tl - T5; 
<!-- EPO <DP n="7"/>-->
 [0025] FIG. 5 is a revised version of the diagram of FIG. 4, in this case illustrating the application of functional parallelism of the present invention to each task, creating a number of fragments that may be separately scheduled across multiple resources; </p><p id="p0036" num="0036"> [0026] FIG. 6 is a listing of all of the fragments (sub-tasks) created in association with the arrangement of FIG. 5; </p><p id="p0037" num="0037"> [0027] FIG. 7 illustrates one exemplary "one-to-many" scheduling of the fragments shown in FIG. 6 across a set of four separate resources Rl - R4; </p><p id="p0038" num="0038"> [0028] FIG. 8 is an overall flowchart of an exemplary compilation of a PLC program utilizing functional parallelism in accordance with the present invention; </p><p id="p0039" num="0039"> [0029] FIG. 9 is a flowchart of a particular sequence of steps that may be used to provide both dataflow analysis and functional analysis to create both types of parallelism and create program fragments in accordance with the present invention; and </p><p id="p0040" num="0040"> [0030] FIG. 10 is a flowchart of an exemplary sequence of steps that may be used to distribute the created program fragments across multiple resources, in accordance with the present invention. </p><p id="p0041" num="0041">Detailed Description </p><p id="p0042" num="0042"> [0031] As will be described in detail hereinbelow, the present invention is directed to a method for automatically identifying and extracting parallelism from PLC programs written in high-level languages, the extracted parallelism preferably from both dataflow analysis and functional analysis, although the functional analysis of the present invention can indeed be performed independent of a dataflow analysis. These separate program fragments (tasks or sub- tasks) can then be assigned to different resources (such as different cores in a multi-core processor) and provide a well-balanced, efficient utilization of today's parallel processing environment. </p><p id="p0043" num="0043"> [0032] Indeed, a significant aspect of the present invention is the realization that the functional information expressed in the high-level languages associated with IEC 61131-3 (hereinafter simply referred to as "PLC programs" for the sake of clarity and simplicity) can serve as a foundation for uncovering a significant amount of parallelization opportunities for distributing tasks between different resources. Traditional approaches to searching for 
<!-- EPO <DP n="8"/>-->
 parallelism in PLC programs have ignored the fact that PLC programs are inherently synchronous, where the concept of "time" can be leveraged to benefit parallel execution. </p><p id="p0044" num="0044">Particularly, there are several library blocks that behave as time delays, where at least one execution cycle is required before the outputs become valid. These blocks therefore effectively break the dependency between input and output. By searching for and recognizing these blocks, the methodology of the present invention creates "slices" within specific function blocks to create distinct segments (fragments), allowing these different fragments to be distributed among the available resources to best utilize the multi-core processor capabilities. </p><p id="p0045" num="0045">[0033] In accordance with the present invention, the term "functional analysis" refers to the high-level behavior of a program. For example, the LAD programming language provides a "flip-flop" operand that can be used to "store information over time". A traditional compiler would translate the flip-flop operand into a sequence of basic instructions that after optimization may be re-ordered and interleaved with other instructions or sequences of instructions. In contrast, the present invention uses the high-level functional information about the flip-flop operand to optimize and slice the program for parallel processing. As mentioned above, PLC programs are inherently synchronous and therefore the concept of time can be leveraged to break the intra-iteration data dependencies that traditional dataflow analysis would conservatively honor. A flip-flop is considered to be exemplary only of the type of function block that can be defined as inserting a "time delay" into a PLC program (i.e., a library block that requires at least one execution cycle before the output becomes valid) and that can be used to partition a single function block into a number of separate tasks and/or sub-tasks (collectively referred to as "fragments"). Other function blocks in this category include simultaneous divergence blocks and asynchronous function calls. </p><p id="p0046" num="0046"> [0034] FIG. 1 illustrates an exemplary user application 10 that may be described and understood as benefitting from the automatic parallelization method of the present invention. The arrangement in this case includes a pair of resources 12-1 and 12-2 (e.g., a pair of single processor PLCs) that are used to execute several tasks, shown as Task 1, Task 2, Task 3 and Task 4 in FIG. 1. In this particular example, resource 12-1 is defined as a "fast CPU" and resource 12-2 is defined as a "slow CPU". As shown and shown in FIG. 1, each task is an instantiation of a program (with Programs A and B shown in application 10), and each program comprises one or more Program Organization Units (POUs). As noted, the different POUs 
<!-- EPO <DP n="9"/>-->
 within application 10 may be written in different languages. The parallelization technique of the present invention is able to search the high-level functional language of the various POUs and find opportunities to "break" the POUs into fragments that can be executed in parallel across multiple resources. </p><p id="p0047" num="0047"> [0035] The configuration shown in FIG. 1 contains the information about the allocation of programs into tasks with different properties, and in this example allocates Task 1 and Task 2 to resource 12-1, and Task 3 and Task 4 to resource 12-2. Each task has an associated program and includes a tuple that specifies the synchronous behavior? (or synchronicity?) and priority configuration. For example, Task 1 executes periodically every 50ms and has a "low" priority, while Task 2 executes only when an interrupt triggered by an I/O occurs and has a "high" priority. </p><p id="p0048" num="0048"> [0036] Once the configuration and the user program are specified, including the mapping of variables to physical addresses (not shown in FIG. 1), the POUs and configuration are translated into machine code for the specific architecture and sent to the devices for execution. </p><p id="p0049" num="0049">[0037] In this case, the availability of two separate PLCs (resources 12-1 and 12-2) allows for the separate programs to be assigned to the separate processors, creating a certain level of optimization of resource allocation. Stated another way, this existing model </p><p id="p0050" num="0050">acknowledges concurrency at the program level by allowing different programs (A, B, ...) to run on different resources through a one-to-one allocation. FIG. 2 illustrates this concept for an exemplary POU consisting of two networks 14 and 16, where data in the system flows from left to right. Network 14 includes a logic AND element 18, calculating the AND operation based on inputs "a" and "b", and then storing the result in a flip-flop memory location 20. The output of flip-flop 20 is thereafter combined with an input "e" in an OR element 22 and the result stored in location 24. Network 16 operates in a similar fashion, with a logic AND element 26 responsive to inputs "y" and "z", storing the result in a flip-flop memory location 28. The output of flip-flip 28 is combined with an input "q" in a second AND element 30, and the result stored in location 32. </p><p id="p0051" num="0051"> [0038] In performing a dataflow analysis of networks 14 and 16, it is found that network</p><p id="p0052" num="0052">14 is not producing any value that is consumed by network 16, nor is network 14 consuming any value produced by network 16. This data independence thus guarantees that network 14 can be executed in parallel with network 16, with this parallelism illustrated by the dotted lines in FIG. 
<!-- EPO <DP n="10"/>-->
 2. If a system has multiple resources (e.g., cores in a multi-core processor), this particular POU can be mapped in a one-to-many fashion by assigning each network to a different resource. Everything within a defined network can be executed in parallel to the other operations in the remaining network. However, the data dependencies within each network must be honored. This prior art dataflow analysis approach has thus been able to create a modest degree of parallelism in PLC programs. </p><p id="p0053" num="0053"> [0039] The present invention provides yet another level of parallelization by developing a methodology in which a single POU can be executed on multiple resources through a one-to- many allocation. In particular, it has been realized that the high-level programming languages utilized by a PLC include domain- specific semantics that facilitate the exploitation of a different type of parallelism that is orthogonal to the parallelism found by the dataflow analysis described above. The type of parallelism exploited by the present invention is referred to as "functional", since it uses domain- specific semantics found in the high-level functional language that describe "purpose" or "intent" of a specific action in a PLC program. Indeed, a significant aspect of the present invention relates to the ability to recognize and implement functional parallelism in addition to dataflow parallelism, resulting in the ability to partition POUs into even "finer" segments, creating the possibility to load balance across the resources in an improved manner. </p><p id="p0054" num="0054">[0040] Reference is made to flip-flops 20 and 28 in FIG. 2, whose function is to store</p><p id="p0055" num="0055">"state" information. The operational behavior of these elements is to delay the outputs (state) one execution cycle. Therefore, since the flip-flop inputs are decoupled from their associated outputs, this information can be used to break the computation flow within both networks 14 and 16. This is shown in FIG. 3, where diamonds within flip-flops 20 and 28 are used to illustrate the "break" in the time flow within each network. As a result, networks 14 and 16 can each be partitioned into two separate fragments, network 14 shown as comprising fragments 34 and 36, and network 16 shown as comprising fragments 38 and 40. In accordance with the present invention, inasmuch as these four fragments are all decoupled, they can be executed in parallel in multiple processing units. </p><p id="p0056" num="0056"> [0041] Thus, while the dataflow analysis identifies two parallel regions resulting in networks 14 and 16 as shown in FIG. 2, the functional parallelization technique of the present invention identifies an additional opportunity to partition the blocks at the time "breaks" associated with flip-flops 20 and 28, as shown in FIG. 3. In combination, the two parallelization 
<!-- EPO <DP n="11"/>-->
 techniques partition the program into four fragments that may be concurrently processed within the same execution cycle; that is, these four fragments can be executed in parallel in different resources. The dataflow analysis can be thought of slicing the program "horizontally" into tasks, with the functional analysis slicing the program "vertically" into sub-tasks. The two analyses, in combination, provide a two-dimensional parsing of the program into parallel fragments. </p><p id="p0057" num="0057">[0042] While this analysis is associated with only a single "pass" through networks 14 and 16, it is to be understood that PLC programs are executed periodically, where the user can select the sampling rate and organize the program into blocks for which the different sampling rates can be specified. FIG. 4 shows three iterations, denoted io, ii and of an exemplary PLC program. Tasks Tl, T2, T3, T4 and T5 have been identified by a dataflow analysis as separate partitions of one or more POUs that are data independent and can be executed in parallel. As shown in FIG. 4, task T2 is running only on even iterations {io, 12,■■■■) and task T5 has a variable workload. The cycle time, shown as T<sub>c</sub>, represents the time that is defined by the user for the set of tasks to complete. Execution time is defined as the time it takes to execute T1-T5, including the "read" of inputs, data processing and "write" to outputs. The time between the completion of the tasks and the beginning of the next cycle is defined as "sleep" time, where the resources are idle. </p><p id="p0058" num="0058"> [0043] As mentioned above, the main advantage of parallelizing industrial PLC applications is a reduction of the associated cycle time and, therefore, an improvement of the response time of the application to the environment. Typically, the faster an application is able to interact with the environment, the better it is for the control algorithms. However, a common problem when attempting to parallelize a program using only dataflow analysis is that the tasks are usually imbalanced and the longest task (critical path) bounds the performance in a parallel execution environment. In the example of FIG. 4, task Tl is shown to define the "critical path". Indeed, if the length of the critical path is 50% of the total execution time, then the maximum increase in processing speed is only twice that of the original, even if there are an infinite number of available resources. </p><p id="p0059" num="0059"> [0044] In accordance with the present invention, therefore, a substantial benefit arises from the ability to find function block "breaks" associated with the task(s) creating the critical path during a program's execution cycle. The ability to partition a critical path into separate fragments thus allows for these fragments to be executed in parallel and significantly reduce the 
<!-- EPO <DP n="12"/>-->
 critical path length. FIG. 5 illustrates the result of applying the functional parallelization technique to the set of tasks as previous described in association with FIG. 4. In this case, task Tl has been found to be separable into three fragments, as shown by the X's along the timeline of task Tl. Obviously, the functional parallelization of the present invention is applied to each identified task, not only the one associated with the critical path. In this particular example, tasks T2 and T3 are both shown as being separable into a pair of fragments. In each instance, the process of the present invention has discovered a function block in the form of a flip-flop, asynchronous function block, simultaneous divergence, or the like, and flags this as a location where the flow can be broken and the separate fragments can be executed on separate resources. </p><p id="p0060" num="0060">[0045] An important observation to understanding the method of the present invention is that at a "current" iteration, data dependencies associated with the above-mentioned function blocks are weak and can be safely ignored, since their results are used in the following iterations, not the current iteration. Therefore, these broken data dependencies allow the compiler to slice the task into subtasks (fragments), as indicated by the X's in FIG. 5. While the existing dataflow analysis has sliced the program into tasks, the method of the present invention finds a </p><p id="p0061" num="0061">complementary synchronous parallelism that is orthogonal to the dataflow analysis, where the dataflow analysis can be thought of as dividing the program "horizontally" into tasks and the method of the present invention divides the program "vertically" into sub-tasks. </p><p id="p0062" num="0062">[0046] FIG. 6 illustrates the results of implementing the functional parallelization on the tasks in the manner shown in FIG. 5, where FIG. 6 is a listing of the generated sub-tasks (i.e., "fragments") denoted ST1 - ST10 (with only the odd iterations, such as ii, having the full number of ten sub-tasks). It is noted that the cycle time T<sub>c</sub> has been reduced when compared to the initial value shown in FIG. 4, as a result of reducing the length of the critical path (now associated with sub-task ST6). </p><p id="p0063" num="0063"> [0047] While the ability to provide this finer-grain partitioning of programs allows for multi-core processors to be used more efficiently is a significant benefit in and of itself, a further advantage can be achieved by ascertaining the most efficient way in which to allocate these POU fragments across a given set of resources. The first step in this allocation process is to characterize the performance of the resources in a latency model, which takes into account the topology of the network to calculate communication latencies and computational capacities of its execution nodes. Different heuristics for parallel scheduling can be used to allocate the 
<!-- EPO <DP n="13"/>-->
 functional fragments into the multiple resources, taking into account the latency model such that the execution time of the application is reduced. </p><p id="p0064" num="0064"> [0048] The method of the present invention is considered to be schedule agnostic inasmuch as it simply finds additional parallelism that is hidden in the synchronous dimension. The final schedule then needs to be created based upon by the underlying implementation. One exemplary final schedule is shown in FIG. 7, which is based upon the availability of four separate resources Rl, R2, R3 and R4 (e.g., a 4-core processor), where it is assumed that the operational capabilities of the resources are identical. The scheduling of the computation across the four resources can be performed by multi-processor scheduling and is defined as an NP-hard optimization problem. An exemplary set of system characterizations includes: minimizing processing time, minimizing power consumption, maximizing resource utilization, maximizing throughput and avoiding "starvation" of one of more resources by underutilization. </p><p id="p0065" num="0065">[0049] PLCs utilize a very strict execution model based on tasks and POUs in which user programs are organized and executed. What makes the PLC execution scheme so unique is the prioritization of the execution of the tasks. That is, a higher priority task interrupts the execution of all lower priority tasks. A task may run uninterrupted only if it has the highest priority or completes. Thus, executing PLC programs in a multi-core processor environment requires careful prioritization of tasks such that the original semantics of the PLC program are honored, as will be discussed below in association with the one-to-many process flowchart of FIG. 10. </p><p id="p0066" num="0066">[0050] FIG. 8 is a high-level flow chart illustrating the utilization of the automatic parallelization of a PLC program in accordance with the present invention. As shown, the process begins at step 100 by parsing the PLC program into POUs. Next, the automatic parallelization process of the present invention is invoked in step 110 to parse each POU into all possible fragments, using both dataflow analysis and functional analysis to identify all sub-task fragments. A flowchart of the parallelization process is shown in FIG. 9 and will be described hereinbelow. </p><p id="p0067" num="0067"> [0051] Referring again to FIG. 8, once all of the program fragments have been identified, the process continues by implementing one-to-many scheduling in step 120, where the program fragments are allocated across the available resources. An exemplary one-to-many scheduling process is shown in detail in FIG. 10. 
<!-- EPO <DP n="14"/>-->
 [0052] Subsequent to the allocation of fragments across the multiple resources, the high- level PLC language is translated into an intermediate representation (step 130) that is used by a compiler as an intermediate step before generating assembly or machine language code. </p><p id="p0068" num="0068">Conventional optimization techniques can then be employed in step 140 to reduce the instruction set (i.e., common subexpression elimination, dead code elimination, register allocation, etc.). The optimized code is sent to the processor for execution in step 150, where the use of a multi- core processor (resources) in accordance with the present invention involves the creation of multiple threads. Lastly, the program is executed as shown in step 160. </p><p id="p0069" num="0069"> [0053] As noted above, FIG. 9 is a flowchart showing an exemplary set of detailed steps that may be executed in performing step 110 (the parallelization process of the present invention). The process begins at step 200 by reading each POU that has been identified in step 100 of the program flow as shown in FIG. 8. Subsequently, a conventional dataflow analysis is performed on each POU in step 210 to identify all data-independent blocks Dl - DN within each POU in the manner defined above. Once identified, each data-independent block Di is then evaluated to identify functional parallelism in accordance with the teachings of the present invention (step 220). </p><p id="p0070" num="0070"> [0054] In the specific flowchart representation of FIG. 9, three different types of function blocks are searched for: time delays (step 221), occurrences of simultaneous divergence (step 222) and asynchronous function block calls (step 223). Each identification is then labeled as a separate program fragment FR. The process continues with, in this example, creating a map M between each fragment FR, its data block D and the associated task in the original program (step 230). Mapping the functional parallelism to the original program structure is important inasmuch as the tasks each have a defined priority and time constraint, as mentioned above. Lastly, the ordered pairs (FR,M) are then returned to step 120 in the main program (flowchart of FIG. 8) in step 240. </p><p id="p0071" num="0071"> [0055] FIG. 10 illustrates an exemplary one-to-many scheduling process that may be utilized as step 120 in the overall process (as shown in the flowchart of FIG. 8) in accordance with the present invention. It is to be understood that the specifics of the flow in FIG. 10 are meant to describe only an example of a suitable process flow; other methods of performing one- to-many scheduling may be used to efficiently allocate the various program fragments FR across a given set of resources. 
<!-- EPO <DP n="15"/>-->
 [0056] Referring to FIG. 10, the process begins by inputting the program fragments FR in step 300. The following steps are then performed for each fragment in turn. First, the available resources are characterized (step 310) in terms of their performance (i.e., latency model), which takes into account the topology of the network to calculate communication latencies and computational capacities of each resource. Next, a scheduling time S is associated with each fragment in step 320, based upon load balancing and prioritization of the specific fragment's task using the map M created in step 230 of the parallelization process (see FIG. 9). Once the scheduling has been identified, a timing analysis for each fragment is performed in both the multi-core environment (step 330), defining a "parallel" time (P_Time) and a single-core environment (step 340), defining a "single" time (S_Time). The times are then compared in step 350, where if the parallel time is greater than the single time, a "sequential" schedule is returned to the main program (step 360). Otherwise, if the parallel time is less than the single time, a "parallel" schedule is returned (step 370), with the assumption being that in most cases the parallel time will be less than the single time. </p><p id="p0072" num="0072"> [0057] While the disclosure has been illustrated and described in typical embodiments, it is not intended to be limited to the details shown, since various modifications and substitutions can be made without departing in any way from the spirit of the present disclosure. As such, further modifications and equivalents of the disclosure herein provided may occur to persons skilled in the art using no more than routine experimentation, and all such modifications and equivalents are believed to be within the spirit and scope of the disclosure as defined by the following claims. 
</p></description><claims mxw-id="PCLM45498586" ref-ucid="WO-2012138464-A1" lang="EN" load-source="patent-office"><claim-statement><!-- EPO <DP n="16"/>-->What is claimed is: </claim-statement><claim id="clm-0001" num="1"><claim-text>1. A programmable logic controller (PLC) for executing a program written in one or more high-level functional languages, the controller comprising </claim-text><claim-text> a plurality of resources for executing various portions of the program; and </claim-text><claim-text> at least one memory coupled to the processors; and </claim-text><claim-text> a compiler for performing functional parallelism by: </claim-text><claim-text> parsing the program into a plurality of program organization units (POUs); </claim-text><claim-text> identifying blocks within the high-level functional languages of each POU that include one or more time delays such that operations before and after the time delays can be executed in parallel; </claim-text><claim-text> creating program fragments as partitioned by the identified time delays; and scheduling the program fragments across the plurality of resources to be executed in parallel. </claim-text></claim><claim id="clm-0002" num="2"><claim-text>2. The PLC as defined in claim 1 wherein the plurality of resources comprises a plurality of cores within a multi-core processor. </claim-text></claim><claim id="clm-0003" num="3"><claim-text>3. The PLC as defined in claim 1 wherein the high-level languages include one or more languages selected from the group consisting of: textual languages including Instruction List (IL) and Structured Text (ST), graphical languages including Ladder Diagram (LD) and Function Block Diagram (FBD) and Sequence Function Chart (SFC) language including with both textual and graphical representations. </claim-text></claim><claim id="clm-0004" num="4"><claim-text>4. A method of creating parallelism in a PLC program to provide parallel execution of various segments of the PLC program across a plurality of separate resources, the method comprising the steps of: </claim-text><claim-text> evaluating a high-level functional representation of the PLC program; </claim-text><claim-text> performing a functional analysis by identifying locations within the high-level functional representation of a time delay between an input and an output of a function block; <!-- EPO <DP n="17"/>--> separating the identified locations into program fragments that may be executed in parallel in different resources of the plurality of separate resources. </claim-text></claim><claim id="clm-0005" num="5"><claim-text>5. The method as defined in claim 4 further comprising the step of performing dataflow analysis by identifying data-independent blocks within the high-level functional representation that may be separated and executed in parallel in different resources of the plurality of separate resources. </claim-text></claim><claim id="clm-0006" num="6"><claim-text>6. The method as defined in claim 5 wherein the dataflow analysis is performed prior to the functional analysis, the functional analysis performed on each identified data-independent block. </claim-text></claim><claim id="clm-0007" num="7"><claim-text>7. The method as defined in claim 4 wherein the function blocks are identified by searching for a block selected from the set of: flip-flops, simultaneous divergence blocks and asynchronous function blocks. </claim-text></claim><claim id="clm-0008" num="8"><claim-text>8. The method as defined in claim 4 wherein the method further comprises the step of: assigning the plurality of created program fragments to various ones of the resources within the plurality of separate resources such that program fragments execute in parallel. </claim-text></claim><claim id="clm-0009" num="9"><claim-text>9. The method as defined in claim 8, wherein in performing the assignment, the allocation is performed to optimize a system characteristic. </claim-text></claim><claim id="clm-0010" num="10"><claim-text>10. The method as defined in claim 9 wherein the optimized system characteristics is selected from the group consisting of: minimizing processing time, minimizing power consumption, maximizing resource utilization, maximizing throughput and avoiding underutilization of selected resources. </claim-text></claim><claim id="clm-0011" num="11"><claim-text>11. The method as defined in claim 8 wherein in determining an execution time for each program fragment, an analysis of the execution time for running on a single processor is <!-- EPO <DP n="18"/>--> compared to the execution time for running on a processor in a multiple processor environment, and the shorter time and processor assignment is selected accordingly. </claim-text></claim></claims><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
