<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2682873-A2" country="EP" doc-number="2682873" kind="A2" date="20140108" family-id="41465342" file-reference-id="318266" date-produced="20180824" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146584879" ucid="EP-2682873-A2"><document-id><country>EP</country><doc-number>2682873</doc-number><kind>A2</kind><date>20140108</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-13186951-A" is-representative="NO"><document-id mxw-id="PAPP154847071" load-source="docdb" format="epo"><country>EP</country><doc-number>13186951</doc-number><kind>A</kind><date>20090409</date><lang>EN</lang></document-id><document-id mxw-id="PAPP174953025" load-source="docdb" format="original"><country>EP</country><doc-number>13186951.3</doc-number><date>20090409</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140556253" ucid="EP-09773941-A" linkage-type="3" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>09773941</doc-number><kind>A</kind><date>20090409</date></document-id></priority-claim><priority-claim mxw-id="PPC140549576" ucid="US-16778208-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>16778208</doc-number><kind>A</kind><date>20080703</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL2122915160" load-source="docdb">G06F   9/00        20060101ALI20140929BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL2122918910" load-source="docdb">G06F  15/00        20060101AFI20140929BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL2122921012" load-source="docdb">G06F  12/02        20060101ALI20140929BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL2122922541" load-source="docdb">G06F  11/34        20060101ALI20140929BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1861390197" load-source="docdb" scheme="CPC">G06F  11/3024      20130101 LI20161222BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1861390798" load-source="docdb" scheme="CPC">G06F  11/301       20130101 LI20161222BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1861390964" load-source="docdb" scheme="CPC">G06F   9/30145     20130101 FI20161222BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1861391163" load-source="docdb" scheme="CPC">G06F   9/3005      20130101 LI20170104BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1861393239" load-source="docdb" scheme="CPC">G06F   9/45533     20130101 LA20161222BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1944040116" load-source="docdb" scheme="CPC">G06F  11/3414      20130101 LI20160506BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1944046614" load-source="docdb" scheme="CPC">G06F  11/3476      20130101 LI20160506BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132359270" lang="DE" load-source="patent-office">Effiziente Aufzeichnung und Wiedergabe nichtdeterministischer Instruktionen in einer virtuellen Maschine und CPU dafür</invention-title><invention-title mxw-id="PT132359271" lang="EN" load-source="patent-office">Efficient recording and replaying of non-deterministic instructions in a virtual machine and CPU therefor</invention-title><invention-title mxw-id="PT132359272" lang="FR" load-source="patent-office">Enregistrement et relecture efficaces d'instructions non déterministes dans une machine virtuelle et unité centrale associée</invention-title><citations><patent-citations><patcit mxw-id="PCIT242942517" load-source="docdb" ucid="US-20080059121-A1"><document-id format="epo"><country>US</country><doc-number>20080059121</doc-number><kind>A1</kind><date>20080306</date></document-id><sources><source name="APP" created-by-npl="N"/></sources></patcit></patent-citations><non-patent-citations><nplcit><text>CHOI ET AL,: ""A Perturbation-Free Replay Platform For Cross-Optimized Multithreaded Applications","</text><sources><source mxw-id="PNPL67455572" load-source="docdb" name="APP"/></sources></nplcit></non-patent-citations></citations></technical-data><related-documents><relation type="division"><child-doc ucid="EP-13186951-A"><document-id load-source="patent-office" format="epo"><country>EP</country><doc-number>13186951</doc-number><kind>A</kind><date>20090409</date></document-id></child-doc><parent-doc ucid="EP-09773941.1"><document-id load-source="patent-office" format="epo"><country>EP</country><doc-number>09773941.1</doc-number><date>20090409</date></document-id><parent-grant-document ucid="EP-2294512-B1"><document-id><country>EP</country><doc-number>2294512</doc-number><kind>B1</kind><date>20150708</date></document-id></parent-grant-document></parent-doc></relation></related-documents><parties><applicants><applicant mxw-id="PPAR919504378" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>VMWARE INC</last-name><address><country>US</country></address></addressbook></applicant><applicant mxw-id="PPAR919523750" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>VMWARE, INC.</last-name></addressbook></applicant><applicant mxw-id="PPAR919008627" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>VMWare, Inc.</last-name><iid>101006140</iid><address><street>3401 Hillview Avenue</street><city>Palo Alto, CA 94304</city><country>US</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR919506580" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>MALYUGIN VYACHESLAV V</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919529446" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>MALYUGIN, VYACHESLAV, V.</last-name></addressbook></inventor><inventor mxw-id="PPAR919013548" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>MALYUGIN, VYACHESLAV, V.</last-name><address><street>3401 Hillview Avenue</street><city>Palo Alto, CA California 94304</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919519614" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>XU MIN</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919545934" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>XU, MIN</last-name></addressbook></inventor><inventor mxw-id="PPAR919005972" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>XU, MIN</last-name><address><street>3401 Hillview Avenue</street><city>Palo Alto, CA California 94304</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919539850" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>WEISSMAN BORIS</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919518782" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>WEISSMAN, BORIS</last-name></addressbook></inventor><inventor mxw-id="PPAR919017830" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>WEISSMAN, BORIS</last-name><address><street>3401 Hillview Avenue</street><city>Palo Alto, CA California 94304</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919536696" load-source="docdb" sequence="4" format="epo"><addressbook><last-name>VENKITACHALAM GANESH</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919531623" load-source="docdb" sequence="4" format="intermediate"><addressbook><last-name>VENKITACHALAM, GANESH</last-name></addressbook></inventor><inventor mxw-id="PPAR919016596" load-source="patent-office" sequence="4" format="original"><addressbook><last-name>VENKITACHALAM, GANESH</last-name><address><street>3401 Hillview Avenue</street><city>Palo Alto, CA California 94304</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919523368" load-source="docdb" sequence="5" format="epo"><addressbook><last-name>KLAIBER ALEXANDER</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919513120" load-source="docdb" sequence="5" format="intermediate"><addressbook><last-name>KLAIBER, ALEXANDER</last-name></addressbook></inventor><inventor mxw-id="PPAR919009705" load-source="patent-office" sequence="5" format="original"><addressbook><last-name>KLAIBER, ALEXANDER</last-name><address><street>3401 Hillview Avenue</street><city>Palo Alto, CA California 94304</city><country>US</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR919007827" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Robinson, Ian Michael</last-name><suffix>et al</suffix><iid>100038148</iid><address><street>Appleyard Lees 15 Clare Road</street><city>Halifax HX1 2HY</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS549813927" load-source="docdb">AT</country><country mxw-id="DS549907419" load-source="docdb">BE</country><country mxw-id="DS549741966" load-source="docdb">BG</country><country mxw-id="DS549739404" load-source="docdb">CH</country><country mxw-id="DS549738381" load-source="docdb">CY</country><country mxw-id="DS549813928" load-source="docdb">CZ</country><country mxw-id="DS549907420" load-source="docdb">DE</country><country mxw-id="DS549738382" load-source="docdb">DK</country><country mxw-id="DS549738383" load-source="docdb">EE</country><country mxw-id="DS549812682" load-source="docdb">ES</country><country mxw-id="DS549741967" load-source="docdb">FI</country><country mxw-id="DS549741968" load-source="docdb">FR</country><country mxw-id="DS549907421" load-source="docdb">GB</country><country mxw-id="DS549738384" load-source="docdb">GR</country><country mxw-id="DS549907422" load-source="docdb">HR</country><country mxw-id="DS549813929" load-source="docdb">HU</country><country mxw-id="DS549739405" load-source="docdb">IE</country><country mxw-id="DS549738385" load-source="docdb">IS</country><country mxw-id="DS549741977" load-source="docdb">IT</country><country mxw-id="DS549738386" load-source="docdb">LI</country><country mxw-id="DS549740053" load-source="docdb">LT</country><country mxw-id="DS549741159" load-source="docdb">LU</country><country mxw-id="DS549740054" load-source="docdb">LV</country><country mxw-id="DS549740055" load-source="docdb">MC</country><country mxw-id="DS549741160" load-source="docdb">MK</country><country mxw-id="DS549741161" load-source="docdb">MT</country><country mxw-id="DS549813962" load-source="docdb">NL</country><country mxw-id="DS549812683" load-source="docdb">NO</country><country mxw-id="DS549739406" load-source="docdb">PL</country><country mxw-id="DS549740056" load-source="docdb">PT</country><country mxw-id="DS549813963" load-source="docdb">RO</country><country mxw-id="DS549739407" load-source="docdb">SE</country><country mxw-id="DS549741978" load-source="docdb">SI</country><country mxw-id="DS549812684" load-source="docdb">SK</country><country mxw-id="DS549741162" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA128673051" lang="EN" load-source="patent-office"><p id="pa01" num="0001">The output of a non-deterministic instruction is handled during record and replay in a virtual machine. An output of a non-deterministic instruction is stored to a buffer during record mode and retrieved from a buffer during replay mode without exiting to the hypervisor. At least part of the contents of the buffer can be stored to a log when the buffer is full during record mode, and the buffer can be replenished from a log when the buffer is empty during replay mode.
<img id="iaf01" file="imgaf001.tif" wi="77" he="106" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA128737196" lang="EN" source="EPO" load-source="docdb"><p>The output of a non-deterministic instruction is handled during record and replay in a virtual machine. An output of a non-deterministic instruction is stored to a buffer during record mode and retrieved from a buffer during replay mode without exiting to the hypervisor. At least part of the contents of the buffer can be stored to a log when the buffer is full during record mode, and the buffer can be replenished from a log when the buffer is empty during replay mode.</p></abstract><description mxw-id="PDES63959039" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><b>BACKGROUND</b></heading><p id="p0001" num="0001">In the background art, <nplcit id="ncit0001" npl-type="s"><text>Choi et al, entitled "A Perturbation-Free Replay Platform For Cross-Optimized Multithreaded Applications</text></nplcit><i>",</i> XP010544385, describes a platform called DejaVu for constructing replay tools for non-deterministic instructions, while ignoring deterministic instructions. <patcit id="pcit0001" dnum="US2008059121A"><text>US2008/059,121</text></patcit> mentions a method and system for measuring the performance of individual logical partitions of a logically partitioned computer system.</p><p id="p0002" num="0002">Deterministic replay in a virtual machine creates an execution that is logically equivalent to an original execution of interest. Two executions are logically equivalent if they contain the same set of dynamic instructions, each dynamic instruction computes the same result in the two executions, and the two executions compute the same final state of the system (processor, memory and devices). Virtual machines are software abstractions of physical computer systems, generally using virtualization software which is typically a thin layer of software that logically sits and provides an interface between hardware and guest OS. Virtualization is well known to those in the field of computer science.</p><p id="p0003" num="0003">A virtual machine-based deterministic replayer may support full-system replay; i.e., the entire virtual machine (VM), including guest operating system (OS) and guest applications, is recorded and replayed. During recording, all sources of non-determinism from outside the virtual machine are captured and logged in a log file. These include data and timing of inputs to all devices, including virtual disks, virtual network interface cards (NIC), etc. A combination of techniques, such as device emulation and binary translation, are used to ensure deterministic replay as long as the recorded device input data are replayed at right time.</p><p id="p0004" num="0004">Certain central processor unit (CPU) instructions are non-deterministic. A non-deterministic instruction is one whose output is not determined entirely by its inputs or a current architectural state. For example, the x86 RDTSC instruction returns the current time expressed in processor clocks, RDPMC and RDMSR return the contents of performance counter registers, etc. As shown in <figref idrefs="f0001">Figure 1</figref>, the outputs of non-deterministic instructions can arise from the interaction of the VM with a non-deterministic units such as real time clock 16, which is a device that can be queried by a CPU with a RDTSC instruction, whose result is returned in real-time and depends on the when the instruction is executed. Examples of other non-deterministic units include input devices (such as a keyboard, mouse, microphone, etc.) a thermal sensor, a transducer, a network card, a video camera, and so on. Such devices are non-deterministic because they produce inputs that cannot be predicted based solely on the state of the machine.<!-- EPO <DP n="2"> --></p><p id="p0005" num="0005">When executing an application within certain VMs, the virtualization software can record the complete execution behavior. Having saved this behavioral information, the user can replay that exact and complete behavior an unlimited number of times. This can be useful for debugging. For example, a users can record execution of the VM, and then attach a gdb debugger to the guest operating system or guest applications during replay. On replay, the user can look at memory, set breakpoints, and single step through the execution to identify problems and resolve them. Of course, record and replay have other applications, any of which may benefit from the embodiments described herein.</p><p id="p0006" num="0006"><figref idrefs="f0001">Figure 1</figref> shows one example of a virtualized computer system 10 wherein the results of non-deterministic instructions are stored in log 40 during record mode. One of applications 28 or guest operating system 24 (including drivers 26) may issue a non-deterministic instruction to virtual system hardware 22, which, as generally known, is implemented by virtualization software 30, e.g., by hypervisor 32. Guest instructions (that is, instructions issuing from VM 20) are often directly executed on host CPU 14. During direct execution of guest instructions from VM 20, the virtual memory system (not shown) and CPU 14 of host platform 12 assume a configuration associated with the context of VM 20. In the present example, VM 20 issues a non-deterministic instruction to read a timestamp value from real-time clock 16, which returns the non-deterministic value, i.e., the timestamp value. Other instructions may similarly elicit non-deterministic values as described above. When system 10 is in record mode, hypervisor 32 records the value in log 40 so that the same results may be made available during replay so that the replay behavior duplicates the behavior of the VM 20 during record mode. In order for the hypervisor to carry out the function of recording the non-deterministic value to log 40, system 10 must exit the context associated with VM 20 and enter a context associated with hypervisor 32. Similarly, when a non-deterministic instruction is executed during replay, it triggers an exit from the context of VM 20 to a context of hypervisor 32, which reads the non-deterministic value from log 40 and returns the value that was recorded for the instruction to VM 20.</p><p id="p0007" num="0007">Changing execution contexts from VM 20 to hypervisor 32 and back is a resource-intensive operation that can introduce substantial penalties in performance. This problem can become severe when numerous such exits are required due to the execution of many non-deterministic instructions from guest application 28 during record and replay. For example, one or more non-deterministic instructions can occur in a loop, causing a large number of non-deterministic instruction executions in a short time.<!-- EPO <DP n="3"> --></p><heading id="h0002"><b>SUMMARY OF THE INVENTION</b></heading><p id="p0008" num="0008">The result of a non-deterministic instruction is handled during record and replay in a virtual machine. A result of a non-deterministic instruction is stored to a storage buffer during record mode and retrieved from a storage buffer during replay mode without exiting to the hypervisor. At least part of the contents of the storage buffer can be stored to a log when the storage buffer is full during record mode, and the storage buffer can be replenished from a log when the storage buffer is empty during replay mode. Embodiments of the invention can be partially implemented in hardware by altering the semantics for the execution of non-deterministic instructions based on a record/replay operating state or mode of operation. Embodiments of the invention can also be implemented completely in software.</p><heading id="h0003"><b>BRIEF DESCRIPTION OF THE DRAWINGS</b></heading><p id="p0009" num="0009"><figref idrefs="f0001">Figure 1</figref> shows one example of a virtualized computer system wherein the results of non-deterministic instructions are stored in a log during record mode.</p><p id="p0010" num="0010"><figref idrefs="f0002">Figure 2</figref> shows a system and method for implementing a record mode in accordance with an embodiment of the present invention.</p><p id="p0011" num="0011"><figref idrefs="f0003">Figure 3</figref> shows a system and method for implementing a replay mode in accordance with an embodiment of the present invention.</p><p id="p0012" num="0012"><figref idrefs="f0004">Figure 4A</figref> is a flow chart illustrating a method in accordance with an embodiment of the present invention in record mode.</p><p id="p0013" num="0013"><figref idrefs="f0004">Figure 4B</figref> illustrates the operation of a memory buffer in accordance with an embodiment of the present invention during record mode.</p><p id="p0014" num="0014"><figref idrefs="f0005">Figure 5A</figref> is a flow chart illustrating a method in accordance with an embodiment of the present invention in replay mode.</p><p id="p0015" num="0015"><figref idrefs="f0005">Figure 5B</figref> illustrates the operation of a memory buffer in accordance with an embodiment of the present invention during replay mode.<!-- EPO <DP n="4"> --></p><heading id="h0004"><b>DETAILED DESCRIPTION</b></heading><p id="p0016" num="0016">In an exemplary hardware-assisted replaying virtualization system, during record mode, the result of a non-deterministic instruction is stored in hardware registers or machine memory by the physical hardware, generally without exiting to the virtualization software. Likewise, during replay mode, results of non-deterministic instructions are retrieved from hardware registers or machine memory by the physical hardware, again generally without exiting to the virtualization software. The storage and retrieval of non-deterministic instruction results without exiting to the virtualization software can make more effective use of processor cycles.</p><p id="p0017" num="0017">In describing the present invention, it is useful to identify three particular states of operation for a virtualization system implementing the present invention. First, a currently executing virtual machine (VM) may be in record mode; second, a currently executing VM may be in replay mode; and, third, there may be no currently active VM in either record mode or replay mode. If there are multiple CPUs in a virtualization system, each CPU may be in one of these three operating states independently of the other CPUs in the system, depending on whether a VM is currently executing on the respective CPU and, if there is a VM executing on the CPU, depending on the execution mode of that VM. Each CPU may be a processor or a processor core in a multicore processor. Thus, these three operating states may be referred to as record/replay operating states, or CPU-specific record/replay operating states. Also, a given CPU may be said to have a record/replay operating state of "record" when a VM that is executing on the CPU is in record mode; the CPU may be said to have a record/replay operating state of "replay" when a VM that is executing on the CPU is in replay mode; and the CPU may be said to have a record/replay operating state of "normal" when there is no VM executing on the CPU that is in either record mode or replay mode.</p><p id="p0018" num="0018">In some embodiments of this invention, the semantics for the execution of non-deterministic instructions are altered, based on which of these three operating states applies for a given CPU. Some suitable means may be provided to indicate a current record/replay operating state to a CPU, or, more specifically, to indicate when an active VM is executing in record mode on the CPU, when an active VM is executing in replay mode on the CPU, and when there is no active VM executing on the CPU in either record mode or replay mode. For example, the record/replay operating state may be indicated using one or more bits in a machine specific register (MSR), or in any other data structure. For example, one bit may be<!-- EPO <DP n="5"> --> set to indicate the record operating state, a second bit may be set to indicate the replay operating state, and both bits may be cleared to indicate the normal operating state. In some embodiments, a CPU determines its current record/replay operating state each time it encounters a non-deterministic instruction, such as by reading selected bits that indicate the state, for example. In other possible embodiments, a CPU may have distinct record/replay modes of operation, such that the CPU need not determine its operating state each time it encounters a non-deterministic instruction. For example, the CPU may have a normal mode, a record mode and a replay mode. When the CPU is set to normal mode, it will execute non-deterministic instructions according to "normal semantics," until it is switched to a different record/replay mode of operation; when the CPU is set to record mode, it will execute non-deterministic instructions according to "record semantics," until it is switched to a different record/replay mode of operation; and, when the CPU is set to replay mode, it will execute non-deterministic instructions according to "replay semantics," until it is switched to a different record/replay mode of operation. The semantics for execution of deterministic instructions generally are not affected by the record/replay operating state or mode of operation.</p><p id="p0019" num="0019"><figref idrefs="f0002">Figure 2</figref> illustrates a virtualization system 100 having an active virtual machine (VM) 120 executing in record mode. Virtualization system 100 executes on a host platform 110, which includes one or more CPU(s) 114. Virtualization system 100 also includes virtualization software 130, which supports execution of VM 120. VM 120 includes virtual system hardware 122, a guest operating system 124, including drivers 126, and guest applications 128. Virtualization software 130 may have any of a wide variety of configurations and implementations. <figref idrefs="f0002">Figure 2</figref> shows virtualization software 130 as including hypervisor 132, as just one example.</p><p id="p0020" num="0020">In one embodiment, when VM 120 is executing in record mode on CPU 114, such that virtualization system 100 is in a record/replay operating state of "record", CPU 114 is controlled to implement record semantics for the execution of non-deterministic instructions. For example, hypervisor 132 may set one or more bits in machine specific register (MSR) 204, or in any other data structure, etc., to indicate that an active VM is executing in record mode. When a non-deterministic instruction is executed 116 while a VM is in record mode, CPU 114 will generally store the returned value to buffer 202 in system memory or CPU hardware registers or system memory 201 as indicated by arrow 152, rather than immediately exiting to the hypervisor context. For example, buffer 202 may be at a location in system<!-- EPO <DP n="6"> --> memory identified by a physical address supplied by hypervisor 132, e.g., by storing the address in MSR 204, when setting the CPU to "record" mode.</p><p id="p0021" num="0021">As used herein, the term "buffer" refers to a data structure in which entries are located in memory, in at least one hardware register, or in a combination thereof. In one embodiment, buffer 202 resides in machine memory that is not available to guest operating systems 124 and applications 128, but is available to the hypervisor 132. When memory buffer 202 is full, CPU 114 can trigger an exit to the hypervisor context so that hypervisor 132 may store at least some of the contents of memory buffer 202 to log 140, which may reside, e.g., in a mass data storage device that is within or accessible to host platform 110. Memory buffer 202 may be managed by pointers. For example, when memory 201 for the memory buffer 202 is allocated, a first pointer PTR<sub>1</sub> can be established that points to the next available memory location. PTR<sub>1</sub> may be initialized to the beginning of the memory buffer 202. A second pointer PTR<sub>2</sub> can be established that points to the end of the memory buffer 202. While PTR<sub>1</sub> is less than or equal to PTR<sub>2</sub>, a value can be stored at the address pointed-to by PTR<sub>1</sub> and PTR<sub>1</sub> can be incremented. When the memory buffer 202 is full, PTR<sub>1 &gt;</sub> PTR<sub>2</sub>, which can trigger an exit to the hypervisor 132 so that the memory buffer 202 contets may be copied by hypervisor 132 to log 140 and the memory buffer 201 cleared, as indicated by arrows 154, 156. The hypervisor 132 may be responsible for once again initializing PTR<sub>1</sub> to point to the first available memory location in the memory buffer, while PTR<sub>2</sub> may point to the end.</p><p id="p0022" num="0022">The order in which the various operations take place when flushing buffers 202 may be varied. For example, the system may exit to the hypervisor context when, after executing a nondeterministic instruction and realizing that the buffer is full, in which case the new nondeterministic may be value held until the context returns to the guest VM so that the new value may be entered into the now empty buffer. Alternatively, the system may pass the new value to the hypervisor after determining the buffer is full. In this case, the hypervisor may copy the contents of the full buffer plus the new value to log 140, the new value being handed-off to the hypervisor during the context switch. It is also possible to ignore the result of the non-deterministic instruction when the buffer is full, drop to the hypervisor context, and then re-execute the non-deterministic instruction upon returning to the VM context, storing the result to the now-emptied buffer. In yet another embodiment, the system may check whether the buffer is full after each write to the buffer. When the buffer is full, it may<!-- EPO <DP n="7"> --> then switch to hypervisor context so that the hypervisor can copy the contents to log file 140 and start with a new execution when returning to the guest VM context.</p><p id="p0023" num="0023">An embodiment during replay mode is shown in <figref idrefs="f0003">Figure 3</figref>. In this mode, according to one embodiment, the hypervisor 132 allocates memory 201 for the memory buffer 202 and populates memory buffer 202 with entries from log 140 created during a previous recording session, as indicated by arrows 153, 155. Hypervisor 132 may establish pointers PTR<sub>1</sub> and PTR<sub>2</sub>, where PTR<sub>1</sub> points to the next value in the memory buffer and PTR<sub>2</sub> points to the end of the memory buffer 202. Operation of the pointers is described in more detail below with reference to <figref idrefs="f0005">Figure 5B</figref>. Hypervisor 132 places CPU in replay mode in a manner such as previously described above with reference to placing the CPU in record mode. When a non-deterministic instruction is received in replay mode, the CPU returns the stored value, as indicated by arrow 157, instead of executing the instruction normally and PTR<sub>1</sub> can be incremented by the CPU. Alternatively, the instruction may be executed normally, but with the results being replaced or ignored in favor of the non-deterministic value read from buffer 202.</p><p id="p0024" num="0024">The normal execution of a non-deterministic instruction may correspond to the way in which it is executed when the virtual machine 120 is in neither record nor replay mode, i.e., without having to change out of the VM execution context. For example, if, during replay, the non-deterministic instruction is RDTSC, then CPU 114 returns the corresponding value previously recorded in memory buffer 202, rather than the actual current time at that point. When at least part of the memory buffer 202 is empty, CPU can invoke the hypervisor 130 to replenish the memory buffer 202 with additional non-deterministic values that were stored to the log 140 during record mode. Those values can subsequently be returned upon the execution of further non-deterministic instructions during replay. An empty memory buffer 202 can be detected when PTR<sub>1</sub> is equal to PTR<sub>2</sub>, at which point the system may drop to hypervisor 130 in order to refill the memory buffer 202 from entries in log 140 and reset PTR<sub>1</sub> to point to the next non-deterministic value in replay mode. PTR<sub>2</sub> can be set to point to the end of the memory buffer 202. In embodiments of the present invention, the memory buffer 202 can be replenished before it is empty.</p><p id="p0025" num="0025">The order in which the various operations take place when refreshing buffer 202 may be varied. In one embodiment, when a non-deterministic instruction is received, the CPU may check the buffer pointers PTR<sub>1</sub>, PTR<sub>2</sub> to identify the location of the next previously recorded non-deterministic value. If the PTR<sub>1</sub> equals PTR<sub>2</sub>, then the system changes context<!-- EPO <DP n="8"> --> to the hypervisor as described above so that the buffer may be loaded with new non-deterministic values. Upon returning to the VM context, the original non-deterministic instruction may be restarted, in which case the first element of the buffer will be read. In another embodiment, the buffer may be eagerly refilled after the CPU reads the last element from the buffer, so that, upon receiving the next non-deterministic instruction, the next value will be readily available. Those skilled in the art will recognize that there are many possible implementations for refilling the buffer during replay, as well as copying the buffer to the log during record, so that the frequency of hypervisor invocations is reduced. The examples presented herein should therefore be understood as illustrative, and not limiting in any way.</p><p id="p0026" num="0026"><figref idrefs="f0004">Figures 4A and 4B</figref> show by way of example how pointers and non-deterministic values may be handled during record mode. <figref idrefs="f0004">Figure 4A</figref> shows a flowchart 300 illustrating by way of example a method CPU 114 may perform when recording a non-deterministic guest instruction. Prior to execution, memory buffer 202 (<figref idrefs="f0004">Figure 4B</figref>) is allocated in machine memory 201, pointer PTR<sub>1</sub> is established for pointing to a next available position in memory buffer 202, and pointer PTR<sub>2</sub> is established for pointing to the end of memory buffer 202.</p><p id="p0027" num="0027">The procedure begins as indicated by start block 302 and flows to operation 304 wherein a non-deterministic instruction is executed. Non-deterministic instructions may be a predefined subset of instructions that CPU 114 can execute. Once the non-deterministic value is obtained as a result of the execution in operation 304, the procedure flows to operation 306 to determine if PTR<sub>1</sub> is equal to PTR<sub>2</sub>. When PTR<sub>1</sub> is not equal PTR<sub>2</sub>, the procedure flows to operation 312, wherein the non-deterministic value is stored at the location identified by PTR<sub>1</sub>, i.e., entry 3 as shown in <figref idrefs="f0004">Figure 4B</figref>. PTR<sub>1</sub> is then updated, e.g., incremented, to the next available memory buffer 202 location as shown in <figref idrefs="f0004">Figure 4B</figref>. When PTR<sub>1</sub> is equal PTR<sub>2</sub> in operation 306, then the procedure flows to operation 308, wherein the system exits the VM context and enters the hypervisor context so that the hypervisor can copy the contents of memory buffer 202 to log 140 (<figref idrefs="f0002">Figures 2</figref>, <figref idrefs="f0003">3</figref>). As mentioned above, in one embodiment, the new non-deterministic value may be presented to the hypervisor during the switch so that it is recorded to log 140 along with the contents of buffer 202. Then in operation 301, pointers PTR<sub>1</sub> and PTR<sub>2</sub> may be reset. The procedure then ends as indicated by done block 314.</p><p id="p0028" num="0028"><figref idrefs="f0005">Figures 5A and 5B</figref> show by way of example how pointers and non-deterministic values may be handled during replay mode. When entering the replay mode, hypervisor 132 may allocate a memory buffer 202 in machine memory 201 as shown in <figref idrefs="f0005">Figure 5B</figref> and set<!-- EPO <DP n="9"> --> PTR<sub>1</sub> to identify the location in memory buffer 202 of the next non-deterministic value (Entry 3) to be provided to the replay and set PTR<sub>2</sub> to identify the location of the end of memory buffer 202. <figref idrefs="f0005">Figure 5A</figref> shows a flowchart 400 illustrating by way of example a procedure CPU 114 may perform when replaying a non-deterministic guest instruction.</p><p id="p0029" num="0029">The procedure begins as indicated by start block 402 and proceeds to operation 404 wherein receipt of a non-deterministic guest instruction is identified. As mentioned above, non-deterministic guest instructions may be identified by being a member of a predefined set of non-deterministic guest instructions that forms a subset of the instructions CPU 114 is capable of executing. Once the non-deterministic guest instruction is identified in operation 404, the procedure flows to operation 406 wherein CPU 114 determines if PTR<sub>1</sub> is equal to PTR<sub>2</sub>. When PTR<sub>1</sub> is equal to PTR<sub>2</sub>, then memory buffer 202 is empty and the procedure flows to operation 408 wherein the system switches contexts for hypervisor execution. The hypervisor then replenishes buffer 202 with non-deterministic values from log 140. Then, in operation 410, the hypervisor resets the pointers, and returns to the VM's context which proceeds with operation 412, described below.</p><p id="p0030" num="0030">Returning to operation 406, when PTR<sub>1</sub> is not equal to PTR<sub>2</sub>, the procedure flows to operation 412, wherein the next non-deterinistic value is retrieved from the location identified by PTR<sub>1</sub> in buffer 202, e.g., entry 3. Thus, the non-deterministic instruction need not be executed in replay mode since the result is simply retrieved from buffer 202. After retrieving the next non-deterministic instruction, PTR<sub>1</sub> may be updated, e.g., incremented as shown in <figref idrefs="f0005">Figure 5B</figref> to the next available memory buffer 202 location.</p><p id="p0031" num="0031">It should be recognized that the Figures are presented for illustration only and an actual implementation may have a much larger buffer. Buffer 202 may be any arbitrary size depending on the implementation. For example, a larger buffer will be more efficient by reducing the frequency of context switches, but will require more memory to implement, or, in the case the buffer is implemented in the CPU, more logic gates and hence, processor real estate.</p><p id="p0032" num="0032">In one embodiment, buffer 202 may be at least partially emptied during record mode and at least partly replenished during record mode in an opportunistic manner. Other events besides the execution of a non-deterministic instruction can cause an exit to hypervisor 132. For example, hypervisor 132 is generally configured to intercept all or most host interrupts. All such interrupts result in exits to hypervisor 132 including a number of periodic<!-- EPO <DP n="10"> --> interrupts from the host timer hardware. Similarly, many privileged instructions may be intercepted by hypervisor 132 in the normal course of virtualization: IN/OUT instructions driving hardware devices, CPU Control Register accesses, etc. A VM 120 executing such instructions will generate additional exits to hypervisor 132. Upon such an exit to hypervisor 132 during record mode, at least some of the contents of the memory buffer 202 can be stored by hypervisor 132 to log 140, even if memory buffer 202 is not full. Likewise, upon such an exit to hypervisor 132 during replay mode, hypervisor 132 may populate empty locations in the memory buffer 202 by additional output values from the log 140. This technique can advantageously reduce the number of expensive hypervisor exits caused by full and empty memory buffers 202.</p><p id="p0033" num="0033">In another embodiment of the present invention, CPU 114 may support the record and replay execution modes wherein memory buffer 202 resides in guest virtual memory instead of machine memory (or hardware registers). For example, in certain CPUs, the microcode that implements RDTSC (and other non-deterministic instructions) might be both simpler and faster when the instruction produces and consumes values from the virtual rather than machine memory. The memory buffer in virtual memory can thus be populated and consumed at hardware speeds without additional exits or to traps to hypervisor 132. However, since the memory buffer resides in guest virtual memory, the memory buffer can be managed (allocated, etc.) by the guest driver 126, the guest operating system 124, etc. For example, memory buffer 202 may be established in virtual memory by VM 120. Such memory may be protected from being altered by guest operating system 124 or guest application 128 while it is being used (during record and replay). For example, hypervisor 132 may unmap pages of memory corresponding to buffer 202 between replenishing points in order to protect memory buffer 202 from accidental changes by the guest operating system 124 or applications 128. Alternatively, if guest operating system 124 is trusted, memory pages used by memory buffer 202 could be mapped as OS-only, thereby disabling access to the memory buffer 202 by applications 128. Guest operating system 124 and/or guest driver 126 may be configured to manage the memory by flexibly allocating different amounts of memory to the memory buffer. This can make at least part of the memory buffer space available to store additional outputs. In such an embodiment, the additional virtual memory may also be protected from being altered by guest operating system 124 or guest application 128 while it is being used.<!-- EPO <DP n="11"> --></p><p id="p0034" num="0034">Other approaches are envisioned wherein more than one memory buffer may be used to handle non-deterministic instructions. For example, certain instructions may be handled using a memory buffer in virtual memory, others may be handled using a memory buffer in machine memory, while yet others may be handled using hardware registers.</p><p id="p0035" num="0035">The various embodiments described herein may employ various computer-implemented operations involving data stored in computer systems. For example, these operations may require physical manipulation of physical quantities--usually, though not necessarily, these quantities may take the form of electrical or magnetic signals, where they or representations of them are capable of being stored, transferred, combined, compared, or otherwise manipulated. Further, such manipulations are often referred to in terms, such as producing, identifying, determining, or comparing. Any operations described herein that form part of one or more embodiments of the invention may be useful machine operations. In addition, one or more embodiments of the invention also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes, or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular, various general purpose machines may be used with computer programs written in accordance with the teachings herein, or it may be more convenient to construct a more specialized apparatus to perform the required operations.</p><p id="p0036" num="0036">The various embodiments described herein may be practiced with other computer system configurations including hand-held devices, microprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers, and the like.</p><p id="p0037" num="0037">One or more embodiments of the present invention may be implemented as or include one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable medium refers to any data storage device that can store data which can thereafter be input to a computer system--computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive, network attached storage (NAS), read-only memory, random-access memory (e.g., a flash memory device), a CD (Compact Discs) --CD-ROM, a CD-R, or a CD-RW, a DVD (Digital Versatile Disc), a magnetic tape, and other optical and non-optical data storage devices. The computer<!-- EPO <DP n="12"> --> readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.</p><p id="p0038" num="0038">Although one or more embodiments of the present invention have been described in some detail for clarity of understanding, it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly, the described embodiments are to be considered as illustrative and not restrictive, and the scope of the claims is not to be limited to details given herein, but may be modified within the scope and equivalents of the claims. In the claims, elements and/or steps do not imply any particular order of operation, unless explicitly stated in the claims.</p><p id="p0039" num="0039">In addition, while described virtualization methods have generally assumed that virtual machines present interfaces consistent with a particular hardware system, persons of ordinary skill in the art will recognize that the methods described may be used in conjunction with virtualizations that do not correspond directly to any particular hardware system. Virtualization systems in accordance with the various embodiments, implemented as hosted embodiments, non-hosted embodiments or as embodiments that tend to blur distinctions between the two, are all envisioned. Furthermore, various virtualization operations may be wholly or partially implemented in hardware. For example, a hardware implementation may employ a look-up table for modification of storage access requests to secure non-disk data.</p><p id="p0040" num="0040">Many variations, modifications, additions, and improvements are possible, regardless the degree of virtualization. The virtualization software can therefore include components of a host, console, or guest operating system that performs virtualization functions. Plural instances may be provided for components, operations or structures described herein as a single instance. Finally, boundaries between various components, operations and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention(s). In general, structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements may fall within the scope of the appended claims(s).</p></description><claims mxw-id="PCLM56982062" lang="EN" load-source="patent-office"><!-- EPO <DP n="13"> --><claim id="c-en-0001" num="0001"><claim-text>A central processor unit, CPU, <b>characterised in that</b>:
<claim-text>the CPU (114) has operational modes comprising at least a normal mode, a record mode, and a replay mode, wherein:
<claim-text>the CPU (114) being configured such that when the CPU (114) is in the record mode, each time an instruction corresponding to a predefined subset of an instruction set of the CPU is encountered by an execution engine, a result of execution of the instruction is stored in a buffer (202); the CPU (114) triggering a fault or exception when the buffer (202) is full;</claim-text>
<claim-text>the CPU (114) being further configured such that when the CPU (114) is in the replay mode, each time the instruction corresponding to the predefined subset is encountered by the execution engine, a next non-deterministic value is read from the buffer (202) and supplied in place of a result of the execution of the instruction; the CPU (114) triggering a fault or exception when the buffer (202) does not contain a next value;</claim-text>
<claim-text>wherein the predefined subset comprises instructions that generate non-deterministic values.</claim-text></claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The CPU of claim 1, wherein the operational mode of the CPU (114) depends on a value of at least two data bits residing in at least one machine specific register.</claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The CPU of claim 1, wherein the operational mode of the CPU (114) depends on a value of at least two data bits within a data structure, the data bits being accessible by a privileged process.</claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The CPU of claim 3, wherein the data bits are located in machine memory, the machine memory being accessible by the CPU (114) via a data bus.<!-- EPO <DP n="14"> --></claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The CPU of claim 3, wherein the data bits define a mode of a guest virtual machine from which the instruction originates.</claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The CPU of claim 1, wherein the operational mode of the CPU (114) is changed by issuing a machine-specific instruction to the CPU (114).</claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>The CPU of claim 1, wherein the buffer (202) resides on the CPU (114).</claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>The CPU of claim 1, wherein the buffer (202) resides in machine memory in communication with the CPU (114) over a data bus.</claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>The CPU of claim 8, wherein the machine memory is addressed by virtual addresses within a virtual address space of a guest virtual machine from which the instruction originates.</claim-text></claim></claims><drawings mxw-id="PDW16670454" load-source="patent-office"><!-- EPO <DP n="15"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="165" he="210" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="16"> --><figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="165" he="223" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="17"> --><figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="165" he="227" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="18"> --><figure id="f0004" num="4A,4B"><img id="if0004" file="imgf0004.tif" wi="165" he="227" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="19"> --><figure id="f0005" num="5A,5B"><img id="if0005" file="imgf0005.tif" wi="165" he="225" img-content="drawing" img-format="tif"/></figure></drawings><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
