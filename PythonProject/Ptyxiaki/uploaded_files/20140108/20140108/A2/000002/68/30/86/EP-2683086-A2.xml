<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2683086-A2" country="EP" doc-number="2683086" kind="A2" date="20140108" family-id="35733811" file-reference-id="287040" date-produced="20180822" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146585163" ucid="EP-2683086-A2"><document-id><country>EP</country><doc-number>2683086</doc-number><kind>A2</kind><date>20140108</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-13020082-A" is-representative="NO"><document-id mxw-id="PAPP154847355" load-source="docdb" format="epo"><country>EP</country><doc-number>13020082</doc-number><kind>A</kind><date>20050801</date><lang>EN</lang></document-id><document-id mxw-id="PAPP220439889" load-source="docdb" format="original"><country>EP</country><doc-number>13020082.7</doc-number><date>20050801</date></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140552741" ucid="EP-05782140-A" linkage-type="3" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>05782140</doc-number><kind>A</kind><date>20050801</date></document-id></priority-claim><priority-claim mxw-id="PPC140555890" ucid="US-90975304-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>90975304</doc-number><kind>A</kind><date>20040802</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1989640679" load-source="docdb">H03M  13/11        20060101AFI20131217BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL1989624754" load-source="docdb" scheme="CPC">H03M  13/1105      20130101 LI20131214BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989626289" load-source="docdb" scheme="CPC">H03M  13/1117      20130101 LI20131214BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989631528" load-source="docdb" scheme="CPC">H03M  13/1137      20130101 LI20131214BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989637278" load-source="docdb" scheme="CPC">H03M  13/1122      20130101 LI20131214BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989639576" load-source="docdb" scheme="CPC">H03M  13/1114      20130101 LI20131212BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989645944" load-source="docdb" scheme="CPC">H03M  13/6362      20130101 FI20131214BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989647438" load-source="docdb" scheme="CPC">H03M  13/1111      20130101 LI20131214BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132360122" lang="DE" load-source="patent-office">Speichereffiziente LDPC-Dekodierungsverfahren und Vorrichtung</invention-title><invention-title mxw-id="PT132360123" lang="EN" load-source="patent-office">Memory efficient LDPC decoding methods and apparatus</invention-title><invention-title mxw-id="PT132360124" lang="FR" load-source="patent-office">Procédés et appareils de décodage LDPC à efficacité de mémoire</invention-title><citations><patent-citations><patcit mxw-id="PCIT377495473" load-source="docdb" ucid="US-11726402-A" dnum-type="application"><document-id format="epo"><country>US</country><doc-number>11726402</doc-number><kind>A</kind><date>20020404</date></document-id><sources><source name="APP" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT377493515" load-source="docdb" ucid="US-61832503-A" dnum-type="application"><document-id format="epo"><country>US</country><doc-number>61832503</doc-number><kind>A</kind><date>20030711</date></document-id><sources><source name="APP" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT248664498" load-source="docdb" ucid="US-6633856-B2"><document-id format="epo"><country>US</country><doc-number>6633856</doc-number><kind>B2</kind><date>20031014</date></document-id><sources><source name="APP" created-by-npl="N"/></sources></patcit></patent-citations></citations></technical-data><related-documents><relation type="division"><child-doc ucid="EP-13020082-A"><document-id load-source="patent-office" format="epo"><country>EP</country><doc-number>13020082</doc-number><kind>A</kind><date>20050801</date></document-id></child-doc><parent-doc ucid="EP-05782140.7"><document-id load-source="patent-office" format="epo"><country>EP</country><doc-number>05782140.7</doc-number><date>20050801</date></document-id></parent-doc></relation></related-documents><parties><applicants><applicant mxw-id="PPAR919541195" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>QUALCOMM INC</last-name><address><country>US</country></address></addressbook></applicant><applicant mxw-id="PPAR919513275" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>QUALCOMM INCORPORATED</last-name></addressbook></applicant><applicant mxw-id="PPAR919011375" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Qualcomm Incorporated</last-name><iid>100204376</iid><address><street>5775 Morehouse Drive</street><city>San Diego, CA 92121-1714</city><country>US</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR919545677" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>RICHARDSON TOM</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919519572" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>RICHARDSON, TOM</last-name></addressbook></inventor><inventor mxw-id="PPAR919013516" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>RICHARDSON, TOM</last-name><address><street>420 Clarkstreet</street><city>South Orange, NJ 07079</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919543286" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>NOVICHKOV VLADIMIR</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919538597" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>NOVICHKOV, VLADIMIR</last-name></addressbook></inventor><inventor mxw-id="PPAR919016838" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>NOVICHKOV, VLADIMIR</last-name><address><street>c/o Florian Technologies, Inc. Bedminster One 135 Route 202/206</street><city>South Bedminster, NJ 07921</city><country>US</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR919013413" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Wimmer, Hubert</last-name><iid>101225389</iid><address><street>Wagner &amp; Geyer Gewürzmühlstrasse 5</street><city>80538 München</city><country>DE</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS549745466" load-source="docdb">AT</country><country mxw-id="DS549816728" load-source="docdb">BE</country><country mxw-id="DS549819316" load-source="docdb">BG</country><country mxw-id="DS549745418" load-source="docdb">CH</country><country mxw-id="DS549815352" load-source="docdb">CY</country><country mxw-id="DS549745467" load-source="docdb">CZ</country><country mxw-id="DS549816729" load-source="docdb">DE</country><country mxw-id="DS549815353" load-source="docdb">DK</country><country mxw-id="DS549815362" load-source="docdb">EE</country><country mxw-id="DS549908778" load-source="docdb">ES</country><country mxw-id="DS549817195" load-source="docdb">FI</country><country mxw-id="DS549819317" load-source="docdb">FR</country><country mxw-id="DS549816734" load-source="docdb">GB</country><country mxw-id="DS549815363" load-source="docdb">GR</country><country mxw-id="DS549745468" load-source="docdb">HU</country><country mxw-id="DS549745419" load-source="docdb">IE</country><country mxw-id="DS549815364" load-source="docdb">IS</country><country mxw-id="DS549819370" load-source="docdb">IT</country><country mxw-id="DS549815365" load-source="docdb">LI</country><country mxw-id="DS549817196" load-source="docdb">LT</country><country mxw-id="DS549743253" load-source="docdb">LU</country><country mxw-id="DS549817197" load-source="docdb">LV</country><country mxw-id="DS549817206" load-source="docdb">MC</country><country mxw-id="DS549745477" load-source="docdb">NL</country><country mxw-id="DS549745420" load-source="docdb">PL</country><country mxw-id="DS549817207" load-source="docdb">PT</country><country mxw-id="DS549745478" load-source="docdb">RO</country><country mxw-id="DS549745433" load-source="docdb">SE</country><country mxw-id="DS549819371" load-source="docdb">SI</country><country mxw-id="DS549908779" load-source="docdb">SK</country><country mxw-id="DS549743254" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA128673335" lang="EN" load-source="patent-office"><p id="pa01" num="0001">Methods and apparatus for implementing memory efficient LDPC decodes are described. In accordance with the invention message information is stored in a compressed state for check node processing operations. The state for a check node is fully updated and then subject to an extraction process to generate check node to variable node messages. The signs of messages received from variable nodes may be stored by the check node processor module of the invention for use in message extraction. The check node processor can process messages in variable node order thereby allowing the variable node processor and check node processor to operate on messages in the same order reducing or eliminating the need to buffer and/or reorder messages passed between check nodes and variable nodes. Graph structures which allow check node processing on one graph iteration to proceed before the previous graph iteration has been completed are also described. Constraining the graph to allow a particular type of partition allows the subsequent iterations to overlap in time and one can effectively reduce and/or eliminate the penalty due to the pipeline delay.
<img id="iaf01" file="imgaf001.tif" wi="78" he="96" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA128737486" lang="EN" source="EPO" load-source="docdb"><p>Methods and apparatus for implementing memory efficient LDPC decodes are described. In accordance with the invention message information is stored in a compressed state for check node processing operations. The state for a check node is fully updated and then subject to an extraction process to generate check node to variable node messages. The signs of messages received from variable nodes may be stored by the check node processor module of the invention for use in message extraction. The check node processor can process messages in variable node order thereby allowing the variable node processor and check node processor to operate on messages in the same order reducing or eliminating the need to buffer and/or reorder messages passed between check nodes and variable nodes. Graph structures which allow check node processing on one graph iteration to proceed before the previous graph iteration has been completed are also described. Constraining the graph to allow a particular type of partition allows the subsequent iterations to overlap in time and one can effectively reduce and/or eliminate the penalty due to the pipeline delay.</p></abstract><description mxw-id="PDES63959323" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><b><u>BACKGROUND OF THE INVENTION</u></b></heading><p id="p0001" num="0001">Nearly all forms of electronic communication and storage systems use error-correcting codes. Error correcting codes compensate for the intrinsic unreliability of information transfer in these systems by introducing redundancy into the data stream. The mathematical foundations of error correcting were established by Shannon. Shannon developed the mathematical concept of the channel in which distortion of signals in communications systems is modeled as a random process. The most fundamental result of Shannon is the Noisy channel theorem, which defines for the channel a <i>capacity</i>, a quantity that specifies the maximum rate at which information can be reliably delivered through the channel. Reliable transmission at rates approaching capacity requires the use of error correcting codes. Thus, error-correcting codes are designed to achieve sufficient reliability while approaching capacity as closely as possible. The complexity of implementing the error correcting code is an additional factor that comes into play in practical applications of error correcting codes. Recent advances in error correcting coding systems resulting from the invention of turbo codes and the subsequent rediscovery and development of low-density parity-check (LDPC) codes offer coding systems of feasible complexity that can approach Shannon's capacity quite closely.</p><p id="p0002" num="0002">LDPC codes are well represented by bipartite graphs, often called Tanner graphs, such as the graph 100 shown in <figref idrefs="f0001">Fig 1</figref>. In Tanner graphs in one set of nodes, the <i>variable</i> nodes 102, corresponds to bits of the codeword and the other set of nodes, the <i>constraint</i> nodes 106, sometimes called <i>check</i> nodes, correspond to the set of parity-check constraints which define the code. Edges 104 in the graph connect variable nodes to constraint nodes. A variable node and a constraint node are said to be <i>neighbors</i> if they are connected by an edge in the graph. One typically assumes that a pair of nodes is connected by at most one edge. LDPC codes can equivalently be represented using the parity check matrix 202. <figref idrefs="f0002">Fig 2</figref> presents an example of a parity matrix representation where the indicated vector x 208 is a codeword if and only if Hx=0.</p><p id="p0003" num="0003">To each variable node is associated one bit of the codeword. In some cases some of these bits might be <i>punctured.</i> Punctured bits may be desirable in certain code structures and they are excluded from the transmitted codeword.<!-- EPO <DP n="2"> --></p><p id="p0004" num="0004">A bit sequence associated one-to-one with the variable node sequence is a codeword of the code if and only if, for each constraint node, the bits neighboring the constraint (via their association with variable nodes) sum to zero modulo two, i.e., they comprise an even number of ones.</p><p id="p0005" num="0005">The decoders and decoding algorithms used to decode LDPC codewords operate by exchanging messages within the graph along the edges and updating these messages by performing computations at the nodes based on the incoming messages. Such algorithms will be generally referred to as message passing algorithms. Each variable node in the graph is initially provided with a soft bit, termed a <i>received value,</i> that indicates an estimate of the associated bit's value as determined by observations from, e.g., the communications channel. Ideally, the estimates for separate bits are statistically independent. This ideal can be, and often is, violated in practice. A collection of received values constitutes a <i>received word.</i> For purposes of this application we may identify the signal observed by, e.g., the receiver in a communications system, with the received word.</p><p id="p0006" num="0006">The number of edges attached to a node, i.e., a variable node or constraint node, is referred to as the <i>degree</i> of the node. A <i>regular</i> graph or code is one for which all variable nodes have the same degree, j say, and all constraint nodes have the same degree, k say. In this case we say that the code is a (j,k) regular code. These were the codes considered originally by Gallager (1961). In contrast to a "regular" code, an irregular code has constraint nodes and/or variable nodes of differing degrees. For example, some variable nodes may be of degree 4, others of degree 3 and still others of degree 2.</p><p id="p0007" num="0007">While irregular codes can be more complicated to represent and/or implement, it has been shown that irregular LDPC codes can provide superior error correction/detection performance when compared to regular LDPC codes.</p><p id="p0008" num="0008">It will be appreciated that received words generated in conjunction with LDPC coding, can be processed by performing LDPC decoding operations thereon, e.g., error correction and detection operations, to generate a reconstructed version of the original codeword. The reconstructed codeword can then be subject to data decoding to recover the original data that<!-- EPO <DP n="3"> --> was coded. The data decoding process may be, e.g., simply selecting a specific subset of the bits from the reconstructed codeword.</p><p id="p0009" num="0009">As mentioned above, LDPC decoding operations generally comprise message passing algorithms. There are many potentially useful message passing algorithms and the use of such algorithms is not limited to LDPC decoding</p><p id="p0010" num="0010">To facilitate understanding of the invention discussed in the sections which follow, we will now give a brief mathematical description of belief propagation.</p><p id="p0011" num="0011">Belief propagation for (binary) LDPC codes can be expressed as follows. Messages transmitted along the edges of the graph are interpreted as log-likelihoods <maths id="math0001" num=""><math display="inline"><mi>log</mi><mo>⁢</mo><mfrac><msub><mi>p</mi><mn>0</mn></msub><msub><mi>p</mi><mn>1</mn></msub></mfrac></math><img id="ib0001" file="imgb0001.tif" wi="14" he="12" img-content="math" img-format="tif" inline="yes"/></maths> for the bit associated to the variable node. Here, (p<sub>0</sub>,p<sub>1</sub>) represents a conditional probability distribution on the associated bit where p<sub>x</sub> denotes the probability that the bit takes the value x. The soft bits provided to the decoder by the receiver are also given in the form of a log-likelihood. Thus, the received values, i.e., the elements of the received word, are log-likelihoods of the associated bits conditioned on the observation of the bits provided by the communication channel. In general, a message m represents the log-likelihood m and a received value y represents the log-likelihood y. For punctured bits the log-likelihood received value y is set to 0, indicating p<sub>0</sub>=p<sub>1</sub>=½.</p><p id="p0012" num="0012">Let us consider the message-passing rules of belief propagation. Messages are denoted by m<sup>C2V</sup> for messages from check nodes to variable nodes and by m<sup>V2C</sup> for messages from variable nodes to check nodes. Consider a variable node with d edges. For each edge j=1,...,d let m<sup>C2V</sup>(i) denote the incoming message on edge i. At the initialization of the decoding process we set m<sup>C2V</sup> =0 for every edge. In general, outgoing messages from variable nodes are given by <maths id="math0002" num=""><math display="block"><msup><mi mathvariant="normal">m</mi><mrow><mi mathvariant="normal">V</mi><mo>⁢</mo><mn mathvariant="normal">2</mn><mo>⁢</mo><mi mathvariant="normal">C</mi></mrow></msup><mfenced><mi mathvariant="normal">j</mi></mfenced><mo>=</mo><mi mathvariant="normal">y</mi><mo>+</mo><mfenced separators=""><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn mathvariant="normal">1</mn></mrow><mi>d</mi></msubsup><mspace width="1em"/><msup><mi mathvariant="normal">m</mi><mrow><mi mathvariant="normal">C</mi><mo>⁢</mo><mn mathvariant="normal">2</mn><mo>⁢</mo><mi mathvariant="normal">V</mi></mrow></msup><mfenced><mi mathvariant="normal">i</mi></mfenced></mfenced><mo>-</mo><msup><mi mathvariant="normal">m</mi><mrow><mi mathvariant="normal">C</mi><mo>⁢</mo><mn mathvariant="normal">2</mn><mo>⁢</mo><mi mathvariant="normal">V</mi></mrow></msup><mfenced><mi mathvariant="normal">j</mi></mfenced><mn mathvariant="normal">.</mn></math><img id="ib0002" file="imgb0002.tif" wi="81" he="14" img-content="math" img-format="tif"/></maths></p><p id="p0013" num="0013">The outgoing decoded soft value from a node (not an edge message) corresponding to this operation is given by <maths id="math0003" num=""><math display="inline"><msub><mi mathvariant="normal">x</mi><mi>out</mi></msub><mo>=</mo><mi mathvariant="normal">y</mi><mo>+</mo><mfenced separators=""><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn mathvariant="normal">1</mn></mrow><mi mathvariant="normal">d</mi></msubsup><mo>⁢</mo><msup><mrow><mspace width="1em"/><mi mathvariant="normal">m</mi></mrow><mrow><mi mathvariant="normal">C</mi><mo>⁢</mo><mn mathvariant="normal">2</mn><mo>⁢</mo><mi mathvariant="normal">V</mi></mrow></msup><mfenced><mi mathvariant="normal">i</mi></mfenced></mfenced><mn mathvariant="normal">.</mn></math><img id="ib0003" file="imgb0003.tif" wi="42" he="8" img-content="math" img-format="tif" inline="yes"/></maths>The outgoing hard decision associated to this output is obtained from the sign of x<sub>out</sub>.<!-- EPO <DP n="4"> --></p><p id="p0014" num="0014">At the check nodes it is often more convenient to represent the messages using their 'sign' and magnitudes. Thus, for a message m let <i>m<sub>p</sub></i> ∈ <i>GF</i>[2] denote the 'parity' of the message, i.e., m<sub>p</sub> = 0 if m ≥ 0 and m<sub>p</sub> = 1 if m &lt; 0. Additionally let <i>m<sub>r</sub></i> ∈ [0,∞] denote the magnitude of m. Thus, we have <i>m</i> = -1<i><sup>m<sub2>p</sub2></sup> m<sub>r</sub></i>. At the check node the updates for m<sub>p</sub> and m<sub>r</sub> are separate. We have, for a check node of degree d, <maths id="math0004" num=""><math display="block"><msup><msub><mi mathvariant="normal">m</mi><mi mathvariant="normal">p</mi></msub><mrow><mi mathvariant="normal">C</mi><mo>⁢</mo><mn mathvariant="normal">2</mn><mo>⁢</mo><mi mathvariant="normal">V</mi></mrow></msup><mfenced><mi mathvariant="normal">j</mi></mfenced><mo>=</mo><mfenced separators=""><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn mathvariant="normal">1</mn></mrow><mi>d</mi></msubsup><mspace width="1em"/><msup><msub><mi mathvariant="normal">m</mi><mi mathvariant="normal">p</mi></msub><mrow><mi mathvariant="normal">V</mi><mo>⁢</mo><mn mathvariant="normal">2</mn><mo>⁢</mo><mi mathvariant="normal">C</mi></mrow></msup><mfenced><mi mathvariant="normal">i</mi></mfenced></mfenced><mo>-</mo><msup><msub><mi mathvariant="normal">m</mi><mi mathvariant="normal">p</mi></msub><mrow><mi mathvariant="normal">V</mi><mo>⁢</mo><mn mathvariant="normal">2</mn><mo>⁢</mo><mi mathvariant="normal">C</mi></mrow></msup><mfenced><mi mathvariant="normal">j</mi></mfenced><mo>,</mo></math><img id="ib0004" file="imgb0004.tif" wi="70" he="13" img-content="math" img-format="tif"/></maths><br/>
where all addition is over GF[2], and <maths id="math0005" num=""><math display="block"><msup><msub><mi mathvariant="normal">m</mi><mi mathvariant="normal">r</mi></msub><mrow><mi mathvariant="normal">C</mi><mo>⁢</mo><mn mathvariant="normal">2</mn><mo>⁢</mo><mi mathvariant="normal">V</mi></mrow></msup><mfenced><mi mathvariant="normal">j</mi></mfenced><mo>=</mo><msup><mi mathvariant="normal">F</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>⁢</mo><mfenced separators=""><mfenced separators=""><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn mathvariant="normal">1</mn></mrow><mi>d</mi></msubsup><mspace width="1em"/><mi>F</mi><mfenced separators=""><msup><msub><mi mathvariant="normal">m</mi><mi mathvariant="normal">r</mi></msub><mrow><mi mathvariant="normal">V</mi><mo>⁢</mo><mn mathvariant="normal">2</mn><mo>⁢</mo><mi mathvariant="normal">C</mi></mrow></msup><mfenced><mi mathvariant="normal">i</mi></mfenced></mfenced></mfenced><mo>-</mo><mi mathvariant="normal">F</mi><mfenced separators=""><msup><msub><mi mathvariant="normal">m</mi><mi mathvariant="normal">r</mi></msub><mrow><mi mathvariant="normal">V</mi><mo>⁢</mo><mn mathvariant="normal">2</mn><mo>⁢</mo><mi mathvariant="normal">C</mi></mrow></msup><mfenced><mi mathvariant="normal">j</mi></mfenced></mfenced></mfenced><mo>,</mo></math><img id="ib0005" file="imgb0005.tif" wi="95" he="10" img-content="math" img-format="tif"/></maths><br/>
where addition is real and we define F(x):= ln coth (x/2). We note that F is its own inverse, i.e., F<sup>-1</sup>(x)=F(x).</p><p id="p0015" num="0015">An algorithm often mentioned in LDPC literature is the so-called MIN-SUM algorithm. In this algorithm the update operation at check nodes can be expressed mathematically as <maths id="math0006" num=""><math display="block"><msup><msub><mi mathvariant="normal">m</mi><mi mathvariant="normal">r</mi></msub><mrow><mi mathvariant="normal">C</mi><mo>⁢</mo><mn mathvariant="normal">2</mn><mo>⁢</mo><mi mathvariant="normal">V</mi></mrow></msup><mfenced><mi mathvariant="normal">j</mi></mfenced><mo>=</mo><mi>min</mi><mspace width="1em"/><mfenced open="{" close="}" separators=""><mfenced separators=""><msubsup><mi mathvariant="normal">U</mi><mrow><mi>i</mi><mo>=</mo><mn mathvariant="normal">1</mn></mrow><mi>d</mi></msubsup><mspace width="1em"/><msup><msub><mi mathvariant="normal">m</mi><mi mathvariant="normal">r</mi></msub><mrow><mi mathvariant="normal">V</mi><mo>⁢</mo><mn mathvariant="normal">2</mn><mo>⁢</mo><mi mathvariant="normal">C</mi></mrow></msup><mfenced><mi mathvariant="normal">i</mi></mfenced></mfenced><mo>∖</mo><msup><msub><mi mathvariant="normal">m</mi><mi mathvariant="normal">r</mi></msub><mrow><mi mathvariant="normal">V</mi><mo>⁢</mo><mn mathvariant="normal">2</mn><mo>⁢</mo><mi mathvariant="normal">C</mi></mrow></msup><mfenced><mi mathvariant="normal">j</mi></mfenced></mfenced><mn mathvariant="normal">.</mn></math><img id="ib0006" file="imgb0006.tif" wi="83" he="10" img-content="math" img-format="tif"/></maths></p><p id="p0016" num="0016">Thus, the reliability of a C2V message is equal to the minimum reliability of the V2C messages incoming along other edges. To implement this algorithm it is sufficient to save at the check node the smallest and second smallest reliability (they may be the same value if that value occurs for at least two incoming messages) and the identity of the edge providing the incoming message of least reliability. The reliability of the outgoing C2V message on the edge originating the least reliable incoming message is equal to the second smallest incoming reliability and the reliability of the outgoing C2V message on all other edges is equal to the smallest reliability.</p><p id="p0017" num="0017">In the <patcit id="pcit0001" dnum="US6633856B"><text>U.S. patent 6,633,856</text></patcit> an LDPC decoder architecture was described. In that architecture the messages being sent from check nodes to variable nodes were stored in memory.<!-- EPO <DP n="5"> --> If the messages comprise 5 bits, for example, and a check node has degree K, then the storage used for those messages is 5K bits.</p><p id="p0018" num="0018">From an implementation and cost standpoint it is generally desirable to implement an LDPC decoder in a manner that is relatively simple to construct and requires a relatively small amount of hardware. Memory is a major component in many decoder designs. It would be desirable if the amount of memory required to implement a decoder could be keep to a low or minimal amount to thereby reduce hardware costs.</p><p id="p0019" num="0019">While memory reduction is of a concern, in reducing the amount of memory used, it is often necessary to avoid a design which would impose unacceptable processing delays which might result in the failure to meet one or more real world decoding time constraints.</p><p id="p0020" num="0020">In view of the above discussion, it should be apparent that memory efficient methods and apparatus which can be used to simply the implementation of LDPC decoders and/or produce an LDPC decoder capable of performing decoding operations with a relatively small amount of memory would be desirable. In addition, methods for avoiding the introduction of extensive delays into an LDPC decoding process using a memory efficient decoder implementation are desirable and would be beneficial.</p><heading id="h0002"><b><u>SUMMARY OF THE INVENTION</u></b></heading><p id="p0021" num="0021">The present invention is directed to methods and apparatus for performing LDPC decoding operations in a memory efficient manner. Various features of the present invention are directed to check node processing methods and apparatus which are implemented in a memory efficient manner, e.g., using one or more message information compression and/or decompression techniques. Additional features of the present invention are directed to avoiding and/or reducing delays in memory efficient LDPC decoders, e.g., decoder of the type described in the present application, by the use of LDPC codes with a code structure that avoids introducing significant delays into the decoding process.</p><p id="p0022" num="0022">The inventor of the present application realized that check node computation in LDPC decoders has the property that outgoing reliabilities take on only two values and one of those<!-- EPO <DP n="6"> --> values goes out along only one edge and that this property could be used to efficiently store check node message information and to efficiently implement a check node processor module. Using this property, the full message for each edge need not be stored during check node processing with the storage being reduced to the amount that will be needed for processing and to construct the output messages when check node processing corresponding to a node has been completed. By using message compression, the storage requirement for a check node processor module, in many cases, can be substantially reduced as compared to implementations where message compression is not used in accordance with the invention.</p><p id="p0023" num="0023">Various features of the present invention are directed to check node processing modules. The processing modules store message information corresponding to the messages associated with each check node in a compressed format. To do this a check node state memory including, e.g., one entry per check node, is used. The state information for a check node includes information generated from the input messages to that particular check node rather than a complete set of messages for the check node. Thus the state information represents a compressed set of message information. The compressed information corresponding to each check node is updated as each input message, e.g., variable node to check node message, is received. Input messages can be received in any order, e.g., the input messages for each individual check node need not be received and processed consecutively. Thus, in accordance with the invention an input message corresponding to one check node can be processed, followed by an input message corresponding to another check node, without first receiving all the input messages for the other check node. This allows for variable to check node messages to be received and processed in variable node edge order as opposed to the order at which the edges appear at the check node side of the LDPC graph. Thus, assuming processing of messages at the variable node processing element in variable node order, there is no need to re-order the generated messages prior to processing at the check node processing module of the invention.</p><p id="p0024" num="0024">After the full set of variable node to check node messages corresponding to an individual check node is processed, the compressed message information corresponding to the full set of messages associated with a check node is accessed and processed, e.g., subject to a decompression process also referred to herein as an extraction processes. The extraction process generates the full set of check node to variable node messages which are to be produced by the<!-- EPO <DP n="7"> --> individual check node, e.g., as dictated by the particular code structure being implemented and the individual check node's position within that code structure.</p><p id="p0025" num="0025">In some embodiments, the stored state for each check node includes two values, e.g., first and a second values. These values may be message magnitude values. The state also includes edge position information associated with one of the values. This information represents the state used to generate the magnitude portion of outgoing message produced by the particular check node. In addition to the message magnitude information which represents reliability information, for each check node an accumulated sign bit value is stored. The accumulated sign bit is generated by XORing the sign bit of each input message to the check node which is processed with the last generated accumulated sign bit value to generate the sign bit for each output message.</p><p id="p0026" num="0026">In one particular embodiment, additional sign bit information is stored for each input message that is received corresponding to a check node. In such an embodiment the input sign bit is stored from each message received on a check node edge. Thus, in such an embodiment, in addition to an accumulated sign bit for each check node, an input sign bit is stored for each check node edge, where each edge corresponds to a different input message.</p><p id="p0027" num="0027">While the full set of input messages corresponding to an individual check node need to be processed before output messages from the particular individual check node are generated, by using a code structure where check nodes do not receive input messages from variable nodes which will be processed much later during the decoding process, the output messages for at least some check nodes can be generated without having to process the messages from the full set of variable nodes present in the implemented graph structure. By using a code which takes into consideration the benefits of making the processing of check nodes occurring in one part of a graph so that they do not depend on messages from variable nodes which will be processed much later, timing delays associated with check node output message generation can be reduced and/or minimized.</p><p id="p0028" num="0028">Check node output messages for a check node may be generated once the full set of input messages, e.g., one input message for each check node edge, has been processed. To generate a check node output message, which serves as an input message to a variable node, the check node<!-- EPO <DP n="8"> --> processing module of the present invention reads the check node state associated with the check node for which the output message. From the stored magnitude state information, e.g., first and second magnitude values and edge identifier, the check node processing module processes the state to extract, e.g., generate, a complete output message for one edge, e.g., a check node to variable node message. The process will be repeated for each edge of the check node until a full set of output message is generated. The processing of the check node state information is, in effect, a decompression operation.</p><p id="p0029" num="0029">In some embodiments the min sum algorithm is used to store check node message magnitude (reliability) information in a compressed state. In such embodiments, for each check node a minimum message magnitude value, a second minimum message magnitude value and information indicating the edge to which the minimum message magnitude value corresponds is stored. This information is in addition to the accumulated sign bit information. This information is updated each time an input message corresponding to the particular check node to which the information correspond is received until each of the input messages for the particular check node have been processed.</p><p id="p0030" num="0030">To generate the magnitude portion of an outgoing message corresponding to an edge, the edge is compared to the stored edge identifier which indicates the edge on which the minimum message value was received. If the edge for which the outgoing message is being generated does not match the stored edge identifier, the minimum message value is used as the magnitude of the outgoing message. If the stored edge identifier matches the edge for which the outgoing message is being generated, the second minimum value is used as the outgoing message value. Thus, the magnitudes of outgoing messages generated by a check node will either have the minimum value or the second minimum value with the second minimum value being output on the single edge which supplied the minimum magnitude value that was received by the check node.</p><p id="p0031" num="0031">Computationally, this amounts to performing a multiplexing (selecting) operation between two possible reliabilities, A and B, where A and B are the two possible outgoing magnitude values, e.g., the minimum or second minimum received message magnitude value received by the particular check node. The second outgoing magnitude value B is selected for the magnitude portion of the outgoing message if the edge (variable to check node connection)<!-- EPO <DP n="9"> --> matches the stored edge index indicating the edge on which the magnitude value A (the minimum value) was received. Otherwise the minimum magnitude value A is output.</p><p id="p0032" num="0032">The sign bit for an outgoing message may be generated in a variety of ways. In one particular exemplary embodiment. The accumulated sign bit value corresponding to a check node is combined, e.g., XORed, with the stored received sign bit value corresponding to the edge for which the outgoing message is being generated to produce the sign bit value of the outgoing message for that edge. This process is repeated, like the magnitude generation portion of the outgoing message generation process for each edge for which an outgoing message is generated.</p><p id="p0033" num="0033">From an implementation standpoint, the check node processing method of the present invention has the advantage of reducing the amount of memory required to implement check node processing through the use of message compression. From an implementation standpoint, this can be significant particularly in cases where check nodes may large numbers of edges as is the case with many robust LDPC codes in use today and likely to be used in the future.</p><p id="p0034" num="0034">For example consider the case of 5 bit messages which are include 1 sign bit and 4 magnitude bits. Under the above assumptions the output information from the check node can be compressed to approximately K + 8 + log<sub>2</sub> K bits, where K is the number of incoming and outgoing messages. In the 5 bit message example, K storage bits will be used to store the sign bits corresponding to each of the K input messages, 8 bits will be used for storing each of the two possible magnitude values which the output messages may assume, e.g., the minimum input message magnitude and the next smallest input message magnitude value, and log<sub>2</sub> K bits are used to indicate the edge (message) that is to receive the second reliability value while the other edges will receive the minimum input message magnitude value. If K is large, which will be the case for high rate LDPC codes, then use of this message information storage technique can result in a substantial savings as compared to implementations which store the full sets of bits corresponding to each received message as part of the process of generating output messages.</p><p id="p0035" num="0035">While, some additional processing is required to generate outgoing messages from the stored state, e.g., min message magnitude, second min message magnitude, edge position corresponding to the min message magnitude, and stored sign bits corresponding to each of the<!-- EPO <DP n="10"> --> edges, as compared to embodiments where complete messages are stored, but, in return, there may be substantial memory savings.</p><p id="p0036" num="0036">The check node processing module of the present invention has the additional advantage that variable to check node messages which serve as the input to the check node processing module can be received and processed without regard to a particular message processing order. Output messages are generated after each of the input messages to a check node have been processed.</p><p id="p0037" num="0037">Numerous additional features and benefits of the invention will be apparent from the detailed description which follows.</p><heading id="h0003"><b><u>BRIEF DESCRIPTION OF THE DRAWINGS</u></b></heading><p id="p0038" num="0038"><ul><li><figref idrefs="f0001">Figure 1</figref> is a graph illustrating an exemplary LDPC code including ten variable nodes and five check nodes.</li><li><figref idrefs="f0002">Figure 2</figref> is alternative representation of the LDPC code of <figref idrefs="f0001">Figure 1</figref> which shows the code through the use of a matrix representation as an alternative to the graph representation shown in <figref idrefs="f0001">Fig. 1</figref>.</li><li><figref idrefs="f0003">Figure 3</figref> illustrates a constraint node processing module implemented in accordance with the invention.</li><li><figref idrefs="f0004">Figure 4</figref> illustrates an LDPC decoder implemented in accordance with the present invention.</li><li><figref idrefs="f0005">Figure 5</figref> illustrates another LDPC decoder implemented using N parallel constraint node and variable node processing elements in accordance with the present invention.</li><li><figref idrefs="f0006">Figure 6</figref> illustrates an exemplary LDPC code structure which can be used to control decoding in, for example, the decoder of <figref idrefs="f0004">Fig. 4</figref>.<!-- EPO <DP n="11"> --></li><li><figref idrefs="f0007">Figure 7</figref> illustrates another exemplary LDPC code structure which can be used to control decoding in, for example, the exemplary decoder of <figref idrefs="f0004">Fig. 4</figref>, in accordance with the invention.</li><li><figref idrefs="f0008">Figure 8</figref> illustrates the results of performing a decoding operation on a set of input values using the decoder of <figref idrefs="f0004">Fig. 4</figref> and the LDPC code structure illustrated in <figref idrefs="f0007">Fig. 7</figref>.</li></ul></p><heading id="h0004"><b><u>DETAILED DESCRIPTION</u></b></heading><p id="p0039" num="0039">The following (3) related applications are hereby expressly incorporated by reference and are to be considered part of the present application: <patcit id="pcit0002" dnum="US97533101A"><text>U.S. patent application S.N. 09/975,331 filed October 10, 2001</text></patcit> entitled "METHODS AND APPARATUS FOR DECODING LDPC CODES", <patcit id="pcit0003" dnum="US11726402A"><text>U.S. patent application S.N. 10/117,264 filed April 4, 2002</text></patcit> entitled "NODE PROCESSORS FOR USE IN PARITY CHECK DECODERS", and <patcit id="pcit0004" dnum="US61832503A"><text>U.S. patent application S.N. 10/618,325 filed July 11, 2003</text></patcit> entitled "METHODS AND APPARATUS FOR ENCODING LDPC CODES".</p><p id="p0040" num="0040">Various embodiments of the present invention are directed to methods and apparatus which provide a simple, e.g., low hardware complexity, implementation of an LDPC decoder architecture. The methods and apparatus of the invention take advantage of the observation that, for certain algorithms, the reliabilities sent out from a check node take on one of two possible values and one of those values is sent along only one message edge. This is the case, for example, for the min-sum algorithm. The same conditions can exist for other algorithms which can be used to store LDPC message information in a compressed form, e.g., algorithms that share with the min-sum algorithm the property that the reliabilities sent out from a check node take on only two possible values and one of those values is sent along just one message edge attached to a check node.</p><p id="p0041" num="0041">In accordance with the invention, associated with each check node in an LDPC code structure being used to control decoding is a state S. The state will include the reliability (message magnitude) information of incoming messages in a current decoding iteration that will be used to generate outgoing messages. Let S<sub>k</sub> denote the state assuming that messages m<sub>1</sub>,...,m<sub>k</sub> have been incorporated. Then, given a state update function G, the updated state for a<!-- EPO <DP n="12"> --> given check node resulting after processing of a received variable to check node message corresponding to a check node can be expressed as: <maths id="math0007" num=""><math display="block"><msub><mi mathvariant="normal">S</mi><mrow><mi mathvariant="normal">k</mi><mo>+</mo><mn mathvariant="normal">1</mn></mrow></msub><mo>=</mo><mi mathvariant="normal">G</mi><mo>⁢</mo><mfenced separators=""><msub><mi mathvariant="normal">m</mi><mrow><mi mathvariant="normal">k</mi><mo>+</mo><mn mathvariant="normal">1</mn></mrow></msub><mo>⁢</mo><msub><mi mathvariant="normal">S</mi><mi mathvariant="normal">k</mi></msub></mfenced><mn mathvariant="normal">.</mn></math><img id="ib0007" file="imgb0007.tif" wi="46" he="8" img-content="math" img-format="tif"/></maths></p><p id="p0042" num="0042">In accordance with various embodiments of the invention, the state update operation is performed on state which represents the magnitude portion of a plurality of messages corresponding to a check node in a compressed form. Thus, the state update operation compresses the incoming messages.</p><p id="p0043" num="0043">In the case of an implementation which uses the MINSUM algorithm to store message information in a compressed format, the stored message state may be, for example, in the form of (m<sub>A</sub>, m<sub>B</sub>, A, s). Where m<sub>A</sub> is the minimum incoming reliability (message magnitude) seen so far by a check node to which the state corresponds, m<sub>B</sub> is the second smallest reliability seen so far, A indexes the edge that carried the incoming message of reliability m<sub>A</sub> thereby indicating which message edge supplied the minimum value m<sub>A</sub>, and s is the XOR of the signs of the incoming messages corresponding to the check node to which the state information corresponds.</p><p id="p0044" num="0044">By performing updates on state information corresponding to check nodes using the function G, and by providing an decoder implementation where state corresponding to individual check nodes can be stored and retrieved for updating with incoming messages as a function of which check node the message is directed to, then the order of messages coming into a check node processor can be essentially arbitrary. Thus, in accordance with the invention variable to check node messages can arrive in variable node order at the check node processor module with the messages being processed in the order they are received. This allows LDPC decoders, such as the decoders 400 and 500 illustrated in <figref idrefs="f0004">Figs. 4</figref> and <figref idrefs="f0005">5</figref>, implemented in accordance with the invention where both sides (variable node and check node which are implemented as variable node and check node processors, respectively to be updated in variable node order. Further more, both variable node and check node processing elements can, and do, operate in parallel, e.g., simultaneously, in some embodiments.</p><p id="p0045" num="0045">Such decoder implementations of the present invention allow for substantial savings in memory requirements when compared to decoder implementations where variable node processing is performed in variable node message order and check node processing is performed<!-- EPO <DP n="13"> --> in check node message order and a memory is used to store and allow for the reordering of messages being passed between the check node and variable node processors.</p><p id="p0046" num="0046">Having described some of the basic principles and benefits of the LDPC decoder design of the present invention, various exemplary modules and LDPC decoders which implement one or more features of the present invention will now be described.</p><p id="p0047" num="0047"><figref idrefs="f0003">Figure 3</figref> illustrates a check node processing module 300, also known as a constraint node processing module, implemented in accordance with the present invention. The module 300 receives variable to check node (V2C) messages via input 302, control information via a control signal input 324 and generates check node to variable node (C2V) messages which are output via output 322. The check node processing module 300 stores message information which can be used to generate check node to variable node messages in a compressed format.</p><p id="p0048" num="0048">The check node processing module 300 includes a check node state memory module 310, a control module 309, a check node processor element 308, message sign memory 312, a check node state buffer memory 314 and check node extractor 316 which are coupled together as shown in <figref idrefs="f0003">Fig. 3</figref>. In the illustrated embodiment, the sign value for each received V2C message is separated from the magnitude value. The magnitude message value is supplied to the check node processor 308 via input 304 while the sign value corresponding to each received message supplied to the check node processor element 308 and is also stored in message sign memory 312 which stores the sign bit to be used later in generating outgoing C2V messages from stored state 321, 323.</p><p id="p0049" num="0049">The check node state memory 310 includes, for each check node in the code structure which is being used to control decoding, a single state memory element 321, 323 which is used to store the state for the particular check node to which the memory element corresponds. Each check node state memory 321, 323 store state information corresponding to one check node corresponding to an LDPC graph structure used to control decoding.</p><p id="p0050" num="0050">In the <figref idrefs="f0003">Fig. 3</figref> example, state is stored in a compressed representation corresponding to the min sum algorithm discussed above. The entry is reset at the start of check node processing corresponding to the entry for each processing iteration corresponding the edge messages<!-- EPO <DP n="14"> --> included in one complete representation of the LDPC graph being used to control decoding. Processing of check nodes from one iteration to another iteration of the graph may occur prior to completion of the first iteration, e.g., once the full set of variable nodes corresponding to one check node in the graph has been completed. In such a case, resetting of all the sets of check node state information 321, 323 will not occur at the same time. Rather, the check node state corresponding to a check node will be fully updated and then reset after being supplied to check node state buffer memory for use in generating C2V messages.</p><p id="p0051" num="0051">Each state entry 321, 323 corresponds to one check node in the graph structure being used to control decoding. Each state entry 321, 323 includes S, a one bit value which is the XOR of the sign bits corresponding each received V2C message directed to the check node to which the entry corresponds, a minimum value m<sub>A</sub> indicating the minimum received message magnitude corresponding to the particular check node, the second minimum message magnitude value m<sub>B</sub> corresponding to the particular check node, and an index I<sub>A</sub> indicating the message edge on which the lowest minimum value m<sub>A</sub>, was received.</p><p id="p0052" num="0052">Control signal input 324 receives a control signal which is used to control operation of the check node processing module as a function of the code structure used to control decoding, e.g., as a function of the number of graph edges and thus messages which will be passed between the variable and check node processing elements. Control signal 324 includes information indicating which edge, and thus which V2C message is being received at input 302 at a particular time. This same signal can be used to drive C2V message generation in cases where there is a fixed or known relationship between V2C input message timing and the desired C2V output message timing which will normally be the case. The control signal 324 is supplied to the control module 309, message sign memory 312 and check node read processor (extractor) 316. The control module 309 uses the received control signal to determine which check node a received V2C message corresponds. Based on the received control information, the control module determines which set of check node state information 321, 323 to read out from the check node state memory 310 for updating. Thus, control module determines based on the edge information the check node to which the receive message corresponds. Once the check node processor updates the retrieved state information by using the received message information as will be discussed below, the updated state is written back into the check node state entry 321, 323 from which the state to be updated was retrieved. This process will continue until the<!-- EPO <DP n="15"> --> control module 309 signals to the check node processor element 308 that the check node state for a particular check node has been fully updated using the last V2C message directed to the check node during the particular processing iteration. With the state for the check node being fully updated, the check node processor will reset the values in the check node state by writing default values into the check node state and output the fully updated check node state to the check node state buffer 314 to be used in message extraction. Check node state buffer memory 314 includes state entries for one or more check nodes which have the same content as entries 321, 323 but with the values corresponding to a set of fully updated state for the check node. Check node state buffer memory 314 knows what entry to store the fully updated check node information in bases on the control signal obtained from input 324.</p><p id="p0053" num="0053">The check node state memory 310 includes an updated check node state message input 327 for receiving state information to be stored and a control input 327 for receiving a control signal indicating which set of check node state information 321, 323 is to be accessed and whether updated state information is to be stored or read from the indicated set of check node state information. The check node state information 321 or 323 read from the check node state memory is output via output 329 and supplied to a state input of check node processor element 308 where it is used in a state update operation.</p><p id="p0054" num="0054">The state update operation performed by the check node processor 308 on a set of state information retrieved from memory as a function of information included in a received V2C message as follows: the magnitude m<sub>r</sub> of the received C2V message is compared to the minimum magnitude m<sub>A</sub> in the retrieved state information corresponding to the check node to which the received message is directed.</p><p id="p0055" num="0055">If m<sub>r</sub> is less the m<sub>A</sub> then: m<sub>B</sub> is set equal to m<sub>A</sub> to create the updated m<sub>B</sub> and m<sub>A</sub> is set equal to m<sub>r</sub> with m<sub>r</sub> thereby becoming the updated minimum and the previous minimum becoming the current second minimum for the check node. In addition the index I indicating the message edge to which the minimum m<sub>A</sub> corresponds to indicate the message edge on which the message being processed, e.g., the message providing the updated minimum magnitude value, was received.<!-- EPO <DP n="16"> --></p><p id="p0056" num="0056">If m<sub>r</sub> is less than m<sub>B</sub>, but greater than m<sub>A,</sub> then m<sub>B</sub> is set equal to m<sub>r</sub> without changing m<sub>A</sub> or I.</p><p id="p0057" num="0057">If m<sub>r</sub> is equal to or greater than m<sub>b</sub> the m<sub>A</sub>, m<sub>B</sub> and I values read from memory are not altered and the updated state will include the values for these elements which were read out from memory.</p><p id="p0058" num="0058">Regardless of the relative magnitude of the received message value and stored minimums, the accumulated sign bit S for the check node will be updated with each received message by performing an XOR of the sign bit in the received message with the sign bit read from the stored check node state entry. The result of the XOR operation becomes the sign S bit of the updated entry for the check node which is written back into memory in the case of a check node which has not been fully updated or is supplied to the check node state memory buffer 314 in the case of a fully updated check node entry. As mentioned above, in the case of a fully updated check node entry, default values will be written into the check node's entry 321, 323 from which the check node state was read thereby resetting the information for another iteration of graph processing. The default values for the minimum m<sub>A</sub> and second minimum m<sub>B</sub> will normally be the maximum values these elements may assume.</p><p id="p0059" num="0059">Given the above described check node processing and state update technique, it should be apparent that check node processor element 308 can process variable to check node messages in an arbitrary order, e.g., in variable node as opposed to check node edge order. This allows the check node processor element 308 to processes V2C messages in the order they are naturally generated as a result of variable node processor operation given that variable node processors normally operate in variable node edge order.</p><p id="p0060" num="0060">Since the fully updated state information for a check node is in a compressed format representation of the information required to generate C2V output messages, additional processing is used to construct the actual C2V messages output via output 322. The check node read processor, e.g., extractor, 316 generates the complete C2V messages from the fully updated state stored in check node state memory 314 and the stored sign values which were stored in memory 312, one sign value 313, 315 being stored for each received V2C message.<!-- EPO <DP n="17"> --></p><p id="p0061" num="0061">Thus, to "read" a C2V message requires additional processing, as compared implementations where messages are not stored in a compressed format, in order to perform the decompression that would not be required if the compressed storage format was not used. Stored incoming message sign values 313, 315 are read directly from sign memory. Each sign value read from memory 312 is XORED with fully updated sum S corresponding to a check node to get the outgoing sign corresponding to a message edge associated with an outgoing C2V message. Thus, the outgoing sign for a message edge is generated from the message sign received on the message edge and the accumulated sign value S corresponding to the XOR of the full set of messages corresponding to the check node to which the message edge is attached in the LDPC graph. The reliability, e.g., message magnitude portion is extracted from the minimum, second minim and message index values included in the stored state for the check node. If the index of the edge being read matches A, then reliability m<sub>A</sub> is output, otherwise reliability m<sub>B</sub> is output. There are many possibilities for representing the index A which servers as a message edge identifier. While a simple edge number is one possible way of representing index A, other numbering schemes and/or edge indexing methods may be used as well.</p><p id="p0062" num="0062">The message magnitude generated by the message extractor 316 is output on magnitude output 318 while the outgoing message sign is output on output 320 which are combined to form the complete message output via output 322.</p><p id="p0063" num="0063">Having described the inventive check node processing module 300 of the present invention with regard to <figref idrefs="f0003">Fig. 3</figref>, the module's use in an exemplary LDPC decoder implement in accordance with the invention will now be described with reference to <figref idrefs="f0004">Fig. 4</figref>.</p><p id="p0064" num="0064"><figref idrefs="f0004">Fig. 4</figref> shows an exemplary LPDC decoder 400 implemented using the check node processing module 300 shown in <figref idrefs="f0003">Fig. 3</figref>. The decoder 400 performs both variable node processing and check node processing in variable node edge order. The decoder 400 includes, in addition to the check node processing module 300, a decoder control module 402, a variable node processing element 404, a soft input buffer 406, a soft/hard output buffer 412, a constraint check module 408 and an iteration control logic circuit 410.</p><p id="p0065" num="0065">Input values to be decoded are supplied to the soft input buffer 406 prior to loading in to the variable node processing element 404. Decoder control module 402 is responsible for<!-- EPO <DP n="18"> --> generating decoder control signals in accordance with stored decoding control information corresponding to an LDPC graph structure to be used in controlling decoding operations. The decoder control module generates the control signals used to control check node processing module operation discussed above in regard to <figref idrefs="f0003">Fig. 3</figref> as well as variable node processing element operation. Under the control of the decoder control module, the variable node processing element is sequentially loaded with portions the input data to be processed, e.g., a received message value including magnitude information and a sign bit. During the initial iteration, there are no existing constraint messages to be processed by the variable node PE 404 and V2C messages are generated by processing the input data. V2C messages are generated and output from the input data in variable node message edge order. The generated V2C messages including a magnitude and sign value are supplied to the V2C input 302 of the check node processing module 300. The messages are also supplied to constraint check module 408 while the soft/hard output ping pong buffer receives the sign bit associated with each generated V2C message. Constraint check module 408 checks to determine if the received message sign values corresponding to one iteration of the decoder graph, satisfy a predetermined decoding constraint, e.g., a parity check. If, at the end of a message passing iteration wherein one full set of V2C and C2V messages have been generated, the constraint check module 408 determines where or not the parity check is satisfied. Module 408 generates a decoding complete signal if it detects that the current message passing decoding iteration has resulted in successful decoding or, if decoding has not been determined to be successful, generates an iteration complete signal. The signal generated by the constraint check module 408 is supplied to the iteration control logic 410. At the end of each iteration, the stored sign values corresponding to the edges of the graph can be output from output buffer 412 as soft decisions assuming the constraint check has not been satisfied or as hard decisions in the event the constraint check has been satisfied.</p><p id="p0066" num="0066">Iteration control logic 410 will signal unsuccessful decoding, as a timeout signal, after a preselected number of message passing iterations which have not resulted in the parity check signal being satisfied, or signal successful decoding if the parity check is satisfied prior to the timeout. Thus, control logic 410 includes a timeout function which will terminate decoding I the event decoding is not successfully completed within a preselected number of decoding iterations.<!-- EPO <DP n="19"> --></p><p id="p0067" num="0067">The LDPC decoder 400 performs both variable and check node processing operations in variable node edge order thereby reducing or eliminating the need for message storage between the variable node and check node processing elements 308, 404 as compared to other systems where check node processing is performed in check node edge order and variable node processing is performed in variable node edge order. Furthermore, as will be discussed below, by careful selection of LDPC graph structure, there can be an overlap in processing of each iteration of an LDPC graph structure without the need for providing a full set of duplicate constraint node state memory entries 321, 323.</p><p id="p0068" num="0068">A decoding iteration using the decoder 400 may proceed as follows. Variable nodes are updated one at a time. Messages are read from check node output state memory and sign memory and outgoing check node messages are produced. These messages are summed at the variable nodes and subsequently subtracted from the sum, following standard variable node processing. As the outgoing messages are produced they are sent directly to the check node processor, which also retrieves the corresponding partial state from memory. The state is updated and returned to partial state memory. If the V2C message is the last one for that constraint in the current iteration, then the state may be written to output state memory and the partial state memory is reset.</p><p id="p0069" num="0069">The check node processing module 300 of the present invention and general LDPC decoder system shown in <figref idrefs="f0004">Fig. 4</figref> can be easily adapted in accordance with the present invention to support the use of multiple constraint node and variable node processing elements which are arranged and work in parallel. In <figref idrefs="f0005">Fig. 5</figref>, the decoder 500 operates using N constraint node, constraint state extraction circuits, and variable node processing elements in parallel. In <figref idrefs="f0005">Fig. 5</figref>, constraint check module 308', iteration control logic 310', and buffers 312' and 306' operate in the same or similar manner to the similarly numbered elements described in regard to <figref idrefs="f0004">Fig. 4</figref>. Other elements in check node processing module 300' also work in the same or similar manner as described with like numbered elements of <figref idrefs="f0004">Fig. 4</figref> which do not include the '. However, in the <figref idrefs="f0005">Fig. 5</figref> embodiment, element 308' includes N constraint processors 308 arranged in parallel while constraint node state memory 324 is also designed to work with N times as many sets of check node state while constraint state extraction module 316' include N message extraction circuits. Note that memory 310' while supporting accessing of N sets of state information at a time does not have to include any additional state entries as compared to the <figref idrefs="f0004">Fig. 4</figref> embodiment since the<!-- EPO <DP n="20"> --> number of state entries is determined by the number of check nodes in a graph and not how many nodes are implemented in parallel.</p><p id="p0070" num="0070">The <figref idrefs="f0005">Fig. 5</figref> embodiment includes a decoder control module 502 designed to support N wide decoding operations based on use of a small graph description and control information on how to modify the small graph to generate a larger graph intended to control decoding. The modifications to the small graph may be embodied as reordering, e.g., rotations, of messages being passed between variable and check node processing elements where sets of N messages are passed in parallel. In particular, in the <figref idrefs="f0005">Fig. 5</figref> embodiment, switches 530, 526, 528 are used to control reordering of messages as they are passed between various elements of the decoder 500. The reordering is a function of graph description information stored in control logic 518 and rotation signals generated by permutation map 522, as a function of a column counter 520 driven by control logic 518. Rotation control signals used to control reordering of messages supplied to the check node processing module 300' are generated by delaying by use of delay line 524, some of rotation signals used to control variable the reordering of messages supplied to the input of variable pressing elements 504.</p><p id="p0071" num="0071">Having described a check node processor module 300 and various LDPC decoders 400 and 500 implemented in accordance with the present invention, various features regarding graph design, LDPC code structure and decoding implementations using particular graph structures in decoders implementing the present invention will now be discussed.</p><p id="p0072" num="0072">When implementing a decoder such as depicted in <figref idrefs="f0005">Figs 5</figref> for high speed applications, the small graph which is described by the stored graph description information which is sometimes referred to as a projected graph will typically be quite small, i.e., it will have a small number of variable nodes. As depicted the architecture performs one projected edge update per clock cycle which corresponds to processing N messages during each clock cycle. If decoding of a complete graph iteration must finish before the next can begin, delays will be introduced into the decoding system. This can induce an inefficiency in the case of long pipeline delay, e.g., in the case of large graphs. The pipeline delay is the additional clock cycles needed to complete the decoding operations on each of the edges after each edge has initiated processing. If the pipeline delay is large relative to the projected graph size then this additional delay can significantly slow down the decoder.<!-- EPO <DP n="21"> --></p><p id="p0073" num="0073">By judicious graph design, however, one can ameliorate the delay problem whether it occurs in the decoder 400 or the parallel decoder 500.</p><p id="p0074" num="0074">Suppose the set of projected variable nodes V can be partitioned into multiple sets, e.g., at least sets SV1 and SV2 where SV1 precedes SV2 and the set of projected check nodes C can be partitioned into at least two sets SC1 and SC2 so that check nodes in SC1 connect by edges in the graph only to variable nodes in SV1. Then, if the processing is performed in variable node order, messages corresponding to variable node V1 will be processed first, followed by messages corresponding to variable node V2, followed by messages from variable node V3 and so on. In such a case, processing of messages corresponding to the first set of check nodes SC1 will have been completed by the time the last message corresponding to the last variable node in SV1 has been processed or before if the last check node in SC1 does not connect to the last edge of last variable node in SV2. The resulting fully completed state corresponding to check nodes in set SC1 can be stored in the check node state memory for use in generating V2C messages while processing on V2C messages from variable node V1 for the next graph iteration begins. Thus, the next iteration of graph processing can begin while the constraint node processing module 300 is still processing V2C messages corresponding to the uncompleted iteration of graph processing.</p><p id="p0075" num="0075">This is because when processing of messages from the set of variable nodes SV1 begins in iteration n+1, constraints in C1 have already been fully updated in iteration n. Constraining the graph to have this type of partition allows the subsequent iterations to overlap in time and one can effectively reduce and/or eliminate the penalty due to the pipeline delay.</p><p id="p0076" num="0076">An LDPC code and corresponding graph structure 600 with such properties is shown in <figref idrefs="f0006">Fig. 6</figref>. In <figref idrefs="f0006">Fig. 6</figref>, the graph includes 8 check nodes 602 identified as C<sub>1</sub> through C<sub>8</sub> and 16 variable nodes 604 identified as V<sub>1</sub> through V<sub>16</sub>. Note that by the time the messages from variable nodes V<sub>1</sub> through V<sub>12</sub> included in variable node set SV1 are processed by the constraint node processor module 300, the state corresponding to the first 4 constraint nodes C<sub>1</sub> through C<sub>4</sub> will have been fully updated. This fully updated state can be transferred to constraint node buffer memory 314 freeing up the constraint node entries corresponding to constraint nodes C<sub>1</sub> through C<sub>4</sub> to be used in the next iteration of graph processing. Thus, as processing in regard to<!-- EPO <DP n="22"> --> constraint nodes in set SC2, i.e., constraint nodes C5, C6, C7 and C8 continues for one iteration, the C2V messages for that iteration corresponding to nodes in set SC1 will be generated while, at the same time constraint node processing for the next iteration can begin overlapping the ongoing processing associated with the current iteration.</p><p id="p0077" num="0077">The LDPC decoder methods and apparatus of the present invention are particularly well-suited for high rate codes where the number of check nodes is often substantially smaller than the number of edges in the graph. In such a case the state memory used in accordance with the invention will tend to be substantially smaller than the edge memory that would otherwise be required if complete messages were stored for constraint node processing purposes.</p><p id="p0078" num="0078"><figref idrefs="f0007">Fig. 7</figref> illustrates a relatively simple graph which will be used to explain decoder processing, e.g., processing which occurs when the decoder 400 of <figref idrefs="f0004">Fig. 4</figref> is used to decode an exemplary set of input data having the message values 0, -1, 5 and 4 which are loaded into the variable nodes during the first processing iteration of the graph.</p><p id="p0079" num="0079">In <figref idrefs="f0007">Fig. 7</figref>, the graph 700 includes a total of three check nodes 702 and four variable nodes 706 coupled together by 9 edges number in variable node order from 0 to 8. Note that if the edges were numbered from the check node side the edges would have a different numbering sequence since they appear at the check nodes in a different order than at the variable nodes. Messages are passed back and fourth between the variable nodes 706 and check nodes 702 along the illustrated edges. The check nodes 702 include first through third check nodes 710, 712, 714 while the variable nodes 706 includes first through fourth variable nodes 720, 722, 724, 726.</p><p id="p0080" num="0080">Various resulting values of using the decoder 400 and the code structure shown in <figref idrefs="f0007">Fig. 7</figref> are shown in Fig. 800. Fig. 800 illustrates the results of two full decoder processing iterations which follow the initial iteration used to load the received messages (0, -1, 5 and 4) into the decoder 400 and initially process the messages. A negative is used before the second input value to indicate a negative sign bit, equivalently a 1 bit, associated with the message while no negative sign indicates a positive sign bit, equivalently a 0 bit. Thus, the second message -1 has a negative sign bit while the first, third and fourth input messages have a positive sign bit. At the end of the first processing iteration, the state memory entries corresponding to check nodes<!-- EPO <DP n="23"> --> C1, C2 and C3 will include the values shown at the top of <figref idrefs="f0008">Fig. 8</figref> in the set of state memory entry values 802.</p><p id="p0081" num="0081">An iteration begins with the extraction of V2C messages. In the initial iteration the extracted C2V messages are set to 0. These messages are summed at the variable nodes as part of the current iteration and V2C are generated. These messages are received by a check node processor that updates the check node state associated with the current iteration. The iteration is complete when all check node states have been updated.</p><p id="p0082" num="0082">In the chart below the set of state memory entry values 802, each row corresponds to the processing associated with a different message edge, e.g., with the extraction of a C2V message, the generation of a V2C message to be transmitted along the indicated edge and an update of the check node state associated to the given edge. Each iteration of the graph involves the generation and processing one C2V message per edge of the <figref idrefs="f0007">Fig. 7</figref> graph and the generation and processing of one V2C message for each edge.</p><p id="p0083" num="0083">Generally, columns 810, 812, 816, 818, and 820 illustrate C2V message extraction using the results of processing which occurred in the previous decoder iteration. Column 822 shows the variable node sums which are the sums of all incoming messages to the variable node and the received value associated to the variable node.</p><p id="p0084" num="0084">Column 824 shows the V2C message which will be generated along the corresponding edge in this iteration. It is equal to the variable node sum minus the incoming C2V message. These C2V messages will be received by the constraint node processor and used to update state information as shown in columns 826, 828, 830. Columns 826, 828, 830 show how the check node processor state is updated during a current processing iteration in response to receiving each V2C message shown in Column 824.</p><p id="p0085" num="0085">Information 810 shows the check node state generated during the preceding graph processing iteration read from the constraint node buffer state memory 314 to generate C2V messages. This fully updated state corresponding to each check node which is generated during the previous processing iteration is used to generate the C2V messages that are processed by the variable node processor 304 in the current graph iteration to generate the V2C messages.<!-- EPO <DP n="24"> --> Column 812 illustrates the sign bit corresponding to the V2C message from the previous iteration along an edge which is retrieved from the sign bit memory 312 to construct the C2V message in the current processing iteration which will be the input to the variable node processor which generates the V2C message for the current processing iteration. Column 814 illustrates the updated sign bit generated by the constraint state extracted by XORing the stored sign bit 812 from the previously received V2C message with the stored accumulated sign bit S, generated in the previous iteration and obtained from the state corresponding to the check node (C1, C2 or C3) to which the message edge associated with the C2V message corresponds. Column 816 indicates the result of the check performed by the constraint state extractor to determine if the first minimum m<sub>A</sub> or the second minimum m<sub>B</sub> should be output during the previous processing iteration. The check involves comparing the edge index of the C2V message being generated with the edge index I corresponding to the stored first minimum. Here a "Y" indicates a "yes," meaning the edge index does correspond to the edge that transmitted the minimum magnitude in the previous iteration, and a "N" indicates a "no," meaning the edge index does not correspond to the edge that transmitted the minimum magnitude in the previous iteration. Column 812 illustrates the result of selecting m<sub>A</sub> or m<sub>B</sub> to be used as the magnitude of the outgoing C2V message. Column 820 shows the actual C2V message which will be transmitted on the indicated edge for use by the variable node processor 304 during the current iteration. The variable node processor 304 generates a sum of C2V messages received during a processing iteration. The resulting VNode sum shown in column 822 is then used for generating the V2C message to be supplied to the constraint processor module 300 along a message edge, e.g., for constraint node processing during the current iteration.</p><p id="p0086" num="0086">From the constraint node processing module perspective, the information shown in cols. 810, 812, 814, 816, 818, 820 and 822 represent operations which derive from result computed in a previous graph processing iteration. As discussed above, given careful graph design, there may be some overlap in when these operations occur for one graph processing iteration and when updating of message state for the next iteration of constraint node processing occurs.</p><p id="p0087" num="0087">Col. 824 illustrates the V2C message which will be received and processed during the second and third constraint node processing module iterations corresponding to processing the exemplary input using the graph structure shown in <figref idrefs="f0007">Fig. 7</figref>. Each graph iteration involves processing of nine V2C messages corresponding to the messages passed on the edges E0<!-- EPO <DP n="25"> --> through E8. The processing of messages by the constraint processing module 300 occurs in variable node edge order. At the start of processing, the constraint memory corresponding to the check nodes will have been re-initialized. Assuming no overlap in processing iterations, the state for each of check nodes C1, C2 and C3 will have been re-initialized prior to receipt of the first V2C message corresponding to edge E0. Each of the columns 826, 828, 830 shows the stored state corresponding to one of the check nodes C1, C2, C3, respectively, after it is updated by the received V2C message with each row corresponding to the processing of a different V2C message. State contents updated in response to a particular message, e.g., the message communicated on the edge to which the row corresponds, are shown in bold. X's are used in the columns 826, 828, 830 to show values which have been set to an initial value. These values are "don't care" values since they will not be used in the generated C2V output message.</p><p id="p0088" num="0088">Note that at the end of the second iteration, the fully updated message state C1, C2, C3 will have been updated to the values for C1 (m<sub>A</sub>=0,m<sub>B</sub>=4, I=2, S=0); C2 (m<sub>A</sub>=1,m<sub>B</sub>=3, I=1, S=1); and C3 (m<sub>A</sub>=1,m<sub>B</sub>=3, I=3, S=1). At the end of the third iteration, the fully updated message state C1, C2, C3 will have been updated to the values for C1 (m<sub>A</sub>=1,m<sub>B</sub>=3, I=2, S=0); C2 (m<sub>A</sub>=0,m<sub>B</sub>=3, I=1, S=0); and C3 (m<sub>A</sub>=3,m<sub>B</sub>=3, I=3, S=0).</p><p id="p0089" num="0089">While the state is not shown as being cleared after processing of messages corresponding to a check node has been completed, in embodiments where there is overlap between graph processing iterations, the reset of the state corresponding to a fully updated constraint node would be stored in the constrain node state buffer memory 324 and the state information reset in the constraint state memory. In the example shown in <figref idrefs="f0008">Fig. 8</figref> such resetting is not shown simply to facilitate understanding of the constraint state update sequence and how a complete set of updated state is generated during the processing associated with a complete graph iteration.</p><p id="p0090" num="0090">Given various code structures with which the decoder and decoding methods of the present invention can be used, a great deal of flexibility with regard to the amount of overlap which can occur between processing iterations is possible. To reduce decoding delays overlaps with regard to performing check node processing corresponding to different decoder iterations the code structure can be selected to allow 10%, 20%, 30%, 40% or more overlap in graph processing iterations.<!-- EPO <DP n="26"> --></p><p id="p0091" num="0091">Various exemplary decoding method implementations and exemplary variations will node be described.</p><p id="p0092" num="0092">One particular exemplary method of performing Low Density Parity Check Decoding operations, includes the steps of: storing in a memory message state information corresponding to messages received by a plurality of check nodes; receiving a check node input message directed to one of said plurality of check nodes; selecting, based on the check node to which said received message is directed, one of said plurality of sets of state information to be used in a state update operation; retrieving from said memory the selected set of message state information; and updating the selected set of message state information as a function of said received message. The method further includes the step of writing said updated set of message state information into the memory location from which said message state information was retrieved and repeating said receiving, selecting, retrieving and updating steps sequentially for each of a plurality of messages received in a first sequence corresponding to the order in which edges corresponding to said received messages are attached to variable processing nodes in a graph representing an LDPC code. In some implementations the sequence corresponding to the order in which edges corresponding to said received messages are attached to variable processing nodes in a graph representing said LDPC code is different from a second sequence in which edges corresponding to said received messages are attached to constraint processing nodes in a graph representing said LDPC code. The exemplary method further includes performing a check node to variable node message extraction operation on at least one set of state information corresponding to a check node for which a full set of variable to check node messages have been received wherein the extraction operation is performed multiple times to generate a plurality of check node to variable nodes messages, check node to variable node messages directed to an individual one of said plurality of variable nodes being generated consecutively to produce a sequence of check node to variable node messages directed to said individual one of said plurality of variable nodes.</p><p id="p0093" num="0093">In the exemplary method, fully updated state is generated for each check node prior to the fully updated state being stored in a buffer memory for use in the C2V message extraction process. Fully updated state is state which has been updated by the full set of V2C messages corresponding to the check node to which the state corresponds. Multiple sets of state will be updated during the processing corresponding to a full graph. Multiple decoding iterations<!-- EPO <DP n="27"> --> corresponding to a graph are normally performed with each iteration corresponding to the processing of one full set of messages in the graph used to represent the LDPC code used to control decoding. Check node state can be updated corresponding to different graph processing iterations during the same period of time assuming that the check node state for the subsequent iteration was fully updated already during the previous iteration.</p><p id="p0094" num="0094">Thus, in some implementations, the method includes updating another set of state corresponding to said first check node as part of a second iteration of variable to check node message processing, prior to fully completing said state update of said at least one other check node, e.g., the last check node in the graph, during said first iteration of decoder processing.</p><p id="p0095" num="0095">As part of the decoding method to facilitate overlap of iterations of graph processing, in some embodiments the method further includes buffering said fully updated state corresponding to said first check node; and extracting check node to variable node messages from said buffered fully updated state. The step of extracting check node to variable node messages from said buffered fully updated state includes, in some implementations, generating a plurality of outgoing messages from said fully updated state and stored sign information corresponding to a plurality of variable node to check node messages used to generate said fully updated state.</p><p id="p0096" num="0096">Some exemplary decoding methods include fully completing the state update for a first plurality of check nodes prior to completing state updates corresponding to a second plurality of check nodes, a state update for a check node being fully completed when the state for the check node has been updated once for each one of a plurality of message edges corresponding to said check node. In some embodiments the first and second pluralities of check nodes each include at least 20% of the total number of check nodes in an LDPC graph representing an implemented LDPC code structure being used to control decoding.</p><p id="p0097" num="0097">The state update operation may be performed as part of updating state corresponding to a first set of check nodes. In some implementations the updating of the first set of check nodes is performed during a first period of time using a first set of variable to check node messages, with the method further including: updating state information corresponding to a second set of check nodes during a second period of time, said second set of check nodes including only check nodes which are not included in said first set of check nodes, said second period of time following said<!-- EPO <DP n="28"> --> first period of time. In such implementations check node information may be extracted at different times. In one implementation the method includes extracting check node to variable node messages from the updated state information corresponding to said first set of check nodes during said second period of time. In some implementations which implement this timing feature the first and second periods of time are equal in length. The first and second periods of time may, and often are, separated by a third period of time wherein state corresponding to a third set of check nodes is updated. This is often the case where large graphs including many nodes are used. In some implementations the first and second sets of check nodes each include at least 10% of the check nodes in a graph corresponding to an LDPC code being used to control decoding. In other implementations the first and second sets of check nodes each include at least 20% of the check nodes in a graph corresponding to an LDPC code being used to control decoding. In some implementations the first period of time is less than 40% of the time required to processes N variable to check node messages where N is equal to the total number of message edges in a graph corresponding to an LDPC code being used to control decoding while in other embodiments the first period of time is less than 20% of the time required to processes N variable to check node messages where N is equal to the total number of message edges in a graph corresponding to an LDPC code being used to control decoding.</p><p id="p0098" num="0098">Numerous variations on the above described methods and apparatus are possible while remaining within the scope of the invention. For example while using compressed state about messages, the sign information for C2V messages may be generated in a slightly different manner than described above while still staying within the scope of the invention. An alternative implementation uses a ping-pong structure in which one memory is used for state memory while the other contains complete states from the previous iteration and, at the end of an iteration, the roles of the buffers are reversed. In such embodiment the sign bits would be handled as follows. The signs of V2C messages are stored. In addition to the reliability information the XOR of incoming sign bits is also maintained as part of the state. When the C2V messages are extracted, the stored V2C sign is XORED with the cumulative X-OR in the state to yield the C2V message sign bit. Note that once it is read, the V2C sign bit is no longer needed so the V2C sign bit that will soon be produced by the variable node processor may subsequently overwrite it.<!-- EPO <DP n="29"> --></p><p id="p0099" num="0099">The above-described methods may be implemented in a computer system that includes memory, a CPU and one or more input and/or output devices coupled together. In such an embodiment, the memory includes a routine implemented in accordance with the invention. When executed, the routine causes the CPU to receive, process, e.g., decode, and output data in accordance with the present invention. Alternatively, the steps of the present invention may be implemented using dedicated hardware, e.g., circuits and/or a combination of hardware and software.<!-- EPO <DP n="30"> -->
<ol><li>1. An apparatus for performing Low Density Parity Check (LDPC) decoding operations, comprising:
<ul><li>a check node processor module including:
<ol><li>i) check node state memory including a plurality of message state memory storage elements for a plurality of check nodes, each check node state storage element corresponding to a single check node and including a first and a second location for storing for storing first and second message magnitude values corresponding to messages directed to the check node to which said check node state memory corresponds, each node state storage element further including a sign memory location for storing an accumulated sign value corresponding to the check node to which the check node state storage element corresponds;</li><li>ii) a check node processor element for updating state stored in said check node state memory based on the content of a received variable node to check node state message; and</li><li>iii) a control module coupled to said check node state memory for controlling said check node state memory to output check node state, corresponding to the same check node as a variable to check node message to be processed, said check node state being output from the one of said check node state storage elements which corresponds to the same node as said variable to check node message to be processed.</li></ol></li></ul></li><li>2. The apparatus of 1, further comprising:
<ul><li>a message sign memory for storing the sign bit included in each received message corresponding to a check node for use in generating check node to variable node messages.</li></ul></li><li>3. The apparatus of 2, further comprising:
<ul><li>a check node state buffer memory for storing fully updated check node state information corresponding to at least one check node.</li></ul></li><li>4. The apparatus of 3, wherein fully updated check node state information corresponding to the at least one check node is state information which has been generated from<!-- EPO <DP n="31"> --> each of M variable node to check node messages, where M is the number of edges corresponding to said at least one check node.</li><li>5. The apparatus of 3, further comprising:
<ul><li>a check node to variable node message extractor coupled to said check node state buffer memory and to said message sign memory for generating check node to variable node messages from said fully updated check node state information corresponding to said at least one check node and from stored sign message information corresponding to said at least one check node, one check node to variable node message being generated for each received check node to variable node message that was received corresponding to said at least one check node.</li></ul></li><li>6. The apparatus of 5, wherein said control module controls said check node state memory to store updated state corresponding to a check node in the same message state memory storage element from which state information corresponding to said check node was read.</li><li>7. The apparatus of 1, where said check node state memory includes one check node state memory storage element for each check node included in an LDPC graph structure used to control decoding.</li><li>8. The apparatus of 1, where said check node state memory includes one check node state memory storage element for each check node included in an LDPC graph structure used to control decoding.</li><li>9. The apparatus of 2, where said message sign memory includes one sign bit storage location for each message edge included in an LDPC graph structure used to control decoding.</li><li>10. The apparatus of 9, further comprising:
<ul><li>a variable node processor coupled to said check node processing module, said variable node processor module receiving check node to variable node messages from said check node processing module and generating variable node to check node messages supplied to said check node processing module.</li></ul></li><li>11. The apparatus of 10, further comprising:<!-- EPO <DP n="32"> -->
<ul><li>a decoder control module coupled to said check node processing module and to said variable node processor module, said decoder control module control both said check node processing module and said variable node processor module to process messages in variable node order.</li></ul></li><li>12. The apparatus of 11, wherein said variable node processor includes a plurality of variable node processing elements arranged in parallel.</li><li>13. The apparatus of 12, wherein said check node processor module includes a plurality of check node processing elements arranged in parallel.</li><li>14. The apparatus of 13, wherein there is at least one message reordering element arranged between said variable node processor module and said check node processor module for reordering messages passed in parallel between said variable node processor and said check node processor.</li><li>15. The apparatus of 14, wherein said decoder control module includes control logic for controlling the message reordering element as a function of stored message reordering information.</li><li>16. A method of performing Low Density Parity Check Decoding operations, comprising the steps of:
<ul><li>storing in a memory message state information corresponding to messages received by a plurality of check nodes;</li><li>receiving a check node input message directed to one of said plurality of check nodes;</li><li>selecting, based on the check node to which said received message is directed, one of said plurality of sets of state information to be used in a state update operation;</li><li>retrieving from said memory the selected set of message state information; and</li><li>updating the selected set of message state information as a function of said received message.</li></ul></li><li>17. The method of 16, further comprising:<!-- EPO <DP n="33"> -->
<ul><li>writing said updated set of message state information into the memory location from which said message state information was retrieved.</li></ul></li><li>18. The method of 17, further comprising:
<ul><li>repeating said receiving, selecting, retrieving and updating steps sequentially for each of a plurality of messages received in a first sequence corresponding to the order in which edges corresponding to said received messages are attached to variable processing nodes in a graph representing an LDPC code.</li></ul></li><li>19. The method of 18, wherein said sequence corresponding to the order in which edges corresponding to said received messages are attached to variable processing nodes in a graph representing said LDPC code is different from a second sequence in which edges corresponding to said received messages are attached to constraint processing nodes in a graph representing said LDPC code.</li><li>20. The method of 18, further comprising:
<ul><li>performing a check node to variable node message extraction operation on at least one set of state information corresponding to a check node for which a full set of variable to check node messages have been received.</li></ul></li><li>21. The method of 20, further comprising:
<ul><li>performing said extraction operation to generate a plurality of check node to variable nodes messages, check node to variable node messages directed to an individual one of said plurality of variable nodes being generated consecutively to produce a sequence of check node to variable node messages directed to said individual one of said plurality of variable nodes.</li></ul></li><li>22. The method of 16, further comprising:
<ul><li>fully completing the state update of a first check node to generate a set of fully updated state corresponding to said first check node, prior to completing the state update of at least one other check node, a state update for a check node being fully completed when the state for the check node has been updated once for each one of a plurality of message edges corresponding to said check node.</li></ul><!-- EPO <DP n="34"> --></li><li>23. The method of 16, further comprising:
<ul><li>updating another set of state corresponding to said first check node as part of a second iteration of variable to check node message processing, prior to fully completing said state update of said at least one other check node.</li></ul></li><li>24. The method of 23, further comprising the step of:
<ul><li>buffering said fully updated state corresponding to said first check node; and</li><li>extracting check node to variable node messages from said buffered fully updated state.</li></ul></li><li>25. The method of 24, wherein said step of extracting check node to variable node messages from said buffered fully updated state includes:
<ul><li>generating a plurality of outgoing messages from said fully updated state and stored sign information corresponding to a plurality of variable node to check node messages used to generate said fully updated state.</li></ul></li><li>26. The method of 16, further comprising:
<ul><li>fully completing the state update for a first plurality of check nodes prior to completing state updates corresponding to a second plurality of check nodes, a state update for a check node being fully completed when the state for the check node has been updated once for each one of a plurality of message edges corresponding to said check node.</li></ul></li><li>27. The method of 26, wherein the first and second pluralities of check nodes each include at least 20% of the total number of check nodes in an LDPC graph representing an implemented LDPC code structure being used to control decoding.</li><li>28. The method of 16, wherein said updating operation is performed as part updating state information corresponding to a first set of check nodes.</li><li>29. The method of 28, wherein said updating of a first set of check nodes is performed during a first period of time using a first set of variable to check node messages, the method further comprising:
<ul><li>updating state information corresponding to a second set of check nodes during a second period of time, said second set of check nodes including only check nodes which are not<!-- EPO <DP n="35"> --> included in said first set of check nodes, said second period of time following said first period of time.</li></ul></li><li>30. The method of 29, further comprising:
<ul><li>extracting check node to variable node messages from the updated state information corresponding to said first set of check nodes during said second period of time.</li></ul></li><li>31. The method of 30, wherein said first and second periods of time are equal in length.</li><li>32. The method of 30, wherein said first and second periods of time are separated during a third period of time wherein state corresponding to a third set of check nodes is updated.</li><li>33. The method of 30, wherein said first and second sets of check nodes each include at least 10% of the check nodes in a graph corresponding to an LDPC code being used to control decoding.</li><li>34. The method of 30, wherein said first and second sets of check nodes each include at least 20% of the check nodes in a graph corresponding to an LDPC code being used to control decoding.</li><li>35. The method of 30, wherein said first period of time is less than 40% of the time required to processes N variable to check node messages where N is equal to the total number of message edges in a graph corresponding to an LDPC code being used to control decoding.</li><li>36. The method of 30, wherein said first period of time is less than 20% of the time required to processes N variable to check node messages where N is equal to the total number of message edges in a graph corresponding to an LDPC code being used to control decoding.</li></ol></p></description><claims mxw-id="PCLM56982357" lang="EN" load-source="patent-office"><!-- EPO <DP n="36"> --><claim id="c-en-0001" num="0001"><claim-text>A method of performing Low Density Parity Check, LDPC, Decoding operations, comprising the steps of:
<claim-text>storing in a memory message a plurality of sets of state information corresponding to variable node to check node, V2C, messages received by a plurality of check nodes, wherein each set of state information includes a first and a second location for storing first and second message magnitude values corresponding to messages directed to one of said plurality of check nodes, and a sign memory location for storing an accumulated sign value corresponding to said one of the plurality of check nodes;</claim-text>
<claim-text>receiving a V2C message directed to one of said plurality of check nodes;</claim-text>
<claim-text>selecting, based on the check node to which said received V2C message is directed, one of said plurality of sets of state information to be used in a state update operation;</claim-text>
<claim-text>retrieving from said memory the selected set of message state information; and</claim-text>
<claim-text>updating the selected set of message state information as a function of said received V2C message</claim-text>
<claim-text>wherein in the step of updating the selected set of message state information said accumulated sign value is updated<u>,</u> wherein said updating operation is performed as part updating state information corresponding to a first set of check nodes, wherein said updating of a first set of check nodes is performed during a first period of time using a first set of V2C messages, the method further comprising:
<claim-text>updating state information corresponding to a second set of check nodes during a second period of time, said second set of check nodes including only check nodes which are not included in said first set of check nodes, said second period of time following said first period of time.</claim-text></claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The method of claim 1, further comprising:
<claim-text>writing said updated set of message state information into the memory location from which said message state information was retrieved, and preferably<!-- EPO <DP n="37"> --></claim-text>
<claim-text>repeating said receiving, selecting, retrieving and updating steps sequentially for each of a plurality of messages received in a first sequence corresponding to the order in which edges corresponding to said received V2C messages are attached to variable nodes in a graph representing an LDPC code.</claim-text></claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The method of claim 2, wherein said sequence corresponding to the order in which edges corresponding to said received V2C messages are attached to variable nodes in a graph representing said LDPC code is different from a second sequence in which edges corresponding to said received V2C messages are attached to check nodes in a graph representing said LDPC code.</claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The method of claim 2, further comprising:
<claim-text>performing a check node to variable node message extraction operation on at least one set of state information corresponding to a check node for which a full set of V2C messages have been received.</claim-text></claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The method of claim 4, further comprising:
<claim-text>performing said extraction operation to generate a plurality of check node to variable nodes, C2V, messages, C2V messages directed to an individual one of said plurality of variable nodes being generated consecutively to produce a sequence of C2V messages directed to said individual one of said plurality of variable nodes.</claim-text></claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The method of claim 1, further comprising:
<claim-text>fully completing the state update of a first check node to generate a set of fully updated states corresponding to said first check node, prior to completing the state update of at least one other check node, a state update for a check node being fully completed when the state for the check node has been updated once for each one of a plurality of message edges corresponding to said check node.</claim-text></claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>The method of claim 1, further comprising:
<claim-text>updating another set of state corresponding to said first check node as part of a second iteration of V2C message processing, prior to fully completing said state update of said at least one other check node.</claim-text><!-- EPO <DP n="38"> --></claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>The method of claim 7, further comprising the step of:
<claim-text>buffering said fully updated state corresponding to said first check node; and</claim-text>
<claim-text>extracting C2V messages from said buffered fully updated state.</claim-text></claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>The method of claim 8, wherein said step of extracting C2V messages from said buffered fully updated state includes:
<claim-text>generating a plurality of outgoing messages from said fully updated state and stored sign information corresponding to a plurality of V2C messages used to generate said fully updated state.</claim-text></claim-text></claim><claim id="c-en-0010" num="0010"><claim-text>The method of claim 1, further comprising:
<claim-text>fully completing the state update for a first plurality of check nodes prior to completing state updates corresponding to a second plurality of check nodes, a state update for a check node being fully completed when the state for the check node has been updated once for each one of a plurality of message edges corresponding to said check node.</claim-text></claim-text></claim><claim id="c-en-0011" num="0011"><claim-text>The method of claim 10, wherein the first and second pluralities of check nodes each include at least 20% of the total number of check nodes in an LDPC graph representing an implemented LDPC code structure being used to control decoding.</claim-text></claim><claim id="c-en-0012" num="0012"><claim-text>The method of claim 1, further comprising:
<claim-text>extracting check node to variable node messages from the updated state information corresponding to said first set of check nodes during said second period of time.</claim-text></claim-text></claim><claim id="c-en-0013" num="0013"><claim-text>The method of claim 12, wherein said first and second periods of time are equal in length and/or wherein said first and second periods of time are separated during a third period of time wherein state corresponding to a third set of check nodes is updated.</claim-text></claim><claim id="c-en-0014" num="0014"><claim-text>The method of claim 12, wherein said first and second sets of check nodes each include at least 10% of the check nodes in a graph corresponding to an<!-- EPO <DP n="39"> --> LDPC code being used to control decoding or wherein said first and second sets of check nodes each include at least 20% of the check nodes in a graph corresponding to an LDPC code being used to control decoding.</claim-text></claim><claim id="c-en-0015" num="0015"><claim-text>The method of claim 12, wherein said first period of time is less than 40% of the time required to processes N V2C messages where N is equal to the total number of message edges in a graph corresponding to an LDPC code being used to control decoding, or wherein said first period of time is less than 20% of the time required to processes N V2C messages where N is equal to the total number of message edges in a graph corresponding to an LDPC code being used to control decoding.</claim-text></claim></claims><drawings mxw-id="PDW16670737" load-source="patent-office"><!-- EPO <DP n="40"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="151" he="121" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="41"> --><figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="102" he="119" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="42"> --><figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="160" he="227" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="43"> --><figure id="f0004" num="4"><img id="if0004" file="imgf0004.tif" wi="165" he="195" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="44"> --><figure id="f0005" num="5"><img id="if0005" file="imgf0005.tif" wi="165" he="191" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="45"> --><figure id="f0006" num="6"><img id="if0006" file="imgf0006.tif" wi="165" he="147" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="46"> --><figure id="f0007" num="7"><img id="if0007" file="imgf0007.tif" wi="165" he="169" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="47"> --><figure id="f0008" num="8"><img id="if0008" file="imgf0008.tif" wi="165" he="233" img-content="drawing" img-format="tif"/></figure></drawings><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
