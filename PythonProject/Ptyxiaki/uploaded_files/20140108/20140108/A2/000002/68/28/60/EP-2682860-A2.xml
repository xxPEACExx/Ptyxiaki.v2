<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2682860-A2" country="EP" doc-number="2682860" kind="A2" date="20140108" family-id="43302037" file-reference-id="287040" date-produced="20180824" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146584892" ucid="EP-2682860-A2"><document-id><country>EP</country><doc-number>2682860</doc-number><kind>A2</kind><date>20140108</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-13187240-A" is-representative="NO"><document-id mxw-id="PAPP154847084" load-source="docdb" format="epo"><country>EP</country><doc-number>13187240</doc-number><kind>A</kind><date>20100729</date><lang>EN</lang></document-id><document-id mxw-id="PAPP168045688" load-source="docdb" format="original"><country>EP</country><doc-number>13187240.0</doc-number><date>20100729</date></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140553884" ucid="EP-10171294-A" linkage-type="3" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>10171294</doc-number><kind>A</kind><date>20100729</date></document-id></priority-claim><priority-claim mxw-id="PPC140555331" ucid="EP-13187240-A" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>13187240</doc-number><kind>A</kind><date>20100729</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL2112533621" load-source="docdb">G06F   7/544       20060101ALI20140829BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL2112541236" load-source="docdb">G06F   7/22        20060101AFI20140829BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL2112542323" load-source="docdb">G06F  17/18        20060101ALI20140829BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL1989634285" load-source="docdb" scheme="CPC">G06F   7/544       20130101 LI20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989637588" load-source="docdb" scheme="CPC">G06F  17/18        20130101 LI20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989642122" load-source="docdb" scheme="CPC">G06F   7/22        20130101 FI20130101BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132359309" lang="DE" load-source="patent-office">Schaltung und Verfahren zur teilweisen Mittelung</invention-title><invention-title mxw-id="PT132359310" lang="EN" load-source="patent-office">Partial averaging circuit and method</invention-title><invention-title mxw-id="PT132359311" lang="FR" load-source="patent-office">Circuit et procédé pour callculer une moyenne partièlle</invention-title><citations><non-patent-citations><nplcit><text>None</text><sources><source mxw-id="PNPL45210621" load-source="docdb" name="APP"/></sources></nplcit></non-patent-citations></citations></technical-data><related-documents><relation type="division"><child-doc ucid="EP-13187240-A"><document-id load-source="patent-office" format="epo"><country>EP</country><doc-number>13187240</doc-number><kind>A</kind><date>20100729</date></document-id></child-doc><parent-doc ucid="EP-10171294.1"><document-id load-source="patent-office" format="epo"><country>EP</country><doc-number>10171294.1</doc-number><date>20100729</date></document-id></parent-doc></relation></related-documents><parties><applicants><applicant mxw-id="PPAR919529082" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>NXP BV</last-name><address><country>NL</country></address></addressbook></applicant><applicant mxw-id="PPAR919514168" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>NXP B.V.</last-name></addressbook></applicant><applicant mxw-id="PPAR919009721" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>NXP B.V.</last-name><iid>101002440</iid><address><street>High Tech Campus 60</street><city>5656 AG Eindhoven</city><country>NL</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR919527963" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>VERMEULEN HUBERTUS GARARDUS HENDRIKUS</last-name><address><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR919518059" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>Vermeulen, Hubertus Garardus Hendrikus</last-name></addressbook></inventor><inventor mxw-id="PPAR919014578" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Vermeulen, Hubertus Garardus Hendrikus</last-name><address><street>c/o NXP B.V., Intellectual Property &amp; Licensing Red Central 60 High Street</street><city>Redhill, Surrey RH1 1SH</city><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR919535046" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>STASCHULAT JAN</last-name><address><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR919512256" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>STASCHULAT, JAN</last-name></addressbook></inventor><inventor mxw-id="PPAR919005990" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>STASCHULAT, JAN</last-name><address><street>c/o NXP B.V., Intellectual Property &amp; Licensing Red Central 60 High Street</street><city>Redhill, Surrey RH1 1SH</city><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR919510920" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>NIEUWLAND ANDRE</last-name><address><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR919520846" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>NIEUWLAND, ANDRE</last-name></addressbook></inventor><inventor mxw-id="PPAR919009259" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>NIEUWLAND, ANDRE</last-name><address><street>c/o NXP B.V., Intellectual Property &amp; Licensing Red Central 60 High Street</street><city>Redhill, Surrey RH1 1SH</city><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR919521024" load-source="docdb" sequence="4" format="epo"><addressbook><last-name>STEFENS ELISABETH</last-name><address><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR919542036" load-source="docdb" sequence="4" format="intermediate"><addressbook><last-name>Stefens, Elisabeth</last-name></addressbook></inventor><inventor mxw-id="PPAR919010910" load-source="patent-office" sequence="4" format="original"><addressbook><last-name>Stefens, Elisabeth</last-name><address><street>c/o NXP B.V., Intellectual Property &amp; Licensing Red Central 60 High Street</street><city>Redhill, Surrey RH1 1SH</city><country>GB</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR919006417" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Jones, Keith William</last-name><iid>101398456</iid><address><street>NXP Semiconductors Intellectual Property &amp; Licensing Red Central 60 High Street</street><city>Redhill, Surrey RH1 1SH</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS549739461" load-source="docdb">AL</country><country mxw-id="DS549812000" load-source="docdb">AT</country><country mxw-id="DS549739462" load-source="docdb">BE</country><country mxw-id="DS549740148" load-source="docdb">BG</country><country mxw-id="DS549907485" load-source="docdb">CH</country><country mxw-id="DS549812810" load-source="docdb">CY</country><country mxw-id="DS549812001" load-source="docdb">CZ</country><country mxw-id="DS549739463" load-source="docdb">DE</country><country mxw-id="DS549812811" load-source="docdb">DK</country><country mxw-id="DS549812812" load-source="docdb">EE</country><country mxw-id="DS549738450" load-source="docdb">ES</country><country mxw-id="DS549740149" load-source="docdb">FI</country><country mxw-id="DS549740150" load-source="docdb">FR</country><country mxw-id="DS549739464" load-source="docdb">GB</country><country mxw-id="DS549812813" load-source="docdb">GR</country><country mxw-id="DS549739465" load-source="docdb">HR</country><country mxw-id="DS549812006" load-source="docdb">HU</country><country mxw-id="DS549907486" load-source="docdb">IE</country><country mxw-id="DS549812818" load-source="docdb">IS</country><country mxw-id="DS549740151" load-source="docdb">IT</country><country mxw-id="DS549812819" load-source="docdb">LI</country><country mxw-id="DS549742137" load-source="docdb">LT</country><country mxw-id="DS549812007" load-source="docdb">LU</country><country mxw-id="DS549742138" load-source="docdb">LV</country><country mxw-id="DS549742139" load-source="docdb">MC</country><country mxw-id="DS549814200" load-source="docdb">MK</country><country mxw-id="DS549814201" load-source="docdb">MT</country><country mxw-id="DS549739466" load-source="docdb">NL</country><country mxw-id="DS549740152" load-source="docdb">NO</country><country mxw-id="DS549742140" load-source="docdb">PL</country><country mxw-id="DS549907487" load-source="docdb">PT</country><country mxw-id="DS549739467" load-source="docdb">RO</country><country mxw-id="DS549742153" load-source="docdb">SE</country><country mxw-id="DS549907488" load-source="docdb">SI</country><country mxw-id="DS549740153" load-source="docdb">SK</country><country mxw-id="DS549742154" load-source="docdb">SM</country><country mxw-id="DS549812820" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA128673064" lang="EN" load-source="patent-office"><p id="pa01" num="0001">The present application relates to a circuit (200) for sorting a set of data values (202), the circuit comprising a first set (220) of p+q registers (220a-c) for storing the p+q largest data values of the set of data values including p statistical outliers; a second set (230) of p+q registers (230a-c) for storing the p+q smallest data values of the set of data values including p statistical outliers, wherein p is a non-negative integer and q is a positive integer; a controller (210) coupled to each register in said first and second sets, said controller being arranged to: receive the set of data values and for each data value obtain a comparison result of the data value with the respective data values in each of said registers; and update said registers as a function of said comparison results; the circuit further comprising a data processing circuit (260) coupled to at least the q registers in said first and second sets, which for instance may be used to produce an average value (204) of the data values stored in said q registers in response to the controller. The present application further relates to a sorting method using such a circuit.
<img id="iaf01" file="imgaf001.tif" wi="78" he="95" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA128737209" lang="EN" source="EPO" load-source="docdb"><p>The present application relates to a circuit (200) for sorting a set of data values (202), the circuit comprising a first set (220) of p+q registers (220a-c) for storing the p+q largest data values of the set of data values including p statistical outliers; a second set (230) of p+q registers (230a-c) for storing the p+q smallest data values of the set of data values including p statistical outliers, wherein p is a non-negative integer and q is a positive integer; a controller (210) coupled to each register in said first and second sets, said controller being arranged to: receive the set of data values and for each data value obtain a comparison result of the data value with the respective data values in each of said registers; and update said registers as a function of said comparison results; the circuit further comprising a data processing circuit (260) coupled to at least the q registers in said first and second sets, which for instance may be used to produce an average value (204) of the data values stored in said q registers in response to the controller. The present application further relates to a sorting method using such a circuit.</p></abstract><description mxw-id="PDES63959052" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001">FIELD OF THE INVENTION</heading><p id="p0001" num="0001">The present invention relates to a circuit for sorting a set of data values.</p><p id="p0002" num="0002">The present invention further relates to a method of sorting a set of data values using such a circuit.</p><heading id="h0002">BACKGROUND OF THE INVENTION</heading><p id="p0003" num="0003">Nowadays, many electronic systems have to be able to cope with large volumes of simultaneously transmitted data in a robust and fault-tolerant manner. Such requirements are for instance of paramount importance in application domains where the correct functioning of a complex system depends on the fault-free operation of the electronic system included in the complex system. Examples of such complex systems include systems that when operating incorrectly may jeopardize the safety of a person operating the system, such as vehicles. For this reason, it has taken a long time for electronic systems being entrusted with managing critical functionality of such complex systems, e.g. fly-by-wire and drive-by-wire being non-limiting examples of such critical functionality.</p><p id="p0004" num="0004">However, the ever-increasing ability of circuitry to implement complex functions has recently seen a shift towards a more receptive attitude towards electronics being entrusted with operations of a wide variety of more or less critical functions in complex systems. For instance, in the automotive industry, continuing efforts are taking place to provide standardized electronic control networks for vehicles, which makes it easier to design additional functionality for such standardized networks, as the communication protocols between the various components of the network are defined in the standard. An example of such an in-car network communication protocol is the FlexRay™ protocol, a description of which can be found on <u>www.flexray.com.</u><!-- EPO <DP n="2"> --></p><p id="p0005" num="0005">One of the major challenges in providing robust and fault-tolerant in-car networks is the fact that the network may comprise a large number of discrete and independent components, which nevertheless may need to communicate with each other in a synchronized manner. To this end, communication cycles may be defined, with the simultaneous initialization of the communication cycles for each of these independent components being a challenging task.</p><p id="p0006" num="0006">In FlexRay™, a multi-master distributed clock synchronization mechanism is applied in which up to 15 master components can send a synchronization message, with each node adjusting their local view of global time based on the reception of these synchronization messages. As some of these messages may however suffer some form of corruption, e.g. an unexpected delay, each node applies a voting mechanism based on the fault-tolerant midpoint algorithm (FTMA). In FTMA, the p highest and p lowest values are discarded, after which an average value is calculated for the set of remaining values from the q highest and q lowest remaining values, with p is a non-negative integer and q is a positive integer. The FTMA may also be used in other applications within or outside FlexRay™ where it is necessary to implement fault-tolerance by means of e.g. majority voting.</p><p id="p0007" num="0007">A practical problem associated with the implementation of the FTMA is that it can be expensive in terms of hardware requirements. As FTMA relies on a sorting algorithm to identify the p+q highest and p+q lowest values, current implementations of the FTMA may rely on the provision of a memory that can store all received values to be sorted, with a microcontroller operating on the set of data stored in the memory to identify the sets of highest and lowest values, and calculate the average value of the set in accordance with the FTMA. For large sets of data, this may require an excessively large memory, which may not be feasible in terms of cost and/or available silicon area. In addition, the sorting must be done in a post-processing step, i.e. after all data values have been received, which may lead to unacceptably long processing times for large data sets, especially if large numbers of data have to be averaged, and/or if the data has large values, i.e. is represented by a large number of bits.<!-- EPO <DP n="3"> --></p><heading id="h0003">SUMMARY OF THE INVENTION</heading><p id="p0008" num="0008">The present invention seeks to provide a circuit for sorting a set of data that is more efficient in terms of area and throughput time.</p><p id="p0009" num="0009">The present invention further seeks to provide a method of sorting data values using such an improved circuit.</p><p id="p0010" num="0010">According to a first aspect of the present invention, there is provided a circuit for sorting a set of data values, the circuit comprising a first set of p+q registers for storing the p+q largest data values of the set of data values including p statistical outliers; a second set of p+q registers for storing the p+q smallest data values, wherein p is a non-negative integer and q is a positive integer; a controller coupled to each register in said first and second sets, said controller being arranged to receive the set of data values and for each data value obtain a comparison result of the data value with the respective data values in each of said registers; and update said registers as a function of said comparison results; the circuit further comprising a data processing circuit coupled to at least the q registers in said first and second sets for processing at least one of the data values stored in each of said registers in response to the controller.</p><p id="p0011" num="0011">The present invention is based on the realization that fault-tolerant sorting algorithms such as FTMA do not require all data values to be stored as typically only a few data values are used for producing the averaged data value. Consequently, by providing two sets of registers, which combined size is typically substantially smaller than the total number of data values in the set of data values to be averaged, an on-the-fly comparison may be made between received data values and data values already stored in the registers such that once the last data value has been received, the sorting result is almost immediately available. Hence, the circuit of the present invention provides a more compact implementation of such a sorting algorithm due to the fact that only a fraction of<!-- EPO <DP n="4"> --> the total number of incoming data values are actually stored, whilst at the same time providing a much improved throughput time due to the fact that the sorting of the data values is done during rather than after receiving the data values. This further yields a significant power saving compared to known implementations of such sorting algorithms.</p><p id="p0012" num="0012">In a preferred embodiment, the controller is adapted to insert a received data value in a register of the first set if said received data value is larger than a data value stored in said register; insert a received data value in a register of the second set if said received data value is smaller than a data value stored in said register; and discard a received data value if said received data is not larger than any of the data values stored in the registers of the first set nor smaller than any of the data values stored in the registers of the second set. To this end, the controller may be arranged to update said registers by instructions selected from an instruction set including a load instruction for overwriting a register data value with a current data value; and a shift instruction for shifting a register data value to a neighboring shift register.</p><p id="p0013" num="0013">The controller may be further arranged to store the highest possible data value in each register in the second set and store the lowest possible data value in each register in the first set upon initialization of the circuit. This ensures that all data values that are subsequently received by the circuit will be placed in the correct position in the registers.</p><p id="p0014" num="0014">In an embodiment, each register comprises a comparator for comparing the data value stored in the register with a data value provided by the controller, and for providing the controller with the comparison result. This for instance makes it possible to perform the comparisons between the received data value and the data values stored in the respective registers of the first and second sets in parallel. Alternatively, the controller may comprise 2(p+q) comparators for facilitating such parallel comparisons.</p><p id="p0015" num="0015">In case not all q data values of each set of registers need to be averaged, the circuit may further comprise a first multiplexer coupled between the first set of registers and the averaging circuit; and a second multiplexer coupled between<!-- EPO <DP n="5"> --> the second set of registers and the averaging circuit, the first and second multiplexers being controlled by a selection signal generated by the controller for selecting the register data values to be averaged by the averaging circuit. This facilitates the selection of a particular one of the q registers in each register set. This is for instance advantageous if it cannot be predicted beforehand how many data values will be received by the circuit, with this number influencing which or how many of the q registers should be selected for averaging.</p><p id="p0016" num="0016">In an embodiment, the controller further comprises a look-up table for generating the selection signal as a function of the number of received data values; and a counter for counting the number of received data values, said look-up table being responsive to said counter. This facilitates a straightforward selection of the appropriate registers for averaging, and has the additional advantage that the look-up table may be (re-)programmed such that the circuit may implement different sorting algorithms having different data selection requirements.</p><p id="p0017" num="0017">The circuit of the present invention may be advantageously included in a communication controller such as a FlexRay™ communication controller.</p><p id="p0018" num="0018">In accordance with a further aspect of the present invention, there is provided a method of sorting a set of data values using the circuit of the present invention, the method comprising repeating the steps of receiving a data value; comparing the data value with the data values in the registers of the first and second sets; and, if necessary, updating the data values in the registers of the first and second sets as a function of said comparisons; until all data values have been received, the method further comprising processing at least one data value stored in the first set of registers and at least one data value stored in the second set of registers; and producing an output signal indicative of said processed value. Hence, this method provides a reduction in processing time before the processed result such as an average result, a summed result, a difference result and so on is produced, for reasons already explained in more detail above</p><p id="p0019" num="0019">Preferably, the method comprises the step of updating the data values in the registers of the first and second sets as a function of said comparisons<!-- EPO <DP n="6"> --> comprises inserting a received data value in a register of the first set if said received data value is larger than a data value stored in said register; inserting a received data value in a register of the second set if said received data value is smaller than a data value stored in said register.</p><p id="p0020" num="0020">In an embodiment, the step of calculating a processed value of at least one data value stored in the first set of registers and at least one data value stored in the second set of registers comprises selecting a first data value from the first set of registers and a second data value from the second set of registers, and calculating the average of the first data value and the second data value.</p><p id="p0021" num="0021">In a further embodiment, the method further comprises counting the number of received data values, and wherein the step of selecting a first data value from the first set of registers and a second data value from the second set of registers is controlled by the counted number of received data values.</p><p id="p0022" num="0022">Preferably, the step of comparing the data value with the data values in the registers of the first and second sets comprises comparing the received data value with each of said data values stored in said registers in parallel. This further improves the sorting speed of the circuit as previously explained.</p><heading id="h0004">BRIEF DESCRIPTION OF THE EMBODIMENTS</heading><p id="p0023" num="0023">Embodiments of the invention are described in more detail and by way of non-limiting examples with reference to the accompanying drawings, wherein
<ul><li><figref idrefs="f0001">FIG. 1</figref> schematically depicts an algorithm for a clock correction value calculation within FlexRay™;</li><li><figref idrefs="f0002">FIG. 2</figref> schematically depicts a sorting circuit for implementing such an algorithm in accordance with a preferred embodiment of the present invention; and</li><li><figref idrefs="f0003">FIG. 3</figref> depicts a flow chart of an embodiment of the method of the present invention.</li></ul></p><heading id="h0005">DETAILED DESCRIPTION OF THE DRAWINGS</heading><!-- EPO <DP n="7"> --><p id="p0024" num="0024">It should be understood that the Figures are merely schematic and are not drawn to scale. It should also be understood that the same reference numerals are used throughout the Figures to indicate the same or similar parts.</p><p id="p0025" num="0025"><figref idrefs="f0001">FIG. 1</figref> schematically depicts a fault-tolerant sorting algorithm that may be implemented by the circuit and method of the present invention. A sorted table 100 stores a number of data values received from one or more sources, including a number of statistical outliers 102 and data values 104 that are considered relevant. After construction of the sorted table 100, selected relevant data values 104 are added in operation 110 after which a mean or average of the combined value of the selected relevant data values 104 is calculated in operation 120. As previously explained the routine implementation of this algorithm is to provide a memory for storing the table 100 and provide a processor that implements a sorting algorithm as well as the operations 110 and 120 which performs a number of post-processing steps on the table 100 to produce the relevant average value from the sorted data. This is costly in terms of hardware due to the fact that all data values have to be stored in table 100 and is time-consuming due to the fact that both the sorting as well as the average calculation can only be performed once all data values have been stored in table 100. In addition, this routine implementation consumes more power than the embodiments of the present invention described in more detail below.</p><p id="p0026" num="0026">In sorting algorithms such as FTMA, the number of statistical outliers is typically determined based on the total number of data values in the set of data values to be processed by the algorithm. For instance, the implementation of FTMA in FlexRay™ for the purpose of clock value correction uses the following relationship between the total number of data values in the set of data values and the number of statistical outliers to be discarded (Table I):
<tables id="tabl0001" num="0001"><table frame="all"><title>Table I</title><tgroup cols="2"><colspec colnum="1" colname="col1" colwidth="43mm"/><colspec colnum="2" colname="col2" colwidth="64mm"/><thead><row><entry valign="top"># of data values in a data set</entry><entry valign="top"># of statistical outliers to be discarded (=2p)</entry></row></thead><tbody><row><entry>1-2</entry><entry>0</entry></row><!-- EPO <DP n="8"> --><row><entry>3-7</entry><entry>2</entry></row><row><entry>&gt;7</entry><entry>4</entry></row></tbody></tgroup></table></tables></p><p id="p0027" num="0027">The number of statistical outliers to be discarded typically is an even number as for each high value statistical outlier to be discarded, a low value statistical outlier is also discarded, as for instance is apparent from <figref idrefs="f0001">FIG. 1</figref>. In the context of the present invention, a statistical outlier is a data value at the extremes of a sorted set of data values, which is to be removed to improve the statistical relevance of an average or mean taken over the data values in the set of data.</p><p id="p0028" num="0028">The list 100 can be divided in two halves, an upper half and a lower half, from which the same number of statistical outliers is to be removed based on a predetermined metric, which may be the total number of received data values or any other suitable metric. The number of statistical outliers to be removed from each half may be defined as p, in which p is a non-negative integer, i.e. p≥0.</p><p id="p0029" num="0029">After removal of the statistical outliers from the sorted data set, the algorithm typically processes the q data values from each half, for instance calculates an average value of the remaining data values, as previously mentioned. This average may be calculated explicitly, i.e. by summing all N remaining values and calculating the average by dividing the sum by N, N being a positive integer.</p><p id="p0030" num="0030">Alternatively, the algorithm may select a number of extreme values, i.e. the q highest values and the q lowest values from the remaining data set, with q being a positive integer, i.e. q≥1 and calculate an average or mean over the selected 2q values. This approach generally works well for data sets that exhibit a relatively homogenous spread of data values. In practice, most data sets processed in application domains such as FlexRay™ networks exhibit such homogeneous spreads as these spreads are typically caused by delay variations over the network utilizing the FlexRay™ protocol. It will be apparent that most electronic application domains are suitable for such a truncated averaging approach, as most electronic application domains typically exhibit homogenous<!-- EPO <DP n="9"> --> spreads in data sets having data values that for instance vary in value because of local variations in the electronic circuit.</p><p id="p0031" num="0031">The present invention is based on the insight that in case of such data sets with homogeneous spreads, each half of the table 100 only contains p+q relevant data values. All other data values will not be considered in the averaging step, such that large numbers of data values do not have to be stored but may be immediately discarded.</p><p id="p0032" num="0032">A circuit in which these insights have been utilized is shown in <figref idrefs="f0002">FIG.2</figref>. The circuit 200 comprises a controller 210 adapted to receive a stream of input values 202. The controller 210 is coupled to a first set 220 of registers 220a-c, in which the p+q values of the upper half of the table 100 are to be stored, and is furthermore coupled to a second set 230 of registers 230a-230c, in which the p+q values of the upper half of the table 100 are to be stored. Three registers are shown in each set by way of non-limiting example only. It should be appreciated that the sets 220, 230 may comprise any suitable number of registers. The register sets 220, 230 are coupled to an averaging circuit 260 for producing an average value 204 from the q relevant values stored in each set 220, 230. The averaging circuit 260 typically comprises an adder and a divider, implemented in any suitable way, for generating the average value 204.</p><p id="p0033" num="0033">In case it is <i>a priori</i> unknown how many data values will be received, the number of registers for storing the p statistical outliers may be chosen on the basis of a worst case scenario, i.e. the largest number of statistical outliers that may have to be discarded. As can be seen in Table I, a metric is typically available for the algorithm to be implemented to determine the number of statistical outliers for a data set of a given size. The number p may be simply derived from such a metric. Similarly, the number of additional registers for storing the q relevant data values may be based on the number of relevant values typically taken into consideration by the algorithm to be implemented.</p><p id="p0034" num="0034">As the number of registers in each set 220, 230 may be based on a worst case scenario, it may be necessary to dynamically determine the actual value of in particular p, i.e. the number of statistical outliers in the first set 220 and the<!-- EPO <DP n="10"> --> second set 230. To this end, the circuit 200 may comprise a counter 212 and a look-up table 214, with the look-up table controlling a first multiplexer 240 placed between the first set 220 of registers 220a-c and the averaging circuit 260 and for controlling a second multiplexer 250 placed between the second set 230 of registers 230a-c and the averaging circuit 260. The counter 212 is adapted to count the number of data values received by the controller 210 whereas the look-up table 214 may be programmed with the metric to dynamically determine the number of statistical outliers 102 to be discarded from each of the sets 220, 230. For instance, the look-up table 214 may implement Table I as shown above. It should however be appreciated that the counter 212, look-up table 214 and multiplexers 240, 250 may be omitted in case the numbers p and q, i.e. which registers will contain the statistical outliers 102, can be predefined.</p><p id="p0035" num="0035">The operation of the circuit 200 will now be explained in more detail with the aid of <figref idrefs="f0003">FIG. 3</figref>, which depicts an embodiment of the method of the present invention. The method starts in step 310, after which the method moves to step 320 in which the registers 220a-c and 230a-c are initialized. This is typically done by storing the lowest possible value of an n-bit data element to be received by the controller 210 in the registers 220a-c, and the highest possible value of the n-bit data element in the registers 230a-c. Alternatively, in case the user of the circuit 200 has some <i>a priori</i> knowledge of the outer limits of the range of data values 202 to be received, the lower limit value may be stored in the registers 220a-c and the upper limit value may be stored in the registers 230a-c. The initialization step may further optionally comprise resetting the counter 212 and loading the correct data into the look-up table 214.</p><p id="p0036" num="0036">Upon initialization, the method proceeds to the sorting of the data, as indicated by step 330 in which the controller 210 receives an input data value 202. As indicated in step 335, the controller 210 compares the received data input with the values stored in each of the registers 220a-c and registers 230a-c. To this end, each register may comprise a comparator (not shown), with the controller 210 forwarding the received data value to each register, which returns a comparison result to the controller 210. Typically, as registers 220a-c are<!-- EPO <DP n="11"> --> intended to store the p+q largest data values in the data set received by the controller 210, the comparators in the set 220 will provide an indication of whether or not the input data value 202 is larger than the data value stored in the corresponding register 220a-c. Similarly, as registers 230a-c are intended to store the p+q smallest data values in the data set received by the controller 210, the comparators in the set 230 will provide an indication of whether or not the input data value 202 is smaller than the data value stored in the corresponding register 230a-c. Alternatively, the comparators may be integrated in the controller 210, in which case the controller 210 will request the registers 220a-c and registers 230a-c to provide a copy of the data value stored in these registers such that the controller 210 can generate the comparison results internally. The comparison results are preferably generated in parallel as this gives the largest performance gain.</p><p id="p0037" num="0037">If at least one of the comparison results is positive, i.e. the data value received in step 330 is larger than a data value stored in one of the registers 220a-c and/or is smaller than the data value stored in one of the registers 230a-c, the method will proceed to step 340, in which the input data value 202 will be inserted by the controller 210 into the register for which the positive comparison result was obtained using appropriate load and shift instructions, as will become apparent from the following example.
<tables id="tabl0002" num="0002"><table frame="all"><title>Table II</title><tgroup cols="2"><colspec colnum="1" colname="col1" colwidth="17mm"/><colspec colnum="2" colname="col2" colwidth="22mm"/><thead><row><entry valign="top">Register</entry><entry valign="top">Data Value</entry></row></thead><tbody><row><entry>220a</entry><entry>15</entry></row><row><entry>220b</entry><entry>11</entry></row><row><entry>220c</entry><entry>9</entry></row><row><entry>230c</entry><entry>5</entry></row><row><entry>230b</entry><entry>3</entry></row><row><entry>230a</entry><entry>2</entry></row></tbody></tgroup></table></tables><!-- EPO <DP n="12"> --></p><heading id="h0006">Example I.</heading><p id="p0038" num="0038">Controller 210 has received a data element 202 with value 13. The state of register sets 220 and 230 is as shown in Table II. The comparators associated with registers 220b and 220c provide a positive comparison result in step 335, as the value of data element 202 is larger than the data values stored in these registers. All other comparison results are negative as the value of data element 202 is smaller than the value stored in register 220a and larger than any of the values stored in registers 230a-c. The controller 210 subsequently will issue a shift instruction for register 220b to shift its current data value downwards to register 220c, thereby overwriting the data value in register 220c with the data value from 220b, followed by a load instruction for register 220b in which the data value in register 220b is overwritten with the value of the data element 202 received by the controller 210. Alternatively, said shift instruction and said load instruction may be issued in parallel. The resulting state of the registers after the completion of step 340 is shown in Table III:
<tables id="tabl0003" num="0003"><table frame="all"><title>Table III:</title><tgroup cols="2"><colspec colnum="1" colname="col1" colwidth="17mm"/><colspec colnum="2" colname="col2" colwidth="22mm"/><thead><row><entry valign="top">Register</entry><entry valign="top">Data Value</entry></row></thead><tbody><row><entry>220a</entry><entry>15</entry></row><row><entry>220b</entry><entry>13</entry></row><row><entry>220c</entry><entry>11</entry></row><row><entry>230c</entry><entry>5</entry></row><row><entry>230b</entry><entry>3</entry></row><row><entry>230a</entry><entry>2</entry></row></tbody></tgroup></table></tables></p><heading id="h0007">Example 2.</heading><p id="p0039" num="0039">Controller 210 has received a data element 202 with value 1. The state of register sets 220 and 230 is again as shown in Table II. The comparators associated with registers 230a-c all provide a positive comparison result in step 335, as the value of data element 202 is smaller than the data values stored in<!-- EPO <DP n="13"> --> these registers. All other comparison results are negative as the value of data element 202 is smaller than the values stored in registers 220a-c. The controller 210 subsequently will issue a shift instruction for registers 230a and 230b to shift their current data value upwards to registers 230b and 230c respectively, thereby overwriting the data value in registers 230b and 230c with the data value from registers 230a and 230b respectively, followed by a load instruction for register 230a in which the data value in register 230a is overwritten with the value of the data element 202 received by the controller 210. Alternatively, said shift instruction and said load instruction may be issued in parallel. The resulting state of the registers after the completion of step 340 is shown in Table IV:
<tables id="tabl0004" num="0004"><table frame="all"><title>Table IV</title><tgroup cols="2"><colspec colnum="1" colname="col1" colwidth="18mm"/><colspec colnum="2" colname="col2" colwidth="23mm"/><thead><row><entry valign="top">Register</entry><entry valign="top">Data Value</entry></row></thead><tbody><row><entry>220a</entry><entry>15</entry></row><row><entry>220b</entry><entry>11</entry></row><row><entry>220c</entry><entry>9</entry></row><row><entry>230c</entry><entry>3</entry></row><row><entry>230b</entry><entry>2</entry></row><row><entry>230a</entry><entry>1</entry></row></tbody></tgroup></table></tables></p><p id="p0040" num="0040">As will be apparent from the above examples, the controller 210 ensures that the register set 220 stores the p+q largest data values received by the controller 210 in an ordered fashion, and similarly ensures that register set 230 stores the p+q smallest data values received by the controller 210 in an ordered fashion by applying load and shift instructions to the registers as demonstrated in the above examples.</p><p id="p0041" num="0041">If on the other hand none of the comparison results generated in step 335 is positive, the data value 202 received by the controller 210 will be discarded in step 350, as it can be concluded that the received data value is an intermediate value, i.e. p+q larger and p+q smaller data values have already been previously<!-- EPO <DP n="14"> --> received by the circuit 200, that will not be used for calculating the average or mean value of the data set received by the circuit 200.</p><p id="p0042" num="0042">In step 355 it is determined if the circuit 200 is to receive another input data value 202. This may for instance be done by simply counting the number of already received data values in case of a known number of data values to be expected, in which a comparison of the counted value against this known number can determine whether or not all values have been received, or by waiting for a predetermined amount of time, e.g. a time-out period, with the controller 200 progressing to the averaging step if no further data value is to be received during this waiting period. Other suitable implementations of step 355 will be immediately apparent to the skilled person.</p><p id="p0043" num="0043">In an alternative embodiment, the average data value is produced by the averaging circuit 260 after every clock cycle. In another embodiment, the average data value is produced by the averaging circuit 260 on demand only. In these embodiments, step 355 may be omitted from the method 300, with the method returning to step 330 following completion of step 340 or step 350. The method 300 may be terminated in this instance e.g. by user intervention.</p><p id="p0044" num="0044">If a further data value is to be received by the circuit 200, the method 300 reverts back to step 330. Otherwise, if all input data values have been received by the circuit 200, the method proceeds to step 360 in which the average of the q relevant data values in register set 220 and register set 230 is calculated. As previously explained, it may be necessary at this stage to determine which of the registers contain statistical outliers and which of the registers contain the relevant data values, in case it is not <i>a priori</i> known how many statistical outliers the registers contain. The number of statistical outliers may be determined by providing the count value of the counter 212 to the look-up table 214, which determines the correct number of statistical outliers based on the values stored in its table, e.g. the statistical outlier selection criteria as shown in Table I above, and uses the determined number of statistical outliers to configure the multiplexers 240 and 250 accordingly. Upon processing the selected data values in step 360, e.g. producing an average of said data values, and producing an<!-- EPO <DP n="15"> --> output signal 204 indicative of the processed result, the method 300 may terminate in step 370.</p><p id="p0045" num="0045">In a preferred embodiment, the circuit implements FTMA, with q selected as equal to 1, although it should be appreciated that embodiments in which other sorting algorithms and/or other values of q are implemented are also feasible.</p><p id="p0046" num="0046">Synthesis experiments have demonstrated that the circuit 200 can be successfully implemented in CMOS technology suitable for implementation in automotive application domains and successfully operated with sufficient parallelism at clock speeds of at least 80 MHz. The circuit 200 can be successfully included in a FlexRay™ active star device, which is a communication controller in a network operating the FlexRay™ protocol that is responsible for transferring data streams on one branch to all other branches. As active stars typically operate at operation speeds of 10Mbps, it will be clear that the circuit 200 is suitable for implementing the FTMA of such active stars given its ability to implement sufficient parallelism at 80 MHz digital clock speeds.</p><p id="p0047" num="0047">It should be noted that the above-mentioned embodiments illustrate rather than limit the invention, and that those skilled in the art will be able to design many alternative embodiments without departing from the scope of the appended claims. In the claims, any reference signs placed between parentheses shall not be construed as limiting the claim. The word "comprising" does not exclude the presence of elements or steps other than those listed in a claim. The word "a" or "an" preceding an element does not exclude the presence of a plurality of such elements. The invention can be implemented by means of hardware comprising several distinct elements. In the device claim enumerating several means, several of these means can be embodied by one and the same item of hardware. The mere fact that certain measures are recited in mutually different dependent claims does not indicate that a combination of these measures cannot be used to advantage.</p></description><claims mxw-id="PCLM56982075" lang="EN" load-source="patent-office"><!-- EPO <DP n="16"> --><claim id="c-en-0001" num="0001"><claim-text>A circuit (200) for producing an average value of a set of homogeneously spread data values (202), the circuit comprising:
<claim-text>a first set (220) of p+q registers (220a-c) for storing the p+q largest data values of the set of data values including p statistical outliers;</claim-text>
<claim-text>a second set (230) of p+q registers (230a-c) for storing the p+q smallest data values of the set of data values including p statistical outliers, wherein p is a non-negative integer and q is a positive integer, and wherein the data set comprises in excess of 2(p+q) data values;</claim-text>
<claim-text>a controller (210) coupled to each register in said first and second sets, said controller being arranged to:
<claim-text>- receive the set of data values and for each data value obtain a comparison result of the data value with the respective data values in each of said registers;</claim-text>
<claim-text>- insert the received data value (202) in a register (220a-c) of the first set (220) if said received data value is larger than a data value stored in said register;</claim-text></claim-text>
<claim-text>insert the received data value in a register (230a-c) of the second set (230) if said received data value is smaller than a data value stored in said register; and</claim-text>
<claim-text>discard the received data value if said received data value is not larger than any of the data values stored in the registers of the first set nor smaller than any of the data values stored in the registers of the second set;</claim-text>
<claim-text>the circuit further comprising an averaging circuit (260) coupled to at least the q registers in said first and second sets for averaging at least one of the data values from each of said q registers in response to the controller.</claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The circuit (200) of claim 1, wherein the controller (210) is further arranged to store the highest possible data value in each register (230a-c) of the second<!-- EPO <DP n="17"> --> set (230) and store the lowest possible data value in each register (220a-c) of the first set (220) upon initialization of the circuit.</claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The circuit (200) of claim 1 or 2, wherein each register (220a-c; 230a-c) comprises a comparator for comparing the data value stored in the register with a data value (202) provided by the controller (210), and for providing the controller with the comparison result.</claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The circuit (200) of claim 3, wherein the controller (210) is arranged to update said registers (220a-c; 230a-c) by instructions selected from an instruction set including:
<claim-text>- a load instruction for overwriting a register data value with a current data value; and</claim-text>
<claim-text>- a shift instruction for shifting a register data value to a neighboring register.</claim-text></claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The circuit (200) of any of the preceding claims, further comprising:
<claim-text>a first multiplexer (240) coupled between the first set (220) of registers (220a-c) and the averaging circuit (260); and</claim-text>
<claim-text>a second multiplexer (250) coupled between the second set (230) of registers (230a-c) and the averaging circuit, the first and second multiplexers being controlled by a selection signal generated by the controller (210) for selecting the register data values to be averaged by the averaging circuit.</claim-text></claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The circuit (200) of claim 5, wherein the circuit further comprises:
<claim-text>a look-up table (214) for generating the selection signal as a function of the number of received data values; and</claim-text>
<claim-text>a counter (212) for counting the number of received data values, said look-up table being responsive to said counter.</claim-text><!-- EPO <DP n="18"> --></claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>The circuit (200) of any of the preceding claims, wherein the circuit is adapted to perform the comparisons between the received data value (202) and the data values stored in the respective registers (220a-c; 230a-c) of the first and second sets (220; 230) in parallel.</claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>A communication controller comprising the circuit (200) of any of claims 1-7.</claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>The communication controller of claim 8, wherein the communication controller is a FlexRay™ communication controller.</claim-text></claim><claim id="c-en-0010" num="0010"><claim-text>A method (300) of producing an average value of a set of homogeneously spread data values (202) using the circuit (200) of claim 1, the method comprising repeating the steps of:
<claim-text>- receiving (330) a data value;</claim-text>
<claim-text>- comparing (335) the data value with the data values in the registers of the first and second sets; and
<claim-text>- inserting the received data value in a register of the first set if said received data value falls within a predetermined spread and is higher than a data value stored in said register;</claim-text>
<claim-text>- inserting the received data value in a register of the second set if said received data value falls within the predetermined spread and is lower than a data value stored in said register; and</claim-text>
<claim-text>- discarding the received data value if said received data value is not larger than any of the data values stored in the registers of the first set nor smaller than any of the data values stored in the registers of the second set;</claim-text></claim-text>
until all data values have been received, the method further comprising:<br/>
averaging (360) at least one data value stored in the first set of registers and at least one data value stored in the second set of registers; and<br/>
producing an output signal (204) indicative of said average value.<!-- EPO <DP n="19"> --></claim-text></claim><claim id="c-en-0011" num="0011"><claim-text>The method (300) of claim 10, further comprising counting the number of received data values, and wherein the step of selecting a first data value from the first set of registers and a second data value from the second set of registers is controlled by the counted number of received data values.</claim-text></claim><claim id="c-en-0012" num="0012"><claim-text>The method (300) of claim 10 or 11, wherein the step (335) of comparing the data value with the data values in the registers of the first and second sets comprises comparing the received data value with each of said data values stored in said registers in parallel.</claim-text></claim></claims><drawings mxw-id="PDW16670467" load-source="patent-office"><!-- EPO <DP n="20"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="129" he="115" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="21"> --><figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="165" he="204" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="22"> --><figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="146" he="214" img-content="drawing" img-format="tif"/></figure></drawings><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
