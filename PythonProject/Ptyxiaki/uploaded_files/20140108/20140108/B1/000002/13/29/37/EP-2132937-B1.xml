<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2132937-B1" country="EP" doc-number="2132937" kind="B1" date="20140108" family-id="39743048" file-reference-id="318255" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146588972" ucid="EP-2132937-B1"><document-id><country>EP</country><doc-number>2132937</doc-number><kind>B1</kind><date>20140108</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-08744419-A" is-representative="NO"><document-id mxw-id="PAPP154851164" load-source="docdb" format="epo"><country>EP</country><doc-number>08744419</doc-number><kind>A</kind><date>20080327</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140551785" ucid="US-2008058335-W" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>2008058335</doc-number><kind>W</kind><date>20080327</date></document-id></priority-claim><priority-claim mxw-id="PPC140557173" ucid="US-69356707-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>69356707</doc-number><kind>A</kind><date>20070329</date></document-id></priority-claim></priority-claims><dates-of-public-availability><intention-to-grant-date><date>20130726</date></intention-to-grant-date></dates-of-public-availability><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1989327229" load-source="docdb">H03M   7/40        20060101ALI20081022BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989327230" load-source="docdb">H04N   7/26        20060101AFI20081022BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-2137596262" load-source="docdb" scheme="CPC">H04N  19/91        20141101 LI20141108BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2137599314" load-source="docdb" scheme="CPC">H04N  19/436       20141101 LI20141108BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989621292" load-source="docdb" scheme="CPC">H03M   7/4006      20130101 FI20130904BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132371549" lang="DE" load-source="patent-office">ENTROPIEKODIERUNG FÜR VIDEOVERARBEITUNGSANWENDUNGEN</invention-title><invention-title mxw-id="PT132371550" lang="EN" load-source="patent-office">ENTROPY CODING FOR VIDEO PROCESSING APPLICATIONS</invention-title><invention-title mxw-id="PT132371551" lang="FR" load-source="patent-office">CODAGE ENTROPIQUE POUR APPLICATIONS DE TRAITEMENT VIDÉO</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR919536352" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>SCIENT ATLANTA LLC</last-name><address><country>US</country></address></addressbook></applicant><applicant mxw-id="PPAR919508192" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>SCIENTIFIC-ATLANTA, LLC</last-name></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR919527017" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>AU JAMES</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR919529040" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>AU, JAMES</last-name></addressbook></inventor><inventor mxw-id="PPAR919025697" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>AU, JAMES</last-name><address><street>3716 Ulster Street</street><city>Port Coquitlam, British Columbia V3B7H1</city><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR919535644" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>FARLEY STEPHEN</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR919503944" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>FARLEY, STEPHEN</last-name></addressbook></inventor><inventor mxw-id="PPAR919025698" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>FARLEY, STEPHEN</last-name><address><street>128 Meadowbank Road</street><city>Newmarket, Ontario L3Y2Y9</city><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR919508981" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>HEINRICH KENN</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR919538880" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>HEINRICH, KENN</last-name></addressbook></inventor><inventor mxw-id="PPAR919025699" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>HEINRICH, KENN</last-name><address><street>547 Lombardy Avenue</street><city>Oshawa, Ontario L1J8H5</city><country>CA</country></address></addressbook></inventor></inventors><assignees><assignee mxw-id="PPAR919025701" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Scientific-Atlanta, LLC</last-name><iid>101196526</iid><address><street>5030 Sugarloaf Parkway</street><city>Lawrenceville, GA 30044</city><country>US</country></address></addressbook></assignee></assignees><agents><agent mxw-id="PPAR919025700" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Mathys &amp; Squire LLP</last-name><iid>100061165</iid><address><street>120 Holborn</street><city>London EC1N 2SQ</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="US-2008058335-W"><document-id><country>US</country><doc-number>2008058335</doc-number><kind>W</kind><date>20080327</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2008121663-A2"><document-id><country>WO</country><doc-number>2008121663</doc-number><kind>A2</kind><date>20081009</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS549889756" load-source="docdb">AT</country><country mxw-id="DS549882983" load-source="docdb">BE</country><country mxw-id="DS549792302" load-source="docdb">BG</country><country mxw-id="DS549926020" load-source="docdb">CH</country><country mxw-id="DS549882984" load-source="docdb">CY</country><country mxw-id="DS549874705" load-source="docdb">CZ</country><country mxw-id="DS549790220" load-source="docdb">DE</country><country mxw-id="DS549882985" load-source="docdb">DK</country><country mxw-id="DS549882998" load-source="docdb">EE</country><country mxw-id="DS549806779" load-source="docdb">ES</country><country mxw-id="DS549792303" load-source="docdb">FI</country><country mxw-id="DS549792304" load-source="docdb">FR</country><country mxw-id="DS549790233" load-source="docdb">GB</country><country mxw-id="DS549882999" load-source="docdb">GR</country><country mxw-id="DS549790234" load-source="docdb">HR</country><country mxw-id="DS549874710" load-source="docdb">HU</country><country mxw-id="DS549926021" load-source="docdb">IE</country><country mxw-id="DS549883000" load-source="docdb">IS</country><country mxw-id="DS549792321" load-source="docdb">IT</country><country mxw-id="DS549883001" load-source="docdb">LI</country><country mxw-id="DS549792322" load-source="docdb">LT</country><country mxw-id="DS549889761" load-source="docdb">LU</country><country mxw-id="DS549792323" load-source="docdb">LV</country><country mxw-id="DS549792324" load-source="docdb">MC</country><country mxw-id="DS549889762" load-source="docdb">MT</country><country mxw-id="DS549883014" load-source="docdb">NL</country><country mxw-id="DS549790235" load-source="docdb">NO</country><country mxw-id="DS549883015" load-source="docdb">PL</country><country mxw-id="DS549792337" load-source="docdb">PT</country><country mxw-id="DS549874711" load-source="docdb">RO</country><country mxw-id="DS549883016" load-source="docdb">SE</country><country mxw-id="DS549926022" load-source="docdb">SI</country><country mxw-id="DS549790236" load-source="docdb">SK</country><country mxw-id="DS549889763" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><description mxw-id="PDES63961388" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><u>BACKGROUND OF THE INVENTION</u></heading><p id="p0001" num="0001">This disclosure relates generally to video processing and more specifically relates to entropy coding of video data. Video processing systems are employed in various demanding application, including high-definition television, missile guidance systems, and internet video streaking. Such applications often demand compact cost-effective systems for encoding, transmitting, and decoding high quality compressed video relatively accurately, quickly, and efficiently.</p><p id="p0002" num="0002">Efficient video processing systems are particularly important in so-called H.264 applications, where video processing systems are subjected two strict .standards. H.264 is digital video codec standard written by the Joint Video Team (JVT) comprising the International Telecommunication Unison (ITU)-Telecommunication Standardization Sector (T) and the International Organization for Standardization (ISO)/International Electrotechnical Commission (IEC) Moping Picture Experts Group (MPEG). The H.264 standard is also called the ISO/IEC MPBG-4 Part 10 standard or the ITU-T H.264 standard.</p><p id="p0003" num="0003">In an example H.264 system, pixels of a video image are logically grouped into 16*16 blocks of pixels called macroblocks. The image is partitioned into horizontal bands, called slices, each containing several macroblocks. Conventionally, a video frames must be partitioned into multiple slices, and sub-optimal motion search methods must be used due to relatively inefficient video processing methods and hardware speed constraints. For example, H.264 standards specify use of certain nested loops to perform Context. Adaptive Binary Arithmetic Coding (CABAC) entropy coding in an H.264 encoder, which can result in relatively inefficient serial processing operations.</p><p id="p0004" num="0004">Background art is: <nplcit id="ncit0001" npl-type="b"><text>Li Mo et al: "A high throughout binary arithmetic coding engine for h.264/avc" 8th International Conference of Solid-state and Integrated Circuit Technology ICSICT'06, IEEE, PI, 1st January 2006, pages 1914-1918, ISBN: 978 1-4244-0160-4</text></nplcit>; and<nplcit id="ncit0002" npl-type="s"><text> H Shojania et al, "A VLSI Architecture for High Performance<!-- EPO <DP n="2"> --> CABAC Encoding" PROC. of SPITE Visual Communications and Image Processing, vol 5960, 2005</text></nplcit>.</p><p id="p0005" num="0005">In an aspect of the invention, there is provided an apparatus according to claim 1 appended hereto. Various other respective aspects and features are defined in the appended claims.<!-- EPO <DP n="3"> --></p><heading id="h0002"><b><u>Brief Description of the Drawings</u></b></heading><p id="p0006" num="0006"><ul><li><figref idrefs="f0001">Fig. 1</figref> illustrates an example video-encoding system.</li><li><figref idrefs="f0002">Fig. 2</figref> is a more detailed diagram illustrating example components of the encoding module included in the video-encoding system of <figref idrefs="f0001">Fig. 1</figref>.</li><li><figref idrefs="f0003">Fig. 3</figref> is a more detailed diagram illustrating example components of the Context Adaptive Binary Arithmetic Coding (CABAC) module of <figref idrefs="f0002">Fig. 2</figref>.</li><li><figref idrefs="f0004">Fig. 4</figref> is a more detailed diagram illustrating example components of the encode-bin module of the CABAC module of <figref idrefs="f0002">Figs. 2</figref> and <figref idrefs="f0003">3</figref>.</li><li><figref idrefs="f0005">Fig. 5</figref> is a diagram illustrating example inputs and outputs of an encode-decision module of the encode-bin module of <figref idrefs="f0004">Fig. 4</figref>.</li><li><figref idrefs="f0005">Fig. 6</figref> is a diagram illustrating example inputs and outputs of a renormalization module of the encode-bin module of <figref idrefs="f0004">Fig. 4</figref>.</li><li><figref idrefs="f0006">Fig. 7</figref> is a diagram illustrating example inputs and outputs of a PutBit module of the encode-bin module of <figref idrefs="f0004">Fig. 4</figref>.</li><li><figref idrefs="f0007">Fig. 8</figref> is a flow diagram of an example process implemented by the encode-decision module of <figref idrefs="f0005">Fig. 5</figref> via parallel processing.</li><li><figref idrefs="f0008">Fig. 9</figref> is a flow diagram of a method suitable for use with the CABAC module and accompanying components of <figref idrefs="f0003 f0004 f0005 f0006">Figs. 3-7</figref>.</li></ul></p><heading id="h0003"><b><u>Detailed Description of Example Embodiments</u></b></heading><p id="p0007" num="0007">For the purposes of the present discussion, a macroblock may be any grouping of pixels in a frame of data. A frame may be any set of data that includes plural pixels of information, where a pixel may be a value associated with a data point. An image frame may be any collection of data points or pixels that are associated with an image or something to be displayed or viewed. An image may be any thing or representation of a thing that can be viewed. A slice of an image frame may be any grouping of macroblocks for processing purposes.</p><p id="p0008" num="0008">An example of a macroblock is the macroblock discussed in the H.264 standard, which includes a 16x16 group of pixels. An example of documentation that provides details of the H.264 standard is <nplcit id="ncit0003" npl-type="s"><text>ISO/IEC 14496-10 (ITU-T H.264), International Standard (2005</text></nplcit>), Advanced video coding for generic audiovisual services;<!-- EPO <DP n="4"> --> as if set forth in full in this specification for all purposes. For the purposes of generating a prediction frame, macroblocks within a slice are predicted based on previously predicted macroblocks so that values associated with one macroblock within the slice depend on values associated with one or more other macroblocks within the slice.</p><p id="p0009" num="0009">An example embodiment of an entropy coding module includes a renormalization process and an encode-decision process that communicates with the renormalization process. The encode-decision process is adapted to run in parallel with the renormalization process without the renormalization process being nested therein. For the purposes of the present discussion, an entropy coding module may be any module that employs one or more statistics or probability values to facilitate encoding data.</p><p id="p0010" num="0010">In a more specific embodiment, the entropy coding module includes an entropy encoder that is H.264 compliant. The encode-decision process includes a first mechanism for pre-computing certain parameters to eliminate nesting of the renormalization process within the encode-decision process that otherwise occurs in an H.264 Context Adaptive Binary Arithmetic Coding (CABAC) entropy encoding module. The renormalization process and the encode-decision process are components of a CABAC module. Parallel processing in a CABAC encoding module is enabled by eliminating nesting requirements that result in nested processing loops and relatively inefficient and slow serial processes.</p><p id="p0011" num="0011">The CABAC module of the present example embodiment is included within a video encoder. The certain parameters include an interval offset value (L) and an interval range value (R) as defined in one or more H.264 standards and further include a parameter (S) that is adapted to specify a number of cycles or duration for which the renormalization process should run before receiving additional data from the encode-decision process.</p><p id="p0012" num="0012">For the purposes of the present discussion, a CABAC module may be any module that is adapted to employ arithmetic coding of data in a signal to facilitate entropy coding. Arithmetic coding may be any method capable of assigning a number to a portion of a signal, such as a message in the signal. In an example entropy coding scheme, lengths of numbers or codes used to encode a portion of a signal are affected by the probability of<!-- EPO <DP n="5"> --> occurrence of the portion within the signal. In an example entropy encoder, commonly used symbols in a given data stream, i.e., signal, are encoded with the shorter codewords than less commonly used symbols.</p><p id="p0013" num="0013">Use of this embodiment or other embodiments disclosed herein or may facilitate implementing an encoder capable of encoding single-slice video frames, wherein one slice is employed for each video frame. This may greatly improve video quality. Note however, that the certain embodiments disclosed herein may also be used in multiple slice implementations without departing from the scope of the present teachings.</p><p id="p0014" num="0014">The term "coding" may refer to any encoding or decoding process. While certain embodiments are discussed herein with respect to an encoder, those skilled in the art may readily adapt certain embodiments herein to a decoder without departing from the scope of the present teachings and without undue experimentation.</p><p id="p0015" num="0015">In the present embodiment, an entire image frame is treated as a single slice, thereby yielding improved video output quality. The encode-bin module may be implemented via a first pipelined process. The encode-decision process may be implemented via a second pipelined process. For the purposes of the present discussion, a pipelined processor or process may be any processor or process that may begin processing a second portion of information without waiting for the completion of processing of a previously input first portion of information. An example pipelined processor performs certain operations back-to-back so that during a certain portion of the processing, both operations are operating simultaneously, i.e., in parallel.</p><p id="p0016" num="0016">Hence, unlike a conventional H.264 CABAC module, which must implement certain functions, such as an encode-decision and a renormalization function, in a serial fashion, certain interdependencies between functions created by nested loops or recursive processes are removed in certain embodiments disclosed here. Accordingly, certain embodiments disclosed herein may process corresponding functions in parallel, such as via one or more pipelined processes. This may result in improved CABAC speed and performance, which may enable use of single-slice video frames, which may further increase video quality. The improved CABAC speed facilitates real-time bit production feedback to rate control to further improve video quality.<!-- EPO <DP n="6"> --></p><p id="p0017" num="0017">In summary, certain embodiments disclosed herein employ novel techniques to facilitate parallel processing in a CABAC module, which helps to enable single-slice per picture H.264 encoding for high definition pictures and facilitates more sophisticated rate control methods.</p><p id="p0018" num="0018">For clarity, various well-known components, such as power supplies, H.264 decoders, computer systems, daughter cards, audio encoders, hosts, user interfaces, scaling circuits, timing clocks, and so on, have been omitted from the figures. However, those skilled in the art with access to the present teachings will know which components to implement and how to implement them to meet the needs of a given application.</p><p id="p0019" num="0019"><figref idrefs="f0001">Fig. 1</figref> illustrates an example video-encoding system 10. The encoding system 10 includes an encoder 12, which receives video input from a video receiver 14 and provides resulting compressed video to a video transmitter 16. For illustrative purposes, the encoder 12 is shown communicating with a display 18 for displaying video frames.</p><p id="p0020" num="0020">The encoder 12 includes an encoding module 20, a front end 22, a display module 24, and a controller 26. The front end 22 communicates with the video receiver 14, the encoding module, the display module 24, and the controller 26. The encoding module 20 further communicates with the controller 26. The display module 24 further communicates with the controller 26 and the display monitor 18.</p><p id="p0021" num="0021">In operation, the front end 22 formats input from the video receiver 14, which is accessible by the display module 24 and the encoding module 20. The controller 26 provides control input to the display module, the front end 22, and the encoding module 20 to facilitate controlling the operation of the encoder. Input video may be displayed via the display monitor 18 after the video data is formatted and prepared as needed via the display module 24.</p><p id="p0022" num="0022">In the present example embodiment, the encoding module 20 compresses input video in accordance with one or more H.264 standards and via a pipelined or parallel processing scheme, as discussed more fully below. Example processing functions implemented via the encoding module 20 include inter prediction, intra prediction, exhaustive motion search, frequency transforms, quantization, dequantization, frame subtraction and addition, and entropy coding for video image frames. The encoding module 20 outputs resulting compressed video to the video transmitter 16. The video<!-- EPO <DP n="7"> --> transmitter 16 may then transmit the resulting video to a decoder, to memory, and so on, as needed for a particular application.</p><p id="p0023" num="0023">The encoding module 20 may be implemented to perform processing in accordance with the H.264 standard. The front end 22, display module 24, and controller 26 may be implemented via various technologies, including, but not limited to Field Programmable Gate Array (FPGA) and Digital Signal Processor (DSP) technologies.</p><p id="p0024" num="0024"><figref idrefs="f0002">Fig. 2</figref> is a more detailed diagram illustrating example components 30-52 of the encoding module 20 included in the video-encoding system 10 of <figref idrefs="f0001">Fig. 1</figref>. The encoding module 20 includes an input-frame memory 30 for receiving and selectively storing video frames from the front end 22 of <figref idrefs="f0001">Fig. 1</figref>. The output of the input-frame memory 30 is input to a subtracter 32 and to an inter/intra processing module 50. The subtracter 32 also receives input from the inter/intra processing module 50 and provides output to a transformation module 36. An output of the transformation module 36 is coupled to a quantization module 38, also called a quantizer, an output of which is coupled to inputs of a dequantization module 40 and a entropy encoder 34. In the present example embodiment, the entropy encoder 34 implements Context Adaptive Binary Arithmetic Coding (CABAC), and consequently, is also called a CABAC module. The CABAC module 34 provides feedback to a rate control module 52, which provides a rate-control signal to the quantizer 38.</p><p id="p0025" num="0025">The dequantizer 40 is further coupled to an inverse transform module 42, an output of which is coupled to an input of an adder 44. An output of the adder 44 is coupled to an input of a deblocking filter 46. An output of the deblocking filter 46 is coupled to an input of a reference frame memory 48. An output of the reference frame memory 48 is coupled to an input of the inter/intra processing module 50. An output of the inter/intra processing module 50 is coupled to an input of the subtracter 32 and to an input of the adder 44.</p><p id="p0026" num="0026">In operation, an input frame from the input-frame memory 30 is provided to the inter/intra processing module 50 and to the subtracter 32. The frame is processed by the encoding module 20 in units of macroblocks. Each macroblock is encoded so-called inter mode or intra mode. In inter mode, the inter/intra processing module 50 executes one or more instructions to facilitate forming a prediction frame based on a previously<!-- EPO <DP n="8"> --> reconstructed and filtered frame, called a reference frame, which is provided to the inter/intra processing module 50 by the reference frame memory 48. The inter/intra processing module 50 may also implement inter/intra search and mode-decision functions. Details of inter/intra search and mode-decision operations that are known in the art may be readily adapted for use with example embodiments by those skilled in the art, without undue experimentation.</p><p id="p0027" num="0027">Reference frames used for inter prediction have been filtered by the deblocking filter 46. The inter/intra processing module 50 employs a first feedback loop formed by the inter/intra processing module 50, the subtracter 32, the transformation module 36, the quantization module 38, the dequantizer 40, the inverse transform module 42, the adder 44, the deblocking filter 46, and the reference frame memory 48 to facilitate generating a motion-compensated predicted frame from one or more reference frames.</p><p id="p0028" num="0028">In intra mode, the inter/intra processing module 50 executes one or more instructions to facilitate forming a prediction frame based on the current frame, as opposed to a reference frame. In intra mode, the inter/intra processing module 50 employs a second feedback loop that includes the inter/intra processing module 50, the subtracter 32, the transformation module 36, the quantizer 38, the dequantizer 40, the inverse transform 42, and the adder 44 to facilitate computing a reconstructed prediction frame.</p><p id="p0029" num="0029">In either mode, a predicted macroblock output by the inter/intra processing module 50 is subtracted from the corresponding macroblock in the input frame that is output from the input-frame memory 30. The resulting macroblock is called a residual or difference macroblock. The difference macroblock is then transformed from a time domain to a frequency domain, such as via a block transform, by the transformation module 36. The resulting transformed macroblock is quantized by the quantizer 38; dequantized by the dequantizer 40; and then transformed back to the time domain via the inverse transform module 42. The resulting residual macroblock is added to a corresponding macroblock from the prediction frame that is output from the inter/intra processing module 50 before the resulting added macroblock, called a reconstructed macroblock, is input back to the inter/intra processing module 50 as a reconstructed macroblock.<!-- EPO <DP n="9"> --></p><p id="p0030" num="0030">The output of the quantizer 38 represents a set of quantized transform coefficients. These coefficients are then entropy encoded via the CABAC 34. Entropy encoded coefficients and information required to decode a macroblock, such as prediction mode, quantizer step size, motion vector information, motion-compensation information, and so on, are output from the CABAC 34 via one or more bitstreams. The number of bits employed by the CABAC during a given operation may be fed back to the rate control module 52 to facilitate controlling the rate of the quantizer 38.</p><p id="p0031" num="0031">Hence, the rate control module 52 generates rate control signals to control the quantizer 38 and accompanying quantization parameters based on bit-production feedback from a previous Macroblocks, picture complexity, current bit buffer levels. The inter/intra processing module 50 may facilitate performing prediction through motion search and intra search mode-decision operations; may implement a mode decision function that selects a best prediction mode for each macroblock to be processed; and may perform prediction via motion compensation or intra compensation to form sample intensity predictions. The terms <i>intra compensation</i> and <i>intra prediction</i> may be employed interchangeably herein. Intra compensation involves predicting a macroblock based on information from the current frame in which the macroblock is a part.</p><p id="p0032" num="0032">The subtracter 32 outputs residuals representing differences between input data samples from the input-frame memory 30 and prediction samples from the inter/intra processing module 50. The transform module 36 converts residuals to the frequency domain. The quantizer 38 quantizes frequency coefficients, effectively discarding certain information to reduce entropy in the residuals. The dequantizer 40 and inverse transform module 42 are adapted to reconstruct transformed and quantized residuals through dequantization and inverse transform processes. The adder 44 facilitates adding reconstructed residuals output from the inverse transform module 42 to prediction samples output from the inter/intra processing module 50 to reconstruct decoded samples for a given macroblock. The deblocking filter 46 is adapted to remove blocking artifacts from decoded samples output from the adder 44. The CABAC 34 is adapted to implement entropy coding in accordance with H.264 main/high profile. The CABAC 34 codes macroblock modes, prediction information, and residuals into H.264-compliant bitstreams.<!-- EPO <DP n="10"> --></p><p id="p0033" num="0033">For illustrative purposes, the controller 26 is shown communicating with the inter/intra processing module 50. The controller 26 may communicate with more modules, different modules, or no modules in <figref idrefs="f0002">Fig. 2</figref> without departing from the scope of the present teachings. Furthermore, the rate-control module 52 and the controller 26 may be implemented in a common control module without departing from the scope of the present teachings.</p><p id="p0034" num="0034">Example embodiments discussed more fully below pertain primarily to intra prediction mode and corresponding components within the inter/intra processing module 50 for implementing intra prediction mode, which may include facilitating performing intra prediction and implementing an exhaustive motion search, wherein one or more motion search vectors are computed for each macroblock.</p><p id="p0035" num="0035">For the purposes of the present discussion, a motion search vector may be any value or set of values that contain information pertaining to the movement or projected movement of information or values in an image frame.</p><p id="p0036" num="0036"><figref idrefs="f0003">Fig. 3</figref> is a more detailed diagram illustrating example components of the Context Adaptive Binary Arithmetic Coding (CABAC) module 34 of <figref idrefs="f0002">Fig. 2</figref>. The CABAC module 34 includes an initial binarization/context-selection module 70, which includes a binarization module 74 and a context-selection module 76. An output of the binarization/context-selection module 70 is coupled to an input of an arithmetic bin-encoding module 72.</p><p id="p0037" num="0037">The arithmetic bin-encoding module 72 includes a function-selection module 80, which is coupled to an encode-bin process module 78, a Pulse Code Modulation (PCM) module, and an initialization module 90. The encode-bin process module 78 further includes an encode-bin module 82, an encode-bypass module 84, and an encode-terminate module 86, which are also coupled to the function-selection module 80. Outputs of the encode-bin module 82, the encode-bypass module 84, the encode-terminate module 86, and the PCM module 88 provide input to a write-bits encapsulation module 92, which outputs an encoded bitstream from the arithmetic bin-encoding module 72.</p><p id="p0038" num="0038">In the present example embodiment, the initialization module 90 communicates with the entropy-encode module 78 and accompanying encode-bin module 82. The<!-- EPO <DP n="11"> --> encode-bin module 82 is implemented via a pipelined processor that facilitates parallel processing of various functions internal to the encode-bin module 82, as discussed more fully below. For illustrative purposes, the controller 26 is coupled to the entropy-encode module 78 and the function-select module 80. Note however, that the function-select module 80 may operate without control input from the controller 26 without departing from the scope of the present teachings.</p><p id="p0039" num="0039">In operation, the binarization/context-selection module 70 receives an input data stream representing macroblock data, such as residuals, i.e., coefficients, motion vectors, reference index , delta Quantization Parameter (QP), Coded Block Pattern (CBP) information, and so on, from the quantization module 38 of <figref idrefs="f0002">Fig. 2</figref>.</p><p id="p0040" num="0040">For the purposes of the present discussion, macroblock data may be any information pertaining to a macroblock of a frame. The binarization module 74 maps incoming macroblock data into a binary sequence of 1's and 0's or other binary representations and outputs bins associated with a context identification, also called a context index. Hence, the binarization module 74 converts incoming modes and residual coefficients and prediction mode data into a string of zeros and ones. The binarization module 74 employs logic and memory modules to process different syntax elements and corresponding context templates.</p><p id="p0041" num="0041">The context-selection module 76 determines a context for certain input data and selects a probability model based on each context. The input macroblock data further includes syntax elements, which specify macroblock type, motion-vector data, texture data, and so on. The context-selection module 76 employs an adaptive coding to estimate a Probability Density Function (PDF) for each syntax element. The binarization/context-selection module 70 subsequently outputs data, including bin, context identification, called a context index (context idx), and function identification information, called a function index (function idx).</p><p id="p0042" num="0042">The context-selection module 76 further determines an appropriate context index and function index for each encoded bin. Hence, each bin is associated with a context index and a function index. The function index facilitates routing of each bin in the arithmetic bin-encoding module 72 by the function-selection module 80 to the encode-decision<!-- EPO <DP n="12"> --> module 82, the encode-bypass module 84, the encode-terminate module, the PCM module, and so on.</p><p id="p0043" num="0043">The bin and the context index information are employed inside various functions within the arithmetic bin-encoding module 72 to facilitate encoding operations. The binarization module 74 and the context-selection module 76 may be implemented in accordance with H.264 standards by those skilled in the art without undue experimentation.</p><p id="p0044" num="0044">The bin, context index, and function index are input from the binarization/context-selection module 70 to the function-selection module 80 of the arithmetic bin-encoding module 72. Additional values, such as bypass, End of Sequence (EOS), context flags (ctx flag), coding flags (coder_flag). Most Probable Sequence (MPS) information, and so on, may be output from the binarization/context-selection module to the arithmetic bin-encoding module 72.</p><p id="p0045" num="0045">The function-selection module 80 receives bin, context identification, and function identification from the binarization/context-selection module 70 and selectively activates one or more functions associated with the modules 82-90 of the arithmetic bin-encoding module 72 based on the received information.</p><p id="p0046" num="0046">The initialization module 90 is adapted to compute various initial values, such initial coder flags (init_coder_flag), initial interval offset values (init_L), initial interval range values (init_R), initial context flags (init_context_flag), initial probability information (init prob), and initial MPS information for use by the encode-bin module 82, as discussed more fully below. These parameters, such as init_context_flag, init_coder_flag, and so on, may be as defined in one or more H.264 standards.</p><p id="p0047" num="0047">For the purposes of the present discussion, an encode-decision module, such as the module 82, may be any module, hardware or software function, procedure, computer, or other set of instructions adapted to determine or update a context state pertaining to an input thereof. A context state may be any description of an input or other data describing a condition thereof. A module may be any module, hardware or software function, procedure, computer, or other set of instructions.</p><p id="p0048" num="0048">An encode-bypass module may be any module that is adapted to selectively skip encoding of different portions of an input via different probability values or functions. In<!-- EPO <DP n="13"> --> certain example embodiments disclosed herein, the encode-bypass module 84 is adapted to selectively adjust interval offset (L) and interval range (R) values when a bypass value is set to one (ByPass = 1). An encode-terminate module may be any module that is adapted to selectively terminate an encoding process.</p><p id="p0049" num="0049">The write-bits encapsulation module 92 facilitates performing any remaining tasks to format the output bitstream from the arithmetic bin-encoding module 72. The arithmetic bin-encoding module 72 incorporates requisite functionality for performing binary arithmetic bin encoding.</p><p id="p0050" num="0050">The entropy-encode module 78 takes each bin output from the binarization/context-selection module 70 and performs arithmetic encode (e.g., encode-decision, bin-encode, encode-bypass, and encode-terminate functions). The entropy-encode module 78 is further adapted to implement context probability update, renormalization, and write-bits functions, as defined in H.264 standards. The entropy-encode module 78 may be implemented via relatively simple logic in hardware, such as via a Field Programmable Gate Array (FPGA) or Application Specific Integrated Circuit (ASIC).</p><p id="p0051" num="0051">The Pulse Code Modulation (PCM) module 88 may act as an escape mode that prepares raw macroblock pixels for transmission instead of performing entropy encode operations. When the arithmetic bin-encoding module 72 operates in PCM mode, the CABAC 34 is flushed before raw pixel values are inserted into the output bitstream.</p><p id="p0052" num="0052"><figref idrefs="f0004">Fig. 4</figref> is a more detailed diagram illustrating example components of the encode-bin module 82 of the CABAC module 34 of <figref idrefs="f0002">Figs. 2</figref> and <figref idrefs="f0003">3</figref>. The encode-bin module 82 includes an encode-decision module 100, a renormalization module 102, a PutBit module 104. A first buffer (First In First Out (FIFO) buffer) 106 is coupled between an input of the encode-bin module 82 and an input of the encode-decision module 100. The first FIFO 106 buffers input, such as bin, context index (ctxid), bypass flag (bypass), and End of Sequence (EOS) values, from the binarization/context-selection module 70 of <figref idrefs="f0003">Fig. 3</figref>, before the input is provided to the encode-decision module 100. A second buffer (FIFO) 108 is coupled between an output of the encode-decision module 100 and the renormalization module 102. A third FIFO is 110 is coupled between an output of the<!-- EPO <DP n="14"> --> renormalization module 102 and an input of the PutBit module 104. The PutBit module 104 provides the output of the encode-bin module 82.</p><p id="p0053" num="0053">A first MUltipleXer (MUX) 112 receives an initial coder flag (init_coder_flag) from the initialization module 90 of <figref idrefs="f0003">Fig. 3</figref> as a control input. Alternatively, init_coder_flag is provided to the encode-bin module 82 by the controller 26 of <figref idrefs="f0003">Fig. 3</figref>. The first MUX 112 receives an initial interval offset (L) and interval range (R) value as a first pair of inputs (init_L, init_R) and receives a second set of inputs comprising computed L and R values (L, R) output from the encode-decision module 100. The value of init_coder_flag input to the first MUX 112 controls whether the first pair of inputs (init_L, init_R) or the second pair of inputs (L, R) is output from the first MUX 112 to an L-R register 114. The L-R register 114 is coupled between an output of the first MUX 112 and an input of the encode-decision module 100.</p><p id="p0054" num="0054">A second MUX 116 receives an initial context flag (init_context_flag) as a control input. The second MUX 116 is adapted to selectively switch its output between a first group of inputs (ctxid, init prob, MPS) and a second group of inputs (prob, MPS). The first group of inputs includes an initial context index (ctxid), an initial probability associated with a given bin (init_prob), and an initial Most Probable Sequence (MPS) value. The first group of inputs is obtained via the initialization module 90 of <figref idrefs="f0003">Fig. 3</figref>, or alternatively, the controller 26 of <figref idrefs="f0003">Fig. 3</figref> provides one or more of the inputs. The second group of inputs includes a computed probability value (prob) and a computed MPS value output from the encode-decision module 100. A context-state register 118 buffers output of the second MUX 116, which is fed back to the encode-decision module 100.</p><p id="p0055" num="0055">A third MUX 120 receives the init_coder_flag as a control input and selectively switches its output between zero (0) and an Outstanding Bits (OB) value output from the renormalization module 102, in accordance with the value of init_coder_flag. Output from the third MUX 120 is input to an OB register 122, an output of which fed back to the renormalization register 102. The OB register 122 implements a predetermined delay in the feedback between the third MUX 120 and the renormalization module 102.</p><p id="p0056" num="0056">A fourth MUX 126 receives the init_coder_flag as a control input and selectively switches its output between one (1) and a first bit (firstBit) output from the PutBit module 104, in accordance with the value of the init_coder_flag. Output from the fourth MUX<!-- EPO <DP n="15"> --> 126 is input to a first-bit register 124, an output of which is fed back to the renormalization register 104. The first-bit register 124 implements a predetermined delay in the feedback between the fourth MUX 126 and the PutBit module 104.</p><p id="p0057" num="0057">In operation, the CABAC encode-bin module 82 is implemented via a pipelined processor for facilitating implementing CABAC encoding via parallel processes. This is unlike a conventional CABAC encoder as defined in H.264 standards, which requires various serial processes, which are relatively slow, as discussed more fully below.</p><p id="p0058" num="0058">Representative parallel processes implemented via the CABAC encode-bin module 82 include processes implemented via the encode-decision module 100, the renormalization module 102, and the PutBit module 104. For the purposes of the present discussion, CABAC encoding may be any process that employs arithmetic coding to facilitate entropy coding or vice versa.</p><p id="p0059" num="0059">Certain states of the CABAC encode-bin module 82 are characterized by the current interval range (R) and the current offset value (L) in the current code interval. The value L is read from the register holding current L. The interval range (R) is subdivided in two regions, including a Least Probable Symbol (LPS) range and a Most Probable Symbol (MPS) range. The lengths of the ranges correspond to the probabilities associated with LPS and MPS, which are determined by the probability model used to encode the next symbol.</p><p id="p0060" num="0060">The encode-decision module 100 employs bin, context index (ctxid), bypass, EOS inputs, interval offset (L) and interval range (R), probability values, and MPS values to implement an arithmetic state machine and to perform probability updates. The encode-decision module 100 includes instructions for selectively updating L, R, probabilities (prob) and MPS values. L may be implemented as a fraction or floating point number, where R defines the length of an interval beginning at a position in a code, where the position is identified by L.</p><p id="p0061" num="0061">In the present embodiment, the encode-decision module 100 further includes a pre-computation module 127, which includes instructions for computing L, R, and an S parameter so that L and R feedback from the renormalization module 102 is not required. Hence, strategic use of the S parameter and pre-computation of S, L, and R facilitate removal of processing dependencies between various modules 100, 102, 104 of the<!-- EPO <DP n="16"> --> CABAC encode-bin module 82. This facilitates enabling the processes associated with the various modules 100, 102, 104 to run in parallel, such as in a pipelined fashion or via separate parallel-processing engines. For the purposes of the present discussion, a parallel process may be any process or execution of a set of instructions that includes the simultaneous or overlapping execution of two or more sub-processes or the simultaneous or overlapping execution of two or more subsets of instructions.</p><p id="p0062" num="0062">The renormalization module 102 implements instructions for updating the value of L associated with each bin being processed and further determines which bits (B) and Outstanding Bits (OBs) to output. For the purposes of the present discussion, a renormalization module may be any module capable of determining an output bit value based on a predetermined interval associated therewith. The interval may be a time interval, interval of a bit sequence, or other interval. Note that in the present example embodiment, renormalization processes involving shifting bits of L and R are performed in the encode-decision module 100 instead of in the renormalization module 102, where such operations are conventionally implemented. Splitting such renormalization and selective shifting operations of L and R from the associated renormalization module facilitates removing dependencies between the renormalization module 102 and the encode-decision module 100. Removing the dependencies between the renormalization module 102 and the encode-decision module 100 facilitate implementing the CABAC encode-bin module 82 via a parallel process, such as via a pipelined processor. As shown in <figref idrefs="f0004">Fig. 4</figref>, various modules 100, 102, and 104 lack feedback between each other, and are implemented via corresponding processes running in a pipelined fashion in the present embodiment.</p><p id="p0063" num="0063">Separation of certain renormalization functions associated with L and R from the renormalization module 102 facilitates reducing the overall recursion path length of the CABAC encode-bin module 82. Furthermore, performing certain renormalization functions associated with L and R in the encode-decision module 100, facilitates storing a <i>shift</i> and a <i>shifted-out</i> portion of L in the encode-decision module 100 or the renormalization module 102, which facilitates removal of processing dependencies between the modules 100, 102, 104, which enables parallel processing. The <i>shift</i> portion of L corresponds to a portion, such as certain bits, of L that is added to L during a<!-- EPO <DP n="17"> --> renormalization process involving shifting of a sequence of bits representing L. Similarly, a <i>shifted-out</i> portion of L corresponds to a portion of L that is removed from the sequence associated with L during renormalization.</p><p id="p0064" num="0064">By strategically moving and positioning logic and functionality of an H.264 CABAC encode-bin module into different positions in accordance with the present teachings, various computational efficiencies are achieved. Parallel processing may now be employed to run the modules 100, 102, 104 simultaneously. As another example, B and OB values used by PutBit 104 may be stored and processed at a more desirable time during the PutBit process associated with the PutBit module 104.</p><p id="p0065" num="0065">The B values output from the renormalization module 102 instruct the PutBit module 104 to insert either a zero or one into the bitstream output from the PutBit module 104. OB acts as a counter to instruct the PutBit module 104 as to how many outstanding bits should be output for each execution of the PutBit process implemented via the PutBit module 104.</p><p id="p0066" num="0066">Hence, the PutBit module 104 determines which bits (bits) to output and how to output them, such as in what order, B and OB values output from the third FIFO 110, a first-bit parameter (firstbit), and a bFlush parameter (bFlush). For the purposes of the present discussion, a PutBit module may be any module adapted to provide an appropriate bit value as output based on bit value input to the PutBit module. In the present example embodiment, the PutBit module 104 may be further based on an OB parameter and an EOS or and end of process parameter associated with an end of a sequence, which may correspond to the end of a sequence of data comprising a given slice in a video frame.</p><p id="p0067" num="0067">In the present example embodiment, the renormalization module 102 calculates an additional outstanding-bits parameter (OB2) that is used by the PutBit module 104 to facilitate determining a number of bits to output for a given iteration of the PutBit module 104.</p><p id="p0068" num="0068">In a conventional CABAC encoder as defined in H.264 standards, the associated renormalization module includes an internal nested loop that must be completed before L and R values are fed back to the renormalization module to the associated encode-decision module. The conventional encode-decision module must wait for completion of<!-- EPO <DP n="18"> --> the renormalization process to return L and R values to the encode-decision module. Hence, conventionally, the renormalization module acts as a nested loop within the encode-decision module, and the renormalization module itself has nested loops. Unfortunately, these nested loops have yielded inefficient serial processes, resulting in slow CABAC encoder.</p><p id="p0069" num="0069">In a conventional CABAC encoder, the associated encode-decision module is recursive on L and R, and the recursion path includes certain loops. The conventional encode-decision, renormalization, and PutBit modules each include loops for each input bin being processed. The resulting CABAC has a multi-level nested loop, wherein a given process depended upon the results of a sub-process, which depended upon the results of another sub-process, so that each process or sub-process had to be completed serially in a certain sequence. Unfortunately, such serial processing operations gave resulted in inefficient CABAC designs that are relatively slow. Such CABAC designs place design constraints on accompanying encoders, which inhibit single-slice video encoding and the associated high quality video output associated therewith. For the purposes of the present discussion, a loop may be any process or sub-process that is adapted to be repeated until a certain condition or state is met.</p><p id="p0070" num="0070">The S-parameter computed by the pre-computation module 127 is provided to the renormalization module 102 and specifies how many cycles or how long the renormalization module 102 should run before receiving additional information from the encode-decision module 100. Use of certain FIFO buffers, such as the second FIFO buffer 108 facilitates enabling the encode-decision module 100 to continue running while the renormalization module 102 continues running for a duration specified by S. Hence, strategic use of the S parameter and the FIFO buffer 108 facilitate enabling the encode-decision module 100 and the renormalization module 102 to operate in parallel, such as in a pipelined fashion.</p><p id="p0071" num="0071">Conventionally, each process (encode-decision, renormalization, PutBit) of a CABAC encoder waits for the next process before starting the next iteration. Use of the FIFOs 106, 108, 110 in the present embodiment help to eliminate the need for one process to wait for the completion of another process.<!-- EPO <DP n="19"> --></p><p id="p0072" num="0072">Note that in a conventional renormalization process as defined by H.264 standards employs a recursive loop that renormalizes L and R by performing a cycle a certain number of times until a certain condition is met (e.g., R &lt; 0x100). Unfortunately, this loop is computationally costly and acts to inhibit parallel processing implementations. Instead of employing this so-called conditional loop, the renormalization module 102 implements a simple set of instructions to update L based on the current value of L, and implements the set of instructions a predetermined number of times, as determined by the pre-computed S parameter. Updating and renormalization of R is moved to the encode-decision module 100. Furthermore, renormalization of L is moved to the encode-decision module 100.</p><p id="p0073" num="0073">Similarly, as the renormalization module 102 continues to run, any data that is not immediately needed by the PutBit module 104 is stored in the third FIFO buffer 110. The third FIFO buffer 110 stores data (e.g., output Bit value (B), Outstanding Bits (OB)) in the third FIFO 110 until needed by the PutBit module 104. Consequently, the renormalization module 102 may continue to run in parallel with the PutBit module 104, without stopping and waiting for the PutBit module 104 to request data.</p><p id="p0074" num="0074">Note that the CABAC encode-bin module 82 lacks feedback between the various modules 100, 102, 104, which might otherwise necessitate serial or nested processing, which could slow down the operation of the CABAC encode-bin module 82. For the purposes of the present discussion, a first process is said to be nested within a second process if the second process must wait for the completion of the first process before the second process can be continue. Hence, a nested process, loop, or function, or other set of instructions may be any group of processes wherein one process requires results from another before proceeding with processing operations. The CABAC encode-bin module 82 is adapted to produce an output bitstream that substantially similar to what a conventional CABAC encode-bin module would produce, but does so more efficiently, via parallel processes instead of nested processes.</p><p id="p0075" num="0075">The example CABAC encode-bin module 82 is H.264 compliant. For the purposes of the present discussion, a module, processor, function, or other device or method is said to be H.264 compliant if any outputs thereof may be employed in an<!-- EPO <DP n="20"> --> H.264 system. An H.264 system may be any set of components constructed in accordance with one or more H.264 standards.</p><p id="p0076" num="0076">The encode decision module 100 implements an encode-decision function. For the purposes of the present discussion, an encode decision function may be any operation that returns a result pertaining to a state associated with arithmetic coding process. An arithmetic coding process may be any process adapted to encode data into a number. An example encode-decision module determines or updates a context state pertaining an input to the module.</p><p id="p0077" num="0077">Hence, use of this embodiment may facilitate processing video frames in a single slice, which may greatly increase video quality. This is unlike certain conventional video processing systems that must partition each video frame into multiple slices due to use of relatively inefficient methods, serial processing, and hardware speed and performance limitations.</p><p id="p0078" num="0078">The embodiment as shown in <figref idrefs="f0004">Fig. 4</figref> has split the circular dependency between the encode-decision module 100 and the renormalization module 102 that occurs in conventional CABAC encoders as defined in H.264 standards. The elimination of the circular dependency facilitates enabling parallel executions of the new encode-decision module 100 and the PutBit module 104.</p><p id="p0079" num="0079">In summary, certain key modifications were made to a conventional H.264 CABAC encode-bin module to implement the CABAC encode-bin module 82, including:</p><p id="p0080" num="0080">1. Logic employed to update L and R was moved from the renormalization module into the encode-decision module to remove the dependency of the encode decision on L and R values from the renormalization module, thereby effectively splitting the updating of L and R from output bitstream generation.</p><p id="p0081" num="0081">2. Single-cycle updating of R was implemented in the encode-decision module 100. Conventionally, the updating of R required a loop inside of a renormalization module, which included performing a left shift of R until all leading zero bits in R a shifted out. In the present embodiment, a loop count (S parameter) representing the number of leading zero bits in R was implemented in the encode-decision module 100. Relatively inexpensive and high-speed hardware may be employed to count leading zero bits to determine S, as implemented in the pre-computation circuit 127.<!-- EPO <DP n="21"> --></p><p id="p0082" num="0082">3. The encode-decision module 100 employs single-cycle updating of L, which conventionally required a loop inside the renormalization module. Knowledge of the loop count (S parameter) facilitates updating L via a single step or cycle, as illustrated via pseudo code discussed below. A simple conditional subtraction is employed to update L, where the amount to be subtracted from L is represented by the values in a maskLookup table. S may be employed to look up the values.</p><p id="p0083" num="0083">4. FIFO buffers 108, 110 were inserted to hold output data from the encode-decision module 100 and the renormalization module 102. This facilitates parallel executions of the encode-decision, renormalization, and PutBit functions, which are also facilitated by the removal of nested function calls, which further enables the renormalization module 102 and the PutBit module 104 to perform requisite processes or loops without stalling previous processes.</p><p id="p0084" num="0084"><figref idrefs="f0005">Fig. 5</figref> is a diagram illustrating example inputs and outputs of an encode-decision module 100 of the encode-bin module 82 of <figref idrefs="f0004">Fig. 4</figref>. The encode-decision module 100 receives context index (CtxIdx), bin (Bin), bypass (ByPass), and End Of Sequence (EOS) inputs and provides an S (S), L-renormalization (Lrenorm), flush, and data_valid outputs. Lrenorm acts as a variable for storing the value of L. The meanings of the remaining variables should be clear with reference to the pseudo-code below and/or H.264 standards.</p><p id="p0085" num="0085">In the present example embodiment, CtxIdx is a nine-bit input, while Bin, Bypass, and EOS are single-bit inputs. S is a four-bit output, Lrenorm is a sixteen-bit output, and flush and data_valid are single-bit outputs. Note, however, that other bit lengths for various inputs and outputs may be changed without departing from the scope of the present teachings.</p><p id="p0086" num="0086">An example set of instructions implemented by the encode-decision module 100 is provided below in pseudo code, where certain syntax, such as left-shift and right-shift operators (e.g., « and ») used in the pseudo code below, is similar to that used in the American National Standards Institute (ANSI) C programming language.</p><p id="p0087" num="0087">Encode decision:
<pre listing-type="program-listing">{
 1. if (ByPass = 1) // encode bypass (equalprob)
   {<!-- EPO <DP n="22"> -->
     1.L=L&lt;&lt; 1;
     2. if(Bin== 1)
         L+=R;
     3. output(S=1, Lrenorm=(L,&gt;&gt;1), flush=0);
       if (L &gt;= 0x400)
         L = 0x400;
       else if (L &lt; 0x200)
         L=L;
       else
         L = 0x200;
       R=R;
   }
  else // encode normal bin
   {
     /* load context state. To achieve 1 cycle/bin, context state can be loaded ahead of
     time. To handle write/read coherency, most recently updated context states are cached.
 When the input CtxId matches a cached context, the cached values are used instead. The
 exact number of cached context states required is application specific. */
     1. CtxState[5..0] = CtxStateLoad(CtxIdx);
       CtxMPS = CtxMPSLoad(CtxIdx);
     // Context probability update and most probable bit comparison
     2. if (Bin == MPS)
        bLPS = 0;
       else
        bLPS = 1;
     3. if (CtxState = 0 and bLPS = 1)
         CtxMPS = not(CtxMPS);
       else
         CtxMPS = CtxMPS;
       if(bLPS =1)
         CtxState = LPSStateLookup (CtxState[5..0]);
       else if (CtxState &lt; 62)
         CtxState = CtxState + 1;
       else<!-- EPO <DP n="23"> -->
         CtxState = CtxState;
     4. Store CtxState and CtxMPS;
     // Renormalize R, L
     2. R_LPS[7..0] = RLPSLookup( CtxState[5..0], R[8..7] ); // 256 entries of 8-bit
     3. R2[8..0] = R[8..0] - R_LPS[7..0];
     4. L2[15..0] = L[15..0] + R2[8..0];
     5. if (bLPS ==1)
        R3 [8..0] = R_LPS;
        L3 [15..0] = L2;
      else
        R3 [8..0] = R2;
        L3 [15..0] = L;
     6. Shift[3..0] = CountNumLeadingZeroBit( R3[8..0] );
     7. Output(Lrenorm=L3, S=Shift, flush=EOS);
      R = R3 &lt;&lt; Shift;
      L4[17..0] = L3[15..0] &lt;&lt; Shift;
      mask = maskLookup( Shift);
     8. if (L4 &lt; mask)
        L[15..0] = L4[8..0]; // keep only 9 LSB
      else
        L[15..0] = L4 - mask; // only 8-bit MSB subtract
   }
 }</pre></p><p id="p0088" num="0088">Note that the above pseudo-code for the encode-bin module 100 includes renormalization of L and R and the computation of S. S is a four-bit number representing the number of leading zero bits in the R3 register or array indicated in the pseudo code above.</p><p id="p0089" num="0089">The renormalization of L and R and the computation of S occur in the pre-computation module 127 of <figref idrefs="f0004">Fig. 4</figref>. Furthermore, note that the encode-decision process indicated by the pseudo code above employs an L and R registers or arrays 114 of Fi and a context state register or array 118, as shown in <figref idrefs="f0004">Fig. 4</figref>, to facilitate calculations.</p><p id="p0090" num="0090"><figref idrefs="f0005">Fig. 6</figref> is a diagram illustrating example inputs and outputs of the renormalization module 102 of the encode-bin module 82 of <figref idrefs="f0004">Fig. 4</figref>. The renormalization module 102 receives S, L-renormalization (Lrenorm), flush (flush), and OB inputs from the second<!-- EPO <DP n="24"> --> FIFO 108 and OB register 122 of <figref idrefs="f0004">Fig. 4</figref> and outputs bit value (B), a first Outstanding Bits (OB) value, a second OB value (OB2), a bit-flush value (Bflush), and a data-ready value (data_ready).</p><p id="p0091" num="0091">An example set of instructions implemented by the renormalization, module 102 is provided below in pseudo code, where certain syntax may be understood with reference to syntax defined by ANSI for the C programming language.</p><p id="p0092" num="0092">Renormalization:
<pre listing-type="program-listing">{
   L = Lrenorm;
   1. for S times
     {
       1. if (L &lt;0x100)
         {
           1. Output(B=0, OB2=OB, Bflush=0);
            L=L;
          2. OB = 0;
         }
         else
         {
          if (L &gt;= 0x200)
           {
             1 . Output(B=1, OB2=OB, Bflush=0);
               L = L - 0x200;
             2.OB=0;
           }
           else
           {
             1.L=L-0x100;
               OB=OB+1;
           }
         }
       // L left by 1 every cycle<!-- EPO <DP n="25"> -->
       2.L=L&lt;&lt;1;
     }
     // flush bits at end of slice
   2. if (bFlush = 1)
     {
       1. Output(B=L[10], OB2=OB, BFlush=0);
         OB = 0;
       2. Output(B=L[9], OB2=0, Bflush= 1);
     }
 }</pre></p><p id="p0093" num="0093">Note that the above pseudo-code for the renormalization module 102 of <figref idrefs="f0004">Fig. 4</figref> repeats the first step (step 1) S times. Hence, S acts as a pre-computed counter that tells the renormalization module 102 of <figref idrefs="f0004">Fig. 4</figref> how many iterations to perform on a given set of inputs.</p><p id="p0094" num="0094">With reference to <figref idrefs="f0004">Figs. 4</figref>, <figref idrefs="f0005">5, and 6</figref>, the encode-decision module 100 of <figref idrefs="f0004">Figs. 4</figref> and <figref idrefs="f0005">5</figref> sends the S parameter to the renormalization module 102 along with other inputs as needed. The renormalization module 102 refrains from taking new data from the encode-decision module 100 until S cycles have been completed. Simultaneously, the encode-decision module 100 continues to run without needing to wait for the renormalization module 102 to complete processing of a given set of inputs.</p><p id="p0095" num="0095">Note that the renormalization module 102 and the encode-decision module 100 may represent processes running at different speeds. The second FIFO 108 selectively holds data from the encode-decision module 100 as needed while the renormalization module 102 is completing S cycles based on its input.</p><p id="p0096" num="0096"><figref idrefs="f0006">Fig. 7</figref> is a diagram illustrating example inputs and outputs of a PutBit module 104 of the encode-bin module 82 of <figref idrefs="f0004">Fig. 4</figref>. With reference to <figref idrefs="f0004">Figs. 4</figref>, <figref idrefs="f0005">6</figref>, and <figref idrefs="f0006">7</figref>, the PutBit module 104 receives B, OB2, Bflush, and first-bit (firstBit) inputs from the third FIFO 110 and first-bit register 124 of <figref idrefs="f0004">Fig. 4</figref>, and provides bitstream (bit), data-ready (data_ready), and firstBit outputs. The bitstream (bit) output from the PutBit module 104 represents the output of the encode-bin module 82.<!-- EPO <DP n="26"> --></p><p id="p0097" num="0097">An example set of instructions implemented by the PutBit module 104 is provided below in pseudo code, where certain syntax may be understood with reference to syntax defined by ANSI for the C programming language.</p><p id="p0098" num="0098">PutBit:
<pre listing-type="program-listing">  Internal Register: bFirstBit
  if (BFlush) // end of slice flush bits
  {
     Output(bit=B);
     Output(bit=1);
     Output bits to byte-align buffer;
  }
  else // encode normal bin
  {
     if (firstBit == 1)
     {
       firstBit = 0;
     }
     else
     {
       OutputBit(bit=B);
     }
     for OB2 times
     {
       OutputBit(bit=!B);
     }
   }</pre></p><p id="p0099" num="0099">Note, with reference to the above pseudo code for PutBit, that OB2 is employed to determine how many times to output the compliment of B in an output sequence. The function OutputBit(x) is a function that outputs bits associated with x from the PutBit module 104.</p><p id="p0100" num="0100">Note that if the Bflush parameter is set, flush bits at the end of a video slice have been reached, and an encode-terminate function is implemented. The encode-terminate<!-- EPO <DP n="27"> --> function involves outputting B (bit = B) followed by a one (1) and then performing byte-alignment of one or more buffers as needed. Clever use of the Bflush parameter obviates the need to implement encode-terminate as a separate function outside of the PutBit module 104.</p><p id="p0101" num="0101"><figref idrefs="f0007">Fig. 8</figref> is a flow diagram of an example process 100' implemented by the encode-decision module of <figref idrefs="f0005">Fig. 5</figref> via parallel processing. The encode-decision process 100' represents a 3-stage pipeline, wherein three different stages 130, 132, 134 are performed in parallel in a pipelined fashion.</p><p id="p0102" num="0102">The first stage 130 includes a context-state lookup function (CtxState_lookup) 138 and a context-state MPS lookup function (ctxMPS_Lookup) 136, which receive context index (CtxIdx) as input and provide context-state (ctx_state) 152 and context-MPS (ctx_MPS) 140, respectively, as output. The logical compliment of the context-MPS value is computed by an MPS-compliment module 142 and subsequently output to one terminal of a context-MPS MUX 144. The context-MPS value input to another terminal of the context-MPS MUX 144.</p><p id="p0103" num="0103">A bin-value decision module 150 employs the context-MPS value 140 and a bin value 148 to perform a bin-decision function 150 to determine an LPS associated with the bin (bLPS). The bin-decision function 150 provides a bLPS signal to a context-state MUX 160 in the first stage 130; to an R MUX 178 in the second stage 132; and to an L MUX 194 in the third stage 134. bLPS is also provided to a b-state function 156, which outputs a MUX control signal (bFlipMPS) based on whether the state associated with the bin (b) is equal to zero and based on bLPS.</p><p id="p0104" num="0104">The context-state value 152 is also provided to an LPS LookUp Table (LUT), which outputs a state associated with an LPS (sLPS) to an input terminal of the context-state MUX 160. The context-state value 152 is incremented by one by a state-incrementing function 164 to yield a state value associated with an MPS (sMPS). sMPS is then input to a second input terminal of the context-state MUX 160. An updated context-state value is output from the context-state MUX 160 and stored in a context-state memory 162. The updated context-state value is affected by bPLS, which acts as a control input to the context-state MUX 160. Similarly, an updated context-MPS value is selectively output from the context-MPS MUX 144 to a context-MPS memory 146.<!-- EPO <DP n="28"> --></p><p id="p0105" num="0105">In the present example embodiment, the lookup functions 136, 138 of the encode-decision process 100' are configured to preload a recently used context value, such as ctx_state and ctx_MPS, to facilitate implementing a context function via a one-cycle process. For the purposes of the present discussion, a one-cycle process may be any process that may be implemented so that only one clock cycle or iteration of a function is required to produce a desired output. The encode-decision process 100' and associated lookup functions may be readily implemented by those skilled in the art with access to the present teachings without undue experimentation.</p><p id="p0106" num="0106">Various modules or functions 140-166 in the first stage 130 depend on the current context state. Consequently, the first stage 130 is said to have context dependency.</p><p id="p0107" num="0107">The second stage 132 includes a range-selection function 172, which receives four different range LPS (Range_LPS) values from a range-LPS LUT 166. The range-selection function 172 further receives R 170 associated with the current bin and provides a selected R LPS (R_LPS) value as output. R_LPS is input to a first terminal of the R MUX 178 and to a range subtracter function 174. The range subtract 174 subtracts R_LPS from R, which results in R2 176, which is input to a second terminal of the R MUX 178. The bLPS value output from the bin-decision function 150 acts as a control input to the R MUX 178.</p><p id="p0108" num="0108">Output of the R MUX 178 is an R value, called R3, the bits of which are selectively left shifted by an R-shifter function 182. R3 is also input to a leading zero-counter function 180, which counts leading zeros of R3 to determine a four-bit S parameter (Shift). In this case, Shift acts as a control input to the R-shifter function 182, which affects how much R3 is shifted to yield the renormalized R value, which represents the output of the second stage 132.</p><p id="p0109" num="0109">The second stage 132 depends on values of R for the current bin. Consequently, the second stage 132 is said to have R-dependency.</p><p id="p0110" num="0110">The third stage 134 receives L 190 as input, which is provided to an adder function 192. The adder function 192 adds L and R2 to yield L2. L2 is input to a first terminal of the L MUX 194. L is input to a second terminal of the L MUX 194. The L MUX 194 outputs L3, which equals L or L2 depending upon the value of the bLPS control input to the L MUX 194. L3 is then selectively shifted via an L-shifter function<!-- EPO <DP n="29"> --> 196. The L-shifter function 196 left shifts L3 by Shift amount, which yields L4. A lookup mask 198 is determined based on Shift, and the resulting mask value is input to an L-determining function 200. The L-determining function 200 sets the renormalized output interval offset value (L) to equal L4 if L4 is less than the mask value. Otherwise, L is set equal to the difference between L4 and the current value of mask (L4-mask). The resulting L value represents the output of the third stage 134.</p><p id="p0111" num="0111">The third stage 134 depends on values of L for the current bin. Consequently, the third stage 134 is said to have R dependency.</p><p id="p0112" num="0112">The process flow 100' clearly shows that the three stages 130, 132, and 134 have limited interdependencies, enabling the three stages 130, 132, 134 to be readily implemented via a pipelined processor, parallel engines, or in software.</p><p id="p0113" num="0113">Conventionally, production of the L, R, ctx_state and ctx_MPS values output by the encode-decision process 100' requires nested loops and serial processing. By organizing the logic of an encode-decision process in the manner shown in <figref idrefs="f0004">Fig. 4</figref>, great improvements in CABAC encoder speed and performance are achievable.</p><p id="p0114" num="0114">An alternative description of the encode-decision process 100' is provided in the pseudo code above pertaining to the encode-decision module 100 of <figref idrefs="f0005">Fig. 5</figref>.</p><p id="p0115" num="0115"><figref idrefs="f0008">Fig. 9</figref> is a flow diagram of a method 210 suitable for use with the CABAC module 34 and accompanying components of <figref idrefs="f0003 f0004 f0005 f0006">Figs. 3-7</figref>. The method 210 includes a first step 212 that involves implementing an encode-decision function. A second step 214 includes establishing communications between the encode-decision function and a renormalization function. A third step 216 includes employing a parallel process to implement the encode-decision and renormalization functions.</p><p id="p0116" num="0116">With reference to <figref idrefs="f0002 f0003 f0004 f0005 f0006 f0007 f0008">Figs. 2-9</figref>, use of parallel processing in accordance with various embodiments disclosed herein may improve the performance of not only the CABAC 34 but also the accompanying encoder 20. For example, the rate-control module 52 of <figref idrefs="f0002">Fig. 2</figref> will receive output data from the CABAC module 34 more quickly, thereby enabling the rate-control module 52 to more effectively control the behavior of the quantizer 38. Hence, use of faster parallel processing operations within the CABAC 34 may reduce CABAC feedback latency, thereby further enhancing encoder output quality.<!-- EPO <DP n="30"> --></p><p id="p0117" num="0117">Although embodiments of the invention are discussed primarily with respect to an H.264-compliant encoder, embodiments of the present invention may be adapted to any video encoder wherein parallel engines or a pipelined engine may be useful. Furthermore, any acceptable architecture, topology, protocols, or other network and digital processing features can be employed. In general, certain modules and components discussed herein can be implemented in hardware, software, or via any device with processing ability or other requisite functionality. Techniques described herein may be suitable for use with other types of information processing. For example, the processing can operate on previously compressed or encoded image information, on three-dimensional image data, on non-visual information, etc.</p><p id="p0118" num="0118">Although specific processing sequences have been provided for processing data such as macroblocks, sub-blocks, slices, etc., any other suitable processing order or approach may be used. For example, any number of contiguous macroblocks may be in a slice. A slice can be a horizontal band but can also span horizontal bands, or be oriented vertically, diagonally, or in other non-horizontal directions.</p><p id="p0119" num="0119">Although specific processing sequences have been provided for processing data such as macroblocks, sub-blocks, slices, etc., any other suitable processing order or approach may be used. For example, any number of contiguous macroblocks may be in a slice. A slice can be a horizontal band but can also span horizontal bands, or be oriented vertically, diagonally, or in other non-horizontal directions.</p><p id="p0120" num="0120">Arrowheads shown on signal paths between various modules are for illustrative purposes only. For example, various communication paths or connecting lines, which appear to be unidirectional in the drawings, may be bidirectional without departing from the scope of the present invention.</p><p id="p0121" num="0121">Although processes of the present invention and the hardware executing the processes may be characterized by language common to a discussion of video processing (e.g., "FPGA," "CABAC," etc.), it should be apparent that operations of an embodiment of the present invention can execute on any type of suitable hardware in any communication relationship to another device on any type of link or network.</p><p id="p0122" num="0122">Although a process of the present invention may be presented as a single entity, such as software or hardware executing on a single machine, such software can readily be<!-- EPO <DP n="31"> --> executed on multiple machines. That is, there may be multiple instances of a given software program, a single program may be executing on two or more processors in a distributed processing environment, parts of a single program may be executing on different physical machines, etc. Furthermore, two different programs, such as a transformation program and a quantization program, can be executing in a single module, or in different modules.</p><p id="p0123" num="0123">Although the invention has been discussed with respect to specific example embodiments thereof, these embodiments are merely illustrative, and not restrictive, of the invention. In the description herein, numerous specific details are provided, such as examples of components and/or methods, to provide a thorough understanding of discussed example embodiments. One skilled in the relevant art will recognize, however, that certain embodiments can be practiced without one or more of the specific details, or with other apparatus, systems, assemblies, methods, components, materials, parts, and/or the like. In other instances, well-known structures, materials, or operations are not specifically shown or described in detail to avoid obscuring aspects of the example embodiments discussed herein.</p><p id="p0124" num="0124">A "machine-readable medium" or "computer-readable medium" may be any medium that can contain, store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, system or device. The computer readable medium can be, by way of example only but not by limitation, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, system, device, propagation medium, or computer memory.</p><p id="p0125" num="0125">A "processor" or "process" includes any human, hardware and/or software system, mechanism or component that processes data, signals or other information. A processor can include a system with a general-purpose central processing unit, multiple processing units, dedicated circuitry for achieving functionality, or other systems. Processing need not be limited to a geographic location, or have temporal limitations. For example, a processor can perform its functions in "real time," "offline," in a "batch mode," etc. Portions of processing can be performed at different times and at different locations, by different (or the same) processing systems. A computer may be any processor in communication with a memory.<!-- EPO <DP n="32"> --></p><p id="p0126" num="0126">Reference throughout this specification to "one embodiment", "an example embodiment", or "a specific embodiment" means that a particular feature, structure, or characteristic described in connection with the embodiment not necessarily included in all possible example embodiments. Thus, respective appearances of the phrases "in one embodiment", "in an embodiment", or "in a specific embodiment" in various places throughout this specification are not necessarily referring to the same embodiment. Furthermore, the particular features, structures, or characteristics of any specific embodiment or example embodiment discussed herein may be combined in any suitable manner with one or more other embodiments. It is to be understood that other variations and modifications of the embodiments described and illustrated herein are possible in light of the teachings herein, and the variations are to be considered as part of the spirit and scope of the present invention.</p><p id="p0127" num="0127">Example embodiments discussed herein may be implemented in whole or in part by using a programmed general purpose digital computer; by using application specific integrated circuits, programmable logic devices, FPGAs, optical, chemical, biological, quantum or nanoengineered systems or mechanisms; and so on. In general, the functions of various embodiments can be_achieved by any means as is known in the art. Distributed or networked systems, components, and/or circuits can be used. Communication, or transfer of data may be wired, wireless, or by any other means.</p><p id="p0128" num="0128">It will also be appreciated that one or more of the elements depicted in the drawings/figures can also be implemented in a more separated or integrated manner, or even removed or rendered as inoperable in certain cases, as is useful in accordance with a particular application. It is also within the spirit and scope of the present invention to implement a program or code that can be stored in a machine-readable medium to permit a computer to perform any of the methods described above.</p><p id="p0129" num="0129">Additionally, any signal arrows in the drawings/figures should be considered only as exemplary, and not limiting, unless otherwise specifically noted. Furthermore, the term "or" as used herein is generally intended to mean "and/or" unless otherwise indicated. Combinations of components or steps will also be considered as being noted, where terminology is foreseen as rendering the ability to separate or combine is unclear.<!-- EPO <DP n="33"> --></p><p id="p0130" num="0130">As used in the description herein and throughout the claims that follow "a", "an", and "the" include plural references unless the context clearly dictates otherwise. Furthermore, as used in the description herein and throughout the claims that follow, the meaning of "in" includes "in" and "on" unless the context clearly dictates otherwise.</p><p id="p0131" num="0131">The foregoing description of illustrated example embodiments, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed herein. While certain example embodiments are described herein for illustrative purposes only, various equivalent modifications are possible within the spirit and scope of the present invention, as those skilled in the relevant art will recognize and appreciate. As indicated, these modifications may be made in light of the foregoing description of illustrated example embodiments and are to be included within the spirit and scope of the present invention.</p><p id="p0132" num="0132">Thus, while example embodiments have been described herein, a latitude of modification, various changes and substitutions are intended in the foregoing disclosures, and it will be appreciated that in some instances some features of embodiments will be employed without a corresponding use of other features without departing from the scope and spirit of the invention. Therefore, many modifications may be made to adapt a particular situation or material to the essential scope and spirit of the present invention. It is intended that the invention not be limited to the particular terms used in following claims and/or to a particular embodiment disclosed as the best mode contemplated for carrying out this invention, but that the invention will include any and all embodiments and equivalents falling within the scope of the appended claims.</p></description><claims mxw-id="PCLM56986904" lang="DE" load-source="patent-office"><!-- EPO <DP n="35"> --><claim id="c-de-01-0001" num="0001"><claim-text>Vorrichtung (20) zum Codieren von Daten unter Verwendung eines Renormierungsverfahrens und eines Codier-Entscheidungsverfahrens, wobei die Vorrichtung Folgendes umfasst:
<claim-text>ein Renormierungsmodul (102) und</claim-text>
<claim-text>ein Codier-Entscheidungsmodul (100), das mit dem Renormierungsmodul in Verbindung steht, wobei das Codier-Entscheidungsmodul (100) so angeordnet ist, dass es parallel mit dem Renormierungsmodul (102) ausgeführt wird und unabhängig von Feedback vom Renormierungsmodul (102) arbeitet, wobei das Codier-Entscheidungsmodul Folgendes umfasst:
<claim-text>Mittel zum Berechnen eines Intervallversatzwerts (L) und eines Intervallbereichswerts (R) für ein Codierintervall sowie einen Schleifenparameter (S), der auf dem Intervallbereichswert basiert und so angepasst ist, dass er eine Anzahl von Iterationen angibt, die das Renormierungsmodul ausführen muss, bevor weitere Daten von dem Codier-Entscheidungsmodul empfangen werden; und</claim-text>
<claim-text>Mittel zum Ausgeben des Intervallsversatzwerts und des Schleifenparameters an das Renormierungsmodul.</claim-text></claim-text></claim-text></claim><claim id="c-de-01-0002" num="0002"><claim-text>Vorrichtung (20) nach Anspruch 1, wobei das Renormierungsverfahren, das von dem Renormierungsmodul ausgeführt wird, nicht in dem Codier-Entscheidungsverfahren verschachtelt ist, das von dem Codier-Entscheidungsmodul ausgeführt wird.</claim-text></claim><claim id="c-de-01-0003" num="0003"><claim-text>Vorrichtung (20) nach Anspruch 2, wobei die Vorrichtung Folgendes umfasst:
<claim-text>einen H.264-kompatiblen Entropie-Encoder.</claim-text><!-- EPO <DP n="36"> --></claim-text></claim><claim id="c-de-01-0004" num="0004"><claim-text>Vorrichtung (20) nach Anspruch 1, wobei das Renormierungsmodul und das Codier-Entscheidungsmodul Komponenten eines kontextadaptiven binären arithmetischen Codiermoduls (Context Adaptive Binary Arithmetic Coding - CABAC) sind.</claim-text></claim><claim id="c-de-01-0005" num="0005"><claim-text>Vorrichtung (20) nach Anspruch 4, wobei das CABAC-Modul ferner in einem Video-Codierer enthalten ist.</claim-text></claim></claims><claims mxw-id="PCLM56986905" lang="EN" load-source="patent-office"><!-- EPO <DP n="34"> --><claim id="c-en-01-0001" num="0001"><claim-text>An apparatus (20) operable to code data using a renormalization process and an encode-decision process, the apparatus comprising:
<claim-text>a renormalization module (102); and</claim-text>
<claim-text>an encode-decision module (100) in communication with the renormalization module, wherein the encode-decision module (100) is arranged to run in parallel with the renormalization module (102) and to operate independently of feedback from the renormalization module (102), the encode-decision module including:
<claim-text>means for computing an interval offset value (L) and an interval range value (R) for a coding interval, and a loop parameter (S) based on the interval range value and adapted to specify a number of iterations to be performed by the renormalization module before receiving further data from the encode-decision module; and</claim-text>
<claim-text>means for outputting the interval offset value and the loop parameter to the renormalization module.</claim-text></claim-text></claim-text></claim><claim id="c-en-01-0002" num="0002"><claim-text>The apparatus (20) of claim 1, wherein the renormalization process performed by the renormalization module is not nested within the encode-decision process performed by the encode-decision module.</claim-text></claim><claim id="c-en-01-0003" num="0003"><claim-text>The apparatus (20) of claim 2, wherein the apparatus includes: an entropy encoder that is H.264 compliant.</claim-text></claim><claim id="c-en-01-0004" num="0004"><claim-text>The apparatus (20) of claim 1, wherein the renormalization module and the encode-decision module are components of a Context Adaptive Binary Arithmetic Coding (CABAC) module.</claim-text></claim><claim id="c-en-01-0005" num="0005"><claim-text>The apparatus (20) of claim 4, wherein the CABAC module is further included within a video encoder.</claim-text></claim></claims><claims mxw-id="PCLM56986906" lang="FR" load-source="patent-office"><!-- EPO <DP n="37"> --><claim id="c-fr-01-0001" num="0001"><claim-text>Appareil (20) servant à coder des données au moyen d'un processus de renormalisation et d'un processus de décision de codage, l'appareil comportant :
<claim-text>un module de renormalisation (102) ; et</claim-text>
<claim-text>un module de décision de codage (100) en communication avec le module de renormalisation, dans lequel le module de décision de codage (100) est agencé pour s'exécuter de manière parallèle par rapport au module de renormalisation (102) et pour fonctionner indépendamment de toute rétroaction en provenance du module de renormalisation (102), le module de décision de codage comprenant :
<claim-text>des moyens permettant de calculer une valeur de décalage d'intervalle (L) et une valeur de plage d'intervalle (R) pour un intervalle de codage, et un paramètre de boucle (S) basé sur la valeur de plage d'intervalle et adapté pour spécifier un nombre d'itérations à être réalisées par le module de renormalisation avant de recevoir d'autres données en provenance du module de décision de codage ; et</claim-text>
<claim-text>des moyens permettant de transmettre la valeur de décalage d'intervalle et le paramètre de boucle au module de renormalisation.</claim-text></claim-text></claim-text></claim><claim id="c-fr-01-0002" num="0002"><claim-text>Appareil (20) selon la revendication 1, dans lequel le processus de renormalisation exécuté par le module de renormalisation n'est pas emboîté dans le processus de décision de codage exécuté par le module de décision de codage.</claim-text></claim><claim id="c-fr-01-0003" num="0003"><claim-text>Appareil (20) selon la revendication 2, dans lequel l'appareil comprend : un codeur entropique qui est conforme à la norme H.264.<!-- EPO <DP n="38"> --></claim-text></claim><claim id="c-fr-01-0004" num="0004"><claim-text>Appareil (20) selon la revendication 1, dans lequel le module de renormalisation et le module de décision de codage sont des composants d'un module de codage arithmétique binaire adaptatif selon le contexte (CABAC).</claim-text></claim><claim id="c-fr-01-0005" num="0005"><claim-text>Appareil (20) selon la revendication 4, dans lequel le module CABAC est par ailleurs inclus dans un codeur vidéo.</claim-text></claim></claims><drawings mxw-id="PDW16672589" load-source="patent-office"><!-- EPO <DP n="39"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="123" he="182" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="40"> --><figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="165" he="231" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="41"> --><figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="165" he="219" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="42"> --><figure id="f0004" num="4"><img id="if0004" file="imgf0004.tif" wi="165" he="214" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="43"> --><figure id="f0005" num="5,6"><img id="if0005" file="imgf0005.tif" wi="165" he="154" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="44"> --><figure id="f0006" num="7"><img id="if0006" file="imgf0006.tif" wi="123" he="186" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="45"> --><figure id="f0007" num="8"><img id="if0007" file="imgf0007.tif" wi="165" he="216" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="46"> --><figure id="f0008" num="9"><img id="if0008" file="imgf0008.tif" wi="165" he="134" img-content="drawing" img-format="tif"/></figure></drawings><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
