<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2070090-B1" country="EP" doc-number="2070090" kind="B1" date="20140108" family-id="38941921" file-reference-id="287191" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146588330" ucid="EP-2070090-B1"><document-id><country>EP</country><doc-number>2070090</doc-number><kind>B1</kind><date>20140108</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-07842100-A" is-representative="NO"><document-id mxw-id="PAPP154850522" load-source="docdb" format="epo"><country>EP</country><doc-number>07842100</doc-number><kind>A</kind><date>20070907</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140553523" ucid="US-2007077940-W" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>2007077940</doc-number><kind>W</kind><date>20070907</date></document-id></priority-claim><priority-claim mxw-id="PPC140556766" ucid="US-53039206-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>53039206</doc-number><kind>A</kind><date>20060908</date></document-id></priority-claim><priority-claim mxw-id="PPC140550856" ucid="US-53039906-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>53039906</doc-number><kind>A</kind><date>20060908</date></document-id></priority-claim><priority-claim mxw-id="PPC140547195" ucid="US-85222907-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>85222907</doc-number><kind>A</kind><date>20070907</date></document-id></priority-claim></priority-claims><dates-of-public-availability><intention-to-grant-date><date>20130726</date></intention-to-grant-date></dates-of-public-availability><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1989325300" load-source="ipcr">G11C   7/02        20060101AFI20130419BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989325301" load-source="ipcr">G11C   7/10        20060101ALI20130419BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989325302" load-source="ipcr">G11C   7/20        20060101ALI20130419BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989325303" load-source="ipcr">G11C  11/56        20060101ALI20130419BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989325304" load-source="ipcr">G11C  16/04        20060101ALI20130419BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989325305" load-source="ipcr">G11C  16/10        20060101ALI20130419BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989325306" load-source="ipcr">G11C  16/34        20060101ALI20130419BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL1989622349" load-source="docdb" scheme="CPC">G11C   7/1051      20130101 LA20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989625522" load-source="docdb" scheme="CPC">G11C   7/20        20130101 LI20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989628798" load-source="docdb" scheme="CPC">G11C2207/2245      20130101 LA20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989628969" load-source="docdb" scheme="CPC">G11C   7/1039      20130101 LI20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989631155" load-source="docdb" scheme="CPC">G11C   7/02        20130101 LI20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989631870" load-source="docdb" scheme="CPC">G11C   7/1006      20130101 FI20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989632942" load-source="docdb" scheme="CPC">G11C  16/3418      20130101 LI20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989634009" load-source="docdb" scheme="CPC">G11C  16/0483      20130101 LI20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989635983" load-source="docdb" scheme="CPC">G11C   7/1063      20130101 LI20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989642746" load-source="docdb" scheme="CPC">G11C  16/3427      20130101 LI20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989649625" load-source="docdb" scheme="CPC">G11C  11/5621      20130101 LI20130101BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989650558" load-source="docdb" scheme="CPC">G11C  16/10        20130101 LI20130101BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132369623" lang="DE" load-source="patent-office">PSEUDOZUFALLS- UND BEFEHLSGESTEUERTE BITKOMPENSATION FÜR TAKTUNGSEFFEKTE IN FLASH-SPEICHERN UND ENTSPRECHENDE VERFAHREN</invention-title><invention-title mxw-id="PT132369624" lang="EN" load-source="patent-office">PSEUDO RANDOM AND COMMAND DRIVEN BIT COMPENSATION FOR THE CYCLING EFFECTS IN FLASH MEMORY AND METHODS THEREFOR</invention-title><invention-title mxw-id="PT132369625" lang="FR" load-source="patent-office">COMPENSATION DE BITS PSEUDO-ALÉATOIRE ET DIRIGÉE PAR LA COMMANDE POUR LES EFFETS DE CYCLE EN MÉMOIRE FLASH ET SES PROCÉDÉS</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR919538835" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>SANDISK TECHNOLOGIES INC</last-name><address><country>US</country></address></addressbook></applicant><applicant mxw-id="PPAR919536687" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>SANDISK TECHNOLOGIES INC.</last-name></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR919522926" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>LI YAN</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919521994" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>LI, YAN</last-name></addressbook></inventor><inventor mxw-id="PPAR919022597" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>LI, YAN</last-name><address><street>695 Kevenaire Drive</street><city>Milpitas, CA 95035</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919524359" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>FONG YUPIN KAWING</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919542268" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>FONG, YUPIN KAWING</last-name></addressbook></inventor><inventor mxw-id="PPAR919022599" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>FONG, YUPIN KAWING</last-name><address><street>2938 Bruce Drive</street><city>Fremont, CA 94539</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919521359" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>MOKHLESI NIMA</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919505296" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>MOKHLESI, NIMA</last-name></addressbook></inventor><inventor mxw-id="PPAR919022598" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>MOKHLESI, NIMA</last-name><address><street>14285 Selinda Way</street><city>Los Gatos, CA 95032</city><country>US</country></address></addressbook></inventor></inventors><assignees><assignee mxw-id="PPAR919022601" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>SanDisk Technologies Inc.</last-name><iid>101274537</iid><address><street>Two Legacy Town Center 6900 North Dallas Parkway</street><city>Plano, Texas 75024</city><country>US</country></address></addressbook></assignee></assignees><agents><agent mxw-id="PPAR919022600" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Hitchcock, Esmond Antony</last-name><iid>100026869</iid><address><street>Marks &amp; Clerk LLP 90 Long Acre</street><city>London WC2E 9RA</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="US-2007077940-W"><document-id><country>US</country><doc-number>2007077940</doc-number><kind>W</kind><date>20070907</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2008031074-A1"><document-id><country>WO</country><doc-number>2008031074</doc-number><kind>A1</kind><date>20080313</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS549891908" load-source="docdb">AT</country><country mxw-id="DS549923603" load-source="docdb">BE</country><country mxw-id="DS549784651" load-source="docdb">BG</country><country mxw-id="DS549783864" load-source="docdb">CH</country><country mxw-id="DS549878197" load-source="docdb">CY</country><country mxw-id="DS549891921" load-source="docdb">CZ</country><country mxw-id="DS549923604" load-source="docdb">DE</country><country mxw-id="DS549878198" load-source="docdb">DK</country><country mxw-id="DS549878199" load-source="docdb">EE</country><country mxw-id="DS549869237" load-source="docdb">ES</country><country mxw-id="DS549801941" load-source="docdb">FI</country><country mxw-id="DS549784652" load-source="docdb">FR</country><country mxw-id="DS549923605" load-source="docdb">GB</country><country mxw-id="DS549878200" load-source="docdb">GR</country><country mxw-id="DS549891922" load-source="docdb">HU</country><country mxw-id="DS549783869" load-source="docdb">IE</country><country mxw-id="DS549878201" load-source="docdb">IS</country><country mxw-id="DS549784657" load-source="docdb">IT</country><country mxw-id="DS549878202" load-source="docdb">LI</country><country mxw-id="DS549801942" load-source="docdb">LT</country><country mxw-id="DS549872342" load-source="docdb">LU</country><country mxw-id="DS549801943" load-source="docdb">LV</country><country mxw-id="DS549801944" load-source="docdb">MC</country><country mxw-id="DS549872343" load-source="docdb">MT</country><country mxw-id="DS549784658" load-source="docdb">NL</country><country mxw-id="DS549783870" load-source="docdb">PL</country><country mxw-id="DS549872344" load-source="docdb">PT</country><country mxw-id="DS549784659" load-source="docdb">RO</country><country mxw-id="DS549783871" load-source="docdb">SE</country><country mxw-id="DS549891923" load-source="docdb">SI</country><country mxw-id="DS549869238" load-source="docdb">SK</country><country mxw-id="DS549801945" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><description mxw-id="PDES63960753" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><p id="p0001" num="0001">The present invention relates generally to portable mass storage devices such as the memory cards and portable universal serial bus ("USB") flash memory drives used to store and transfer large files to and from digital devices, and more specifically to minimizing the effects of repeatedly stored bit patterns in those drives.</p><p id="p0002" num="0002">As the capacity of flash memory cards and drives increases, the scale of the memory cells within the memory array continues to decrease. Within a high density array, especially of the NAND variety, a charge stored in one cell or portion of the array may influence a read or program operation of a neighboring cell. This is what as known as a read or program disturb and cell coupling.</p><p id="p0003" num="0003">For further information on cell coupling, disturbs, and the operation and structure of NAND flash gcnerally, please refer to <patcit id="pcit0001" dnum="US381995A"><text>U.S. patent application Nos.: 11/381,995</text></patcit> entitled "Method for Non-Voltile Memory With Background Data Latch Caching During Program Operations" (granted as <patcit id="pcit0002" dnum="US7502260B"><text>US 7,502,260</text></patcit>); <patcit id="pcit0003" dnum="US11382001B"><text>11/382,001</text></patcit> entitled "Method for Non-Volatile Memory With Background Data Latch Caching During Erase Operations" (granted as <patcit id="pcit0004" dnum="US7619922B"><text>US 7,619,922</text></patcit>); <patcit id="pcit0005" dnum="US11381994B"><text>11/381,994</text></patcit> entitled "Method for Non-Volatile Memory With Background Data Latch Caching During Read Operations" (granted as <patcit id="pcit0006" dnum="US7447078B"><text>US 7,447,078</text></patcit>); <patcit id="pcit0007" dnum="US10923320B"><text>10/923,320</text></patcit> entitled "Techniques for Reducing Effects of Coupling Between Storage Elements of Adjacent Rows of Memory Cells" (granted as <patcit id="pcit0008" dnum="US6870768B"><text>US 6,870,768</text></patcit>); now Patent No. <patcit id="pcit0009" dnum="US6870768B"><text>6,870,768</text></patcit>; and <patcit id="pcit0010" dnum="US11021872B"><text>11/021,872</text></patcit> entitled "Reducing Floating Gate to Floating Gate Coupling Effect" (granted as <patcit id="pcit0011" dnum="US7230851B"><text>US 7,230,851</text></patcit>).</p><p id="p0004" num="0004">Flash memory is often used by some users to constantly store the same data pattern again and again repeatedly in some blocks of the flash memory. The result is that there will be some bits left to be erased but never programmed. Additionally, there will be also some bits always programmed and rarely erased.<!-- EPO <DP n="2"> --> These persistent data patterns are problematic in that they may result in disturbs and other difficulties such as floating gate to floating gate effects, NAND string resistance effect, and reduced memory endurance and reliability, etc.</p><p id="p0005" num="0005">Solid-state memory capable of nonvolatile storage of charge, particularly in the form of EEPROM and flash EEPROM packaged as a small form factor card, has recently become the storage of choice in a variety of mobile and handheld devices, notably information appliances and consumer electronics products. Unlike RAM (random access memory) that is also solid-state memory, flash memory is non-volatile, retaining its stored data eve after power is turned off. In spite of the higher cost, flash memory is increasingly being used in mass storage applications. Conventional mass storage, based on rotating magnetic medium such as hard drives and floppy disks, is unsuitable for the mobile and handheld environment. This is because disk drives tend to be bulky, are prone to mechanical failure and have high latency and high power requirements. These undesirable attributes make disk-based storage impractical in most mobile and portable applications. On the other hand, flash memory, both embedded and in the form of a removable card is ideally suited in the mobile and handheld environment because of its small size, low power consumption, high speed and high reliability features.</p><p id="p0006" num="0006">EEPROM and electrically programmable read-only memory (EPROM) are non-volatile memory that can be erased and have new data written or "programmed" into their memory cells. Both utilize a floating (unconnected) conductive gate, in a field effect transistor structure, positioned over a channel region in a semiconductor substrate, between source and drain regions. A control gate is then provided over the floating gate. The threshold voltage characteristic of the transistor is controlled by the amount of charge that is retained on the floating gate. That is, for a given level of charge on the floating gate, there is a corresponding voltage (threshold) that must be applied to the control gate before the transistor is turned "on" to permit conduction between its source and drain regions.</p><p id="p0007" num="0007">The floating gate can hold a range of charges and therefore can be programmed to any threshold voltage level within a threshold voltage window. The<!-- EPO <DP n="3"> --> size of the threshold voltage window is delimited by the minimum and maximum threshold levels of the device, which in turn correspond to the range of the charges that can be programmed onto the floating gate. The threshold window generally depends on the memory device's characteristics, operating conditions and history. Each distinct, resolvable threshold voltage level range within the window may, in principle, be used to designate a definite memory state of the cell.</p><p id="p0008" num="0008">The transistor serving as a memory cell is typically programmed to a "programmed" state by one of two mechanisms. In "hot electron injection," a high voltage applied to the drain accelerates electrons across the substrate channel region. At the same time a high voltage applied to the control gate pulls the hot electrons through a thin gate dielectric onto the floating gate. In "tunneling injection," a high voltage is applied to the control gate relative to the substrate. In this way, electrons are pulled from the substrate to the intervening floating gate.</p><p id="p0009" num="0009">The memory device may be erased by a number of mechanisms. For EPROM, the memory is bulk erasable by removing the charge from the floating gate by ultraviolet radiation. For EEPROM, a memory cell is electrically erasable, by applying a high voltage to the substrate relative to the control gate so as to induce electrons in the floating gate to tunnel through a thin oxide to the substrate channel region (i.e., Fowler-Nordheim tunneling.) Typically, the EEPROM is erasable byte by byte. For flash EEPROM, the memory is electrically erasable either all at once or one or more blocks at a time, where a block may consist of 512 bytes or more of memory.</p><heading id="h0001"><u>EXAMPLES OF NON-VOLATILE MEMORY CELLS</u></heading><p id="p0010" num="0010">The memory devices typically comprise one or more memory chips that may be mounted on a card. Each memory chip comprises an array of memory cells supported by peripheral circuits such as decoders and erase, write and read circuits. The more sophisticated memory devices also come with a controller that performs intelligent and higher level memory operations and interfacing. There are many commercially successful non-volatile solid-state memory devices being used today. These memory devices may employ different types of memory cells, each type having<!-- EPO <DP n="4"> --> one or more charge storage element.</p><p id="p0011" num="0011"><figref idrefs="f0001 f0002">FIGs. 1A-1E</figref> illustrate schematically different examples of non-volatile memory cells.</p><p id="p0012" num="0012"><figref idrefs="f0001">FIG. 1A</figref> illustrates schematically a non-volatile memory in the form of an EEPROM cell with a floating gate for storing charge. An electrically erasable and programmable read-only memory (EEPROM) has a similar structure to EPROM, but additionally provides a mechanism for loading and removing charge electrically from its floating gate upon application of proper voltages without the need for exposure to UV radiation. Examples of such cells and methods of manufacturing them are given in United States patent no. <patcit id="pcit0012" dnum="US5595924A"><text>5,595,924</text></patcit>.</p><p id="p0013" num="0013"><figref idrefs="f0001">FIG. 1B</figref> illustrates schematically a flash EEPROM cell having both a select gate and a control or steering gate. The memory cell 10 has a "split-channel". 12 between source 14 and drain 16 diffusions. A cell is formed effectively with two transistors T1 and T2 in series. T1 serves as a memory transistor having a floating gate 20 and a control gate 30. The floating gate is capable of storing a selectable amount of charge. The amount of current that can flow through the T1's portion of the channel depends on the voltage on the control gate 30 and the amount of charge residing on the intervening floating gate 20. T2 serves as a select transistor having a select gate 40. When T2 is turned on by a voltage at the select gate 40, it allows the current in the T1's portion of the channel to pass between the source and drain. The select transistor provides a switch along the source-drain channel independent of the voltage at the control gate. One advantage is that it can be used to turn off those cells that are still conducting at zero control gate voltage due to their charge depletion (positive) at their floating gates. The other advantage is that it allows source side injection programming to be more easily implemented.</p><p id="p0014" num="0014">One simple embodiment of the split-channel memory cell is where the select gate and the control gate are connected to the same word line as indicated schematically by a dotted line shown in <figref idrefs="f0001">FIG. 1B</figref>. This is accomplished by having a charge storage element (floating gate) positioned over one portion of the channel and a control gate structure (which is part of a word line) positioned over the other<!-- EPO <DP n="5"> --> channel portion as well as over the charge storage element. This effectively forms a cell with two transistors in series, one (the memory transistor) with a combination of the amount of charge on the charge storage element and the voltage on the word line controlling the amount of current that can flow through its portion of the channel, and the other (the select transistor) having the word line alone serving as its gate. Examples of such cells, their uses in memory systems and methods of manufacturing them are given in United States patents nos. <patcit id="pcit0013" dnum="US5070032A"><text>5,070,032</text></patcit>, <patcit id="pcit0014" dnum="US5095344A"><text>5,095,344</text></patcit>, <patcit id="pcit0015" dnum="US5315541A"><text>5,315,541</text></patcit>,<patcit id="pcit0016" dnum="US5343063A"><text> 5,343,063</text></patcit>, and<patcit id="pcit0017" dnum="US5661053A"><text> 5,661,053</text></patcit>.</p><p id="p0015" num="0015">A more refined embodiment of the split-channel cell shown in <figref idrefs="f0001">FIG. 1B</figref> is when the select gate and the control gate are independent and not connected by the dotted line between them. One implementation has the control gates of one column in an array of cells connected to a control (or steering) line perpendicular to the word line. The effect is to relieve the word line from having to perform two functions at the same time when reading or programming a selected cell. Those two functions are (1) to serve as a gate of a select transistor, thus requiring a proper voltage to turn the select transistor on and off, and (2) to drive the voltage of the charge storage element to a desired level through an electric field (capacitive) coupling between the word line and the charge storage element. It is often difficult to perform both of these functions in an optimum manner with a single voltage. With the separate control of the control gate and the select gate, the word line need only perform function (1), while the added control line performs function (2). This capability allows for design of higher performance programming where the programming voltage is geared to the targeted data. The use of independent control (or steering) gates in a flash EEPROM array is described, for example, in United States patent nos. <patcit id="pcit0018" dnum="US5313421A"><text>5,313,421 </text></patcit>and <patcit id="pcit0019" dnum="US6222762B"><text>6,222,762</text></patcit>.</p><p id="p0016" num="0016"><figref idrefs="f0001">FIG. 1C</figref> illustrates schematically another flash EEPROM cell having dual floating gates and independent select and control gates. The memory cell 10 is similar to that of <figref idrefs="f0001">FIG. 1B</figref> except it effectively has three transistors in series. In this type of cell, two storage elements (i.e., that of T1 - left and T1 - right) are included over its channel between source and drain diffusions with a select transistor T1 in between them. The memory transistors have floating gates 20 and 20', and control gates 30 and 30', respectively. The select transistor T2 is controlled by a select gate<!-- EPO <DP n="6"> --> 40. At any one time, only one of the pair of memory transistors is accessed for read or write. When the storage unit T1 - left is being accessed, both the T2 and T1 - right are turned on to allow the current in the T1 - left's portion of the channel to pass between the source and the drain. Similarly, when the storage unit T1 - right is being accessed, T2 and T1 - left are turned on. Erase is effected by having a portion of the select gate polysilicon in close proximity to the floating gate and applying a substantial positive voltage (e.g. 20V) to the select gate so that the electrons stored within the floating gate can tunnel to the select gate polysilicon.</p><p id="p0017" num="0017"><figref idrefs="f0002">FIG. 1D</figref> illustrates schematically a string of memory cells organized into an NAND cell. An NAND cell 50 consists of a series of memory transistors M1 M2, ... Mn (n= 4, 8, 16 or higher) daisy-chained by their sources and drains. A pair of select transistors S1, S2 controls the memory transistors chain's connection to the external via the NAND cell's source terminal 54 and drain terminal 56. In a memory array, when the source select transistor S1 is turned on, the source terminal is coupled to a source line. Similarly, when the drain select transistor S2 is turned on, the drain terminal of the NAND cell is coupled to a bit line of the memory array. Each memory transistor in the chain has a charge storage element to store a given amount of charge so as to represent an intended memory state. A control gate of each memory transistor provides control over read and write operations. A control gate of each of the select transistors S1, S2 provides control access to the NAND cell via its source terminal 54 and drain terminal 56 respectively.</p><p id="p0018" num="0018">When an addressed memory transistor within an NAND cell is read and verified during programming, its control gate is supplied with an appropriate voltage. At the same time, the rest of the non-addressed memory transistors in the NAND cell 50 are fully turned on by application of sufficient voltage on their control gates. In this way, a conductive path is effective created from the source of the individual memory transistor to the source terminal 54 of the NAND cell and likewise for the drain of the individual memory transistor to the drain terminal 56 of the cell. Memory devices with such NAND cell structures are described in United States patent nos. <patcit id="pcit0020" dnum="US5570315A"><text>5,570,315</text></patcit>, <patcit id="pcit0021" dnum="US5903495A"><text>5,903,495</text></patcit>,<patcit id="pcit0022" dnum="US6046935A"><text> 6,046,935</text></patcit>.<!-- EPO <DP n="7"> --></p><p id="p0019" num="0019"><figref idrefs="f0002">FIG. 1E</figref> illustrates schematically a non-volatile memory with a dielectric layer for storing charge. Instead of the conductive floating gate elements described earlier, a dielectric layer is used. Such memory devices utilizing dielectric storage element have been described by <nplcit id="ncit0001" npl-type="s"><text>Eitan et al., "NROM: A Novel Localized Trapping, 2-Bit Nonvolatile Memory Cell," IEEE Electron Device Letters, vol. 21, no. 11, November 2000, pp. 543-545</text></nplcit>. An ONO dielectric layer extends across the channel between source and drain diffusions. The charge for one data bit is localized in the dielectric layer adjacent to the drain, and the charge for the other data bit is localized in the dielectric layer adjacent to the source. For example, United States patents nos. <patcit id="pcit0023" dnum="US5768192A"><text>5,768,192</text></patcit> and <patcit id="pcit0024" dnum="US6011725A"><text>6,011,725</text></patcit> disclose a nonvolatile memory cell having a trapping dielectric sandwiched between two silicon dioxide layers. Multi-state data storage is implemented by separately reading the binary states of the spatially separated charge storage regions within the dielectric.</p><heading id="h0002"><u>MEMORY ARRAY</u></heading><p id="p0020" num="0020">A memory device typically comprises of a two-dimensional array of memory cells arranged in rows and columns and addressable by word lines and bit lines. The array can be formed according to an NOR type or an NAND type architecture.</p><heading id="h0003"><u>NOR Array</u></heading><p id="p0021" num="0021"><figref idrefs="f0003">FIG. 2</figref> illustrates an example of an NOR array of memory cells. Memory devices with an NOR type architecture have been implemented with cells of the type illustrated in <figref idrefs="f0001">FIGs. 1B or 1C</figref>. Each row of memory cells are connected by their sources and drains in a daisy-chain manner. This design is sometimes referred to as a virtual ground design. Each memory cell 10 has a source 14, a drain 16, a control gate 30 and a select gate 40. The cells in a row have their select gates connected to word line 42. The cells in a column have their sources and drains respectively connected to selected bit lines 34 and 36. In some embodiments where the memory cells have their control gate and select gate controlled independently, a steering line 36 also connects the control gates of the cells in a column.<!-- EPO <DP n="8"> --></p><p id="p0022" num="0022">Many flash EEPROM devices are implemented with memory cells where each is formed with its control gate and select gate connected together. In this case, there is no need for steering lines and a word line simply connects all the control gates and select gates of cells along each row. Examples of these designs are disclosed in United States patent nos. <patcit id="pcit0025" dnum="US5172338A"><text>5,172,338</text></patcit> and <patcit id="pcit0026" dnum="US5418752A"><text>5,418,752</text></patcit>. In these designs, the word line essentially performed two functions: row selection and supplying control gate voltage to all cells in the row for reading or programming.</p><heading id="h0004"><u>NAND Array</u></heading><p id="p0023" num="0023"><figref idrefs="f0004">FIG. 3</figref> illustrates an example of an NAND array of memory cells, such as that shown in <figref idrefs="f0002">FIG. 1D</figref>. Along each column of NAND cells, a bit line is coupled to the drain terminal 56 of each NAND cell. Along each row of NAND cells, a source line may connect all their source terminals 54. Also the control gates of the NAND cells along a row are connected to a series of corresponding word lines. An entire row of NAND cells can be addressed by turning on the pair of select transistors (see <figref idrefs="f0002">FIG. 1D</figref>) with appropriate voltages on their control gates via the connected word lines. When a memory transistor within the chain of a NAND cell is being read, the remaining memory transistors in the chain are turned on hard via their associated word lines so that the current flowing through the chain is essentially dependent upon the level of charge stored in the cell being read. An example of an NAND architecture array and its operation as part of a memory system is found in United States patents nos. <patcit id="pcit0027" dnum="US5570315A"><text>5,570,315</text></patcit>,<patcit id="pcit0028" dnum="US5774397A"><text> 5,774,397</text></patcit> and <patcit id="pcit0029" dnum="US6046935A"><text>6,046,935</text></patcit>.</p><heading id="h0005"><u>Block Erase</u></heading><p id="p0024" num="0024">Programming of charge storage memory devices can only result in adding more charge to its charge storage elements. Therefore, prior to a program operation, existing charge in a charge storage element must be removed (or erased). Erase circuits (not shown) are provided to erase one or more blocks of memory cells. A non-volatile memory such as EEPROM is referred to as a "Flash" EEPROM when an entire array of cells, or significant groups of cells of the array, is electrically erased<!-- EPO <DP n="9"> --> together (i.e., in a flash). Once erased, the group of cells can then be reprogrammed. The group of cells erasable together may consist one or more addressable erase unit. The erase unit or block typically stores one or more pages of data, the page being the unit of programming and reading, although more than one page may be programmed or read in a single operation. Each page typically stores one or more sectors of data, the size of the sector being defined by the host system. An example is a sector of 512 bytes of user data, following a standard established with magnetic disk drives, plus some number of bytes of overhead information about the user data and/or the block in with it is stored.</p><heading id="h0006"><u>READ/WRITE CIRCUITS</u></heading><p id="p0025" num="0025">In the usual two-state EEPROM cell, at least one current breakpoint level is established so as to partition the conduction window into two regions. When a cell is read by applying predetermined, fixed voltages, its source/drain current is resolved into a memory state by comparing with the breakpoint level (or reference current I<sub>REF</sub>). If the current read is higher than that of the breakpoint level, the cell is determined to be in one logical state (e.g., a "zero" state). On the other hand, if the current is less than that of the breakpoint level, the cell is determined to be in the other logical state (e.g., a "one" state). Thus, such a two-state cell stores one bit of digital information. A reference current source, which may be externally programmable, is often provided as part of a memory system to generate the breakpoint level current.</p><p id="p0026" num="0026">In order to increase memory capacity, flash EEPROM devices are being fabricated with higher and higher density as the state of the semiconductor technology advances. Another method for increasing storage capacity is to have each memory cell store more than two states.</p><p id="p0027" num="0027">For a multi-state or multi-level EEPROM memory cell, the conduction window is partitioned into more than two regions by more than one breakpoint such that each cell is capable of storing more than one bit of data. The information that a given EEPROM array can store is thus increased with the number of states that each cell can store. EEPROM or flash EEPROM with multi-state or multi-level memory cells have been described in <patcit id="pcit0030" dnum="US5172338A"><text>U.S. Patent No. 5,172,338</text></patcit>.<!-- EPO <DP n="10"> --></p><p id="p0028" num="0028">In practice, the memory state of a cell is usually read by sensing the conduction current across the source and drain electrodes of the cell when a reference voltage is applied to the control gate. Thus, for each given charge on the floating gate of a cell, a corresponding conduction current with respect to a fixed reference control gate voltage may be detected. Similarly, the range of charge programmable onto the floating gate defines a corresponding threshold voltage window or a corresponding conduction current window.</p><p id="p0029" num="0029">Alternatively, instead of detecting the conduction current among a partitioned current window, it is possible to set the threshold voltage for a given memory state under test at the control gate and detect if the conduction current is lower or higher than a threshold current. In one implementation the detection of the conduction current relative to a threshold current is accomplished by examining the rate the conduction current is discharging through the capacitance of the bit line.</p><p id="p0030" num="0030"><figref idrefs="f0005">FIG. 4</figref> illustrates the relation between the source-drain current I<sub>D</sub> and the control gate voltage V<sub>CG</sub> for four different charges Q1-Q4 that the floating gate may be selectively storing at any one time. The four solid I<sub>D</sub> versus V<sub>CG</sub> curves represent four possible charge levels that can be programmed on a floating gate of a memory cell, respectively corresponding to four possible memory states. As an example, the threshold voltage window of a population of cells may range from 0.5V to 3.5V. Six memory states may be demarcated by partitioning the threshold window into five regions in interval of 0.5V each. For example, if a reference current, I<sub>REF</sub> of 2 µA is used as shown, then the cell programmed with Q1 may be considered to be in a memory state "1" since its curve intersects with I<sub>REF</sub> in the region of the threshold window demarcated by V<sub>CG</sub> = 0.5V and 1.0V. Similarly, Q4 is in a memory state "5".</p><p id="p0031" num="0031">As can be seen from the description above, the more states a memory cell is made to store, the more finely divided is its threshold window. This will require higher precision in programming and reading operations in order to be able to achieve the required resolution.</p><p id="p0032" num="0032">United States Patent No. <patcit id="pcit0031" dnum="US4357685A"><text>4,357,685</text></patcit> discloses a method of programming a 2-state EPROM in which when a cell is programmed to a given state, it is subject to<!-- EPO <DP n="11"> --> successive programming voltage pulses, each time adding incremental charge to the floating gate. In between pulses, the cell is read back or verified to determine its source-drain current relative to the breakpoint level. Programming stops when the current state has been verified to reach the desired state. The programming pulse train used may have increasing period or amplitude.</p><p id="p0033" num="0033">Prior art programming circuits simply apply programming pulses to step through the threshold window from the erased or ground state until the target state is reached. Practically, to allow for adequate resolution, each partitioned or demarcated region would require at least about five programming steps to transverse. The performance is acceptable for 2-state memory cells. However, for multi-state cells, the number of steps required increases with the number of partitions and therefore, the programming precision or resolution must be increased. For example, a 16-state cell may require on average at least 40 programming pulses to program to a target state.</p><p id="p0034" num="0034"><figref idrefs="f0005">FIG. 5</figref> illustrates schematically a memory device with a typical arrangement of a memory array 100 accessible by read/write circuits 170 via row decoder 130 and column decoder 160. As described in connection with <figref idrefs="f0003">FIGs. 2</figref> and <figref idrefs="f0004">3</figref>, a memory transistor of a memory cell in the memory array 100 is addressable via a set of selected word line(s) and bit line(s). The row decoder 130 selects one or more word lines and the column decoder 160 selects one or more bit lines in order to apply appropriate voltages to the respective gates of the addressed memory transistor. Read/write circuits 170 are provided to read or write (program) the memory states of addressed memory transistors. The read/write circuits 170 comprise a number of read/write modules connectable via bit lines to memory elements in the array.</p><p id="p0035" num="0035"><figref idrefs="f0006">FIG. 6A</figref> is a schematic block diagram of an individual read/write module 190. Essentially, during read or verify, a sense amplifier determines the current flowing through the drain of an addressed memory transistor connected via a selected bit line. The current depends on the charge stored in the memory transistor and its control gate voltage. For example, in a multi-state EEPROM cell, its floating gate can be charged to one of several different levels. For a 4-level cell, it may be used to store two bits of data. The level detected by the sense amplifier is converted by a level-to-bits<!-- EPO <DP n="12"> --> conversion logic to a set of data bits to be stored in a data latch.</p><heading id="h0007"><u>FACTORS AFFECTING READ/WRITE PERFORMANCE AND ACCURACY</u></heading><p id="p0036" num="0036">In order to improve read and program performance, multiple charge storage elements or memory transistors in an array are read or programmed in parallel. Thus, a logical "page" of memory elements are read or programmed together. In existing memory architectures, a row typically contains several interleaved pages. All memory elements of a page will be read or programmed together. The column decoder will selectively connect each one of the interleaved pages to a corresponding number of read/write modules. For example, in one implementation, the memory array is designed to have a page size of 532 bytes (512 bytes plus 20 bytes of overheads.) If each column contains a drain bit line and there are two interleaved pages per row, this amounts to 8512 columns with each page being associated with 4256 columns. There will be 4256 sense modules connectable to read or write in parallel either all the even bit lines or the odd bit lines. In this way, a page of 4256 bits (i.e., 532 bytes) of data in parallel are read from or programmed into the page of memory elements. The read/write modules forming the read/write circuits 170 can be arranged into various architectures.</p><p id="p0037" num="0037">Referring to <figref idrefs="f0005">FIG. 5</figref>, the read/write circuits 170 is organized into banks of read/write stacks 180. Each read/write stack 180 is a stack of read/write modules 190. In a memory array, the column spacing is determined by the size of the one or two transistors that occupy it. However, as can be seen from <figref idrefs="f0006">FIG. 6A</figref>, the circuitry of a read/write module will likely be implemented with many more transistors and circuit elements and therefore will occupy a space over many columns. In order to service more than one column among the occupied columns, multiple modules are stacked up on top of each other.</p><p id="p0038" num="0038"><figref idrefs="f0006">FIG. 6B</figref> shows the read/write stack of <figref idrefs="f0005">FIG. 5</figref> implemented conventionally by a stack of read/write modules 190. For example, a read/write module may extend over sixteen columns, then a read/write stack 180 with a stack of eight read/write<!-- EPO <DP n="13"> --> modules can be used to service eight columns in parallel. The read/write stack can be coupled via a column decoder to either the eight odd (1, 3, 5, 7, 9, 11, 13, 15) columns or the eight even (2, 4, 6, 8, 10, 12, 14, 16) columns among the bank.</p><p id="p0039" num="0039">As mentioned before, conventional memory devices improve read/write operations by operating in a massively parallel manner on all even or all odd bit lines at a time. This architecture of a row consisting of two interleaved pages will help to alleviate the problem of fitting the block of read/write circuits. It is also dictated by consideration of controlling bit-line to bit-line capacitive coupling. A block decoder is used to multiplex the set of read/write modules to either the even page or the odd page. In this way, whenever one set bit lines are being read or programmed, the interleaving set can be grounded to minimize immediate neighbor coupling.</p><p id="p0040" num="0040">However, the interleaving page architecture is disadvantageous in at least three respects. First, it requires additional multiplexing circuitry. Secondly, it is slow in performance. To finish read or program of memory cells connected by a word line or in a row, two read or two program operations are required. Thirdly, it is also not optimum in addressing other disturb effects such as field coupling between neighboring charge storage elements at the floating gate level when the two neighbors are programmed at different times, such as separately in odd and even pages.</p><p id="p0041" num="0041">The problem of neighboring field coupling becomes more pronounced with ever closer spacing between memory transistors. In a memory transistor, a charge storage element is sandwiched between a channel region and a control gate. The current that flows in the channel region is a function of the resultant electric field contributed by the field at the control gate and the charge storage element. With ever increasing density, memory transistors are formed closer and closer together. The field from neighboring charge elements then becomes significant contributor to the resultant field of an affected cell. The neighboring field depends on the charge programmed into the charge storage elements of the neighbors. This perturbing field is dynamic in nature as it changes with the programmed states of the neighbors. Thus, an affected cell may read differently at different time depending on the changing states of the neighbors.<!-- EPO <DP n="14"> --></p><p id="p0042" num="0042">The conventional architecture of interleaving page exacerbates the error caused by neighboring floating gate coupling. Since the even page and the odd page are programmed and read independently of each other, a page may be programmed under one set of condition but read back under an entirely different set of condition, depending on what has happened to the intervening page in the meantime. The read errors will become more severe with increasing density, requiring a more accurate read operation and coarser partitioning of the threshold window for multi-state implementation. Performance will suffer and the potential capacity in a multi-state implementation is limited.</p><p id="p0043" num="0043">United States Patent Publication No. <patcit id="pcit0032" dnum="US20040060031A1"><text>US-2004-0060031-A1</text></patcit> discloses a high performance yet compact non-volatile memory device having a large block of read/write circuits to read and write a corresponding block of memory cells in parallel. In particular, the memory device has an architecture that reduces redundancy in the block of read/write circuits to a minimum. Significant saving in space as well as power is accomplished by redistributing the block of read/write modules into a block read/write module core portions that operate in parallel while interacting with a substantially smaller sets of common portions in a time-multiplexing manner. In particular, data processing among read/write circuits between a plurality of sense amplifiers and data latches is performed by a shared processor.</p><p id="p0044" num="0044">Therefore there is a general need for high performance and high capacity non-volatile memory. In particular, there is a need for a compact non-volatile memory with enhanced read and program performance having an improved processor that is compact and efficient, yet highly versatile for processing data among the read/writing circuits.</p><p id="p0045" num="0045"><patcit id="pcit0033" dnum="US5996041A"><text>US 5,996,041</text></patcit> discloses a storage device according to the preamble of Claim 1.</p><p id="p0046" num="0046"><patcit id="pcit0034" dnum="US2006062055A"><text>US 2006/062055</text></patcit> discloses a DRAM adopting a single intersection memory cell array having randomly accessible data registers accessed whenever the chip is accessed externally.</p><p id="p0047" num="0047">The present invention will reduce or eliminate the specific data patterns which can cause program disturbs or user read disturbs, as well as reducing NAND<!-- EPO <DP n="15"> --> string resistance effect, and increasing memory endurance and reliability. It will also reduce the problem of floating gate to floating gate coupling.</p><p id="p0048" num="0048">According to an aspect of the present invention there is provided a storage device comprising a flash memory EEPROM. The EEPROM comprises a flash memory array comprising a hidden area and a user data area; and peripheral circuitry comprising a multi bit register. A random or pseudo-random multi bit code is stored in the register. The storage device further comprises a comparator for comparing each bit of the code to a page address of a page of data, to either invert the encoding scheme of the page or leave the encoding scheme as is.</p><p id="p0049" num="0049">According to another aspect of the present invention there Is provided a method for storing data on a nonvolatile memory having a plurality of pages of data. The method comprises storing, in the non volatile memory, a code comprising a plurality of pseudo-random or random bits. Each bit of the plurality defines whether the encoding of data of a page of the plurality is to be inverted or remain as is. The method further comprises reading the code from the non volatile memory, transferring the code from the non volatile memory to a register allocated to store the plurality of bits of the code, storing the code in the register, generating a polarity signal by comparing a page address of a page of the plurality of pages to a bit of the code for each bit of the code and changing the encoding of a subset of pages of the plurality based upon the generated polarity signal.</p><p id="p0050" num="0050">According to a further aspect of the present invention there is provided a method for implementing randomization of the stored data on a nonvolatile memory having a plurality of pages of data comprising receiving a user command to program or read the user data in the array and upon receiving the user command, triggering the application of a code comprising a plurality of bits to a block of the user data to randomize the encoding of the user data. Each of the bits of the code determines whether a group of one or more pages of the block is stored as is or is inverted prior to being stored.<!-- EPO <DP n="16"> --></p><p id="p0051" num="0051">A method of implementing pseudo-randomization of the data stored in the flash memory chip or array is disclosed. This method requires only minimal modification to the circuitry of the flash memory, yet at the same time will drastically increase the randomness of the data storage, and therefore increase the performance of the array. The randomization of the data may be either enabled or disabled easily within the memory. Further, the sequence driving the pseudo randomization may continually change, further increasing the flexibility of the system.</p><p id="p0052" num="0052">In some embodiments, a user action triggers a potential change in the encoding of the data. As the timing of user actions is completely unpredictable, the encoding scheme utilized as a result of the user driven trigger is also unpredictable and essentially entirely random.</p><p id="p0053" num="0053">The various randomization methodologies and embodiments are memory chip (EEPROM) implemented. This is to say that they take place within the memory chip itself rather than with a memory controller that communicates with the chip. This differs from a different technique of addressing the issue known as wear leveling that is often implemented on a system level and utilizes the controller to change how data is stored within the memory chip.</p><p id="p0054" num="0054">In an embodiment of the invention the storage device comprises a non volatile NAND flash memory chip comprising a plurality of pages of user data. The chip comprises a memory array, a finite state machine clock signal, a command clock signal, and a polarity bit generated by referencing the finite state machine clock signal and the command clock signal. A first encoding type is used for a first value of the polarity bit, and a second encoding type is used for a second value of the polarity bit. Usage of the different encoding types reduces the duration of storage of the same data pattern in the array, even if the same data is actually stored within the array repeatedly or for long periods of time.<!-- EPO <DP n="17"> --></p><p id="p0055" num="0055">A method in a non volatile NAND flash memory comprising a plurality of pages of data is also disclosed. The method comprises storing, in the non volatile memory, a code comprising a plurality of bits, each bit of the plurality defining whether the encoding of data of a page of the plurality is to be inverted or remain as is. It also comprises reading the code from the non volatile memory, transferring the code from the non volatile memory to a register allocated to store the plurality of bits of the code, storing the code in the register, generating a polarity signal by comparing a page address of a page of the plurality of pages to a bit of the code for each bit of the code, and changing the encoding of a subset of pages of the plurality based upon the generated polarity signal.
<ul><li><figref idrefs="f0001 f0002">FIGS. 1A-1E</figref> illustrate schematically different examples of non-volatile memory cells.</li><li><figref idrefs="f0003">FIG. 2</figref> illustrates an example of an NOR array of memory cells.</li><li><figref idrefs="f0004">FIG. 3</figref> illustrates an example of an NAND array of memory cells, such as that shown in <figref idrefs="f0002">FIG. 1D</figref>.</li><li><figref idrefs="f0005">FIG. 4</figref> illustrates the relation between the source-drain current and the control gate voltage for four different charges Q1-Q4 that the floating gate may be storing at any one time.</li><li><figref idrefs="f0005">FIG. 5</figref> illustrates schematically a typical arrangement of a memory array accessible by read/write circuits via row and column decoders.</li><li><figref idrefs="f0006">FIG. 6A</figref> is a schematic block diagram of an individual read/write module.</li><li><figref idrefs="f0006">FIG. 6B</figref> shows the read/write stack of <figref idrefs="f0005">FIG. 5</figref> implemented conventionally by a stack of read/write modules.</li><li><figref idrefs="f0007">FIG. 7A</figref> illustrates schematically a compact memory device having a bank of partitioned read/write stacks, in which the improved processor of the present invention is implemented.<!-- EPO <DP n="18"> --></li><li><figref idrefs="f0008">FIG. 7B</figref> illustrates a preferred arrangement of the compact memory device shown in <figref idrefs="f0007">FIG. 7A</figref>.</li><li><figref idrefs="f0009">FIG. 8</figref> illustrates schematically a general arrangement of the basic components in a read/write stack shown in <figref idrefs="f0007">FIG. 7A</figref>.</li><li><figref idrefs="f0010">FIG. 9</figref> illustrates one preferred arrangement of the read/write stacks among the read/write circuits shown in <figref idrefs="f0007">FIGs. 7A</figref> and <figref idrefs="f0008">7B</figref>.</li><li><figref idrefs="f0011">FIG. 10</figref> illustrates an improved embodiment of the common processor shown in <figref idrefs="f0010">FIG 9</figref>.</li><li><figref idrefs="f0012">FIG. 11A</figref> illustrates a preferred embodiment of the input logic of the common processor shown in <figref idrefs="f0011">FIG. 10</figref>.</li><li><figref idrefs="f0012">FIG. 11B</figref> illustrates the truth table of the input logic of <figref idrefs="f0012">FIG. 11A</figref>.</li><li><figref idrefs="f0013">FIG. 12A</figref> illustrates a preferred embodiment of the output logic of the common processor shown in <figref idrefs="f0011">FIG. 10</figref>.</li><li><figref idrefs="f0013">FIG. 12B</figref> illustrates the truth table of the output logic of <figref idrefs="f0013">FIG. 12A</figref>.</li><li><figref idrefs="f0014">FIG. 13</figref> is a simplified version of <figref idrefs="f0011">FIG. 10</figref> that shows some specific elements that are relevant to the present discussion in a two-bit arrangement.</li><li><figref idrefs="f0014">FIG. 14</figref> indicates the latch assignment for the same elements as <figref idrefs="f0014">FIG. 13</figref> for upper page program where the lower page data is read in.</li><li><figref idrefs="f0015">FIG. 15</figref> illustrates aspects of cache program in the single page mode.</li><li><figref idrefs="f0015">FIG. 16</figref> shows a programming waveform that can be used in a lower page to full sequence conversion.</li><li><figref idrefs="f0016">FIG. 17</figref> illustrates the relative timing in a cache program operation with a full sequence conversion.</li><li><figref idrefs="f0016">FIG. 18</figref> describes the disposition of latches in a cache page copy operation.<!-- EPO <DP n="19"> --></li><li><figref idrefs="f0017">FIGS. 19A</figref> and <figref idrefs="f0018">19B</figref> illustrate the relative timings in cache page copy operations.</li><li><figref idrefs="f0019">FIG. 20</figref> illustrates threshold voltage distributions of the 4-state memory array when each memory cell stores two bits of data using the LM code.</li><li><figref idrefs="f0020">FIG. 21</figref> is a schematic block diagram of certain components of EEPROM or memory chip 600.</li><li><figref idrefs="f0021">FIG. 22A</figref> is an illustration of the encoding scheme and polarity bit of various pages of data by page address.</li><li><figref idrefs="f0021">FIG. 22B</figref> is a table illustrating the application of an example 17 bit code used to transform the encoding of user data.</li><li><figref idrefs="f0022">FIG. 22C</figref> illustrates application of polarity bits to the upper and lower bits stored in the memory cells of an exemplary NAND chain/string.</li><li><figref idrefs="f0023">FIG. 23A</figref> is an illustration of encoding scheme determination as a function of a command clock signal.</li><li><figref idrefs="f0023">FIG. 23B</figref> is a clock signal of a command.</li><li><figref idrefs="f0023">FIG. 23C</figref> illustrates an embodiment of control circuitry for data encoding determination and inversion.</li><li><figref idrefs="f0023">FIG. 23D</figref>. illustrates a page of user data with the polarity bit stored therein.</li><li><figref idrefs="f0023">FIG. 23E</figref> illustrates an embodiment of control circuitry for reverting the encoding of potentially inverted data for read operations.</li><li><figref idrefs="f0024">FIG. 24A</figref> is a timeline of a command clock signal and a finite state machine clock signal showing the value of the FSM clock at the rising edge of the command clock signal.</li><li><figref idrefs="f0024">FIG. 24B</figref> illustrates exemplary circuitry to determine the polarity bit as a function of the command clock signal shown in <figref idrefs="f0024">FIG. 24A</figref>.</li></ul><!-- EPO <DP n="20"> --></p><p id="p0056" num="0056"><figref idrefs="f0007">FIG. 7A</figref> illustrates schematically a compact memory device having a bank of partitioned read/write stacks, in which the improved processor of an embodiment of the present invention may be implemented. The memory device includes a two-dimensional array of memory cells 300, control circuitry 310, and read/write circuits 370. The memory array 300 is addressable by word lines via a row decoder 330 and by bit lines via a column decoder 360. The read/write circuits 370 is implemented as a bank of partitioned read/write stacks 400 and allows a block (also referred to as a "page") of memory cells to be read or programmed in parallel. In a preferred embodiment, a page is constituted from a contiguous row of memory cells. In another embodiment, where a row of memory cells are partitioned into multiple blocks or pages, a block multiplexer 350 is provided to multiplex the read/write circuits 370 to the individual blocks.</p><p id="p0057" num="0057">The control circuitry 310 cooperates with the read/write circuits 370 to perform memory operations on the memory array 300. The control circuitry 310 includes a state machine 312, an on-chip address decoder 314 and a power control module 316. The state machine 312 provides chip level control of memory operations. The on-chip address decoder 314 provides an address interface between that used by the host or a memory controller to the hardware address used by the decoders 330 and 360. The power control module 316 controls the power and voltages supplied to the word lines and bit lines during memory operations.</p><p id="p0058" num="0058"><figref idrefs="f0008">FIG. 7B</figref> illustrates a preferred arrangement of the compact memory device shown in <figref idrefs="f0007">FIG. 7A</figref>. Access to the memory array 300 by the various peripheral circuits is implemented in a symmetric fashion, on opposite sides of the array so that access lines and circuitry on each side are reduced in half. Thus, the row decoder is split into row decoders 330A and 330B and the column decoder into column decoders 360A and 360B. In the embodiment where a row of memory cells are partitioned into multiple blocks, the block multiplexer 350 is split into block multiplexers 350A and 350B. Similarly, the read/write circuits are split into read/write circuits 370A connecting to bit lines from the bottom and read/write circuits 370B connecting to bit<!-- EPO <DP n="21"> --> lines from the top of the array300. In this way, the density of the read/write modules, and therefore that of the partitioned read/write stacks 400, is essentially reduced by one half.</p><p id="p0059" num="0059"><figref idrefs="f0009">FIG. 8</figref> illustrates schematically a general arrangement of the basic components in a read/write stack shown in <figref idrefs="f0007">FIG. 7A</figref>. The read/write stack 400 comprises a stack of sense amplifiers 212 for sensing k bit lines, an I/O module 440 for input or output of data via an I/O bus 231, a stack of data latches 430 for storing input or output data, a common processor 500 to process and store data among the read/write stack 400, and a stack bus 421 for communication among the stack components. A stack bus controller among the read/write circuits 370 provides control and timing signals via lines 411 for controlling the various components among the read/write stacks.</p><p id="p0060" num="0060"><figref idrefs="f0010">FIG. 9</figref> illustrates one preferred arrangement of the read/write stacks among the read/write circuits shown in <figref idrefs="f0007">Figs. 7A</figref> and <figref idrefs="f0008">7B</figref>. Each read/write stack 400 operates on a group of k bit lines in parallel. If a page has p=r*k bit lines, there will be r read/write stacks, 400-1, ..., 400-r.</p><p id="p0061" num="0061">The entire bank of partitioned read/write stacks 400 operating in parallel allows a block (or page) of p cells along a row to be read or programmed in parallel. Thus, there will be p read/write modules for the entire row of cells. As each stack is serving k memory cells, the total number of read/write stacks in the bank is therefore given by r =p/k. For example, if r is the number of stacks in the bank, then p = r*k. One example memory array may have p = 512 bytes (512x8 bits), k = 8, and therefore r = 512. In the preferred embodiment, the block is a run of the entire row of cells. In another embodiment, the block is a subset of cells in the row. For example, the subset of cells could be one half of the entire row or one quarter of the entire row. The subset of cells could be a run of contiguous cells or one every other cell, or one every predetermined number of cells.</p><p id="p0062" num="0062">Each read/write stack, such as 400-1, essentially contains a stack of sense amplifiers 212-1 to 212-k servicing a segment ofk memory cells in parallel. A preferred sense amplifier is disclosed in United States Patent Publication No. <patcit id="pcit0035" dnum="US20040109357A1"><text>2004-0109357-A1</text></patcit>.<!-- EPO <DP n="22"> --></p><p id="p0063" num="0063">The stack bus controller 410 provides control and timing signals to the read/write circuit 370 via lines 411. The stack bus controller is itself dependent on the memory controller 310 via lines 311. Communication among seach read/write stack 400 is effected by a stack bus including SABus 422 and DBus 423 and controlled by the stack bus controller 410. Control lines 411 provide control and clock signals from the stack bus controller 410 to the components of the read/write stacks 400-1.</p><p id="p0064" num="0064">In the preferred arrangement, the stack bus is partitioned into a SABus 422 for communication between the common processor 500 and the stack of sense amplifiers 212, and a DBus 423 for communication between the processor and the stack of data latches 430.</p><p id="p0065" num="0065">The stack of data latches 430 comprises of data latches 430-1 to 430-k, one for each memory cell associated with the stack The I/O module 440 enables the data latches to exchange data with the external via an I/O bus 231.</p><p id="p0066" num="0066">The common processor also includes an output 507 for output of a status signal indicating a status of the memory operation, such as an error condition. The status signal is used to drive the gate of an n-transistor 550 that is tied to a FLAG BUS 509 in a Wired-Or configuration. The FLAG BUS is preferably precharged by the controller 310 and will be pulled down when a status signal is asserted by any of the read/write stacks.</p><p id="p0067" num="0067"><figref idrefs="f0011">FIG. 10</figref> illustrates an improved embodiment of the common processor shown in <figref idrefs="f0010">FIG 9</figref>. The common processor 500 comprises a processor bus, PBUS 505 for communication with external circuits, an input logic 510, a processor latch PLatch 520 and an output logic 530.</p><p id="p0068" num="0068">The input logic 510 receives data from the PBUS and outputs to a BSI node as a transformed data in one of logical states "1", "0", or "Z" (float) depending on the control signals from the stack bus controller 410 via signal lines 411. A Set/Reset latch, PLatch 520 then latches BSI, resulting in a pair of complementary<!-- EPO <DP n="23"> --> output signals as MTCH and MTCH*.</p><p id="p0069" num="0069">The output logic 530 receives the MTCH and MTCH* signals and outputs on the PBUS 505 a transformed data in one of logical states "1 ", "0", or "Z" (float) depending on the control signals from the stack bus controller 410 via signal lines 411.</p><p id="p0070" num="0070">At any one time the common processor 500 processes the data related to a given memory cell. For example, <figref idrefs="f0011">FIG. 10</figref> illustrates the case for the memory cell coupled to bit line 1. The corresponding sense amplifier 212-1 comprises a node where the sense amplifier data appears. In the preferred embodiment, the node assumes the form of a SA Latch, 214-1 that stores data. Similarly, the corresponding set of data latches 430-1 stores input or output data associated with the memory cell coupled to bit line 1. In the preferred embodiment, the set of data latches 430-1 comprises sufficient data latches, 434-1, ..., 434-n for storing n-bits of data.</p><p id="p0071" num="0071">The PBUS 505 of the common processor 500 has access to the SA latch 214-1 via the SBUS 422 when a transfer gate 501 is enabled by a pair of complementary signals SAP and SAN. Similarly, the PBUS 505 has access to the set of data latches 430-1 via the DBUS 423 when a transfer gate 502 is enabled by a pair of complementary signals DTP and DTN. The signals SAP, SAN, DTP and DTN are illustrated explicitly as part of the control signals from the stack bus controller 410.</p><p id="p0072" num="0072"><figref idrefs="f0012">FIG. 11A</figref> illustrates a preferred embodiment of the input logic of the common processor shown in <figref idrefs="f0011">FIG. 10</figref>. The input logic 520 receives the data on the PBUS 505 and depending on the control signals, either has the output BSI being the same, or inverted, or floated. The output BSI node is essentially affected by either the output of a transfer gate 522 or a pull-up circuit comprising p-transistors 524 and 525 in series to Vdd, or a pull-down circuit comprising n-transistors 526 and 527 in series to ground. The pull-up circuit has the gates to the p-transistor 524 and 525 respectively controlled by the signals PBUS and ONE. The pull-down circuit has the gates to the n-transistors 526 and 527 respectively controlled by the signals ONEB&lt;1&gt; and PBUS.<!-- EPO <DP n="24"> --></p><p id="p0073" num="0073"><figref idrefs="f0012">FIG. 11B</figref> illustrates the truth table of the input logic of <figref idrefs="f0012">FIG. 11A</figref>. The logic is controlled by PBUS and the control signals ONE, ONEB&lt;0&gt;, ONEB&lt;1&gt; which are part of the control signals from the stack bus controller 410. Essentially, three transfer modes, PASSTHROUGH, INVERTED, and FLOATED, are supported.</p><p id="p0074" num="0074">In the case of the PASSTHROUGH mode where BSI is the same as the input data, the signals ONE is at a logical "1", ONEB&lt;0&gt; at "0" and ONEB&lt;1&gt; at "0". This will disable the pull-up or pull-down but enable the transfer gate 522 to pass the data on the PBUS 505 to the output 523. In the case of the INVERTED mode where BSI is the invert of the input data, the signals ONE is at "0", ONEB&lt;0&gt; at "1" and ONEB&lt;1&gt; at "1". This will disable the transfer gate 522. Also, when PBUS is at "0", the pull-down circuit will be disabled while the pull-up circuit is enabled, resulting in BSI being at "1". Similarly, when PBUS is at "1", the pull-up circuit is disabled while the pull-down circuit is enabled, resulting in BSI being at "0". Finally, in the case of the FLOATED mode, the output BSI can be floated by having the signals ONE at "1", ONEB&lt;0&gt; at "1" and ONEB&lt;1&gt; at "0". The FLOATED mode is listed for completeness although in practice, it is not used.</p><p id="p0075" num="0075"><figref idrefs="f0013">FIG. 12A</figref> illustrates a preferred embodiment of the output logic of the common processor shown in <figref idrefs="f0011">FIG. 10</figref>. The signal at the BSI node from the input logic 520 is latched in the processor latch, PLatch 520. The output logic 530 receives the data MTCH and MTCH* from the output of PLatch 520 and depending on the control signals, outputs on the PBUS as either in a PASSTHROUGH, INVERTED OR FLOATED mode. In other words, the four branches act as drivers for the PBUS 505, actively pulling it either to a HIGH, LOW or FLOATED state. This is accomplished by four branch circuits, namely two pull-up and two pull-down circuits for the PBUS 505. A first pull-up circuit comprises p-transistors 531 and 532 in series to Vdd, and is able to pull up the PBUS when MTCH is at "0". A second pull-up circuit comprises p-transistors 533 and 534 in series to ground and is able to pull up the PBUS when MTCH is at "1". Similarly, a first pull-down circuit comprises n-transistors 535 and 536 in series to Vdd, and is able to pull down the PBUS when MTCH is at "0". A second pull-down circuit comprises n-transistors 537 and 538 in series to ground and is able to pull-down the PBUS when MTCH is at "1".<!-- EPO <DP n="25"> --></p><p id="p0076" num="0076">The pull-up circuits with is constituted PMOS transistors and the pull-down circuits with NMOS transistors in one arrangement. Since the pull by the NMOS is much stronger than that of the PMOS, the pull-down will always overcome the pull-up in any contentions. In other words, the node or bus can always default to a pull-up or "1" state, and if desired, can always be flipped to a "0" state by a pull-down.</p><p id="p0077" num="0077"><figref idrefs="f0013">FIG. 12B</figref> illustrates the truth table of the output logic of <figref idrefs="f0013">FIG. 12A</figref>. The logic is controlled by MTCH, MTCH* latched from the input logic and the control signals PDIR, PINV, NDIR, NINV, which are part of the control signals from the stack bus controller 410. Four operation modes, PASSTHROUGH, INVERTED, FLOATED, and PRECHARGE are supported.</p><p id="p0078" num="0078">In the FLOATED mode, all four branches are disabled. This is accomplished by having the signals PINV = 1, NINV = 0, PDIR = 1, NDIR = 0, which are also the default values. In the PASSTHROUGH mode, when MTCH = 0, it will require PBUS = 0. This is accomplished by only enabling the pull-down branch with n-transistors 535 and 536, with all control signals at their default values except for NDIR = 1. When MTCH = 1, it will require PBUS = 1. This is accomplished by only enabling the pull-up branch with p-transistors 533 and 534, with all control signals at their default values except for PINV = 0. In the INVERTED mode, when MTCH = 0, it will require PBUS = 1. This is accomplished by only enabling the pull-up branch with p-transistors 531 and 532, with all control signals at their default values except for PDIR = 0. When MTCH = 1, it will require PBUS = 0. This is accomplished by only enabling the pull-down branch with n-transistors 537 and 538, with all control signals at their default values except for NINV = 1. In the PRECHARGE mode, the control signals settings of PDIR = 0 and PINV = 0 will either enable the pull-up branch with p-transistors 531 and 532 when MTCH = 0 or the pull-up branch with p-transistors 533 and 534 when MTCH = 1.</p><p id="p0079" num="0079">Common processor operations are developed more fully in <patcit id="pcit0036" dnum="US02653604A"><text>U.S. patent application number 11/026,536, December 29, 2004</text></patcit> (published as <patcit id="pcit0037" dnum="US2006140057A"><text>US 2006/140057</text></patcit>).<!-- EPO <DP n="26"> --></p><heading id="h0008"><u>Use of Data Latches in Cache Operations</u></heading><p id="p0080" num="0080">Embodiments of the present invention can make use of the data latches of the read/write stacks described above in <figref idrefs="f0011">FIG. 10</figref> for cache operations that will data in and out while the internal memory is doing other operations such as read, write, or erase. In the above-described architectures, data latches are shared by a number of physical pages. For example, as on the read/write stacks of the bit lines, shared by all of the word lines, so while one operation is going on, if any of these latches are free, they can cache data for future operations in the same or another word line, saving transfer time as this can be hidden behind another operation. This can improve performance by increasing the amount of pipelining of different operations or phases of operations. In one example, in a cache program operations, while programming one page of data another page of data can be loaded in, saving on transfer time. For another example, in one exemplary embodiment, a read operation on one word line is inserted into a write operation on another word line, allowing the data from the read to be transferred out of the memory while the data write continues on.</p><p id="p0081" num="0081">Note that this allows data from another page in the same block, but on a different word line, to be toggled out (to, for example, do an ECC operation) while the write or other operation is going on for the first page of data. This inter-phase pipelining of operations allows the time needed for the data transfer to be hidden behind the operation on the first page of data. More generally, this allows a portion of one operation to be inserted between phases of another, typically longer, operation. Another example would be to insert a sensing operation between phases of, say, an erase operation, such as before an erase pulse or before a soft programming phase used as the later part of the erase.</p><p id="p0082" num="0082">To make the relative times needed for some of the operations discussed, a set of exemplary time values for the system described above can be take as:
<ul><li>Data write: -700µs (lower page∼600µs, upper page 800µs)</li><li>Binary data write: ∼200µs</li><li>Erase: ∼2,500µs<!-- EPO <DP n="27"> --></li><li>Read: ∼20-40µs</li><li>Read and toggle out data: 2KB data, ∼80µs; 4K.13∼160µs; 8KB∼320µs</li></ul>
These values can be used for reference to give an idea of the relative times involved for the timing diagrams below. If have a long operation with different phases, a primary aspect will interpose in a quicker operation using the shared latches of the read/write stacks if latches available. For example, a read can be inserted into a program or erase operation, or a binary program can be inserted into an erase. The primary exemplary embodiments will toggle data in and/or out for one page during a program operation for another page that shares the same read write stacks, where, for example, a read of the data to be toggled out and modified is inserted into the verify phase of the data write.</p><p id="p0083" num="0083">The availability of open data latches can arise in a number of ways. Generally, for a memory storing n bits per cell, n such data latches will be needed for each bit line; however, not all of these latches are needed at all times. For example, in a two-bit per cell memory storing data in an upper page/lower page format, two data latches will be needed while programming the lower page. More generally, for memories storing multiple pages, all of the latches will be needed only when programming the highest page. This leaves the other latches available for cache operations. Further, even while writing the highest page, as the various states are removed from the verify phase of the write operation, latches will free up. Specifically, once only the highest state remains to be verified, only a single latch is needed for verification purposes and the others may be used for cache operations.</p><p id="p0084" num="0084">The following discussion will be based on a four state memory storing two-bits per cell and having two latches for data on each bit line and one additional latch for quick pass write, as described in U.S. patent application entitled "Use of Data Latches in Multi-Phase Programming of Non-Volatile Memories" filed concurrently with the present application that was referred to above. The operations of writing the lower page, or erasing, or doing a post erase soft program are basically a binary operation and have one of the data latches free, which can use it to cache data. Similarly, where doing an upper page or full sequence write, once all but the highest level has verified, only a single state needs to verify and the memory can free<!-- EPO <DP n="28"> --> up a latch that can be used to cache data. An example of how this can be used is that when programming one page, such as in a copy operation, a read of another page that shares the same set of data latches, such as another word line on the same set of bit lines, can be slipped in during the verify phase of the write. The address can then be switched to the page being written, allowing the write process to pick up where it left off without having to restart. While the write continues, the data cached during the interpolated read can be toggled out, checked or modified and transferred back to be present for writing back in once the earlier write operation completes. This sort cache operation allows the toggling out and modification of the second page of data to be hidden behind the programming of the first page.</p><p id="p0085" num="0085">As a first example, a cache program operation for a two-bit memory operating in single page (lower page/upper page format) program mode. <figref idrefs="f0014">FIG. 13</figref> is a simplified version of <figref idrefs="f0011">FIG. 10</figref> that shows some specific elements that are relevant to the present discussion in a two-bit embodiment, the other elements being suppressed to simplify the discussion. These include data latch DL0 434-0, which is connected Data I/O line 231, data latch DL1 434-1, connected to common processor 500 by line 423, data latch DL2 434-2, commonly connected with the other data latches by line 435, and sense amp data latch DLS 214, which is connected to common processor 500 by line 422. The various elements of <figref idrefs="f0014">FIG. 13</figref> are labeled according to their disposition during the programming of the lower page. The latch DL2 434-2 is used for the lower verify (VL) in quick pass write mode, as is described in U.S. patent application entitled "Use of Data Latches in Multi-Phase Programming of Non-Volatile Memories" filed concurrently with the present application; the inclusion of the register, and of using quick pass write when it is included, are optional, but the exemplary embodiment will include this register.</p><p id="p0086" num="0086">The programming of the lower page can include the following steps:
<ol><li>(1) The process begins by resetting data latches DL0 434-0 the default value "1". This convention is used to simplify partial page programming as cells in a selected row that are not to be programmed will be program inhibited.</li><li>(2) Program data is supplied to DL0 434-0 along I/O line 231.<!-- EPO <DP n="29"> --></li><li>(3) The program data will be transferred to DL1 434-1 and DL2 434-2 (if this latch is included and quick pass write is implemented).</li><li>(4) Once the program data is transferred to DL 1 434-1, data latch DL0 434-0 can be reset to "1" and, during program time, the next data page can be loaded to DL0 434-0 along I/O line 231, allowing the caching of a second page while a first page is being written.</li><li>(5) Once the first page is loaded into DL1 434-1, programming can begin. DL1 434-1 data is used for lockout of the cell from further programming. DL2 434-2 data is used for the lower verify lockout that governs the transition to the second phase of quick pass write, as described in U.S. patent application entitled "Use of Data Latches in Multi-Phase Programming of Non-Volatile Memories" filed concurrently with the present application.</li><li>(6) Once programming begins, after a programming pulse, the result of the lower verify is used to update DL2 434-2; the result of the higher verify is used to update DL1 434-1. (This discussion is based on the "conventional" coding, where the lower page programming is to the A state. This, and other codings are discussed further in U.S. patent applications entitled "Use of Data Latches in Multi-Phase Programming of Non-Volatile Memories" filed concurrently with the present application and entitled "Non-Volatile Memory and Method with Power-Saving Read and Program-Verify Operations", filed March 16, 2005. The extension of the present discussion to other codings follows readily.)</li><li>(7) In determining of whether programming is complete, only the DL1 434-1 registers of the cells of row (or appropriate physical unit of program) are checked.</li></ol></p><p id="p0087" num="0087">Once the lower page is written, the upper page can be programmed. <figref idrefs="f0014">FIG. 14</figref> shows the same elements as <figref idrefs="f0014">FIG. 13</figref>, but indicates the latch assignment for upper page program where the lower page data is read in. (The description again uses conventional coding, so that the programming of the upper page is to the B and C states.) The programming of the upper page can include the following steps:
<ol><li>(1) Once the lower page finishes programming, the upper page (or next page) write will begin with a signal from the state machine controller where the (unexecuted) cache program commands are kept.<!-- EPO <DP n="30"> --></li><li>(2) The program data will be transferred from DL0 434-0 (where it was loaded into in step (3) during lower page write) to DL1 434-1 and DL2 434-2.</li><li>(3) The lower page data will be read in from the array and placed into DL0 434-0.</li><li>(4) DL1 434-1 and DL2 434-2 are again respectively used for the verify high and verify low lockout data. Latch DL0 434-0 (holding the lower page data) is checked as program reference data, but is not updated with the verify results.</li><li>(5) As part of verifying the B state, after sensing at the lower verify VBL, the data will be updated in DL2 434-2 accordingly, with DL1 434-1 data being updated with the high verify VBH results. Similarly, the C verify will have corresponding commands to update latches DL2 434-2 and DL1 434-1 with the respective VCL and VCH results.</li><li>(6) Once the B data is completed, then the lower page data (held in DL0 434-0 for reference) is not needed as only the verify for the C state needs to be performed. DL0 434-0 is reset to "1" and another page of program data can be loaded in from I/O line 231 and cached in latch DL0 434-0. The common processor 500 can set an indication that that only the C state is to be verified.</li><li>(7) In determining of whether upper page programming is completed, for the B state, both of latches DL1 434-1 and DL0 434-0 are checked. Once the cells being programmed to the B state and only the C state is being verified, only the latch DL1 434-1 data needs to be checked to see if there are any bits not programmed.</li></ol></p><p id="p0088" num="0088">Note that under this arrangement, in step 6, the latch DL0 434-0 is no longer required and can be used to cache data for the next programming operation. Additionally, in embodiments using quick pass write, once the second, slowly programming phase is entered, the latch DL2 434-2 could also be made available for caching data, although, in practice, it is often the case that this is only available in this way for a fairly short time period that does not justify the additional overhead that is often required to implement this feature.</p><p id="p0089" num="0089"><figref idrefs="f0015">FIG. 15</figref> can be used to illustrate many of the aspects of cache program in the single page mode that has been described in the last few paragraphs. <figref idrefs="f0015">FIG. 15</figref> shows the relative timing of what events are occurring internally to the memory (the<!-- EPO <DP n="31"> --> lower "True Busy" line) and as seen from external to the memory (the upper "Cache Busy" line).</p><p id="p0090" num="0090">At time to the lower page to be programmed onto the selected word line (WLn) is loaded into the memory. This assumes the first lower page of data has not been previously cached, as it will be for the subsequent pages. At time <i>t<sub>1</sub></i> the lower page is finished loading and the memory begins to write it. Since this is equivalent to a binary operation at this point, only the state A needs to be verified ("pvfyA") and the data latch DL0 434-0 is available to receive the next page of data, here taken as the upper pages to be programmed into WLn, at time <i>t<sub>2</sub></i>, which is consequently cached in latch DL0 434-0 during the programming of the lower page. The upper page finishes loading at time <i>t<sub>3</sub></i> and can be programmed as soon as the lower page finishes at <i>t<sub>4</sub></i>. Under this arrangement, although all of the data (lower and upper page) to be written into physical unit of programming (here, word line WLn), the memory must wait from time <i>t<sub>3</sub></i> to time <i>t<sub>4</sub></i> before the upper page data can be written, unlike the full sequence embodiment described below.</p><p id="p0091" num="0091">The programming of the upper page begins at time <i>t<sub>d</sub></i>, where initially only the B state is verified ("pvfyB"), the C state being added at <i>t<sub>5</sub></i> ("pvfyB/C"). Once the B state is no longer being verified at <i>t<sub>6</sub>,</i> only the C state needs to be verified ("pvfyC") and the latch DL0 434-0 is freed up. This allows the next data set to be cached while the upper page finishes programming.</p><p id="p0092" num="0092">As noted, according to the single page algorithm with cache program, as shown in <figref idrefs="f0015">FIG. 15</figref>, even though the upper page data may be available at time <i>t<sub>3</sub></i>, the memory will wait until time <i>t<sub>4</sub></i> before starting to write this data. In a conversion to a full sequence program operation, such as is developed more fully in <patcit id="pcit0038" dnum="US013125A"><text>U.S. patent application 11/013,125</text></patcit> (<patcit id="pcit0039" dnum="US7120051B"><text>granted as US 7,120,051</text></patcit>), once the upper page is available the upper and lower page data can be programmed concurrently.</p><p id="p0093" num="0093">The algorithm for cache program in full sequence (low to full conversion) write begins with lower page program as above. Consequently, steps (1)-(4) are as for the lower page process in single page program mode:<!-- EPO <DP n="32"> -->
<ol><li>(1) The process begins by resetting data latches DL0 434-0 the default value "1". This convention is used to simplify partial page programming as cells in a selected row that are not to be programmed will be program inhibited.</li><li>(2) Program data is supplied to DL0 434-0 along I/O line 231.</li><li>(3) The program data will be transferred to DL1 434-1 and DL2 434-2 (if this latch is included and quick pass write is implemented).</li><li>(4) Once the program data is transferred to DL 1 434-1, data latch DL0 434-0 can be reset to "1" and, during program time, the next data page can be loaded to DL0 434-0 along I/O line 231, allowing the caching of a second page while a first page is being written.
<br/>
Once the second page of data is loaded, if correspond to the upper of the lower page being written and the lower page is not yet finished programming, the conversion to full sequence write can be implemented. This discussion focuses on the use of the data latches in such an algorithm, with many of the other details being developed more full in co-pending, commonly assigned <patcit id="pcit0040" dnum="US013125A"><text>U.S. patent application 11/013,125</text></patcit> (granted as <patcit id="pcit0041" dnum="US7120051B"><text>US 7,120,051</text></patcit>).
</li><li>(5) After the upper page data is loaded into latch DL0 434-0, a judgment will be done in the address block to check if the 2 pages are on the same word line and the same block, with one page is the lower page and one is upper page. If so, then the program state machine will trigger a lower page program to full sequence program conversion if this is allowed. After any pending verify is complete, the transition is then effected.</li><li>(6) Some operation parameters will be typically be changed when the program sequence changed from lower page to full sequence. In the exemplary embodiment these include:
<ol><li>(i) Maximum program loop for the number of pulse verify cycles will be changed from that of the lower page algorithm to that of the full sequence if the lower page data has not been locked out, but the number of program loops completed will not be reset by the conversion.</li><li>(ii) As shown in <figref idrefs="f0015">FIG. 16</figref>, the programming waveform starts with the value VPGM_L used in the lower page programming process. If the programming waveform has progressed to where it exceeds the beginning value VPGM_U used in<!-- EPO <DP n="33"> --> the upper page process, at conversion to full sequence, the staircase will drop back down to VPGM_U prior to continuing up the staircase.</li><li>(iii) The parameters determining the step size and maximum value of the program pulse are not changed.</li></ol></li><li>(7) A full sequence read of the current state of the memory cells should be performed to guarantee the right data will be programmed for multi-level coding. This ensures that states that may have formerly locked out in the lower page programming, but which require further programming to take account of their upper page data, are not program inhibited when the full sequence begins.</li><li>(8) If quick pass write is activated, the data of latch DL2 434-2 will be updated as well to reflect the upper page program data, since this was formerly based on the lower verify for only the A state.</li><li>(9) The programming then resumes with the multi-level, full sequence program algorithm. If the program waveform in the lower page process has increased beyond the upper page starting level, the waveform is stepped back to this level at conversion time, as shown in <figref idrefs="f0015">FIG. 16</figref>.</li></ol></p><p id="p0094" num="0094"><figref idrefs="f0016">FIG. 17</figref> is a schematic representation of the relative times involved in the lower page to full sequence conversion write process. Up until time <i>t<sub>3</sub></i>, the process is as described above for the process in <figref idrefs="f0015">FIG. 15</figref>. At <i>t<sub>3</sub></i> the upper page of data has been loaded and the transition is made to the full sequence algorithm the verification process is switched to include the B states with the A states. Once all of the A states lock out, the verify process switches to checking for the B and C states at time <i>t<sub>4</sub>.</i> Once the B states have verified at <i>t<sub>5</sub></i>, only the C state needs to be checked and a register can be freed up to load the next data to be programmed, such as the lower page on the next word line (WL<sub>n+1</sub>) as indicated on the Cache Busy line. At time <i>t<sub>6</sub></i> this next data set has been cached and one the programming of the C data for the previous set concludes at <i>t<sub>7</sub></i>, this next data set begins programming. Additionally, while the (here) lower page on word line WL<sub>n+1</sub> is programming, the next data (such as the corresponding upper page data) can be loaded into the open latch DL0 434-0.</p><p id="p0095" num="0095">During the full sequence write, a status report is implemented in a way that gives lower page and upper page status independently. At the end of the program<!-- EPO <DP n="34"> --> sequence, if there are unfinished bits, a scan of physical page can be performed. A first scan can check latch DL0 434-0 for unfinished upper page data, a second scan can check DL1 434-1 for unfinished lower page data. Since, the verification of the B state will change both DL0 434-0 and DL1 434-1 data, an A state verification should be performed in the way that DL1 434-1 data "0" will be changed to "1" if the bit's threshold value is higher than the A verify level. This post verify will check on whether any under programmed B levels are passing at the A level; if they are passing at the A level, then the error is only on upper page and not on lower page; if they are not passing at the A level, then both lower and upper pages have error.</p><p id="p0096" num="0096">If the cache program algorithm is used, after the A and B data are programmed the C state will be transferred to latch DL1 434-1 to finish programming. In this case, the scan of latch is not necessary for lower page, because the lower page will have already passed program without any failed bits.</p><p id="p0097" num="0097">Another set of arrangements relate to page copy operations, where a data set is relocated from one location to another. Various aspects of data revocation operations are described in U.S. patent applications number <patcit id="pcit0042" dnum="US10846289B"><text>US 10/846,289 filed May 13, 2004</text></patcit> (granted as <patcit id="pcit0043" dnum="US7490283B"><text>US 7,490,283</text></patcit>); number <patcit id="pcit0044" dnum="US11022462B"><text>11/022,462, December 21, 2004</text></patcit> (granted as <patcit id="pcit0045" dnum="US7409473B"><text>US 7,409,473</text></patcit>); and number <patcit id="pcit0046" dnum="US10915039B"><text>US 10/915,039, filed August 9, 2004</text></patcit> (published as <patcit id="pcit0047" dnum="US2006031593A"><text>US 2006/031593</text></patcit>); and <patcit id="pcit0048" dnum="US6266273B"><text>U.S. patent number 6,266,273</text></patcit>. When data is copied from one location to another, the data is often toggled out to be checked (%r error, for example), updated (such as updating a header), or both (such correcting detected error). Such transfers are also to consolidate date in garbage collection operations. A data read to an open register can be interpolated during the verify phase of a write operation, with this cached data then being transferred out of the memory device as the write operation continues, allowing the time for toggling the data out to hide behind the write operation.</p><p id="p0098" num="0098">The following presents two exemplary embodiments of a cache page copy operation. In both cases, an implementation that uses a quick pass write implementation is described. <figref idrefs="f0016">FIG. 18</figref> indicates the disposition of the exemplary<!-- EPO <DP n="35"> --> arrangement of latches as the process progresses.</p><p id="p0099" num="0099">The first version of cache page copy will write to a lower page and can include the following steps, where read addresses are labeled M, M+1, ..., and write addresses are labeled N, N+1, ..:
<ul><li>(1) The page to be copied ("page M") is read into latch DL1 434-1. This can be either an upper or lower page of data</li><li>(2) Page M is then transferred into DL0 434-0.</li><li>(3) The data in DL0 434-0 is then toggle out and modified, after which it is transferred back into the latch.</li><li>(4) The program sequence can then begin. After data to be written into the lower page N is transferred to DL1 434-1 and DL2 434-2, the latch DL0 434-0 is ready for cache data. This lower page will be programmed. For this embodiment, the program state machine will stop here.</li><li>(5) The next page to be copied is then read into DL0 434-0. Programming can then resume. The state machine, stopped at the end of step (4), will restart the program sequence from the beginning.</li><li>(6) Programming continues until the lower page finishes.</li></ul></p><p id="p0100" num="0100">The copy destination page address will determine whether a write is to a lower or an upper page. If the program address is an upper page address, then the programming sequence will not be stopped until the programming finishes and the read of step (5) will be executed after the write is complete.</p><p id="p0101" num="0101">In a second cache page copy method, the program/verify process can be paused to insert a read operation and then restart the write operation, picking up at the point where it left off. The data that was read during this interleaved sensing operation can then be toggled out while the resumed write operation continues on. Also, this second process allows for the page copy mechanism to be used in an upper page or full sequence write process once only the C state is being verified and one<!-- EPO <DP n="36"> --> latch on each bit line opens up. The second cache page copy operation begins with the same first three steps as in the first case, but then differs. It can include the following steps:
<ul><li>(1) The page to be copied ("page M") is read into latch DL1 434-1. This can be either a lower or upper page</li><li>(2) The data from page M is then transferred into DL0 434-0. (As before, N, etc. will denote a write address, M, etc., for a read address.)</li><li>(3) The data in DL0 434-0 is then toggled out, modified, and then transferred back to the latch.</li><li>(4) The state machine program will go to an infinite wait state until a read command is entered and then a read of another page, say the next page M+1, to latch DL0 434-0 will begin.</li><li>(5) Once the read of step (4) is complete, the address is switched back to word line and block address to program the data in steps (1-3) into page N (here, a lower page) and the programming is resumed.</li><li>(6) After the read of page M+1 is finished, the data can be toggled out, modified, and returned. Once the process is complete, the write can be converted to a full sequence operation if the two pages are the corresponding upper and lower pages on the same WL.</li><li>(7) Once the A and B levels are done in the full sequence write, the data in DL0 434-0 will be transferred to DL1 434-1, as in the normal cache program described earlier, and a read command for another page (e.g., page M+2) can be issued. If there is not a single page to full sequence conversion, the lower page will finish the writing and then the upper page will start. After the B level state is done completely, the same DL0 434-0 to DL1 434-1 data transfer will occur, and the state machine will go into state of waiting for the read command for page M+2.</li><li>(8) Once the read command arrives, the address is switched to the read address and the next page (page M+2) is read out.<!-- EPO <DP n="37"> --></li><li>(9) Once the read is complete, the address will be switched back to previous upper page address (program address N+1) until the write finishes.</li></ul></p><p id="p0102" num="0102">As noted above, the exemplary embodiments include the latch DL2 434-2 used for the lower verify of the quick pass write technique in addition to the latches DL0 434-0 and DL1 434-1 used in holding the (here, 2 bits) of data that can be programmed into each of the memory cells. Once the lower verify is passed, the latch DL2 434-2 may also be freed up and used to cache data, although this is not done in the exemplary embodiments.</p><p id="p0103" num="0103"><figref idrefs="f0017">FIGs. 19A</figref> and <figref idrefs="f0018">19B</figref> illustrate the relative timing of the second cache page copy method, where <figref idrefs="f0018">FIG. 19B</figref> illustrates the algorithm with the full sequence write conversion and <figref idrefs="f0017">FIG. 19A</figref> illustrates the algorithm without. (Both <figref idrefs="f0017">FIGs. 19A</figref> and <figref idrefs="f0018">19B</figref> are composed of two parts, the first, upper part beginning at the broken vertical line A, corresponding to <i>t<sub>0</sub></i>, and ending with the broken vertical line B, corresponding to <i>t<sub>5</sub></i>; the second, lower part is a continuation of the upper portion and begins with the broken vertical line B, corresponding to <i>t<sub>5</sub></i>. In both cases the line B at time <i>t<sub>5</sub></i> is same in the upper portion as in the lower portion, being just a seam in two parts allowing it to be displayed on two lines.)</p><p id="p0104" num="0104"><figref idrefs="f0017">FIG. 19A</figref> shows a process that starts with reading of a first page (page M) that is taken to be a lower page in this example, assumes no data has previously been cached, and operates in single page mode, waiting until the lower page has finished writing before beginning to write the upper page. The process starts at time <i>t<sub>0</sub></i> with a read of the page M (Sense page M (L)), which here is a lower that is sensed by a read at the A and C levels in this coding. At time at time <i>t<sub>1</sub></i> the read is complete and page M can be toggled out and checked or modified. Beginning at time <i>t<sub>2</sub></i> a next page (here page M+1, the upper page corresponding to the same physical as lower page M) is sensed by reading at the B level, a process that finishes at time <i>t<sub>3</sub></i>. At this point, the first page (originating from Page M) (lower) is ready to be programmed back into the memory at page N and the data read from page M+1 is being held in a latch and can be transferred out to be modified/checked. Both of these processes can start at the same time, here <i>t<sub>3</sub></i>. Using the typical time values described above, the data from page<!-- EPO <DP n="38"> --> M+1 has been toggled out and modified by time <i>t<sub>4</sub></i>; however, for the embodiment not implementing a full sequence conversion, the memory will wait until page N finishes at time <i>t<sub>5</sub></i> to begin writing the second read page of data (originating from Page M+1) into page N+1.</p><p id="p0105" num="0105">As page N+1 is an upper page, its write begins initially with a verification at the B level, the C level being added at <i>t<sub>6</sub></i>. Once the storage elements having a target stated all lock out (or the maximum count is reached) at time <i>t<sub>7</sub></i>, the B state verification is dropped. As described above this allows a data latch to be freed up, an ongoing write operation is suspended, a reading operation (at a different address than the suspended program/verify operation) is interposed, the write then resumes where it left off, and the data sensed the interposed write operation can be toggled out while the resumed write operation runs on.</p><p id="p0106" num="0106">At time <i>t<sub>7</sub></i> the interposed write operation is performed for the, here, lower page M+2. This sensing is finished at time <i>t<sub>8</sub></i> and the write of page N+1 picks back up and the data from page M+2 is concurrently toggled out and modified. In this example, page N+1 finishes programming at time <i>t<sub>9</sub></i> before page M+2 is finished at time <i>t<sub>10</sub></i>. At time <i>t<sub>10</sub></i> a write of the data originating from page M+2 could begin; however, in this embodiment, instead a read of page M+3 is first executed, allowing for this page's data to be toggled out and the modification to be hidden behind the writing of the data originating from page M+2 into page N+2, beginning at rime <i>t<sub>11</sub></i>. The process then continues on as in the earlier parts of the diagram, but with the page numbers shifted, with time <i>t<sub>11</sub></i> corresponding to time <i>t<sub>3</sub></i>, time <i>t<sub>12</sub></i> corresponding to time <i>t<sub>4</sub></i>, and so on until the copy process is stopped.</p><p id="p0107" num="0107"><figref idrefs="f0018">FIG. 19B</figref> again shows a process that starts with reading of a lower page, page M that is taken to be a lower page, and assumes no data has previously been cached. <figref idrefs="f0018">FIG. 19B</figref> differs from <figref idrefs="f0017">FIG. 19A</figref> by implementing a conversion to full sequence write at time <i>t<sub>4</sub></i>. This roughly speeds up the process by the time (<i>t<sub>5</sub>-t<sub>4</sub></i>) of <figref idrefs="f0017">FIG. 19A</figref>. At time <i>t<sub>4</sub></i> (=<i>t<sub>5</sub></i> in <figref idrefs="f0017">FIG. 19A</figref>), the various changes related to the full sequence conversion are implemented as described previously. Otherwise, the<!-- EPO <DP n="39"> --> process is similar to that of <figref idrefs="f0017">FIG. 19A</figref>, including those aspects found between times <i>t<sub>7</sub></i> and <i>t<sub>12</sub></i>.</p><p id="p0108" num="0108">In both the page copy processes and the other techniques described here that involve writing data, which states are verified at a given time can be selected intelligently, along the lines describe in U.S. patent publication number <patcit id="pcit0049" dnum="US20040109362A1"><text>US-2004-0109362-A1</text></patcit>. For example, in the full sequence write, the write process can begin verifying only the A level. After ever A verify, it is checked to see whether any bits have passed. If so, the B level can be added to the verify phase. The A level verify will be removed after all storage units with it as their target values verify (or except a maximum count based on a settable parameter). Similarly, after the verifications at the B level, a verify of the C level can be added, with the B level verify being removed after all storage units with it as their target values verify (or except a maximum count based on a settable parameter).</p><p id="p0109" num="0109">Programming operation with background data caching for other operations is described with respect to a preferred multi-state coding.</p><heading id="h0009"><u>Exemplary Preferred "LM" Coding for a 4-state Memory</u></heading><p id="p0110" num="0110"><figref idrefs="f0019">FIG. 20</figref> illustrates the programming and reading of the 4-state memory encoded with a 2-bit logical code ("LM" code). This code provides fault-tolerance and alleviates the neighboring cell coupling due to the Yupin Effect. <figref idrefs="f0019">FIG. 20</figref> illustrates threshold voltage distributions of the 4-state memory array when each memory cell stores two bits of data using the LM code. The LM coding differs from the conventional Gray code in that the upper and lower bits are reversed for states "A" and "C". The "LM" code has been disclosed in <patcit id="pcit0050" dnum="US6657891B"><text>U.S. Patent No. 6,657,891</text></patcit> and is advantageous in reducing the field-effect coupling between adjacent floating gates by avoiding program operations that require a large change in charges.</p><p id="p0111" num="0111">The coding is designed such that the 2 bits, lower and upper, may be programmed and read separately. When programming the lower bit, the threshold level of the cell either remains in the unprogrammed region or is moved to a "lower middle" region of the threshold window. When programming the upper bit, the<!-- EPO <DP n="40"> --> threshold level in either of these two regions is further advanced to a slightly higher level not more than one quarter of the threshold window.</p><heading id="h0010"><b><u>PSEUDO AND USER DRIVEN RANDOMIZATION OF DATA PATTERNS</u></b></heading><p id="p0112" num="0112">Various embodiments of a memory EEPROM or chip and method of randomization seek to minimize the problems that result from repetitive data storage patterns such as increased NAND string resistance, decreased endurance and reliability, and unwanted coupling. The pseudo randomization techniques of the present invention are practical and in terms of data processing capacity, they are not costly to implement.</p><p id="p0113" num="0113">The present invention includes different embodiments and methods implementing pseudo-randomization and true user based randomization of the stored data on the flash memory chip. All the embodiments have the advantage of requiring only simple and small circuit modifications to be implemented in a flash EEPROM. This is noteworthy because the randomization techniques and circuitry are not computationally intensive and are implemented with little if any performance penalty. The solutions of the present invention are also flexible in that the randomization can be easily enabled or disabled at any time. Furthermore, the pattern of pseudo randomization utilized in certain embodiments can be varied in many ways and easily changed in time.</p><p id="p0114" num="0114"><figref idrefs="f0020">FIG. 21</figref> illustrates the main components of EEPROM or memory chip 600 that are relevant to the randomization process. Chip 600 comprises memory array 602, register(s) 610 in the peripheral circuitry, and multiplexer 614. Other components of chip 600 will be illustrated in and described in reference to the additional figures. Register 610 is capable of holding multiple bits and may comprise multiple registers. In some embodiments it functions as a shift register. Memory array 602 comprises a hidden area 604 and user data area 606. The hidden area may be used to store firmware and other overhead data such as memory operation control codes. In a NAND architecture, as was described earlier, the data is organized in blocks, each of which may comprise multiple pages of data. In certain embodiments, neither the register 610, nor the multiplexer 614 will be present.<!-- EPO <DP n="41"> --></p><p id="p0115" num="0115">The various embodiments of the present invention will reduce or eliminate long term and repeated storage of specific data patterns which can cause program disturbs or user read disturbs. It does so by varying the encoding of the data by either pseudo random mechanisms or by user triggered randomization. Because the timing of user activity is completely unpredictable, using the activity as a trigger results in a truly random sequence of encoding schemes. Each of the embodiments will also reduce NAND string resistance effect, increase memory endurance and reliability, and reduce the problem of floating gate to floating gate coupling.</p><p id="p0116" num="0116">Each of the embodiments requires only minimal modification to the circuitry of the flash EEPROM, yet at the same time will drastically increase the randomness of the data storage, and therefore increase the performance of the EEPROM. The randomization of the data may be either enabled or disabled easily within the array. Further, the sequence responsible for the pseudo randomization may continually change, providing flexibility within the system.</p><p id="p0117" num="0117">In one embodiment, a code or sequence of bits, which can be either a zero or one, is stored in the hidden area 604 of array 602. The portion of hidden area 604 where the code is stored may be referred to as a "ROM block." The code may comprise 2 or more bits, but preferably comprises 17 or more bits. The more bits, the greater the randomization will be. Upon power up of the chip 600, the value is loaded into register 610. Each bit in the register is assigned to a specific page address. Each bit is compared to the page address of a page, and based on the comparison, the encoding of the data of the page will be inverted or will remain the same (passed) for the page. For example, a 0 value for the bit may be used to indicate that the encoding scheme of the data will remain the same, whereas a value of 1 in the register may indicate that the encoding of data within a page will be inverted. If the code comprises less bits than the number of pages within a block, the code may be applied to more than one group of one or more pages. In other words, the code can be used repeatedly in series until all pages are compared. The code may also be changed between cycles. Alternatively, the code may be multiplexed through multiplexer 614 so that one bit of one code will determine the encoding of multiple pages of data stored in the user data area 602. Each bit of the code can be referred to as a polarity<!-- EPO <DP n="42"> --> bit, as it acts to change the polarity of the encoding employed for some portion of user data. This is depicted in <figref idrefs="f0021">FIG. 22A</figref>. In this case, the encoding is based on the page address, such that it is known that pages 0, N have a polarity of 1, whereas pages 1, n+1 have a polarity 0, and pages 2, n+2 have polarity 1 and so forth. Therefore, in an embodiment where the encoding is based upon the page address, it is not necessary to store the polarity bit with the page, although it may be done for redundancy purposes.</p><p id="p0118" num="0118">Table 1, seen below and reproduced as <figref idrefs="f0021">FIG. 22B</figref>, illustrates the application of the polarity bits of the code in register 610 to portions of user data. While any portion of user data may be compared and associated with a particular polarity bit, the preferred embodiments described illustrate a page as the basic unit.
<tables id="tabl0001" num="0001"><table frame="all"><title><i>Table 1</i></title><tgroup cols="18"><colspec colnum="1" colname="col1" colwidth="23mm"/><colspec colnum="2" colname="col2" colwidth="8mm"/><colspec colnum="3" colname="col3" colwidth="8mm"/><colspec colnum="4" colname="col4" colwidth="8mm"/><colspec colnum="5" colname="col5" colwidth="8mm"/><colspec colnum="6" colname="col6" colwidth="8mm"/><colspec colnum="7" colname="col7" colwidth="8mm"/><colspec colnum="8" colname="col8" colwidth="8mm"/><colspec colnum="9" colname="col9" colwidth="8mm"/><colspec colnum="10" colname="col10" colwidth="8mm"/><colspec colnum="11" colname="col11" colwidth="10mm"/><colspec colnum="12" colname="col12" colwidth="10mm"/><colspec colnum="13" colname="col13" colwidth="10mm"/><colspec colnum="14" colname="col14" colwidth="10mm"/><colspec colnum="15" colname="col15" colwidth="10mm"/><colspec colnum="16" colname="col16" colwidth="10mm"/><colspec colnum="17" colname="col17" colwidth="10mm"/><colspec colnum="18" colname="col18" colwidth="10mm"/><thead><row><entry valign="top">Register position</entry><entry valign="top">1</entry><entry valign="top">2</entry><entry valign="top">3</entry><entry valign="top">4</entry><entry valign="top">5</entry><entry valign="top">6</entry><entry valign="top">7</entry><entry valign="top">8</entry><entry valign="top">9</entry><entry valign="top">10</entry><entry valign="top">11</entry><entry valign="top">12</entry><entry valign="top">13</entry><entry valign="top">14</entry><entry valign="top">15</entry><entry valign="top">16</entry><entry valign="top">17</entry></row></thead><tbody><row><entry>Code (polarity bit)</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>0</entry><entry>0</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>1</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>0</entry></row><row><entry>UD Original encoding</entry><entry>0</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>0</entry></row><row><entry>UD Subsequent encoding</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>0</entry><entry>0</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>1</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>0</entry></row><row><entry>State</entry><entry namest="col2" nameend="col3" align="left">ER</entry><entry namest="col4" nameend="col5" align="left">ER</entry><entry namest="col6" nameend="col7" align="left">B</entry><entry namest="col8" nameend="col9" align="left">C</entry><entry namest="col10" nameend="col11" align="left">ER</entry><entry namest="col12" nameend="col13" align="left">A</entry><entry namest="col14" nameend="col15" align="left">C</entry><entry namest="col16" nameend="col17" align="left">B</entry><entry/></row></tbody></tgroup></table></tables></p><p id="p0119" num="0119">As seen in the table, each (polarity) bit of the code will determine whether the original encoding (data) of a bit will remain the same or will change. For example, looking at register position 1, the polarity code in that position has a value of 1. Thus, in an embodiment where a 1 indicates that the data will be inverted, an original bit of user data stored as a 0 will be inverted to a value of 1. The table illustrates a multi state cell, where 2 bits are used to define a state. The states are shown in <figref idrefs="f0019">FIG. 20</figref>, and as can be seen in <figref idrefs="f0019">FIG. 20</figref>, an upper and a lower bit define the states. In a 2 bit or 4 state memory cell of the type shown in <figref idrefs="f0019">FIG. 20</figref>, (1: 1) defines an erase ("ER") or un-programmed ("U") state; (0:1) defines state A, (0:0) defines state B, and (1:0) defines state C. The upper and lower bits may be physically located in a single memory cell. The same or a different code could be applied to another group<!-- EPO <DP n="43"> --> of data such that the group of data corresponding to bit 17 would be used in conjunction with the data corresponding to bit 1 of the next code applied to determine the state. Each polarity register will control the polarity for all the data on the corresponding page. The lower and upper bits are preferably located on the same physical wordlines. The example given in Table 1 illustrates the function of polarity bits to convert a simple pattern to random pattern(s) across many wordlines. The randomization is achieved on the data located on the same NAND chain structure, an example of which is provided in <figref idrefs="f0022">FIG. 22C</figref> to illustrate this concept.</p><p id="p0120" num="0120">In <figref idrefs="f0022">FIG. 22C</figref>, the lower and upper bits of a given cell are illustrated at each of the illustrated cells of the NAND string or chain. The NAND string shown is simply an example, and there may of course be more or less cells in a string, and structures different than that shown may be used with the present invention. For example, a cell storing 3, 4 or more bits may also be employed. Also, it should be remembered that the polarity bit preferably applies to a page or more of data, although application on the bit level is shown to illustrate the concept of bit inversion, especially in a multi state memory. In <figref idrefs="f0022">FIG. 22C</figref>, the polarity bits are applied to each bit of the user data, and the resulting user data, as inverted or passed by the polarity bit, is labeled as the saved data. The saved data is the data that will subsequently be written to the memory array and stored as a result of the randomization operation. As can be seen, the states indicated at the right of the figure are defined by the upper and lower bit of the cell. The "saved data" terminology employed in <figref idrefs="f0022">FIG. 22C</figref> corresponds to what is referred to as the "User Data (UD) subsequent encoding" in <i>Table 1</i> and <figref idrefs="f0021">FIG. 22B</figref>.</p><p id="p0121" num="0121">In another embodiment, register 610 is configured as a shift register. In such an embodiment, only one bit of the register will be used at a time, in contrast to the embodiment where all the bits of the code were used at a time. When a command is issued by a user, the shift register will shift to the next bit. The polarity bit used on the incoming user page will be from the last register output. This is preferably done on the rising edge of the command. The triggering command may be a program command, a cache program command, a read command, an erase command, or other user issued command. An example program command signal is<!-- EPO <DP n="44"> --> shown in <figref idrefs="f0023">FIG. 23B</figref>. The clock signal associated with the command is shown, and the instantiation of the command will be triggered by the user request, the timing and type of which is unpredictable and essentially random. <figref idrefs="f0023">FIG. 23A</figref> illustrates the clock signal associated with the user command as the one of the inputs that determines the polarity bit. The other input in the figure is the user data. The application of the polarity bit would invert or leave as is, the encoding of the data, as described previously.</p><p id="p0122" num="0122"><figref idrefs="f0023">FIG. 23C</figref> illustrates an example of control circuitry for the data inversion. The data path with the single inverter will result in inverting of the encoding, whereas the path with the two inverters in series will result in the data encoding scheme being unaltered. In such a case, the polarity bit associated with a group of data will be stored with that group of data. For example, as seen in <figref idrefs="f0023">FIG. 23D</figref>, for a page of data 630, the polarity bit 632 for the data in user area 636 would be programmed into the hidden area 634 of the page 630. When the page 630 is read, the polarity bit 632 will be transferred out and latched to control the output data, and will revert the encoding scheme back if it was inverted, as accomplished by the exemplary circuitry shown in <figref idrefs="f0023">FIG. 23E</figref>. In this way, the polarity of the page will be reverted to its original encoding.</p><p id="p0123" num="0123">The pattern of the code utilized by the shift register can vary and can be modified for different applications. If all bits are set to zero (in the case where zero indicates no change) then the randomization will be disabled. While the pattern of the bits in the register is pseudo random, the user behavior is unpredictable, and the resulting polarity at any given time is thus also unpredictable and random. Two examples of user behavior are as follows: 1) the user programs some pages and jumps to a different address to read or program some pages or to erase some blocks, then the returns back to the block where the last program occurred and continues to program more pages; and 2) the user programs all the pages sequentially without jumping to another address. In case 1, a new polarity bit can be triggered for each user command, whereas in case 2 the sequential programming will utilize and be based on one polarity bit. Therefore, even though the original data the user wishes to store may be the same for both cases, the final programmed data in the memory will<!-- EPO <DP n="45"> --> likely be different for at least some of the various individual pages and groups of pages in these 2 cases. Note that the EEPROM is typically controlled by a controller chip, and some of the actions of the "user" may be that of the controller chip.</p><p id="p0124" num="0124">In another embodiment, the polarity bit is also generated randomly as a result of a user command, such as the cache program operation described earlier. This embodiment utilizes two inputs that are not synchronized. The first is the timing of user commands, which as mentioned earlier is unpredictable. The second is a finite state machine clock. In certain memory systems, the finite state machine clock is only active at certain times (e.g. during cache operations), whereas in other systems it may always be active. This technique of this embodiment is available whenever the finite state machine clock of the memory system is active.</p><p id="p0125" num="0125">At the rising edge of the user command clock signal, the level or state of the finite state machine ("FSM") clock is referenced. The state may be either high or low, as seen in <figref idrefs="f0024">FIG. 24A</figref>. A low state may correspond to a polarity bit of zero (although the opposite correspondence is also possible). At time t=0, the FSM is low and thus the polarity bit would be zero, indicating no change of the data encoding, as mentioned previously. At time t=1, the FSM is high, and the polarity bit would be one, whereas at time t=3 it the FSM is again at a low state. In some embodiments, the polarity bit 632 is loaded into the hidden area 634 as soon as the executing command is issued and it is sensed. In other embodiments it may be temporarily stored in another memory of the system. <figref idrefs="f0024">FIG. 24B</figref> illustrates an exemplary circuit to determine the polarity bit as described above. The inverter would again be preferably be rising edge triggered.</p><p id="p0126" num="0126">While embodiments of the invention have been described, it should be understood that the present invention is not limited to these illustrative embodiments but is defined by the appended claims.</p></description><claims mxw-id="PCLM56984996" lang="DE" load-source="patent-office"><!-- EPO <DP n="49"> --><claim id="c-de-01-0001" num="0001"><claim-text>Speichereinrichtung (600), einen Flash-Speicher EEPROM umfassend, wobei das EEPROM umfasst:
<claim-text>ein Flash-Speicherarray (602), einen verdeckten Bereich (604) und einen Benutzerdatenbereich (606) umfassend; und</claim-text>
<claim-text>periphere Schaltungsanordnung, ein Multibit-Register (610) umfassend,</claim-text>
<claim-text><b>dadurch gekennzeichnet, dass</b>:
<claim-text>ein Zufalls- oder Pseudozufalls-Multibitcode im Register gespeichert wird,</claim-text><claim-text>die Speichereinrichtung (600) außerdem einen Komparator zum Vergleichen eines jeden Bits des Codes mit einer Seitenadresse einer Datenseite umfasst, um entweder das Codierschema der Seite zu invertieren oder das Codierschema unverändert zu lassen.</claim-text></claim-text></claim-text></claim><claim id="c-de-01-0002" num="0002"><claim-text>Speichereinrichtung nach Anspruch 1, worin eine Schaltung (310) dazu angepasst ist, den Code zuerst im verdeckten Bereich des Arrays zu speichern und dann in das Register zu transferieren.</claim-text></claim><claim id="c-de-01-0003" num="0003"><claim-text>Speichereinrichtung nach Anspruch 2, worin die Schaltung (310) dazu angepasst ist, den Code nach dem Einschalten des EEPROM in das Register zu transferieren.</claim-text></claim><claim id="c-de-01-0004" num="0004"><claim-text>Speichereinrichtung nach Anspruch 1, worin das EEPROM außerdem einen Multiplexer (614) umfasst und worin der Komparator für eine oder mehrere Seiten über den Multiplexer ein Polaritätsbit generiert.</claim-text></claim><claim id="c-de-01-0005" num="0005"><claim-text>Speichereinrichtung nach Anspruch 1, außerdem umfassend:
<claim-text>Taktsignal-Generatorschaltungen (310) zum Generieren eines Taktsignals einer Maschine endlicher Zustände und eines Befehlstaktsignals;</claim-text>
<claim-text>eine Taktreferenzschaltung zum Generieren eines Polaritätsbits durch Referenzieren des Taktsignals einer Maschine endlicher Zustände und des Befehlstaktsignals; und</claim-text>
<claim-text>Schaltungen, angepasst zum Anwenden eines ersten Codiertyps für einen ersten Wert des Polaritätsbits und eines zweiten Codiertyps für einen zweiten Wert des Polaritätsbits.</claim-text></claim-text></claim><claim id="c-de-01-0006" num="0006"><claim-text>Speichereinrichtung nach Anspruch 5, worin die Taktreferenzschaltung ein Polaritätsbit generiert durch Referenzieren des Taktsignals einer Maschine endlicher Zustände an der steigenden Flanke des Befehlstaktsignals.</claim-text></claim><claim id="c-de-01-0007" num="0007"><claim-text>Verfahren zum Speichern von Daten in einem nichtflüchtigen Speicher (600) mit einer Vielzahl von Datenseiten, Folgendes umfassend:
<claim-text>Speichern eines eine Vielzahl von Pseudozufalls- oder Zufallsbits umfassenden Codes im nichtflüchtigen Speicher, wobei jedes Bit der Vielzahl definiert, ob das Codieren von Daten einer Seite der Vielzahl zu invertieren ist oder unverändert bleibt;<!-- EPO <DP n="50"> --></claim-text>
<claim-text>Lesen des Codes aus dem nichtflüchtigen Speicher;</claim-text>
<claim-text>Transferieren des Codes aus dem nichtflüchtigen Speicher (604) in ein Register (610), das zum Speichern der Vielzahl von Bits des Codes zugewiesen ist;</claim-text>
<claim-text>Speichern des Codes im Register (610);</claim-text>
<claim-text>Erzeugen eines Polaritätssignals durch Vergleichen einer Seitenadresse einer Seite der Vielzahl von Seiten mit einem Bit des Codes für jedes Bit des Codes; und</claim-text>
<claim-text>Ändern der Codierung einer Teilmenge von Seiten der Vielzahl auf der Basis des generierten Polaritätssignals.</claim-text></claim-text></claim><claim id="c-de-01-0008" num="0008"><claim-text>Verfahren nach Anspruch 7, außerdem das Multiplexen des Polaritätssignals umfassend, sodass es auf eine Gruppe der Vielzahl von Seiten anwendbar ist und das Codieren der Gruppe durch ein einzelnes Bit des Codes bestimmt wird.</claim-text></claim><claim id="c-de-01-0009" num="0009"><claim-text>Verfahren nach Anspruch 7, worin der Code 17 oder mehr Bits umfasst.</claim-text></claim><claim id="c-de-01-0010" num="0010"><claim-text>Verfahren nach Anspruch 7, worin das Speichern des Codes im nichtflüchtigen Speicher das Speichern des Codes in einer verdeckten Partition (604) des nichtflüchtigen Speichers umfasst.</claim-text></claim><claim id="c-de-01-0011" num="0011"><claim-text>Verfahren nach Anspruch 7, worin das Lesen des Codes aus dem nichtflüchtigen Speicher während des Einschaltens des Speichers stattfindet.</claim-text></claim><claim id="c-de-01-0012" num="0012"><claim-text>Verfahren nach Anspruch 7, außerdem das Lesen von einer oder mehreren Seiten von Benutzerdaten umfassend, worin das Lesen das Bestimmen der Polarität einer jeden zu lesenden Seite durch die Seitenadresse umfasst.</claim-text></claim><claim id="c-de-01-0013" num="0013"><claim-text>Verfahren zum Implementieren von Randomisierung der gespeicherten Daten in einem nichtflüchtigen Speicher (600) mit einer Vielzahl von Datenseiten, Folgendes umfassend:
<claim-text>Empfangen eines Benutzerbefehls zum Programmieren oder Lesen der Benutzerdaten im Array; und</claim-text>
<claim-text><b>dadurch gekennzeichnet, dass</b>:
<claim-text>nach Empfang des Benutzerbefehls die Anwendung eines eine Vielzahl von Bits umfassenden Codes auf einen Block der Benutzerdaten getriggert wird, um das Codieren der Benutzerdaten zu randomisieren, wobei jedes der Bits des Codes bestimmt, ob eine Gruppe von einer oder mehreren Seiten des Blocks unverändert gespeichert wird oder vor dem Speichern invertiert wird.</claim-text></claim-text></claim-text></claim><claim id="c-de-01-0014" num="0014"><claim-text>Verfahren nah Anspruch 13, außerdem das Speichern des Codes zusammen mit den durch den Code manipulierten Benutzerdaten umfassend.</claim-text></claim><claim id="c-de-01-0015" num="0015"><claim-text>Verfahren nach Anspruch 13, worin der Code 17 oder mehr Bits umfasst.</claim-text></claim><claim id="c-de-01-0016" num="0016"><claim-text>Verfahren nach Anspruch 13, worin der Code zwischen Benutzerbefehlen aktualisiert wird.<!-- EPO <DP n="51"> --></claim-text></claim><claim id="c-de-01-0017" num="0017"><claim-text>Verfahren nach Anspruch 13, worin, falls der Code weniger Bits umfasst als die Anzahl von Seiten innerhalb eines Blocks, der Code auf mehr als eine Gruppe von einer oder mehreren Seiten angewendet wird.</claim-text></claim><claim id="c-de-01-0018" num="0018"><claim-text>Verfahren nach Anspruch 14, worin das Verfahren außerdem umfasst: das Lesen des für jedes Segment gespeicherten Codes und für jedes Segment das Rückbilden der Benutzerdaten auf einer Bit-um-Bit-Basis in das Codierschema, das vor Anwendung des Codes vorhanden war.</claim-text></claim></claims><claims mxw-id="PCLM56984997" lang="EN" load-source="patent-office"><!-- EPO <DP n="46"> --><claim id="c-en-01-0001" num="0001"><claim-text>A storage device (600) comprising a flash memory EEPROM, the EEPROM comprising:
<claim-text>a flash memory array (602) comprising a hidden area (604) and a user data area (606); and</claim-text>
<claim-text>peripheral circuitry comprising a multi bit register (610),</claim-text>
<claim-text><b>CHARACTERISED IN THAT</b></claim-text>
<claim-text>a random or pseudo-random multi bit code is stored in the register,</claim-text>
<claim-text>the storage device (600) further comprises a comparator for comparing each bit of the code to a page address of a page of data, to either invert the encoding scheme of the page or leave the encoding scheme as is.</claim-text></claim-text></claim><claim id="c-en-01-0002" num="0002"><claim-text>The storage device of claim 1, wherein a circuit (310) is adapted to first store the code in the hidden area of the array, and then to transfer to the register.</claim-text></claim><claim id="c-en-01-0003" num="0003"><claim-text>The storage device of claim 2, wherein the circuit (310) is adapted to transfer the code to the register upon power up of the EEPROM.</claim-text></claim><claim id="c-en-01-0004" num="0004"><claim-text>The storage device of claim 1, wherein the EEPROM. further comprises a multiplexer (614), and wherein the comparator generates a polarity bit for one or more pages via the multiplexer.</claim-text></claim><claim id="c-en-01-0005" num="0005"><claim-text>The storage device of claim 1, further comprising:
<claim-text>clock signal generating circuits (310) for generating a finite state machine clock signal and a command clock signal;</claim-text>
<claim-text>a clock referencing circuit for generating a polarity bit by referencing the finite state machine clock signal and the command clock signal; and</claim-text>
<claim-text>circuits adapted to apply a first encoding type for a first value of the polarity bit and a second encoding type for a second value of the polarity bit.</claim-text><!-- EPO <DP n="47"> --></claim-text></claim><claim id="c-en-01-0006" num="0006"><claim-text>The storage device of claim 5, wherein the clock referencing circuit generates a polarity bit by referencing the finite state machine clock signal at the rising edge of the command clock signal.</claim-text></claim><claim id="c-en-01-0007" num="0007"><claim-text>A method for storing data on a nonvolatile memory (600) having a plurality of pages of data, comprising:
<claim-text>storing, in the non volatile memory, a code comprising a plurality of pseudo-random or random bits, each bit of the plurality defining whether the encoding of data of a page of the plurality is to be inverted or remain as is;</claim-text>
<claim-text>reading the code from the non volatile memory;</claim-text>
<claim-text>transferring the code from the non volatile memory (604) to a register (610) allocated to store the plurality of bits of the code;</claim-text>
<claim-text>storing the code in the register (610);</claim-text>
<claim-text>generating a polarity signal by comparing a page address of a page of the plurality of pages to a bit of the code for each bit of the code; and</claim-text>
<claim-text>changing the encoding of a subset of pages of the plurality based upon the generated polarity signal.</claim-text></claim-text></claim><claim id="c-en-01-0008" num="0008"><claim-text>The method of claim 7, further comprising multiplexing the polarity signal such that it applies to a group of the plurality of pages and the encoding of the group is determined by a single bit of the code.</claim-text></claim><claim id="c-en-01-0009" num="0009"><claim-text>The method of claim 7, wherein the code comprises 17 or more bits.</claim-text></claim><claim id="c-en-01-0010" num="0010"><claim-text>The method of claim 7, wherein storing the code in the non volatile memory comprises storing the code in a hidden partition (604) of the non volatile memory.</claim-text></claim><claim id="c-en-01-0011" num="0011"><claim-text>The method of claim 7, wherein reading the code from the non volatile memory occurs during power up of the memory.<!-- EPO <DP n="48"> --></claim-text></claim><claim id="c-en-01-0012" num="0012"><claim-text>The method of claim 7, further comprising reading one or more pages of user data, wherein reading comprises determining the polarity of each page to be read by the page address.</claim-text></claim><claim id="c-en-01-0013" num="0013"><claim-text>A method for implementing randomization of the stored data on a nonvolatile memory (600) having a plurality of pages of data, comprising:
<claim-text>receiving a user command to program or read the user data in the array; and <b>CHARACTERISED IN THAT</b></claim-text>
<claim-text>upon receiving the user command, triggering the application of a code comprising a plurality of bits to a block of the user data to randomize the encoding of the user data, each of then bits of the code determining whether a group of one or more pages of the block is stored as is or is inverted prior to being stormed.</claim-text></claim-text></claim><claim id="c-en-01-0014" num="0014"><claim-text>The method of claim 13, further comprising, storing the code along with the user data manipulated by the code.</claim-text></claim><claim id="c-en-01-0015" num="0015"><claim-text>The method of claim 13, wherein the code comprises 17 or more bits.</claim-text></claim><claim id="c-en-01-0016" num="0016"><claim-text>The method of claim 13, wherein the code is updated between user commands.</claim-text></claim><claim id="c-en-01-0017" num="0017"><claim-text>The method of claim 13, wherein if the code comprises less bits than the number of pages within a block, the code is applied to more than one group of one or more pages.</claim-text></claim><claim id="c-en-01-0018" num="0018"><claim-text>The method of claim 14, wherein the method further comprises reading the code stored for each segment, and for each segment, reverting the user data on a bit by bit basis to the encoding scheme present prior to application of the code.</claim-text></claim></claims><claims mxw-id="PCLM56984998" lang="FR" load-source="patent-office"><!-- EPO <DP n="52"> --><claim id="c-fr-01-0001" num="0001"><claim-text>Dispositif de stockage (600) comprenant une mémoire EEPROM à mémoire flash, la mémoire EEPROM comprenant :
<claim-text>une matrice de mémoire flash (602) comprenant une zone masquée (604) et une zone de données d'utilisateur (606) ; et</claim-text>
<claim-text>un montage de circuits périphériques comprenant un registre à bits multiples (610) ;</claim-text>
<claim-text><b>caractérisé en ce que</b></claim-text>
<claim-text>un code à bits multiples aléatoires ou pseudo-aléatoires est stocké dans le registre ;</claim-text>
<claim-text>le dispositif de stockage (600) comprend en outre un comparateur destiné à comparer chaque bit du code à une adresse de page d'une page de données, en vue d'inverser le schéma de codage de la page ou de laisser le schéma de codage tel quel.</claim-text></claim-text></claim><claim id="c-fr-01-0002" num="0002"><claim-text>Dispositif de stockage selon la revendication 1, dans lequel un circuit (310) est apte à stocker tout d'abord le code dans la zone masquée de la matrice, et à le transférer ensuite au registre.</claim-text></claim><claim id="c-fr-01-0003" num="0003"><claim-text>Dispositif de stockage selon la revendication 2, dans lequel le circuit (310) est apte à transférer le code au registre, suite à la mise sous tension de la mémoire EEPROM.</claim-text></claim><claim id="c-fr-01-0004" num="0004"><claim-text>Dispositif de stockage selon la revendication 1, dans lequel la mémoire EEPROM comprend en outre un multiplexeur (614), et dans lequel le comparateur génère un bit de polarité pour une ou plusieurs pages par l'intermédiaire du multiplexeur.</claim-text></claim><claim id="c-fr-01-0005" num="0005"><claim-text>Dispositif de stockage selon la revendication 1, comprenant en outre :
<claim-text>des circuits de génération de signaux d'horloge (310) destinés à générer un signal d'horloge de machine à états finis et un signal d'horloge de commande ;</claim-text>
<claim-text>un circuit de référencement d'horloge destiné à générer un bit de polarité en référençant le signal d'horloge de machine à états finis et le signal d'horloge de commande ; et</claim-text>
<claim-text>des circuits aptes à appliquer un premier type de codage pour une première valeur du bit de polarité, et un second type de codage pour une seconde valeur du bit de polarité.</claim-text></claim-text></claim><claim id="c-fr-01-0006" num="0006"><claim-text>Dispositif de stockage selon la revendication 5, dans lequel le circuit de référencement d'horloge génère un bit de polarité en référençant le signal d'horloge de machine à états finis au niveau du front montant du signal d'horloge de commande.</claim-text></claim><claim id="c-fr-01-0007" num="0007"><claim-text>Procédé de stockage de données dans une mémoire non volatile (600) présentant une pluralité de pages de données, consistant à :
<claim-text>stocker, dans la mémoire non volatile, un code comprenant une pluralité de bits aléatoires ou pseudo-aléatoires, chaque bit de la pluralité déterminant si le codage de données d'une page de la pluralité doit être inversé ou doit rester tel quel ;</claim-text>
<claim-text>lire le code à partir de la mémoire non volatile ;</claim-text>
<claim-text>transférer le code de la mémoire non volatile (604) à un registre (610) affecté en<!-- EPO <DP n="53"> --> vue de stocker la pluralité de bits du code ;</claim-text>
<claim-text>stocker le code dans le registre (610) ;</claim-text>
<claim-text>générer un signal de polarité en comparant une adresse de page d'une page de la pluralité de pages à un bit du code pour chaque bit du code ; et</claim-text>
<claim-text>changer le codage d'un sous-ensemble de pages de la pluralité sur la base du signal de polarité généré.</claim-text></claim-text></claim><claim id="c-fr-01-0008" num="0008"><claim-text>Procédé selon la revendication 7, consistant en outre à multiplexer le signal de polarité de sorte qu'il s'applique à un groupe de la pluralité de pages et que le codage du groupe est déterminé par un unique bit du code.</claim-text></claim><claim id="c-fr-01-0009" num="0009"><claim-text>Procédé selon la revendication 7, dans lequel le code comprend 17 bits ou plus.</claim-text></claim><claim id="c-fr-01-0010" num="0010"><claim-text>Procédé selon la revendication 7, dans lequel le stockage du code dans la mémoire non volatile consiste à stocker le code dans une partition masquée (604) de la mémoire non volatile.</claim-text></claim><claim id="c-fr-01-0011" num="0011"><claim-text>Procédé selon la revendication 7, dans lequel la lecture du code à partir de la mémoire non volatile est mise en oeuvre au cours de la mise sous tension de la mémoire.</claim-text></claim><claim id="c-fr-01-0012" num="0012"><claim-text>Procédé selon la revendication 7, consistant en outre à lire une ou plusieurs pages de données d'utilisateur, dans lequel la lecture consiste à déterminer la polarité de chaque page devant être lue, par le biais de l'adresse de page.</claim-text></claim><claim id="c-fr-01-0013" num="0013"><claim-text>Procédé de mise en oeuvre d'une randomisation des données stockées dans une mémoire non volatile (600) présentant une pluralité de pages de données, consistant à :
<claim-text>recevoir une commande d'utilisateur visant à programmer ou à lire les données d'utilisateur dans la matrice ; et</claim-text>
<claim-text><b>caractérisé en ce qu'</b>il consiste à :
<claim-text>suite à la réception de la commande d'utilisateur, déclencher l'application d'un code comprenant une pluralité de bits à un bloc des données d'utilisateur en vue de randomiser le codage des données d'utilisateur, chacun des bits du code déterminant si un groupe d'une ou plusieurs pages du bloc est stocké tel quel ou est inversé avant d'être stocké.</claim-text></claim-text></claim-text></claim><claim id="c-fr-01-0014" num="0014"><claim-text>Procédé selon la revendication 13, consistant en outre à stocker le code avec les données d'utilisateur traitées par le code.</claim-text></claim><claim id="c-fr-01-0015" num="0015"><claim-text>Procédé selon la revendication 13, dans lequel le code comprend 17 bits ou plus.</claim-text></claim><claim id="c-fr-01-0016" num="0016"><claim-text>Procédé selon la revendication 13, dans lequel le code est mis à jour entre les commandes d'utilisateur.</claim-text></claim><claim id="c-fr-01-0017" num="0017"><claim-text>Procédé selon la revendication 13, dans lequel, si le code comporte moins de bits que le nombre de pages au sein d'un bloc, le code est appliqué à plus d'un groupe d'une ou plusieurs pages.</claim-text></claim><claim id="c-fr-01-0018" num="0018"><claim-text>Procédé selon la revendication 14, dans lequel le procédé consiste en outre à lire le code stocké pour chaque segment, et pour chaque segment, à retourner les données<!-- EPO <DP n="54"> --> d'utilisateur sur une base « bit par bit » au schéma de codage présent avant l'application du code.</claim-text></claim></claims><drawings mxw-id="PDW16672025" load-source="patent-office"><!-- EPO <DP n="55"> --><figure id="f0001" num="1A,1B,1C"><img id="if0001" file="imgf0001.tif" wi="100" he="201" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="56"> --><figure id="f0002" num="1D,1E"><img id="if0002" file="imgf0002.tif" wi="111" he="232" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="57"> --><figure id="f0003" num="2"><img id="if0003" file="imgf0003.tif" wi="164" he="199" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="58"> --><figure id="f0004" num="3"><img id="if0004" file="imgf0004.tif" wi="157" he="221" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="59"> --><figure id="f0005" num="4,5"><img id="if0005" file="imgf0005.tif" wi="136" he="230" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="60"> --><figure id="f0006" num="6A,6B"><img id="if0006" file="imgf0006.tif" wi="132" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="61"> --><figure id="f0007" num="7A"><img id="if0007" file="imgf0007.tif" wi="154" he="158" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="62"> --><figure id="f0008" num="7B"><img id="if0008" file="imgf0008.tif" wi="161" he="217" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="63"> --><figure id="f0009" num="8"><img id="if0009" file="imgf0009.tif" wi="117" he="208" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="64"> --><figure id="f0010" num="9"><img id="if0010" file="imgf0010.tif" wi="165" he="224" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="65"> --><figure id="f0011" num="10"><img id="if0011" file="imgf0011.tif" wi="165" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="66"> --><figure id="f0012" num="11A,11B"><img id="if0012" file="imgf0012.tif" wi="165" he="231" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="67"> --><figure id="f0013" num="12A,12B"><img id="if0013" file="imgf0013.tif" wi="165" he="224" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="68"> --><figure id="f0014" num="13,14"><img id="if0014" file="imgf0014.tif" wi="139" he="186" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="69"> --><figure id="f0015" num="15,16"><img id="if0015" file="imgf0015.tif" wi="165" he="201" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="70"> --><figure id="f0016" num="17,18"><img id="if0016" file="imgf0016.tif" wi="165" he="228" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="71"> --><figure id="f0017" num="19A"><img id="if0017" file="imgf0017.tif" wi="157" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="72"> --><figure id="f0018" num="19B"><img id="if0018" file="imgf0018.tif" wi="157" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="73"> --><figure id="f0019" num="20"><img id="if0019" file="imgf0019.tif" wi="160" he="62" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="74"> --><figure id="f0020" num="21"><img id="if0020" file="imgf0020.tif" wi="157" he="168" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="75"> --><figure id="f0021" num="22A,22B"><img id="if0021" file="imgf0021.tif" wi="165" he="151" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="76"> --><figure id="f0022" num="22C"><img id="if0022" file="imgf0022.tif" wi="165" he="213" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="77"> --><figure id="f0023" num="23A,23B,23C,23D,23E"><img id="if0023" file="imgf0023.tif" wi="162" he="218" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="78"> --><figure id="f0024" num="24A,24B"><img id="if0024" file="imgf0024.tif" wi="150" he="142" img-content="drawing" img-format="tif"/></figure></drawings><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
