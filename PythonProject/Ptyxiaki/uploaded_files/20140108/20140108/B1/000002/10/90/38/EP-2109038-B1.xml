<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2109038-B1" country="EP" doc-number="2109038" kind="B1" date="20140108" family-id="39651394" file-reference-id="318256" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146589000" ucid="EP-2109038-B1"><document-id><country>EP</country><doc-number>2109038</doc-number><kind>B1</kind><date>20140108</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-08251498-A" is-representative="YES"><document-id mxw-id="PAPP154851192" load-source="docdb" format="epo"><country>EP</country><doc-number>08251498</doc-number><kind>A</kind><date>20080423</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140550099" ucid="US-10058308-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>10058308</doc-number><kind>A</kind><date>20080410</date></document-id></priority-claim></priority-claims><dates-of-public-availability><intention-to-grant-date><date>20130729</date></intention-to-grant-date></dates-of-public-availability><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1989327298" load-source="docdb">G06F   9/302       20060101AFI20080811BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL1989626298" load-source="docdb" scheme="CPC">G06F   9/30014     20130101 LI20131206BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989629072" load-source="docdb" scheme="CPC">G06F   7/49942     20130101 FI20131209BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989638891" load-source="docdb" scheme="CPC">G06F   9/3836      20130101 LI20131209BHEP        </classification-cpc><classification-cpc mxw-id="PCL1989650957" load-source="docdb" scheme="CPC">G06F   9/32        20130101 LI20131209BHEP        </classification-cpc><classification-cpc mxw-id="PCL2062868041" load-source="docdb" scheme="CPC">G06F   9/3867      20130101 LI20140321BHEP        </classification-cpc><classification-cpc mxw-id="PCL2062871376" load-source="docdb" scheme="CPC">G06F   9/30065     20130101 LI20140321BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132371633" lang="DE" load-source="patent-office">Vorrichtung und Verfahren zur Optimierung der Leistung von X87 Gleitkommahinzufügungsanweisungen in einem Mikroprozessor</invention-title><invention-title mxw-id="PT132371634" lang="EN" load-source="patent-office">Apparatus and method for optimizing the performance of X87 floating point addition instructions in a microprocessor</invention-title><invention-title mxw-id="PT132371635" lang="FR" load-source="patent-office">Appareil et procédé pour optimiser la performance d'instruction d'addition à point flottant X87 dans un microprocesseur</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR919535200" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>VIA TECH INC</last-name><address><country>TW</country></address></addressbook></applicant><applicant mxw-id="PPAR919527315" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>VIA TECHNOLOGIES, INC.</last-name></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR919531212" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>ELMER TOM</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919543859" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>ELMER, TOM</last-name></addressbook></inventor><inventor mxw-id="PPAR919025819" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>ELMER, TOM</last-name><address><street>1513 Palo Duro Road</street><city>Austin Texas 78757</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919538749" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>PARKS TERRY</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919509561" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>PARKS, TERRY</last-name></addressbook></inventor><inventor mxw-id="PPAR919025818" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>PARKS, TERRY</last-name><address><street>6 Carriage House Lane</street><city>Austin Texas 78737</city><country>US</country></address></addressbook></inventor></inventors><assignees><assignee mxw-id="PPAR919025821" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>VIA Technologies, Inc.</last-name><iid>100779025</iid><address><street>8F, No. 535, Chung-Cheng Road Hsin-Tien City Taipei</street><city>Hsien 231</city><country>TW</country></address></addressbook></assignee></assignees><agents><agent mxw-id="PPAR919025820" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Rees, Simon John Lewis</last-name><iid>100819336</iid><address><street>Haseltine Lake LLP Redcliff Quay 120 Redcliff Street</street><city>Bristol BS1 6HU</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS549883237" load-source="docdb">DE</country><country mxw-id="DS549926121" load-source="docdb">ES</country><country mxw-id="DS549790477" load-source="docdb">FR</country><country mxw-id="DS549874942" load-source="docdb">GB</country></ep-contracting-states></designated-states></international-convention-data></bibliographic-data><description mxw-id="PDES63961416" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001">FIELD OF THE INVENTION</heading><p id="p0001" num="0001">The present invention relates to mathematical operations on floating point numbers, and more particularly to a method and system for performing a high speed x87 floating point addition operation.</p><heading id="h0002">BACKGROUND OF THE INVENTION</heading><p id="p0002" num="0002">Floating point numbers are typically represented by a sign bit, an exponent, and a mantissa (also referred to as the significand) that contains the significant digits of the floating point number. For example, when representing a normalized floating point number in the IEEE Standard 754 for binary floating point arithmetic, the mantissa comprises an integer "1" and a fraction following a binary point</p><p id="p0003" num="0003">The x87 architecture is a popular architecture for performing floating point arithmetic. The x87 architecture is described in the <nplcit id="ncit0001" npl-type="b"><text>IA-32 Intel Architecture Software Developer's Manual, Volume 1: Basic Architechure, June 2006, (referred to herein as the "Intel manual</text></nplcit>"). In particular, section 4.8 describes the represention of real numbers in various floating point formats; chapter 8 generally describes programming with the x87 FPU; and section 5.2 describes the specific x87 floating point unit (FPU) instructions.</p><p id="p0004" num="0004">There are three different floating point formats that must be supported by an x87 FPU: single precision format numbers are 32 bits comprising a 1-bit sign, an 8-bit exponent, and a 23-bit mantissa; double precision numbers are 64 bits comprising a 1-bit<!-- EPO <DP n="2"> --> sign, an 11-bit exponent, and a 52-bit mantissa; and double extended-precision numbers are 80 bits comprising a 1-bit sign, a 15-bit exponent, 1 integer bit, and a 63-bit mantissa. The precision of a floating point number is limited to the number of bits in its mantissa. Thus, given an implied integer '1' bit to the left of the binary point in the single-precision and double-precision formats and the explicit integer '1' bit to the left of the binary point in the double extended-precision format, the precision of a single precision format floating point number is limited to 24 bits, the precision of a double precision format floating point number is limited to 53 bits, and the default precision of a double extended-precision format floating point number is limited to 64 bits. However, the precision of calculations performed on double extended-precision format floating point numbers may be limited to less than 64 bits, and the precision limit is determined by the programmer. An x87 FPU includes a Precision Control (PC) field in its Floating Point Control Word (FPCW) that determines whether the precision of its floating point calculations are 64, 53, or 24 bits. A program may write to the PC field to change the precision of the x87 FPU floating point calculations. For example, if the program writes to the PC field to specify single precision, then the x87 FPU generates results with 24 bits of precision, even though one or more of the addends may have greater than 24 bits of precision. That is, the FPU rounds the mantissa of the result by clearing to zero the bits that are of less arithmetic significance than the precision specified by the PC field.</p><p id="p0005" num="0005">One common set of floating point arithmetic instructions executed by an x87 FPU are the addition (and subtraction) instructions. A floating point addition instruction performs the calculation of Ra + Rb, where Ra and Rb are floating point addends. The mantissa of Ra is denoted here as A, and the mantissa of Rb is denoted B. Assume Ra is the larger addend and Rb is the smaller addend, i.e., Ra has a larger exponent than Rb. The x87 FPU shifts B right by a number of bits equal to the difference between the exponents of Ra and Rb in order to align the mantissa of the smaller addend with the mantissa of the larger addend. The x87 FPU then adds mantissa A to the aligned mantissa B to generate a resultant sum. The FPU then normalizes the sum to remove<!-- EPO <DP n="3"> --> any leading zeroes. Finally, the FPU performs a rounding operation on the normalized sum.</p><p id="p0006" num="0006">The rounding operation may be critical with respect to the timing of the execution of a floating point addition instruction by an x87 FPU. An FPU executes instructions according to a clock signal having a frequency and period. For a given semiconductor manufacturing process technology employed and FPU design (e.g., the number of gate delays required to execute the addition instruction), the clock period might have to be lengthened to accommodate the time to perform the rounding operation to execute the instruction. In the alternative, it is typical for an FPU to execute addition instructions in multiple clock cycles. In this case, it is desirable from a performance perspective for an FPU to execute floating point addition instructions in the smallest number of clock cycles possible given the clock period, the number of gate delays required by the FPU design to execute the instruction, the semiconductor manufacturing process technology employed, etc.</p><p id="p0007" num="0007">The rounding operation may be determinative of whether or not an additional clock cycle is required to execute a floating point addition instruction, i.e., whether the FPU can execute the floating point addition instruction in N clock cycles or N+1 clock cycles. This is because the rounding determination (i.e., whether the sum of the addends needs to be rounded up by incrementing) for an addition instruction by an x87 FPU depends upon the precision of the addends relative to the precision specified by the PC field of the FPCW. More specifically, the fact that the programmer could specify a precision via the PC field that is different than the precision of one or both of the addends could cause the rounding determination to take longer under some conditions than in others. There may be some conditions under which the longer time to make the rounding determination would cause the total execution time of the instruction to require an additional clock cycle. Thus, for example, whereas an x87 FPU could be designed to execute a floating point addition instruction in three clock cycles for a first set of conditions of the precision of the addends and the precision specified by the PC field, the FPU may require four clock cycles to execute the instruction for a second set of conditions of the precision of the addends and the precision specified by the PC field<!-- EPO <DP n="4"> --> because the rounding determination takes longer for the second set of conditions. Following are some specific examples of conditions of the precision of the addends relative to the precision specified by the PC field and their affect on the rounding determination time.</p><p id="p0008" num="0008">If the precision specified by the PC field is the same as the precision of the addends, then only the smaller addend contributes bits to the rounding operation (referred to herein as sticky bits) due to the mantissa alignment discussed above. In this case, the rounding determination may be performed in parallel with the addition of the larger addend and aligned smaller addend by simply examining the sticky bits of the smaller addend, namely the number of least significant bits shifted right during the alignment operation. That is, the rounding determination time is mostly, if not all, hidden by the time taken to perform the actual addition of the two addend mantissas.</p><p id="p0009" num="0009">However, if the precision of the larger addend is greater than the precision specified by the PC field, then the larger addend may also contribute sticky bits to the rounding determination. In this case, the x87 FPU must add the sticky bits contributed by each of the two addends in order to make the rounding determination. The addition of the sticky bits may take as long as the addition of the non-sticky bits of the mantissa, i.e., the upper bits that are within the precision specified by the PC field. The x87 FPU subsequently examines the sticky bits sum in order to make the rounding determination after the addition of the mantissas. Importantly in this case, unlike the case in which only the smaller addend contributes sticky bits, the FPU cannot make the rounding determination in parallel with the addition of the larger mantissa and aligned smaller mantissa. Rather, the FPU must wait to make the rounding determination until the addition of the sticky bits has completed.</p><p id="p0010" num="0010">Much work has been done to perform fast floating point add operations. For example, see <nplcit id="ncit0002" npl-type="b"><text>ON THE DESIGN OF FAST IEEE FLOATING-POINT ADDERS, Seidel, et al., IEEE Computer Society, Proceedings of the 15th IEEE Symposium on Computer Arithmetic (ARITH '01</text></nplcit>). However, this paper fails to take into account the requirements imposed upon a commercially-viable x87 FPU with respect to the ability of the programmer to specify the precision of floating point number calculations via the<!-- EPO <DP n="5"> --> PC field. Specifically, the paper assumes that only one of the addends will contribute sticky bits to the rounding determination. However, as discussed above, the peculiarities of the x87 architecture, namely the PC field, can create situations where both of the addends contribute bits to the rounding determination. Depending upon factors such as the clock frequency of the microprocessor and the number of gate delays within the various circuits of the x87 FPU (e.g., adders, sifters, and control logic circuits), the additional time required to perform the rounding determination in some cases, such as where both addends contribute sticky bits, may in some designs be enough to require an additional clock cycle for the x87 FPU to execute a floating point add instruction or the clock cycle to be undesirably lengthened.</p><p id="p0011" num="0011">One solution to the problem is to have the FPU execute floating point addition instructions in a variable number of clock cycles. However, this solution is undesirable with respect to instruction scheduling, particularly within a superscalar, out-of-order execution microprocessor. Another solution is to simply take the same greater number of clock cycles (four in the example above) to execute all floating point addition instructions, regardless of the set of conditions. However, this solution is obviously not a high performance solution.</p><p id="p0012" num="0012">Accordingly, what is needed is a solution that generates correct results of an x87 floating point addition instruction in cases where the rounding determination is relatively long, such as where both addends contribute sticky bits to the rounding determination, and yet does not penalize the time to execute an x87 floating point addition instruction in cases where the rounding determination is relatively short, such as where only one addend contributes sticky bits to the rounding determination.</p><p id="p0013" num="0013">An example of a prior art microprocessor is descibed in <patcit id="pcit0001" dnum="WO2008036944A"><text>W02008/036944A</text></patcit>.</p><heading id="h0003">BRIEF SUMMARY OF INVENTION</heading><p id="p0014" num="0014">The present inventors have advantageously observed from analysis of popular commercial software applications and benchmarks that the proportion of x87 floating point addition instructions that present the longer cases (e.g., the case in which both addends contribute bits to the founding determination and therefore require an addition of the sticky bits from each added before the rounding determination can be made) that<!-- EPO <DP n="6"> --> would require an additional clock cycle in embodiments of their x87 FPU is very small relative to the proportion of x87 floating point addition instructions that present the shorter cases (e.g., the case in which only the smaller addend contributes bits to the rounding determination, enabling the rounding determination to be made roughly in parallel with the addition of the addends) that would not require an additional clock cycle, but may instead be executed by the FPU within the desired number of clock cycles, which in one embodiment is two clock cycles. Consequently, the present invention employs a system-wide approach to the problem described above that takes advantage of the fact that an x87 FPU may be integrated into a larger microprocessor system. The microprocessor distinguishes between long and short cases, i.e., cases which would require an additional clock cycle and cases which would not. The long cases are those in which at least one of a set of predetermined conditions exists in the addends of the floating point addition instruction with respect to their contribution to a rounding determination relative to the precision specified by the PC field, such as that both addends contribute sticky bits to the rounding determination; whereas, the short cases are those which do not satisfy any of the set of predetermined conditions. In the long cases, the x87 FPU coordinates with the microprocessor's instruction dispatcher to execute the add instruction in two parts on two separate dispatches of the addition instruction: an initial dispatch by the instruction dispatcher and a re-dispatch (also referred to as a "replay") by the instruction dispatcher. Conversely, in the short cases, the x87 FPU fully executes the instruction on the initial dispatch. In the cases in which a replay of the addition instruction is required, the FPU saves intermediate results from the initial dispatch execution and receives the saved intermediate results on the re-dispatch to complete execution of the instruction. Although because the total time required under this approach to execute an x87 floating point addition instruction when a replay is required is greater than simply taking an additional clock cycle for all x87 floating point additions, the approach advantageously enables the x87 FPU to execute instructions when a replay is not required without taking an additional clock cycle. The present inventors have observed that a microprocessor embodying this approach provides significant performance improvement in popular commercial software applications and<!-- EPO <DP n="7"> --> benchmarks over previous approaches. Apparently this performance improvement is observed because the percentage of cases that do not require a replay is so much greater than the percentage of cases that require a replay that the benefit of faster execution time in the short cases outweighs the disadvantage of slower execution time in the long cases in the aggregate.</p><p id="p0015" num="0015">In one aspect, the present invention includes a microprocessor. The microprocessor includes comprising an x87 Floating Point Control Word (FPCW) including a Precision Control (PC) field, an instruction dispatcher, and a Floating Point Unit (FPU). The (PC) field is programmable for specifying a precision of floating point (FP) calculations made by an FPU of the microprocessor. The instruction dispatcher is configured to dispatch an x87 FP addition instruction (FP ADD) to the FPU, with the FP ADD having first and second FP addends. The FPU adds the first and second addends to generate a sum. The FPU then determines whether any predetermined conditions exist in the first and second addends with respect to their contribution to a rounding determination of the sum and relative to the precision specified by the PC field. If none of the predetermined conditions exists, then the FPU makes the rounding determination based on bits of the mantissa of the smaller of the first and second addends and the precision specified by the PC field. It then selectively rounds the sum based on the rounding determination for generating a final result of the FP ADD. If one of the predetermined conditions exists, the FPU saves the sum and rounding information derived from the first and second addends. It then signals the instruction dispatcher to re-dispatch the FP ADD to the FPU. In response to the instruction dispatcher re-dispatching the FP ADD to the FPU, the FPU makes the rounding determination based on the saved rounding information and the precision specified by the PC field. Following this, the FPU selectively rounds up the sum based on the rounding determination for generating the final result.</p><p id="p0016" num="0016">In another aspect, the present invention includes a method for processing an x87 floating point addition instruction (FP ADD) in a microprocessor having a FP unit (FPU), an instruction dispatcher, and an x87 Floating Point Control Word (FPCW)<!-- EPO <DP n="8"> --> including a Precision Control (PC) field. The instruction dispatcher initially dispatches an x87 FP ADD to the FPU, with the FP ADD having a first and a second FP addend. The FPU adds the first and second addends to generate a sum. After generating the sum, the FPU determines whether any predetermined conditions exist in the first and second addends with respect to their contribution to a rounding determination of the sum and relative to the precision specified by the PC field. If none of the predetermined conditions exists, then the FPU makes the rounding determination based on bits of the mantissa of the smaller of the first and second addends and the precision specified by the PC field. It then selectively rounds the sum based on the rounding determination for generating a final result of the FP ADD. If a predetermined condition exists, the FPU saves the sum and rounding information derived from the first and second addends, and signals the instruction dispatcher to re-dispatch the FP ADD to the FPU. In response to the instruction dispatcher re-dispatching the FP ADD to the FPU, the FPU makes the rounding determination based on the saved rounding information and the precision specified by the PC field. The FPU then selectively rounds up the sum based on the rounding determination for generating the final result.</p><p id="p0017" num="0017">In yet another aspect, the present invention includes a computer program product for use with a computing device including a computer readable storage medium. The computer readable storage medium has computer readable program code embodied in the computer readable storage medium for providing a microprocessor. The computer readable program code includes first program code for providing an x87 Floating Point Control Word (FPCW) including a Precision Control (PC) field. The computer readable program code also includes second program code for providing an instruction dispatcher. The computer readable program code also includes third program code for providing a floating point processing (FPU) function. The PC field of the FPCW specifies a precision of floating point (FP) calculations made by the FPU. The instruction dispatcher is configured to dispatch an x87 FP addition instruction (FP ADD) to the FPU. The FP ADD has first and second FP addends.<!-- EPO <DP n="9"> --></p><p id="p0018" num="0018">The FPU adds the first and second addends to generate a sum. It then determines whether any predetermined conditions exist in the first and second addends with respect to their contribution to a rounding determination of the sum and relative to the precision specified by the PC field. If none of the predetermined conditions exists, the FPU makes the rounding determination based on bits of the mantissa of the smaller of the first and second addends and the precision specified by the PC field. The FPU then selectively rounds the sum based on the rounding determination for generating a final result of the FP ADD. If any predetermined conditions exist, the FPU saves the sum and rounding information derived from the first and second addends, and signals the instruction dispatcher to re-dispatch the FP ADD to the FPU. In response to the instruction dispatcher re-dispatching the FP ADD to the FPU, the FPU makes the rounding determination based on the saved rounding information and the precision specified by the PC field. It then selectively rounds the sum based on the rounding determination for generating the final result.</p><heading id="h0004">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p0019" num="0019"><ul><li><figref idrefs="f0001">FIGURE 1</figref> is a block diagram illustrating a microprocessor according to the present invention.</li><li><figref idrefs="f0002">FIGURE 2</figref> is a block diagram illustrating the Execution Units of <figref idrefs="f0001">Figure 1</figref> according to the present invention.</li><li><figref idrefs="f0003">FIGURE 3</figref> is a block diagram illustrating an x87 FPU of the microprocessor of <figref idrefs="f0001">Figure 1</figref> according to the present invention.</li><li><figref idrefs="f0004">FIGURES 4a, 4b, 4c, and 4d</figref> are four block diagrams illustrating the four possible combinations of the relationship between the precision of the two addends of an x87 floating point addition instruction relative to the precision specified by the PC field according to the present invention.</li><li><figref idrefs="f0004">FIGURE 5</figref> is a depiction illustrating a set of predetermined conditions exists in addends of a floating point addition instruction with respect to their contribution to a<!-- EPO <DP n="10"> --> rounding determination relative to the precision specified by the PC field of the FPCW of <figref idrefs="f0003">Figure 3</figref> according to one embodiment of the present invention.</li><li><figref idrefs="f0005">FIGURE 6</figref> is a flowchart illustrating operation of the microprocessor of <figref idrefs="f0001">Figure 1</figref> to perform x87 floating point addition instructions according to the present invention.</li></ul></p><heading id="h0005">DETAILED DESCRIPTION OF THE INVENTION</heading><p id="p0020" num="0020">The term "sticky bits" refers to the bits of an addend after alignment, if necessary (such as the aligned smaller addend), of a floating point addition instruction that have less arithmetic significance than the precision specified by the PC field 308 of <figref idrefs="f0003">Figure 3</figref>. Stated alternatively, the sticky bits are the bits of an addend that have less arithmetic significance than the least representable bit of the result as specified by the PC field 308.</p><p id="p0021" num="0021">Referring to <figref idrefs="f0001">Figure 1</figref>, a block diagram illustrating a microprocessor 100 according to the present invention is shown. The microprocessor 100 includes a Translator 108 coupled to a Microinstruction ROM 112. The Translator 108 receives x86 macroinstructions 104 and translates them into one or more microinstructions 106. In one embodiment, the x86 macroinstructions 104 comprise instructions of the well-known IA-32 architecture, such as those specified in the Intel manual incorporated by reference above. In particular, the macroinstructions 104 include x87 floating point (FP) addition macroinstructions. The x87 floating point addition macroinstructions 104 may include, but are not limited to, the following well-known instructions: FADD, FADDP, FIADD, FSUB, FSUBP, FISUB, FSUBR, FSUBRP, FCOM, FCOMP, FCOMPP, FCOMI, FCOMIP, FUCOMI, FUCOMIP, FICOM, FICOMP, FILD, FIST, FISTP, FISTTP, FST, FSTP, FISUBR, FUCOM, FUCOMP, and FUCOMPP. The Microinstruction ROM 112 includes microinstruction sequences that the Translator 108 calls in response to complex and/or infrequently executed x86 macroinstructions, as opposed to translating the x86 macroinstructions directly into microinstructions. In one embodiment, the micro-architecture of the microprocessor 100 is a RISC-style micro-architecture that executes the microinstructions 106, which are generally simpler than the x86 macroinstructions and conform to the RISC-style load/store paradigm.<!-- EPO <DP n="11"> --></p><p id="p0022" num="0022">The microprocessor 100 pipeline also includes a Register Allocation Table (RAT) 116 coupled to the Translator 108, an Instruction Dispatcher 120 (or Instruction Scheduler 120) coupled to the RAT 116, Execution Units 124 coupled to the Instruction Dispatcher 120, and a Retire Unit 126 coupled to the Execution Units 124. The Execution Units 124 include a Media A Unit 204 (of <figref idrefs="f0002">Figure 2</figref>) that includes an x87 FPU 388 (of <figref idrefs="f0003">Figure 3</figref>), which are described in more detail below. The microprocessor 100 also includes a Reorder Buffer (ROB) 128 coupled to the RAT 116, Instruction Dispatcher 120, Execution Units 124, and Retire Unit 126.</p><p id="p0023" num="0023">In one embodiment, the microprocessor 100 is an out-of-order execution microprocessor. That is, the Execution Units 124 execute the microinstructions 106 out-of-order with respect to the program order. However, the ROB 128 is used to guarantee that the microinstructions 106 and their associated macroinstructions 104 are retired in program order. Furthermore, the Translator 108 translates the macroinstructions 104 in program order and generates the microinstructions 106 in program order. Additionally, the RAT 116 allocates entries in the ROB 128 in program order. The ROB 128 is a circular FIFO buffer that receives the microinstructions 106 from the RAT 116 in program order and is used by the Retire Unit 126 to retire microinstructions 106 and their associated macroinstructions 104 in program order.</p><p id="p0024" num="0024">The RAT 116 receives the microinstructions 106 from the Translator 108 and detects dependencies between the microinstructions 106. In particular, the RAT 116 determines dependencies of microinstruction source operands, such as x87 FP addition instruction addends on the results of other microinstructions. When the RAT 116 receives a microinstruction 106 it allocates the next available entry in the ROB 128 and stores the microinstruction 106 and its associated dependency information into the allocated ROB 128 entry.</p><p id="p0025" num="0025">The Instruction Dispatcher 120 receives the microinstructions 106 and dependency information from the RAT 116. The Instruction Dispatcher 120 schedules the un-dispatched microinstructions 106 in the ROB 128 to their appropriate Execution Unit 124. In particular, the Instruction Dispatcher 120 dispatches microinstructions, such as microinstructions translated from x87 floating point addition instructions, to the<!-- EPO <DP n="12"> --> Media A 204 execution unit (of <figref idrefs="f0002">Figure 2</figref>) since it contains the x87 FPU 388 (of <figref idrefs="f0003">Figure 3</figref>). Each Execution Unit 124 includes a reservation station (not shown) that buffers microinstructions 106 for the respective Execution Unit 124. When the Instruction Dispatcher 120 determines that the ROB 128 has an un-dispatched microinstruction 106 of the type to be executed by an Execution Unit 124 with an empty reservation station entry, the Instruction Dispatcher 120 dispatches the microinstruction 106 to the appropriate Execution Unit 124 and updates the ROB 128 to indicate that the microinstruction 106 has been dispatched. Once all the source operands upon which the microinstruction 106 depends are available, issue logic issues the microinstruction 106 from the reservation station to the portion of the Execution Unit that executes the instruction.</p><p id="p0026" num="0026">In one embodiment, the ROB 128 includes 48 entries. Each ROB 128 entry has an index, or tag. The tag identifies the microinstruction 106 in the ROB entry. When an Execution Unit 124 completes execution of a microinstruction 106, the Execution Unit 124 provides the tag of the executed microinstruction 106 to the ROB 128 and to the Retire Unit 126. The ROB 128 then updates a flag in the entry associated with the executed microinstruction 106 to indicate that the microinstruction 106 is ready to be retired. As discussed above, the Retire Unit 126 retires the completed microinstructions 106 and their associated macroinstructions 104 in program order from the ROB 128.</p><p id="p0027" num="0027">Advantageously, the x87 FPU 388 includes the ability to request the Instruction Dispatcher 120 and ROB 128 to replay an x87 floating point addition microinstruction 106 when any of a set of predetermined conditions exists in addends of a floating point addition instruction with respect to their contribution to a rounding determination relative to the precision specified by the PC field 308 of the FPCW 304 of <figref idrefs="f0003">Figure 3</figref>, as discussed herein, such as according to the embodiment of <figref idrefs="f0004">Figure 5</figref>.</p><p id="p0028" num="0028">Referring now to <figref idrefs="f0002">Figure 2</figref>, a block diagram illustrating the Execution Units 124 of <figref idrefs="f0001">Figure 1</figref> according to the present invention is shown. In one embodiment, there are seven different Execution Units 124, denoted 204 through 228, which are designed to execute in parallel with and independently from each other. The first execution unit, denoted MEDIA A 204, executes floating point microinstructions and includes the x87<!-- EPO <DP n="13"> --> FPU 388 of <figref idrefs="f0003">Figure 3</figref>. The second execution unit, denoted MEDIA B 208, executes multiply operations. The third execution unit, denoted SINT (Simple Integer) 212, executes integer ALU operations. The fourth execution unit, denoted MOV/BR (MoveBranch) 216, executes move or branch microinstructions as well as simple ALU operations that the SINT unit also performs. The fifth execution unit, denoted LD (Load Data) 220, fetches data, such as addends for floating point additions, from memory into registers of the microprocessor 100. The sixth execution unit, denoted STA (Store Address) 224, calculates the destination address for a store operation and allocates a store buffer for it. The seventh execution unit, denoted STD (Store Data) 228, stores the results of computations from registers to an address in memory specified by the Store Address execution unit 224.</p><p id="p0029" num="0029">Referring now to <figref idrefs="f0003">Figure 3</figref>, a block diagram illustrating an x87 FPU 388 of the microprocessor 100 of <figref idrefs="f0001">Figure 1</figref> according to the present invention is shown. In one embodiment, the x87 FPU 388 is included within the Media A Unit 204 of <figref idrefs="f0002">Figure 2</figref>. The ROB 128 and RAT 116 are coupled to the Instruction Dispatcher 120 of <figref idrefs="f0001">Figure 1</figref>, which is coupled to the x87 FPU 388. The Instruction Dispatcher 120 initially dispatches microinstructions received from the RAT 116, such as an x87 floating point addition microinstruction translated from an x87 floating point macroinstruction, to the x87 FPU 388. The Instruction Dispatcher 120 also re-dispatches x87 floating point addition microinstructions received from the ROB 128 to the x87 FPU 388 when at least one of a set of predetermined conditions in the instruction addends with respect to their contribution to a rounding determination relative to the precision specified by the PC field 308 of the FPCW 304 is satisfied, as discussed below with respect to <figref idrefs="f0004">Figure 5</figref>, for example. The Instruction Dispatcher 120 controls two muxes 392 and 394 that provide operands to the FPU 388. The mux 392 receives as inputs an addend A 316 and a saved sum 346 (from the FPU 388 as discussed below). The mux 394 receives as inputs an addend B 320 and the saved sum 346. The Instruction Dispatcher 120 controls the muxes 392/394 to select the addends 316/320 when the Instruction Dispatcher 120 performs an initial dispatch of an instruction to the x87 FPU 388, and controls the muxes 392/394 to select the saved sum 346 when the Instruction Dispatcher 120 re-dispatches<!-- EPO <DP n="14"> --> an x87 floating point addition microinstruction to the x87 FPU 388, as described herein such as with respect to block 628 of <figref idrefs="f0005">Figure 6</figref>. The x87 FPU 388 includes circuitry for executing all the x87 floating point instructions; however, only some of the circuitry that performs x87 floating point addition instructions is shown in <figref idrefs="f0003">Figure 3</figref>. The x87 FPU 388 includes a two-input round-up Adder 324A and a two-input non-round-up Adder 324B, a two-input mux 396, a two-input mux 398, Control Logic 328, and a Floating Point Control Word (FPCW) 304 that includes the x87 Precision Control (PC) field 308 and a Rounding Control (RC) field 312. The programmer may program various values into the RC field 312 to control the rounding mode used by the x87 FPU 388 to round its results.</p><p id="p0030" num="0030">The mux 398 receives on its inputs the outputs of the respective Adders 324A and 324B. In cases in which none of the set of predetermined conditions exists as determined below with respect to block 612 <figref idrefs="f0005">Figure 6</figref>, the Control Logic 328 generates the control signal to cause the mux 398 to select one of the inputs for outputting as a resultant sum 336, as described with respect to block 616 of <figref idrefs="f0005">Figure 6</figref>, depending upon the rounding determination made at block 614 of <figref idrefs="f0005">Figure 6</figref>. In cases in which at least one of the set of predetermined conditions exists upon initial dispatch of the floating point addition instruction as determined below with respect to block 612, the Control Logic 328 generates the control signal to cause the mux 398 to select the non-rounded-up sum of adder B 324B and saves the resultant sum 346 in a register 346, as described with respect to block 622 of <figref idrefs="f0005">Figure 6</figref>. The x87 FPU 388 receives the saved sum 346 in response to the re-dispatch of the floating point addition instruction by the Instruction Dispatcher 120 to the x87 FPU 388, as described with respect to block 628 of <figref idrefs="f0005">Figure 6</figref>. In response to the re-dispatch of the floating point addition instruction, the Control Logic 328 generates a control signal to cause the mux 398 to select one of the inputs for outputting as a resultant sum 336, as described with respect to block 634 of <figref idrefs="f0005">Figure 6</figref>, depending upon the rounding determination made at block 632 of <figref idrefs="f0005">Figure 6</figref>. It is noted that the term "sum" is used herein to refer to both the result of an effective addition operation and the result of an effective subtraction operation, unless otherwise specified. An effective addition operation is performed when the sign bits of the addends 316/320<!-- EPO <DP n="15"> --> are the same and the floating point addition instruction specifies an addition operation of the addends, or the sign bits of the addends 316/320 are different and the floating point addition instruction specifies a subtraction operation of the addends. An effective subtraction is performed when the sign bits of the addends 316/320 are different and the floating point addition instruction specifies an addition operation of the addends, or the sign bits of the addends 316/320 are the same and the floating point addition instruction specifies a subtraction operation of the addends.</p><p id="p0031" num="0031">Each of the Adders 324 receives on its inputs the output of the mux 392 and the output of the mux 396. The mux 394 receives on one input addend B 320 and receives on its other input the saved sum 346. The mux 396 receives on one input the output of mux 394 (i.e., either addend B 320 or the saved sum 346) and receives on its other input a 64-bit zero value. The Control Logic 328 generates a control signal to cause the mux 396 to select one of its inputs for outputting to the Adders 324, as described below. Additionally, Adder A 324A receives a binary '1' value carry-in bit, and Adder B 324B receives a binary '0' value carry-in bit. Thus, Adder A 324A generates a rounded-up sum of the addend A 316 and addend B 320 on the initial dispatch of the floating point addition instruction, or generates a rounded-up saved sum 346 on the re-dispatch of the floating point addition instruction, as described below. Similarly, Adder B 324B generates a non-rounded-up sum of addend A 316 and addend B 320 on the initial dispatch of the floating point addition instruction, or generates a non-rounded-up saved sum 346 on the re-dispatch of the floating point addition instruction, as described below. In one embodiment, the Adders 324A and 324B are 64-bit adders that receive 64-bit addends and generate a 64-bit sum.</p><p id="p0032" num="0032">The addends 316/320 may be supplied from multiple sources. One source is registers of the IA-32 architecture floating point register set. Another source is rename registers for storing the results of the instructions stored in the ROB 128 of <figref idrefs="f0001">Figure 1</figref>. Another source is temporary registers of the microprocessor 100. Another source is results of instructions executed by the various Execution Units 124 forwarded directly to the x87 FPU 388.<!-- EPO <DP n="16"> --></p><p id="p0033" num="0033">As described above, the PC field 308 value determines whether the precision of the x87 FPU 388 floating point calculation result is 64, 53, or 24 bits; however, the FPU 388 may make intermediate calculations internally with higher precision than the precision specified by the PC field 308. A program may write to the PC field 308 to change the precision of the x87 FPU 388 floating point calculations. For example, if the program writes to the PC field 308 to specify double precision, then the x87 FPU 388 generates results with 53 bits of precision, even though one or more of the addends have greater than 53 bits of precision. That is, the FPU clears to zero the lower unused bits, i.e., the bits that are of less arithmetic significance than the precision specified by the PC field 308, and provides the conditionally incremented 53-bit result.</p><p id="p0034" num="0034">The Control Logic 328 receives as inputs: the PC field 308 value, the outputs of the mux 392 and the mux 396, and the outputs of Adder A 324A and Adder B 324B. The Control Logic 328 uses the inputs determine whether at least one of the set of predetermined conditions exists in the first 316 and second 320 addends with respect to their contribution to a rounding determination relative to the precision specified by the PC field 308 of the FPCW 304. Additionally, the Control Logic 328 uses the inputs to generate a cumulative sticky bit 338, as described with respect to block 622 of <figref idrefs="f0005">Figure 6</figref>, which is saved in a register 348, as described with respect to block 622. The Control Logic 328 also uses the inputs along with the saved cumulative sticky bit 348 to make the rounding determination, as described with respect to block 632 of <figref idrefs="f0005">Figure 6</figref>. The Control Logic 328 includes logic (not shown) that determines the precision of the addends 316/320 of the floating point addition instruction, such as performed at block 608 of <figref idrefs="f0005">Figure 6</figref>.</p><p id="p0035" num="0035">The Control Logic 328 also generates a signal 340 to the Instruction Dispatcher 120 and ROB 128 to request a replay of the floating point addition instruction if one of the set of predetermined conditions exists, as described at block 624 of <figref idrefs="f0005">Figure 6</figref>. The Control Logic 328 also receives a signal 344 from the Instruction Dispatcher 120 indicating that the Instruction Dispatcher 120 is now re-dispatching the floating point addition instruction, as described at block 628 of <figref idrefs="f0005">Figure 6</figref>.<!-- EPO <DP n="17"> --></p><p id="p0036" num="0036">The x87 FPU 388 also includes a shifter (not shown) that shifts the mantissa of the smaller addend by a number of bits equal to the difference between the exponent of the larger addend and the exponent of the smaller addend in order to align the smaller addend mantissa with the larger addend mantissa before provision to the adders 324A and 324B. The larger addend is the addend that has the largest exponent of the two addends 316/320. If the exponents are equal, the x87 FPU 388 arbitrarily chooses one of the addends to be the larger addend, and subsequently corrects the sign of the final result 336, if necessary, i.e., if the arbitrary choice was incorrect. The x87 FPU 388 also includes a shifter (not shown) that receives the output of the mux 398 and shifts the selected input to normalize the result 336. Once the FPU 388 completes the floating point addition instruction, the FPU 388 provides the final result 336 to the Retire Unit 126, which subsequently retires the result 336 to the architeeted IA-32 floating point register specified by the floating point addition instruction.</p><p id="p0037" num="0037">In one embodiment, the x87 FPU 388 includes two distinct paths, known as a "far path" and a "near path" or "round path" and "normalize path", referred to herein as the "R-path" and the "N-path", which are well-known in the art of floating point addition units. The two paths may be generally similar to the arrangement described in the paper ON THE DESIGN OF FAST IEEE FLOATING-POINT ADDERS, Seidel, et al., IEEE Computer Society, Proceedings of the 15th IEEE Symposium on Computer Arithmetic (ARITH '01). The N-path computes effective subtractions (either an addition instruction in which the two operands have different signs, or a subtraction instruction in which the two operands have the same sign) in which the operands have exponent differences less than or equal to 1, and the R-path computes all other cases. The R-path is shown in <figref idrefs="f0003">Figure 3</figref>; however, the N-path is not shown in <figref idrefs="f0003">Figure 3</figref>. Each path executes the floating point addition instruction in parallel, and the Control Logic 328 selects the result from one of the paths as the final result 336.</p><p id="p0038" num="0038">Refering now to <figref idrefs="f0004">Figure 4</figref>, four block diagrams illustrating the four possible combinations of the relationship between the precision of the two addends of an x87 floating point addition instruction relative to the precision specified by the PC field 308<!-- EPO <DP n="18"> --> are shown. The four block diagrams are denoted 4a, 4b, 4c, and 4d. These combinations are relevant to the determination of whether at least one of a set of predetermined conditions exists in the addends 316/320 with respect to their contribution to a rounding determination of their intermediate sum and relative to the precision specified by the PC field 308, for example as described with respect to <figref idrefs="f0004">Figure 5</figref>. The precision of an addend 316/320 is defined herein as the number of bits between and inclusive of the leading and trailing binary '1' value bits in the mantissa of the addend 316/320. In one embodiment, the Control Logic 328 of <figref idrefs="f0003">Figure 3</figref> includes precision determination logic that determines the precision of the addends 316/320 as they are received. The Control Logic 328 uses the precision information from the precision determination logic, along with the alignment operation shift amount in the case of the smaller addend, to determine whether the addends 316/320 will contribute sticky bits to the rounding determination. It should be noted that the precision determination is not to be confused with the determination of which addend is the larger addend (referred to in <figref idrefs="f0004">Figure 4</figref> as 402) and which addend is the smaller addend (referred to in <figref idrefs="f0004">Figure 4</figref> as 404), which the FPU 388 performs by comparing the addend 316/320 exponents, as described with respect to block 604 of <figref idrefs="f0005">Figure 6</figref>.</p><p id="p0039" num="0039"><figref idrefs="f0004">Figure 4a</figref> depicts the case in which the mantissas of both the larger addend 402 and the smaller addend 404 have equal or less precision than the precision specified by the PC field 308 of the FPCW 304 of <figref idrefs="f0003">Figure 3</figref>. In this case, the mantissa of the larger addend 402 will not contribute any sticky bits to the rounding determination. However, the aligned mantissa of the smaller addend 404 may contribute sticky bits to the rounding determination depending upon the amount of right-shifting to perform the alignment.</p><p id="p0040" num="0040"><figref idrefs="f0004">Figure 4b</figref> depicts the case in which the mantissa of the smaller addend 404 has equal or less precision than the precision specified by the PC field 308, and the mantissa of the larger addend 402 has greater precision than the precision specified by the PC field 308. In this case, the mantissa of the larger addend 402 will contribute sticky bits to the rounding determination. However, the aligned mantissa of the smaller addend 404 may contribute sticky bits to the rounding determination depending upon the amount of<!-- EPO <DP n="19"> --> right-shifting to perform the alignment. Thus, in this case the possibility exists that both addends 402/404 (316/320) will contribute to the rounding determination. More specifically, the possibility exists that the addends 402/404 (316/320) will need to be added before the rounding determination can be made.</p><p id="p0041" num="0041"><figref idrefs="f0004">Figure 4c</figref> depicts the case in which the mantissa of the larger addend 402 has equal or less precision than the precision specified by the PC field 308, and the mantissa of the smaller addend 404 has greater precision than the precision specified by the PC field 308. In this case, the mantissa of the larger addend 402 will not contribute any sticky bits to the rounding determination. However, the aligned mantissa of the smaller addend 404 may contribute sticky bits to the rounding determination.</p><p id="p0042" num="0042"><figref idrefs="f0004">Figure 4d</figref> depicts the case in which the mantissas of both the larger addend 402 and the smaller addend 404 have greater precision than the precision specified by the PC field 308. In this case, the mantissa of both the larger addend 402 and the smaller addend 404 will contribute sticky bits to the rounding determination.</p><p id="p0043" num="0043">Referring now to <figref idrefs="f0004">Figure 5</figref>, a depiction illustrating a set of predetermined conditions exists in addends of a floating point addition instruction with respect to their contribution to a rounding determination relative to the precision specified by the PC field 308 of the FPCW 304 of <figref idrefs="f0003">Figure 3</figref> according to one embodiment of the present invention is shown. The x87 FPU 388 of <figref idrefs="f0003">Figure 3</figref> will request a replay of the floating point addition instruction in response to detecting any of the set of predetermined conditions in the instruction addend 316/320 mantissa bits with respect to their contribution to a rounding determination relative to the precision specified by the PC field 308 of <figref idrefs="f0003">Figure 3</figref>. The embodiment of <figref idrefs="f0004">Figure 5</figref> includes two predetermined conditions in the set.</p><p id="p0044" num="0044">The first predetermined condition is: (1) the instruction instructs the x87 FPU 388 to perform an effective addition operation OR the difference between the exponents of the addends 316/320 is greater than 1; and (2) the precision of the larger addend mantissa is greater than the precision specified by the PC field 308. When the first predetermined condition is satisfied there is a possibility that both addend 316/320 mantissas will contribute sticky bits to the effective addition or effective subtraction<!-- EPO <DP n="20"> --> operation, which requires an addition or subtraction of the sticky bits before the rounding determination can be made, which would require an extra clock cycle to perform the floating point addition instruction, according to one embodiment of the microprocessor 100 process technology and x87 FPU 388 design. Consequently, when the Control Logic 328 detects the first predetermined condition is satisfied at block 612, the Control Logic 328, among other things, requests a replay of the instruction, as described with respect to block 624 of <figref idrefs="f0005">Figure 6</figref>.</p><p id="p0045" num="0045">The second predetermined condition is: (1) the instruction instructs the x87 FPU 388 to perform an effective subtraction operation; (2) the difference between the exponents of the addends 316/320 is less than or equal to 1; and (3) the mantissa of at least one of the addends 316/320 is greater than the precision specified by the PC field 308. When the second predetermined condition is satisfied and the exponents of the two addends 316/320 are equal, there is a possibility that the effective subtraction operation will cause cancellation of multiple upper bits of the addend 316/320 mantissas (sometimes referred to as "mass cancellation"), resulting in leading zeros in the resultant intermediate difference, which would require a left-shift by multiple bits to normalize the resultant difference. Because the amount of the left-shift is not known until after the subtraction operation is performed, the Control Logic 328 cannot know which bits of the resultant difference will be the sticky bits that contribute to the rounding determination, which prevents the Control Logic 328 from making the rounding determination in parallel with the effective subtraction operation. Consequently, when the Control Logic 328 detects the second predetermined condition is satisfied at block 612, the Control Logic 328, among other things, requests a replay of the instruction, as described with respect to block 624 of <figref idrefs="f0005">Figure 6</figref>.</p><p id="p0046" num="0046">When the second predetermined condition is satisfied and the absolute value of the difference between the exponent of the minuend and the exponent of the subtrahend equals one, the smaller operand will need to be shifted right one bit. In any case, the minuend will be selected as the operand having the larger exponent. That is, regardless of the initial order, the smaller operand will be the shifted operand. If the least significant bit of the shifted operand is a binary '1' value, the possibility exists that a 65-bit<!-- EPO <DP n="21"> --> difference will be generated in which the least significant bit is a binary '1' value, which would be the lone sticky bit that may require the intermediate difference to be rounded up. However, the Control Logic 328 cannot make this rounding determination until the subtraction operation is performed, which prevents the Control Logic 328 from making the rounding determination in parallel with the effective subtraction operation. Consequently, when the Control Logic 328 detects the second predetermined condition is satisfied at block 612, the Control Logic 328, among other things, requests a replay of the instruction, as described with respect to block 624 of <figref idrefs="f0005">Figure 6</figref>. In this case, the Control Logic 328 selects the result generated by the N-path. However, there is also a possibility that the precision of the larger operand is less than or equal to the precision specified by the PC field 308, in which case the R-path will be able to generate a correct final result 336 in one embodiment within the desired time (e.g., within two clock cycles). Therefore, the R-path overrides the N-path such that the Control Logic 328 does not request a replay via the replay request signal 340 but instead provides the final result 336 from the R-path.</p><p id="p0047" num="0047">In one embodiment, the set of predetermined conditions comprises the two conditions described with respect to <figref idrefs="f0004">Figure 5</figref>. However, other embodiments are contemplated in which the set of predetermined conditions is different. The set of predetermined conditions may depend upon design goals, including performance goals, and upon the design characteristics of the microprocessor 100 and x87 FPU 388, such as the particular semiconductor process technology employed, levels of gate delays, signal propagation times, and the like. For example, it may be observed that a finer granularity of predetermined conditions than the set described in the embodiment of <figref idrefs="f0004">Figure 5</figref> may be employed at a possible cost of more complexity and die real estate, but with a possible increase in aggregate performance by reducing the number of floating point addition instructions in a given program execution that require a replay. The present inventors have observed that an embodiment of the microprocessor 100 employing the set of predetermined conditions of <figref idrefs="f0004">Figure 5</figref> provides significant performance improvement in some commercial software applications and benchmarks, apparently because the percentage of cases in which the floating point addition instruction addends<!-- EPO <DP n="22"> --> and PC field 308 value do not satisfy any of the set of predetermined conditions is so much greater than the percentage of time in which they do satisfy at least one of the set of predetermined conditions that the benefit of faster execution time (2 clock cycles in one embodiment) in the former cases outweighs the disadvantage of slower execution time (due to the replay of the floating point addition instruction) in the latter cases in the aggregate, i.e., over the run time of the software application or benchmark.</p><p id="p0048" num="0048">Referring now to <figref idrefs="f0005">Figure 6</figref>, a flowchart illustrating operation of the microprocessor 100 of <figref idrefs="f0001">Figure 1</figref> to perform x87 floating point addition instructions according to the present invention is shown. It should be understood that the order or concurrency of the steps shown in <figref idrefs="f0005">Figure 6</figref> may be different than shown in the flowchart. For example, in one embodiment, the operation of blocks 604 and 608 may be substantially concurrent in one of the paths of the x87 FPU 388. Flow begins at block 602.</p><p id="p0049" num="0049">At block 602, the Instruction Dispatcher 120 of <figref idrefs="f0001">Figure 1</figref> initially dispatches an x87 floating point addition instruction and its operands to the x87 FPU 388 of <figref idrefs="f0003">Figure 3</figref>. Flow proceeds to block 604.</p><p id="p0050" num="0050">At block 604, the Instruction Dispatcher 120 controls the mux 394 to select addend B 320 and the mux 392 to select addend A 316. Additionally, the Control Logic 328 of <figref idrefs="f0003">Figure 3</figref> controls mux 396 to select the output of mux 394, i.e., to select addend B 316. The Control Logic 328 computes the difference between the exponents of the addends 316/320 and identifies the larger and smaller of the two addends 316/320 from the difference. The Control Logic 328 shifts the smaller addend mantissa right by the difference to align the smaller addend mantissa with the larger addend mantissa. Zero bits are provided into the leading bit positions of the smaller addend vacated by the alignment right shift. Flow proceeds to block 606 and to block 608.</p><p id="p0051" num="0051">At block 606, the Adder A 324A and Adder B 324B each begin adding the larger addend to the aligned smaller addend to generate their respective rounded-up and non-rounded-up sums. Flow proceeds from block 606 to decision block 612.</p><p id="p0052" num="0052">At block 608, the Control Logic 328 analyzes the addends 316/320 with respect to their contribution to the rounding determination and relative to the precision specified<!-- EPO <DP n="23"> --> by the PC field 308 value in order to determine whether any of the set of predetermined conditions exists. In one embodiment, the set of predetermined conditions is the set described with respect to <figref idrefs="f0004">Figure 5</figref>. However, other embodiments are contemplated in which the set of predetermined conditions is different. The Control Logic 328 analyzes the addends 316/320 at block 608 substantially in parallel with the generation of the respective sums by the Adders 324A and 324B in block 606. Flow proceeds from block 608 to decision block 612.</p><p id="p0053" num="0053">At decision block 612, the Control Logic 328 determines whether any of the predetermined conditions exist. If so, flow proceeds to block 622; otherwise, flow proceeds to block 614.</p><p id="p0054" num="0054">At block 614, the Control Logic 328 makes the rounding determination based on the sticky bits contributed by the aligned smaller addend and the precision specified by the PC field 308 value. That is, the Control Logic 328 determines whether or not the rounded-up sum generated by Adder A 324A or the non-rounded-up sum generated by Adder B 324B should be selected by the mux 398 depending upon the value of the sticky bits of the aligned smaller addend in view of the rounding mode specified in the Rounding Control (RC) field 312 of the FPCW 304. The Control Logic 328 performs the rounding determination of block 614 (and the determination at block 612) substantially in parallel with the generation of the respective sums by the Adders 324A and 324B in block 606. Flow proceeds to block 616.</p><p id="p0055" num="0055">At block 616, the Control Logic 328 controls the mux 398 to select the appropriate rounded-up sum generated by Adder A 324A or the non-rounded-up sum generated by Adder B 324B based on the rounding determination made at block 614. That is, if the Control Logic 328 determines that the sum needs rounding up, then the Control Logic 328 controls the mux 398 to select the rounded-up sum generated by Adder A 324A; otherwise, the Control Logic 328 controls the mux 398 to select the non-rounded-up sum generated by Adder B 324B. Flow proceeds to block 618.</p><p id="p0056" num="0056">At block 618, the FPU 388 normalizes the properly rounded sum selected at block 616 as needed to generate the final result 336 of the floating point addition instruction. The FPU 388 performs the normalization by shifting until the most-significant<!-- EPO <DP n="24"> --> binary '1' value bit is to the left of the binary point, as is well-known in the art. Additionally, the FPU 388 clears to zero any bits of the normalized final result 336 that are of less arithmetic significance than the precision specified by the PC field 308. The Retire Unit 126 retires the final result 336 to the architected IA-32 floating point register specified by the floating point addition instruction. In one embodiment, the x87 FPU 388 is advantageously capable of executing the floating point addition instruction according to the steps of blocks 602 through 606 and 612 through 618 (i.e., when a replay is not required) in two clock cycles in a microprocessor 100 manufactured with a 65 nanometer CMOS technology process running at an internal clock frequency of 2.0 GHz. Flow ends at block 618.</p><p id="p0057" num="0057">At block 622, the Control Logic 328 generates a cumulative sticky bit 338 based on the least significant mantissa bits of the aligned smaller addend that are not directly representable in the intermediate 64-bit result format. That is, in an embodiment in which the Adders 324A and 324B are 64 bit adders, the Control Logic 328 generates a binary '1' cumulative sticky bit 338 if any of the aligned smaller addend mantissa bits below the 64<sup>th</sup> bit position of the aligned smaller addend are a binary '1'; otherwise, the Control Logic 328 generates a binary '0' cumulative sticky bit 338. The Control Logic 328 generates the cumulative sticky bit 338 in block 622 (and the determination at block 612) substantially in parallel with the generation of the respective sums by the Adders 324A and 324B in block 606. Additionally, the Control Logic 328 controls the mux 398 to select the non-rounded-up sum generated by Adder B 324B. Finally, the FPU 388 saves the cumulative sticky bit 338 in register 348 and saves the non-rounded-up sum generated by Adder B 324B. The saved cumulative sticky bit 348 and the bits of the non-rounded-up sum generated by Adder B 324B that are of less arithmetic significance than the precision specified by the PC field 308 comprise saved rounding information that will be subsequently used by the FPU 388 on the replay of the floating point addition instruction to make the rounding determination. In one embodiment, the FPU 388 saves the non-rounded-up sum generated by Adder B 324B into the rename register allocated to the floating point addition instruction. In one embodiment, the FPU 388<!-- EPO <DP n="25"> --> saves the non-rounded-up sum generated by Adder B 324B into a temporary register of the microprocessor 100. Flow proceeds to block 624.</p><p id="p0058" num="0058">At block 624, the FPU 388 signals the Instruction Dispatcher 120 and the ROB 128 via the replay request signal 340 that the floating point addition instruction needs to be replayed. In one embodiment, when the FPU 388 asserts the replay request signal 340, it also provides the ROB 128 tag of the floating point addition instruction, which the Instruction Dispatcher 120 stores and subsequently outputs at block 628 when the Instruction Dispatcher 120 re-dispatches the floating point addition instruction. Flow proceeds to block 626.</p><p id="p0059" num="0059">At block 626, in response to the assertion of replay request signal 340 at block 624, the ROB 128 flushes the Execution Unit 124 pipelines of all unretired instructions to avoid instructions that are dependent upon the result of the floating point addition instruction from receiving an incorrect source operand value, since the intermediate result 336 generated by the FPU 388 is not yet correct, i.e., since it still remains to be determined upon the replay of the floating point addition instruction whether or not the intermediate result 336 needs to be rounded-up. After flushing the Execution Unit 124 pipelines, the ROB 128 waits until the floating point addition instruction becomes the oldest instruction in the ROB 128, i.e., until all other instructions older than the floating point addition instruction in program order have retired. Then, the ROB 128 replays all unretired instructions, starting with the floating point addition instruction. In particular, the ROB 128 updates the state of each of the unretired instructions to indicate that they need to be dispatched. Flow proceeds to block 628.</p><p id="p0060" num="0060">At block 628, the Instruction Dispatcher 120 examines the ROB 128 and detects that the floating point addition instruction needs to be dispatched. In response, the Instruction Dispatcher 120 dispatches, i.e., re-dispatches, the floating point addition instruction to the FPU 388 and simultaneously asserts the re-dispatch signal 344 of <figref idrefs="f0003">Figure 3</figref> to notify the FPU 388 that this is the floating point addition instruction being replayed that previously requested to be replayed at block 624. In one embodiment, the Instruction Dispatcher 120 knows it needs to assert the re-dispatch signal 344 because, as it is dispatching instructions from the ROB 128, it compares the ROB 128 tag of the<!-- EPO <DP n="26"> --> instruction about to be dispatched with the ROB 128 tag saved in block 624 and detects that the tags match. Flow proceeds to block 632.</p><p id="p0061" num="0061">At block 632, the Control Logic 328 makes the rounding determination based on the saved rounding information (e.g., the saved cumulative sticky bit 348 and the sticky bits of the saved sum 346, i.e., the bits of the saved sum 346 that are of less arithmetic significance than the precision specified by the PC field 308) and the precision specified by the PC field 308 value and rounding mode specified by the RC field 312 value. That is, the Control Logic 328 determines whether or not the rounded-up sum generated by Adder A 324A or the non-rounded-up sum generated by Adder B 324B should be selected by the mux 398 depending upon the value of the saved rounding information in view of the rounding mode specified in the RC field 312 of the FPCW 304. In one embodiment, the FPU 388, in response to the replay signal 340 from the Instruction Dispatcher 120, modifies the floating point addition microinstruction to a different type of microinstruction that instructs the FPU 388 to convert the saved sum 346 to the precision specified by the PC field 308 and to round based on the saved rounding information and RC field 312. Flow proceeds to block 634.</p><p id="p0062" num="0062">At block 634, the Control Logic 328 controls the mux 398 to select the appropriate rounded-up sum generated by Adder A 324A or the non-rounded-up sum generated by Adder B 324B based on the rounding determination made at block 632. Additionally, the FPU 388 normalizes the rounded sum, i.e., the selected sum, as needed to generate the final result 336 of the floating point addition instruction. Additionally, the FPU 388 clears to zero any bits of the normalized final result 336 that are of less arithmetic significance than the precision specified by the PC field 308. The Retire Unit 126 retires the final result 336 to the architected IA-32 floating point register specified by the floating point addition instruction. Flow ends at block 634.</p><p id="p0063" num="0063">Although the present invention and its objects, features, and advantages have been described in detail, other embodiments are encompassed by the invention. For example, although embodiments have been described in the context of an x87 FPU, other embodiments are contemplated in which other floating point architectures that create conditions in which the FPU cannot make the rounding determination<!-- EPO <DP n="27"> --> substantially in parallel with the addition of the floating point addition instruction addends preventing the FPU from executing the instruction within the desired number of clock cycles employs the selective replay of the instruction technique described herein. Additionally, although embodiments have been described using positive logic, it should be understood that negative logic may also be employed in other embodiments of the invention.</p><p id="p0064" num="0064">While various embodiments of the present invention have been described herein, it should be understood that they have been presented by way of example, and not limitation. It will be apparent to persons skilled in the relevant computer arts that various changes in form and detail can be made therein without departing from the scope of the invention. For example, in addition to using hardware (e.g., within or coupled to a Central Processing Unit ("CPU"), microprocessor, microcontroller, digital signal processor (DSP), processor core, System on Chip ("SOC"), or any other device), implementations may also be embodied in software (e.g., computer readable code, program code, and instructions disposed in any form, such as source, object or machine language) disposed, for example, in a computer usable (e.g., readable) medium configured to store the software. Such software can enable, for example, the function, fabrication, modeling, simulation, description and/or testing of the apparatus and methods described herein. For example, this can be accomplished through the use of general programming languages (e.g., C, C++), hardware description languages (HDL) including Verilog HDL, VHDL, and so on, or other available programs. Such software can be disposed in any known computer readable storage medium such as semiconductor, magnetic disk, or optical disc (e.g., CD-ROM, DVD-ROM, etc.). It is understood that the apparatus and method described herein may be included in a semiconductor intellectual property core, such as a microprocessor core (e.g., embodied in HDL) and transformed to hardware in the production of integrated circuits. Additionally, the apparatus and methods described herein may be embodied as a combination of hardware and software. Thus, the present invention should not be limited by any of the herein-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents.<!-- EPO <DP n="28"> --></p><p id="p0065" num="0065">Finally, those skilled in the art should appreciate that they can readily use the disclosed conception and specific embodiments as a basis for designing or modifying other structures for carrying out the same purposes of the present invention without departing from the scope of the invention as defined by the appended claims.</p></description><claims mxw-id="PCLM56986988" lang="DE" load-source="patent-office"><!-- EPO <DP n="37"> --><claim id="c-de-01-0001" num="0001"><claim-text>Mikroprozessor, umfassend:
<claim-text>ein x87-Floating-Point-Control-Word (FPCW), das ein Precision-Control-Feld (PC) enthält, das dafür programmierbar ist, die Präzision von Fließkommaberechnungen (FP) zu spezifizieren, die eine FP-Einheit (FPU) des Mikroprozessors ausführt,</claim-text>
<claim-text>einen Befehlszuteiler, der dafür konfiguriert ist, der FPU einen x87-FP-Additionsbefehl (FPADD) zuzuteilen, wobei der FPADD einen ersten und einen zweiten Summanden aufweist; und</claim-text>
<claim-text>die FPU dafür konfiguriert ist:
<claim-text>den ersten und den zweiten Summanden zu addieren, damit eine Summe erzeugt wird;</claim-text>
<claim-text>festzustellen, ob zumindest eine Bedingung eines Satzes vorbestimmter Bedingungen für den ersten und zweiten Summanden erfüllt ist, und zwar bezüglich ihrer Beiträge zu einer Rundungsfeststellung der Summe und bezüglich der Präzision, die durch das PC-Feld spezifiziert wird;</claim-text>
<claim-text>falls keine Bedingung des Satzes vorbestimmter Bedingungen erfüllt ist:
<claim-text>1) das Treffen der Rundungsfeststellung gestützt auf Bits der Mantisse des kleineren Summanden der ersten und zweiten Summanden und auf die Präzision, die durch das PC-Feld spezifiziert wird; und</claim-text>
<claim-text>2) das gezielte Aufrunden der Summe abhängig von der Rundungsfeststellung zum Erzeugen eines endgültigen Ergebnisses des FPADD; und falls mindestens eine Bedingung des Satzes vorbestimmter Bedingungen erfüllt ist:
<claim-text>1) das Sichern der Summe und das Sichern der Rundungsinformation, die aus dem ersten und dem zweiten Summanden abgeleitet wurden;</claim-text>
<claim-text>2) das Signalisieren an den Befehlszuteiler, dass er den FPADD erneut an die FPU zuteilen muss; und</claim-text>
<claim-text>3) als Reaktion darauf, dass der Befehlszuteiler den FPADD erneut an die FPU zuteilt:
<claim-text>a) das Treffen der Rundungsfeststellung gestützt auf die gesicherte Rundungsinformation und die Präzision, die durch das PC-Feld spezifiziert ist; und</claim-text>
<claim-text>b) das gezielte Aufrunden der Summe abhängig von der<!-- EPO <DP n="38"> --> Rundungsfeststellung zum Erzeugen des endgültigen Ergebnisses.</claim-text></claim-text></claim-text></claim-text></claim-text></claim-text></claim><claim id="c-de-01-0002" num="0002"><claim-text>Mikroprozessor nach Anspruch 1, wobei eine Bedingung des Satzes vorbestimmter Bedingungen umfasst:
<claim-text>die FPU hat als Reaktion auf den FPADD eine effektive Additionsoperation vorzunehmen; und</claim-text>
<claim-text>die Präzision des größeren der ersten und zweiten Summanden ist größer als die Präzision, die im PC-Feld spezifiziert ist.</claim-text></claim-text></claim><claim id="c-de-01-0003" num="0003"><claim-text>Mikroprozessor nach Anspruch 2, wobei eine zweite Bedingung des Satzes vorbestimmter Bedingungen umfasst:
<claim-text>die Differenz der Exponenten des ersten und des zweiten Summanden ist größer als eins; und</claim-text>
<claim-text>die Präzision des größeren der ersten und zweiten Summanden ist größer als die Präzision, die im PC-Feld spezifiziert ist.</claim-text></claim-text></claim><claim id="c-de-01-0004" num="0004"><claim-text>Mikroprozessor nach Anspruch 3, wobei eine dritte Bedingung des Satzes vorbestimmter Bedingungen umfasst:
<claim-text>die FPU hat als Reaktion auf den FPADD eine effektive Subtraktionsoperation vorzunehmen;</claim-text>
<claim-text>die Differenz der Exponenten des ersten und des zweiten Summanden ist kleiner oder gleich eins; und</claim-text>
<claim-text>die Präzision mindestens eines Summanden der ersten und zweiten Summanden ist größer als die Präzision, die im PC-Feld spezifiziert ist.</claim-text></claim-text></claim><claim id="c-de-01-0005" num="0005"><claim-text>Mikroprozessor nach Anspruch 1, wobei die FPU den FPADD in zwei Taktzyklen ausführt, wenn keine Bedingung des Satzes vorbestimmter Bedingungen erfüllt ist.</claim-text></claim><claim id="c-de-01-0006" num="0006"><claim-text>Mikroprozessor nach Anspruch 1, wobei, wenn der Befehlszuteiler den FPADD erneut auf die FPU zuteilt, der Befehlszuteiler der FPU auch eine Angabe liefert, dass der FPADD erneut zugeteilt wurde, und zwar im Unterschied zur früheren Zuteilung des FPADD durch den Befehlszuteiler an die FPU.</claim-text></claim><claim id="c-de-01-0007" num="0007"><claim-text>Mikroprozessor nach Anspruch 1, wobei die gesicherte Rundungsinformation Bits der Summe umfasst, die weniger arithmetische Signifikanz haben als die Präzision, die im PC-Feld des FPCW spezifiziert ist.<!-- EPO <DP n="39"> --></claim-text></claim><claim id="c-de-01-0008" num="0008"><claim-text>Mikroprozessor nach Anspruch 1, wobei die gesicherte Rundungsinformation ein kumulatives Sticky-Bit umfasst, das auf den geringstwertigen Bits einer ausgerichteten Mantisse des kleineren Summanden der ersten und zweiten Summanden beruht, die nicht in der Addition des ersten und des zweiten Summanden zum Erzeugen der Summe enthalten sind.</claim-text></claim><claim id="c-de-01-0009" num="0009"><claim-text>Mikroprozessor nach Anspruch 1, wobei, wenn keine Bedingung des Satzes vorbestimmter Bedingungen erfüllt ist, die FPU so konfiguriert ist, dass sie die Rundungsfeststellung abhängig von den Bits der Mantisse des kleineren Summanden der ersten und zweiten Summanden trifft, die nach dem Ausrichten weniger arithmetische Signifikanz haben als die Präzision, die im PC-Feld spezifiziert ist.</claim-text></claim><claim id="c-de-01-0010" num="0010"><claim-text>Mikroprozessor nach Anspruch 1, wobei die FPU zudem dafür konfiguriert ist, die gezielt aufgerundete Summe zu normieren, damit das endgültige Ergebnis erzeugt wird.</claim-text></claim><claim id="c-de-01-0011" num="0011"><claim-text>Mikroprozessor nach Anspruch 1, wobei die FPU dafür konfiguriert ist, einen kleineren Summanden der ersten und zweiten Summanden auszurichten, um den ersten und den zweiten Summanden zu addieren, damit die Summe erzeugt wird.</claim-text></claim><claim id="c-de-01-0012" num="0012"><claim-text>Verfahren zum Verarbeiten eines x87-Fließkomma (FP) Additionsbefehls (FPADD) in einem Mikroprozessor, der eine FP-Einheit (FPU), einen Befehlszuteiler und ein x87-Floating-Point-Control-Word (FPCW) enthält, das ein Precision-Control-Feld (PC) enthält, das dafür programmierbar ist, die Präzision von FP-Berechnungen zu spezifizieren, die die FPU ausführt, wobei das Verfahren umfasst:
<claim-text>zuerst das Zuteilen eines x87-FP-Additionsbefehls (FPADD) an die FPU, wobei der FPADD einen ersten und einen zweiten Summanden aufweist;</claim-text>
<claim-text>das Addieren des ersten und des zweiten Summanden, damit eine Summe erzeugt wird;</claim-text>
<claim-text>das Feststellen, ob zumindest eine Bedingung eines Satzes vorbestimmter Bedingungen für den ersten und zweiten Summanden erfüllt ist, und zwar bezüglich ihrer Beiträge zu einer Rundungsfeststellung der Summe und bezüglich der Präzision, die durch das PC-Feld spezifiziert wird;</claim-text>
<claim-text>falls keine Bedingung des Satzes vorbestimmter Bedingungen erfüllt ist:
<claim-text>1) das Treffen der Rundungsfeststellung gestützt auf Bits der Mantisse des kleineren Summanden der ersten und zweiten Summanden und auf die Präzision, die durch das PC-Feld spezifiziert wird; und<!-- EPO <DP n="40"> --></claim-text>
<claim-text>2) das gezielte Aufrunden der Summe abhängig von der Rundungsfeststellung zum Erzeugen eines endgültigen Ergebnisses des FPADD; und falls mindestens eine Bedingung des Satzes vorbestimmter Bedingungen erfüllt ist:
<claim-text>1) das Sichern der Summe und das Sichern der Rundungsinformation, die aus dem ersten und dem zweiten Summanden abgeleitet werden;</claim-text>
<claim-text>2) das Signalisieren an den Befehlszuteiler, dass er den FPADD erneut an die FPU zuteilen muss; und</claim-text>
<claim-text>3) als Reaktion darauf, dass der Befehlszuteiler den FPADD erneut an die FPU zuteilt:
<claim-text>a) das Treffen der Rundungsfeststellung gestützt auf die gesicherte Rundungsinformation und die Präzision, die durch das PC-Feld spezifiziert ist; und</claim-text>
<claim-text>b) das gezielte Aufrunden der Summe abhängig von der Rundungsfeststellung zum Erzeugen des endgültigen Ergebnisses.</claim-text></claim-text></claim-text></claim-text></claim-text></claim><claim id="c-de-01-0013" num="0013"><claim-text>Verfahren nach Anspruch 12, wobei eine Bedingung des Satzes vorbestimmter Bedingungen umfasst:
<claim-text>die FPU hat als Reaktion auf den FPADD eine effektive Additionsoperation vorzunehmen; und</claim-text>
<claim-text>die Präzision des größeren der ersten und zweiten Summanden ist größer als die Präzision, die im PC-Feld spezifiziert ist.</claim-text></claim-text></claim><claim id="c-de-01-0014" num="0014"><claim-text>Verfahren nach Anspruch 13, wobei eine zweite Bedingung des Satzes vorbestimmter Bedingungen umfasst:
<claim-text>die Differenz der Exponenten des ersten und des zweiten Summanden ist größer als eins; und</claim-text>
<claim-text>die Präzision des größeren der ersten und zweiten Summanden ist größer als die Präzision, die im PC-Feld spezifiziert ist.</claim-text></claim-text></claim><claim id="c-de-01-0015" num="0015"><claim-text>Verfahren nach Anspruch 14, wobei eine dritte Bedingung des Satzes vorbestimmter Bedingungen umfasst:
<claim-text>die FPU hat als Reaktion auf den FPADD eine effektive Subtraktionsoperation vorzunehmen;</claim-text>
<claim-text>die Differenz der Exponenten des ersten und des zweiten Summanden ist kleiner oder gleich eins; und</claim-text>
<claim-text>die Präzision mindestens eines Summanden der ersten und zweiten Summanden<!-- EPO <DP n="41"> --> ist größer als die Präzision, die im PC-Feld spezifiziert ist.</claim-text></claim-text></claim><claim id="c-de-01-0016" num="0016"><claim-text>Verfahren nach Anspruch 12, wobei die FPU den FPADD in zwei Taktzyklen ausführt, wenn keine Bedingung des Satzes vorbestimmter Bedingungen erfüllt ist.</claim-text></claim><claim id="c-de-01-0017" num="0017"><claim-text>Verfahren nach Anspruch 12, wobei, wenn der Befehlszuteiler den FPADD erneut an die FPU zuteilt, der Befehlszuteiler der FPU auch eine Angabe liefert, dass der FPADD erneut zugeteilt wurde, und zwar im Unterschied zur früheren Zuteilung des FPADD durch den Befehlszuteiler an die FPU.</claim-text></claim><claim id="c-de-01-0018" num="0018"><claim-text>Verfahren nach Anspruch 12, wobei die gesicherte Rundungsinformation Bits der Summe umfasst, die weniger arithmetische Signifikanz haben als die Präzision, die im PC-Feld des FPCW spezifiziert ist.</claim-text></claim><claim id="c-de-01-0019" num="0019"><claim-text>Verfahren nach Anspruch 12, wobei die gesicherte Rundungsinformation ein kumulatives Sticky-Bit umfasst, das auf den geringstwertigen Bits einer ausgerichteten Mantisse des kleineren Summanden der ersten und zweiten Summanden beruht, die nicht in der Addition des ersten und des zweiten Summanden zum Erzeugen der Summe enthalten sind.</claim-text></claim><claim id="c-de-01-0020" num="0020"><claim-text>Verfahren nach Anspruch 12, wobei, wenn keine Bedingung des Satzes vorbestimmter Bedingungen erfüllt ist, die FPU so konfiguriert ist, dass sie die Rundungsfeststellung abhängig von Bits der Mantisse des kleineren Summanden der ersten und zweiten Summanden trifft, die nach dem Ausrichten weniger arithmetische Signifikanz haben als die Präzision, die im PC-Feld spezifiziert ist.</claim-text></claim><claim id="c-de-01-0021" num="0021"><claim-text>Verfahren nach Anspruch 12, wobei die FPU dafür konfiguriert ist, einen kleineren Summanden der ersten und zweiten Summanden auszurichten, um den ersten und den zweiten Summanden zu addieren, damit die Summe erzeugt wird.</claim-text></claim><claim id="c-de-01-0022" num="0022"><claim-text>Computerprogrammprodukt zum Gebrauch mit einer Computervorrichtung, wobei das Computerprogrammprodukt umfasst:
<claim-text>ein computerlesbares Speichermedium, wobei in dem computerlesbaren Speichermedium computerlesbarer Programmcode verkörpert ist, der einen Mikroprozessor bereitstellt, wobei der computerlesbare Programmcode umfasst:
<claim-text>einen ersten Programmcode zum Bereitstellen eines x87-Floating-Point-Control-Words (FPCW), das ein Precision-Control-Feld (PC) enthält, das dafür programmierbar<!-- EPO <DP n="42"> --> ist, die Präzision von FP-Berechnungen zu spezifizieren, die eine FP-Einheit (FPU) des Mikroprozessors ausführt,</claim-text>
<claim-text>einen zweiten Programmcode zum Bereitstellen eines Befehlszuteilers, der dafür konfiguriert ist, der FPU einen x87-FP-Additionsbefehl (FPADD) zuzuteilen, wobei der FPADD einen ersten und einen zweiten Summanden aufweist; und</claim-text>
<claim-text>einen dritten Programmcode zum Bereitstellen der FPU, konfiguriert dafür:
<claim-text>den ersten und den zweiten Summanden zu addieren, damit eine Summe erzeugt wird;</claim-text>
<claim-text>festzustellen, ob zumindest eine Bedingung eines Satzes vorbestimmter Bedingungen für den ersten und zweiten Summanden erfüllt ist, und zwar bezüglich ihrer Beiträge zu einer Rundungsfeststellung der Summe und bezüglich der Präzision, die durch das PC-Feld spezifiziert wird;</claim-text>
<claim-text>falls keine Bedingung des Satzes vorbestimmter Bedingungen erfüllt ist:
<claim-text>1) das Treffen der Rundungsfeststellung gestützt auf Bits der Mantisse des kleineren Summanden der ersten und zweiten Summanden und auf die Präzision, die durch das PC-Feld spezifiziert wird; und</claim-text>
<claim-text>2) das gezielte Aufrunden der Summe abhängig von der Rundungsfeststellung zum Erzeugen eines endgültigen Ergebnisses des FPADD; und falls mindestens eine Bedingung des Satzes vorbestimmter Bedingungen erfüllt ist:
<claim-text>1) das Sichern der Summe und das Sichern der Rundungsinformation, die aus dem ersten und dem zweiten Summanden abgeleitet werden;</claim-text>
<claim-text>2) das Signalisieren an den Befehlszuteiler, dass er den FPADD erneut an die FPU zuteilen muss; und</claim-text>
<claim-text>3) als Reaktion darauf, dass der Befehlszuteiler den FPADD erneut an die FPU zuteilt:
<claim-text>a) das Treffen der Rundungsfeststellung gestützt auf die gesicherte Rundungsinformation und die Präzision, die durch das PC-Feld spezifiziert ist; und</claim-text>
<claim-text>b) das gezielte Aufrunden der Summe abhängig von der Rundungsfeststellung zum Erzeugen des endgültigen Ergebnisses.</claim-text></claim-text></claim-text></claim-text></claim-text></claim-text></claim-text></claim><claim id="c-de-01-0023" num="0023"><claim-text>Computerprogrammprodukt nach Anspruch 22, wobei eine Bedingung des Satzes vorbestimmter Bedingungen umfasst:
<claim-text>die FPU hat als Reaktion auf den FPADD eine effektive Additionsoperation vorzunehmen; und</claim-text>
<claim-text>die Präzision des größeren der ersten und zweiten Summanden ist größer<!-- EPO <DP n="43"> --> als die Präzision, die im PC-Feld spezifiziert ist.</claim-text></claim-text></claim><claim id="c-de-01-0024" num="0024"><claim-text>Computerprogrammprodukt nach Anspruch 23, wobei eine zweite Bedingung des Satzes vorbestimmter Bedingungen umfasst:
<claim-text>die Differenz der Exponenten des ersten und des zweiten Summanden ist größer als eins; und</claim-text>
<claim-text>die Präzision des größeren der ersten und zweiten Summanden ist größer als die Präzision, die im PC-Feld spezifiziert ist.</claim-text></claim-text></claim><claim id="c-de-01-0025" num="0025"><claim-text>Computerprogrammprodukt nach Anspruch 24, wobei eine dritte Bedingung des Satzes vorbestimmter Bedingungen umfasst:
<claim-text>die FPU hat als Reaktion auf den FPADD eine effektive Subtraktionsoperation vorzunehmen;</claim-text>
<claim-text>die Differenz der Exponenten des ersten und des zweiten Summanden ist kleiner oder gleich eins; und</claim-text>
<claim-text>die Präzision mindestens eines Summanden der ersten und zweiten Summanden ist größer als die Präzision, die im PC-Feld spezifiziert ist.</claim-text></claim-text></claim></claims><claims mxw-id="PCLM56986989" lang="EN" load-source="patent-office"><!-- EPO <DP n="29"> --><claim id="c-en-01-0001" num="0001"><claim-text>A microprocessor, comprising:
<claim-text>an x87 Floating Point Control Word (FPCW) including a Precision Control (PC) field programmable for specifying a precision of floating point (FP) calculations made by a FP unit (FPU) of the microprocessor;</claim-text>
<claim-text>an instruction dispatcher, configured to dispatch an x87 FP addition instruction (FPADD) to the FPU, the FPADD having first and second FP addends; and</claim-text>
<claim-text>the FPU, configured to:
<claim-text>add the first and second addends to generate a sum;</claim-text>
<claim-text>determine whether at least one of a set of predetermined conditions exists in the first and second addends with respect to their contribution to a rounding determination of the sum and relative to the precision specified by the PC field;</claim-text>
<claim-text>if none of the set of predetermined conditions exists:
<claim-text>(1) make the rounding determination based on bits of the mantissa of the smaller of the first and second addends and the precision specified by the PC field; and</claim-text>
<claim-text>(2) selectively round up the sum based on the rounding determination for generating a final result of the FPADD; and</claim-text></claim-text>
<claim-text>if at least one of the set of predetermined conditions exists:
<claim-text>(1) save the sum and save rounding information derived from the first and second addends;<!-- EPO <DP n="30"> --></claim-text>
<claim-text>(2) signal the instruction dispatcher to re-dispatch the FPADD to the FPU; and</claim-text>
<claim-text>(3) in response to the instruction dispatcher re-dispatching the FPADD to the FPU:
<claim-text>(a) make the rounding determination based on the saved rounding information and the precision specified by the PC field; and</claim-text>
<claim-text>(b) selectively round up the sum based on the rounding determination for generating the final result.</claim-text></claim-text></claim-text></claim-text></claim-text></claim><claim id="c-en-01-0002" num="0002"><claim-text>The microprocessor of claim 1, wherein one of the set of predetermined conditions comprises:
<claim-text>an effective addition operation is to be performed by the FPU in response to the FPADD; and</claim-text>
<claim-text>the precision of the larger of the first and second addends is greater than the precision specified by the PC field.</claim-text></claim-text></claim><claim id="c-en-01-0003" num="0003"><claim-text>The microprocessor of claim 2, wherein a second of the set of predetermined conditions comprises:
<claim-text>a difference of the exponents of the first and second addends is greater than one; and</claim-text>
<claim-text>the precision of the larger of the first and second addends is greater than the precision specified by the PC field.</claim-text></claim-text></claim><claim id="c-en-01-0004" num="0004"><claim-text>The microprocessor of claim 3, wherein a third of the set of predetermined conditions comprises:
<claim-text>an effective subtraction operation is to be performed by the FPU in response to the FPADD;</claim-text>
<claim-text>a difference of the exponents of the first and second addends is less than or equal to one; and<!-- EPO <DP n="31"> --></claim-text>
<claim-text>the precision of at least one of the first and second addends is greater than the precision specified by the PC field.</claim-text></claim-text></claim><claim id="c-en-01-0005" num="0005"><claim-text>The microprocessor of claim 1, wherein the FPU executes the FPADD in two clock cycles when none of the set of predetermined conditions exists.</claim-text></claim><claim id="c-en-01-0006" num="0006"><claim-text>The microprocessor of claim 1, wherein when the instruction dispatcher re-issues the FPADD to the FPU, the instruction dispatcher also provides to the FPU an indication that the FPADD is being re-dispatched in distinction from the prior dispatch of the FPADD by the instruction dispatcher to the FPU.</claim-text></claim><claim id="c-en-01-0007" num="0007"><claim-text>The microprocessor of claim 1, wherein the saved rounding information comprises bits of the sum having less arithmetic significance than the precision specified in the PC field of the FPCW.</claim-text></claim><claim id="c-en-01-0008" num="0008"><claim-text>The microprocessor of claim 1, wherein the saved rounding information comprises a cumulative sticky bit based on the least significant bits of an aligned mantissa of a smaller of the first and second addends that are not included in the add of the first and second addends to generate the sum.</claim-text></claim><claim id="c-en-01-0009" num="0009"><claim-text>The microprocessor of claim 1, wherein if none of the set of predetermined conditions exists, the FPU is configured to make the rounding determination based on bits of the mantissa of the smaller of the first and second addends that, after being aligned, have less arithmetic significance than the precision specified by the PC field.</claim-text></claim><claim id="c-en-01-0010" num="0010"><claim-text>The microprocessor of claim 1, wherein the FPU is further configured to normalize the selectively rounded-up sum to generate the final result.</claim-text></claim><claim id="c-en-01-0011" num="0011"><claim-text>The microprocessor of claim 1, wherein the FPU is configured to align a smaller of the first and second addends in order to add the first and second addends to generate the sum.</claim-text></claim><claim id="c-en-01-0012" num="0012"><claim-text>A method for processing an x87 floating point (FP) addition instruction (FPADD) in a microprocessor having a FP unit (FPU), an instruction dispatcher, and an x87 Floating Point Control Word (FPCW) including a Precision Control<!-- EPO <DP n="32"> --> (PC) field programmable for specifying a precision of FP calculations made by the FPU, the method comprising:
<claim-text>dispatching initially an x87 FP addition instruction (FPADD) to the FPU, the FPADD having first and second FP addends;</claim-text>
<claim-text>adding the first and second addends to generate a sum;</claim-text>
<claim-text>determining whether at least one of a set of predetermined conditions exists in<br/>
the first and second addends with respect to their contribution to a rounding determination of the sum and relative to the precision specified by the PC field;</claim-text>
<claim-text>if none of the set of predetermined conditions exists:
<claim-text>(1) making the rounding determination based on bits of the mantissa of the smaller of the first and second addends and the precision specified by the PC field; and</claim-text>
<claim-text>(2) selectively rounding up the sum based on the rounding determination<br/>
for generating a final result of the FPADD; and</claim-text></claim-text>
<claim-text>if at least one of the set of predetermined conditions exists:
<claim-text>(1) saving the sum and saving rounding information derived from the first and second addends;</claim-text>
<claim-text>(2) signaling the instruction dispatcher to re-dispatch the FPADD to the FPU; and</claim-text>
<claim-text>(3) in response to the instruction dispatcher re-dispatching the FPADD to the FPU:
<claim-text>(a) making the rounding determination based on the saved rounding information and the precision specified by the PC field; and<!-- EPO <DP n="33"> --></claim-text>
<claim-text>(b) selectively rounding up the sum based on the rounding determination for generating the final result.</claim-text></claim-text></claim-text></claim-text></claim><claim id="c-en-01-0013" num="0013"><claim-text>The method of claim 12, wherein one of the set of predetermined conditions comprises:
<claim-text>an effective addition operation is to be performed by the FPU in response to the FPADD; and</claim-text>
<claim-text>the precision of the larger of the first and second addends is greater than the precision specified by the PC field.</claim-text></claim-text></claim><claim id="c-en-01-0014" num="0014"><claim-text>The method of claim 13, wherein a second of the set of predetermined conditions comprises:
<claim-text>a difference of the exponents of the first and second addends is greater than one; and</claim-text>
<claim-text>the precision of the larger of the first and second addends is greater than the precision specified by the PC field.</claim-text></claim-text></claim><claim id="c-en-01-0015" num="0015"><claim-text>The method of claim 14, wherein a third of the set of predetermined conditions comprises:
<claim-text>an effective subtraction operation is to be performed by the FPU in response to the FPADD;</claim-text>
<claim-text>a difference of the exponents of the first and second addends is less than or equal to one; and</claim-text>
<claim-text>the precision of at least one of the first and second addends is greater than the precision specified by the PC field.</claim-text></claim-text></claim><claim id="c-en-01-0016" num="0016"><claim-text>The method of claim 12, wherein the FPU executes the FPADD in two clock cycles when none of the set of predetermined conditions exists.</claim-text></claim><claim id="c-en-01-0017" num="0017"><claim-text>The method of claim 12, wherein when the instruction dispatcher re-issues the FPADD to the FPU, the instruction dispatcher also provides to the FPU an<!-- EPO <DP n="34"> --> indication that the FPADD is being re-dispatched in distinction from the prior dispatch of the FPADD by the instruction dispatcher to the FPU.</claim-text></claim><claim id="c-en-01-0018" num="0018"><claim-text>The method of claim 12, wherein the saved rounding information comprises bits of the sum having less arithmetic significance than the precision specified in the PC field of the FPCW.</claim-text></claim><claim id="c-en-01-0019" num="0019"><claim-text>The method of claim 12, wherein the saved rounding information comprises a cumulative sticky bit based on the least significant bits of an aligned mantissa of a smaller of the first and second addends that are not included in the add of the first and second addends to generate the sum.</claim-text></claim><claim id="c-en-01-0020" num="0020"><claim-text>The method of claim 12, wherein if none of the set of predetermined conditions exists, the FPU is configured to make the rounding determination based on bits of the mantissa of the smaller of the first and second addends that, after being aligned, have less arithmetic significance than the precision specified by the PC field.</claim-text></claim><claim id="c-en-01-0021" num="0021"><claim-text>The method of claim 12, wherein the FPU is configured to align a smaller of the first and second addends in order to add the first and second addends to generate the sum.</claim-text></claim><claim id="c-en-01-0022" num="0022"><claim-text>A computer program product for use with a computing device, the computer program product comprising:
<claim-text>a computer readable storage medium, having computer readable program code<br/>
embodied in said computer readable storage medium, for providing a microprocessor, said computer readable program code comprising:
<claim-text>first program code for providing an x87 Floating Point Control Word (FPCW) including a Precision Control (PC) field programmable for specifying a precision of floating point (FP) calculations made by a FP unit (FPU) of the microprocessor;</claim-text>
<claim-text>second program code for providing an instruction dispatcher, configured<br/>
to dispatch an x87 FP addition instruction (FPADD) to the FPU,<br/>
<!-- EPO <DP n="35"> -->the FPADD having first and second FP addends; and</claim-text>
<claim-text>third program code for providing the FPU, configured to:
<claim-text>add the first and second addends to generate a sum;</claim-text>
<claim-text>determine whether at least one of a set of predetermined<br/>
conditions exists in the first and second addends with respect to their contribution to a rounding determination of the sum and relative to the precision specified by the PC field;</claim-text>
<claim-text>if none of the set of predetermined conditions exists:
<claim-text>(1) make the rounding determination based on bits of the mantissa of the smaller of the first and second addends and the precision specified by the PC field; and</claim-text>
<claim-text>(2) selectively round up the sum based on the rounding determination for generating a final result of the FPADD; and</claim-text></claim-text>
<claim-text>if at least one of the set of predetermined conditions exists:
<claim-text>(1) save the sum and save rounding information derived from the first and second addends;</claim-text>
<claim-text>(2) signal the instruction dispatcher to re-dispatch the FPADD to the FPU; and</claim-text>
<claim-text>(3) in response to the instruction dispatcher re-dispatching the FPADD to the FPU:<!-- EPO <DP n="36"> -->
<claim-text>(a) make the rounding determination based on the saved rounding information and the precision specified by the PC field; and</claim-text>
<claim-text>(b) selectively round up the sum based on the rounding determination for generating the final result.</claim-text></claim-text></claim-text></claim-text></claim-text></claim-text></claim><claim id="c-en-01-0023" num="0023"><claim-text>The computer program product of claim 22, wherein one of the set of predetermined conditions comprises:
<claim-text>an effective addition operation is to be performed by the FPU in response<br/>
to the FPADD; and</claim-text>
<claim-text>the precision of the larger of the first and second addends is greater than<br/>
the precision specified by the PC field.</claim-text></claim-text></claim><claim id="c-en-01-0024" num="0024"><claim-text>The computer program product of claim 23, wherein a second of the set of predetermined conditions comprises:
<claim-text>a difference of the exponents of the first and second addends is greater<br/>
than one; and</claim-text>
<claim-text>the precision of the larger of the first and second addends is greater than<br/>
the precision specified by the PC field.</claim-text></claim-text></claim><claim id="c-en-01-0025" num="0025"><claim-text>The computer program product of claim 24, wherein a third of the set of predetermined conditions comprises:
<claim-text>an effective subtraction operation is to be performed by the FPU in<br/>
response to the FPADD;</claim-text>
<claim-text>a difference of the exponents of the first and second addends is less than<br/>
or equal to one; and</claim-text>
<claim-text>the precision of at least one of the first and second addends is greater than<br/>
the precision specified by the PC field.</claim-text></claim-text></claim></claims><claims mxw-id="PCLM56986990" lang="FR" load-source="patent-office"><!-- EPO <DP n="44"> --><claim id="c-fr-01-0001" num="0001"><claim-text>Microprocesseur, comprenant :
<claim-text>un mot de commande à virgule flottante x87 (FPCW)<br/>
incluant un champ de commande de précision (PC) programmable en vue de spécifier une précision de calculs à virgule flottante (FP) réalisés par une unité FP (FPU) du microprocesseur ;</claim-text>
<claim-text>un répartiteur d'instructions, configuré de manière à<br/>
distribuer une instruction d'addition à virgule FP x87 (FPADD) à l'unité FPU, l'instruction FPADD présentant des premier et second cumulateurs à virgule FP ; et</claim-text>
<claim-text>l'unité FPU est configurée de manière à :
<claim-text>additionner les premier et second cumulateurs en<br/>
vue de générer une somme ;</claim-text>
<claim-text>déterminer si au moins une condition parmi un<br/>
ensemble de conditions prédéterminées existe dans les premier et second cumulateurs relativement à leur contribution à une détermination d'arrondi de la somme et relativement à la précision spécifiée par le champ de commande PC ;</claim-text>
<claim-text>si aucune condition parmi l'ensemble de<br/>
conditions prédéterminées n'existe :
<claim-text>(1) exécuter la détermination d'arrondi sur la base de bits de la mantisse du plus petit des premier et second cumulateurs et de la précision spécifiée par le champ de commande PC ; et</claim-text>
<claim-text>(2) arrondir sélectivement la somme sur la base de la détermination d'arrondi, en vue de générer un résultat final de l'instruction FPADD ; et</claim-text><!-- EPO <DP n="45"> --></claim-text>
<claim-text>si au moins une condition parmi l'ensemble de<br/>
conditions prédéterminées existe :
<claim-text>(1) enregistrer la somme et enregistrer les informations d'arrondi dérivées des premier et second cumulateurs ;</claim-text>
<claim-text>(2) signaler au répartiteur d'instructions de redistribuer l'instruction FPADD à l'unité FPU ; et</claim-text>
<claim-text>(3) en réponse au fait que le répartiteur d'instructions redistribue l'instruction FPADD à l'unité FPU :
<claim-text>(a) exécuter la détermination d'arrondi sur la base des informations d'arrondi enregistrées et de la précision spécifiée par le champ de commande PC ; et</claim-text>
<claim-text>(b) arrondir sélectivement la somme sur la base de la détermination d'arrondi, en vue de générer le résultat final.</claim-text></claim-text></claim-text></claim-text></claim-text></claim><claim id="c-fr-01-0002" num="0002"><claim-text>Microprocesseur selon la revendication 1, dans lequel une condition parmi l'ensemble de conditions prédéterminées comporte ce qui suit :
<claim-text>une opération d'addition efficace doit être<br/>
exécutée par l'unité FPU en réponse à l'instruction FPADD ; et</claim-text>
<claim-text>la précision du plus grand des premier et second<br/>
cumulateurs est supérieure à la précision spécifiée par le champ de commande PC.</claim-text></claim-text></claim><claim id="c-fr-01-0003" num="0003"><claim-text>Microprocesseur selon la revendication 2, dans lequel une deuxième condition parmi l'ensemble de conditions prédéterminées comprend ce qui suit :
<claim-text>une différence des exposants des premier et<br/>
second cumulateurs est supérieure à un ; et<!-- EPO <DP n="46"> --> la précision du plus grand des premier et second<br/>
cumulateurs est supérieure à la précision spécifiée par le champ de commande PC.</claim-text></claim-text></claim><claim id="c-fr-01-0004" num="0004"><claim-text>Microprocesseur selon la revendication 3, dans lequel une troisième condition parmi l'ensemble de conditions prédéterminées comprend ce qui suit :
<claim-text>une opération de soustraction efficace doit être<br/>
exécutée par l'unité FPU en réponse à l'instruction FPADD ;</claim-text>
<claim-text>une différence des exposants des premier et<br/>
second cumulateurs est inférieure ou égale à un ; et</claim-text>
<claim-text>la précision d'au moins l'un des premier et<br/>
second cumulateurs est supérieure à la précision spécifiée par le champ de commande PC.</claim-text></claim-text></claim><claim id="c-fr-01-0005" num="0005"><claim-text>Microprocesseur selon la revendication 1, dans lequel l'unité FPU exécute l'instruction FPADD en deux cycles d'horloge lorsqu'aucune condition parmi l'ensemble de conditions prédéterminées n'existe.</claim-text></claim><claim id="c-fr-01-0006" num="0006"><claim-text>Microprocesseur selon la revendication 1, dans lequel, lorsque le répartiteur d'instructions redistribue l'instruction FPADD à l'unité FPU, le répartiteur d'instructions fournit également à l'unité FPU une indication selon laquelle l'instruction FPADD est redistribuée, à la différence de la répartition précédente de l'instruction FPADD par le répartiteur d'instructions à l'unité FPU.</claim-text></claim><claim id="c-fr-01-0007" num="0007"><claim-text>Microprocesseur selon la revendication 1, dans lequel les informations d'arrondi enregistrées comportent des bits de la somme ayant moins de poids arithmétique que la précision spécifiée dans le champ de commande PC du mot FPCW.<!-- EPO <DP n="47"> --></claim-text></claim><claim id="c-fr-01-0008" num="0008"><claim-text>Microprocesseur selon la revendication 1, dans lequel les informations d'arrondi enregistrées comportent un bit de rappel cumulatif basé sur les bits de poids faible d'une mantisse alignée d'un plus petit des premier et second cumulateurs qui ne sont pas inclus dans l'addition des premier et second cumulateurs visant à générer la somme.</claim-text></claim><claim id="c-fr-01-0009" num="0009"><claim-text>Microprocesseur selon la revendication 1, dans lequel, si aucune condition parmi l'ensemble de conditions prédéterminées n'existe, l'unité FPU est configurée de manière à réaliser la détermination d'arrondi sur la base de bits de la mantisse du plus petit des premier et second cumulateurs qui, après avoir été alignés, ont moins de poids arithmétique que la précision spécifiée par le champ de commande PC.</claim-text></claim><claim id="c-fr-01-0010" num="0010"><claim-text>Microprocesseur selon la revendication 1, dans lequel l'unité FPU est en outre configurée de manière à normaliser la somme arrondie sélectivement en vue de générer le résultat final.</claim-text></claim><claim id="c-fr-01-0011" num="0011"><claim-text>Microprocesseur selon la revendication 1, dans lequel l'unité FPU est configurée de manière à aligner un plus petit des premier et second cumulateurs afin d'additionner les premier et second cumulateurs en vue de générer la somme.</claim-text></claim><claim id="c-fr-01-0012" num="0012"><claim-text>Procédé de traitement d'une instruction d'addition à virgule flottante (FP) x87 (FPADD) dans un microprocesseur présentant une unité FP (FPU), un répartiteur d'instructions, et un mot de commande à virgule flottante x87 (FPCW) incluant un champ de commande de précision (PC) programmable destiné à spécifier une précision de calculs à virgule FP réalisés par l'unité FPU, le procédé consistant à :<!-- EPO <DP n="48"> -->
<claim-text>distribuer initialement une instruction d'addition à<br/>
virgule FP x87 (FPADD) à l'unité FPU, l'instruction FPADD présentant des premier et second cumulateurs à virgule FP ;</claim-text>
<claim-text>additionner les premier et second cumulateurs en vue<br/>
de générer une somme ;</claim-text>
<claim-text>déterminer si au moins une condition parmi un ensemble<br/>
de conditions prédéterminées existe dans les premier et second cumulateurs relativement à leur contribution à une détermination d'arrondi de la somme et relativement à la précision spécifiée par le champ de commande PC ;</claim-text>
<claim-text>si aucune condition parmi l'ensemble de conditions<br/>
prédéterminées n'existe :
<claim-text>(1) exécuter la détermination d'arrondi sur la base de bits de la mantisse du plus petit des premier et second cumulateurs et de la précision spécifiée par le champ de commande PC ; et</claim-text>
<claim-text>(2) arrondir sélectivement la somme sur la base de la détermination d'arrondi, en vue de générer un résultat final de l'instruction FPADD ; et</claim-text></claim-text>
<claim-text>si au moins une condition parmi l'ensemble de<br/>
conditions prédéterminées existe :
<claim-text>(1) enregistrer la somme et enregistrer les informations d'arrondi dérivées des premier et second cumulateurs ;</claim-text>
<claim-text>(2) signaler au répartiteur d'instructions de redistribuer l'instruction FPADD à l'unité FPU ; et</claim-text>
<claim-text>(3) en réponse au fait que le répartiteur d'instructions redistribue l'instruction FPADD à l'unité FPU :<!-- EPO <DP n="49"> -->
<claim-text>(a) exécuter la détermination d'arrondi sur la base des informations d'arrondi enregistrées et de la précision spécifiée par le champ de commande PC ; et</claim-text>
<claim-text>(b) arrondir sélectivement la somme sur la base de la détermination d'arrondi, en vue de générer le résultat final.</claim-text></claim-text></claim-text></claim-text></claim><claim id="c-fr-01-0013" num="0013"><claim-text>Procédé selon la revendication 12, dans lequel une condition parmi l'ensemble de conditions prédéterminées comporte ce qui suit :
<claim-text>une opération d'addition efficace doit être<br/>
exécutée par l'unité FPU en réponse à l'instruction FPADD ; et</claim-text>
<claim-text>la précision du plus grand des premier et second<br/>
cumulateurs est supérieure à la précision spécifiée par le champ de commande PC.</claim-text></claim-text></claim><claim id="c-fr-01-0014" num="0014"><claim-text>Procédé selon la revendication 13, dans lequel une deuxième condition parmi l'ensemble de conditions prédéterminées comprend ce qui suit :
<claim-text>une différence des exposants des premier et<br/>
second cumulateurs est supérieure à un ; et la précision du plus grand des premier et second<br/>
cumulateurs est supérieure à la précision spécifiée par le champ de commande PC.</claim-text></claim-text></claim><claim id="c-fr-01-0015" num="0015"><claim-text>Procédé selon la revendication 14, dans lequel une troisième condition parmi l'ensemble de conditions prédéterminées comprend ce qui suit :
<claim-text>une opération de soustraction efficace doit être<br/>
exécutée par l'unité FPU en réponse à l'instruction FPADD ;</claim-text>
<claim-text>une différence des exposants des premier et<br/>
second cumulateurs est inférieure ou égale à un ; et<!-- EPO <DP n="50"> --></claim-text>
<claim-text>la précision d'au moins l'un des premier et<br/>
second cumulateurs est supérieure à la précision spécifiée par le champ de commande PC.</claim-text></claim-text></claim><claim id="c-fr-01-0016" num="0016"><claim-text>Procédé selon la revendication 12, dans lequel l'unité FPU exécute l'instruction FPADD en deux cycles d'horloge lorsqu'aucune condition parmi l'ensemble de conditions prédéterminées n'existe.</claim-text></claim><claim id="c-fr-01-0017" num="0017"><claim-text>Procédé selon la revendication 12, dans lequel, lorsque le répartiteur d'instructions redistribue l'instruction FPADD à l'unité FPU, le répartiteur d'instructions fournit également à l'unité FPU une indication selon laquelle l'instruction FPADD est redistribuée, à la différence de la répartition précédente de l'instruction FPADD par le répartiteur d'instructions à l'unité FPU.</claim-text></claim><claim id="c-fr-01-0018" num="0018"><claim-text>Procédé selon la revendication 12, dans lequel les informations d'arrondi enregistrées comportent des bits de la somme ayant moins de poids arithmétique que la précision spécifiée dans le champ de commande PC du mot FPCW.</claim-text></claim><claim id="c-fr-01-0019" num="0019"><claim-text>Procédé selon la revendication 12, dans lequel les informations d'arrondi enregistrées comportent un bit de rappel cumulatif basé sur les bits de poids faible d'une mantisse alignée d'un plus petit des premier et second cumulateurs qui ne sont pas inclus dans l'addition des premier et second cumulateurs visant à générer la somme.</claim-text></claim><claim id="c-fr-01-0020" num="0020"><claim-text>Procédé selon la revendication 12, dans lequel, si aucune condition parmi l'ensemble de conditions prédéterminées n'existe, l'unité FPU est configurée de manière à réaliser la détermination d'arrondi sur la<!-- EPO <DP n="51"> --> base de bits de la mantisse du plus petit des premier et second cumulateurs qui, après avoir été alignés, ont moins de poids arithmétique que la précision spécifiée par le champ de commande PC.</claim-text></claim><claim id="c-fr-01-0021" num="0021"><claim-text>Procédé selon la revendication 12, dans lequel l'unité FPU est configurée de manière à aligner un plus petit des premier et second cumulateurs afin d'additionner les premier et second cumulateurs en vue de générer la somme.</claim-text></claim><claim id="c-fr-01-0022" num="0022"><claim-text>Produit-programme informatique destiné à être utilisé avec un dispositif de calcul informatique, le produit-programme informatique comprenant :
<claim-text>un moyen de stockage lisible par ordinateur,<br/>
présentant un code de programme lisible par ordinateur intégré dans ledit moyen de stockage lisible par ordinateur, en vue de fournir un microprocesseur, ledit code de programme lisible par ordinateur comprenant :
<claim-text>un premier code de programme destiné à fournir un<br/>
mot de commande à virgule flottante x87 (FPCW) incluant un champ de commande de précision (PC) programmable destiné à spécifier une précision de calculs à virgule flottante (FP) réalisés par une unité FP (FPU) du microprocesseur ;</claim-text>
<claim-text>un deuxième code de programme destiné à fournir<br/>
un répartiteur d'instructions, configuré de manière à distribuer une instruction d'addition à virgule FP x87 (FPADD) à l'unité FPU, l'instruction FPADD présentant des premier et second cumulateurs à virgule FP ; et<!-- EPO <DP n="52"> --></claim-text>
<claim-text>un troisième code de programme destiné à fournir<br/>
l'unité FPU, configuré de manière à :
<claim-text>additionner les premier et second cumulateurs<br/>
en vue de générer une somme ;</claim-text>
<claim-text>déterminer si au moins une condition parmi un<br/>
ensemble de conditions prédéterminées existe dans les premier et second cumulateurs relativement à leur contribution à une détermination d'arrondi de la somme et relativement à la précision spécifiée par le champ de commande PC ;</claim-text>
<claim-text>si aucune condition parmi l'ensemble de<br/>
conditions prédéterminées n'existe :
<claim-text>(1) exécuter la détermination d'arrondi sur la base de bits de la mantisse du plus petit des premier et second cumulateurs et de la précision spécifiée par le champ de commande PC ; et</claim-text>
<claim-text>(2) arrondir sélectivement la somme sur la base de la détermination d'arrondi, en vue de générer un résultat final de l'instruction FPADD ; et</claim-text></claim-text>
<claim-text>si au moins une condition parmi l'ensemble de<br/>
conditions prédéterminées existe :
<claim-text>(1) enregistrer la somme et enregistrer les informations d'arrondi dérivées des premier et second cumulateurs ;</claim-text>
<claim-text>(2) signaler au répartiteur d'instructions de redistribuer l'instruction FPADD à l'unité FPU ; et</claim-text>
<claim-text>(3) en réponse au fait que le répartiteur d'instructions<!-- EPO <DP n="53"> --> redistribue l'instruction FPADD à l'unité FPU :
<claim-text>(a) exécuter la détermination d'arrondi sur la base des informations d'arrondi enregistrées et de la précision spécifiée par le champ de commande PC ; et</claim-text>
<claim-text>(b) arrondir sélectivement la somme sur la base de la détermination d'arrondi, en vue de générer le résultat final.</claim-text></claim-text></claim-text></claim-text></claim-text></claim-text></claim><claim id="c-fr-01-0023" num="0023"><claim-text>Produit-programme informatique selon la revendication 22, dans lequel une condition parmi l'ensemble de conditions prédéterminées comporte ce qui suit :
<claim-text>une opération d'addition efficace doit être<br/>
exécutée par l'unité FPU en réponse à l'instruction FPADD ; et</claim-text>
<claim-text>la précision du plus grand des premier et second<br/>
cumulateurs est supérieure à la précision spécifiée par le champ de commande PC.</claim-text></claim-text></claim><claim id="c-fr-01-0024" num="0024"><claim-text>Produit-programme informatique selon la revendication 23, dans lequel une deuxième condition parmi l'ensemble de conditions prédéterminées comprend ce qui suit :
<claim-text>une différence des exposants des premier et<br/>
second cumulateurs est supérieure à un ; et la précision du plus grand des premier et second<br/>
cumulateurs est supérieure à la précision spécifiée par le champ de commande PC.</claim-text></claim-text></claim><claim id="c-fr-01-0025" num="0025"><claim-text>Produit-programme informatique selon la revendication 24, dans lequel une troisième condition<!-- EPO <DP n="54"> --> parmi l'ensemble de conditions prédéterminées comprend ce qui suit :
<claim-text>une opération de soustraction efficace doit être<br/>
exécutée par l'unité FPU en réponse à l'instruction FPADD ;</claim-text>
<claim-text>une différence des exposants des premier et<br/>
second cumulateurs est inférieure ou égale à un ; et</claim-text>
<claim-text>la précision d'au moins l'un des premier et<br/>
second cumulateurs est supérieure à la précision spécifiée par le champ de commande PC.</claim-text></claim-text></claim></claims><drawings mxw-id="PDW16672616" load-source="patent-office"><!-- EPO <DP n="55"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="165" he="203" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="56"> --><figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="165" he="170" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="57"> --><figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="165" he="211" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="58"> --><figure id="f0004" num="4a,4b,4c,4d,5"><img id="if0004" file="imgf0004.tif" wi="165" he="227" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="59"> --><figure id="f0005" num="6"><img id="if0005" file="imgf0005.tif" wi="165" he="214" img-content="drawing" img-format="tif"/></figure></drawings><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
