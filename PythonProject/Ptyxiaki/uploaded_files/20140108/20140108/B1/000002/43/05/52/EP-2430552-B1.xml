<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2430552-B1" country="EP" doc-number="2430552" kind="B1" date="20140108" family-id="43808342" file-reference-id="315059" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146588437" ucid="EP-2430552-B1"><document-id><country>EP</country><doc-number>2430552</doc-number><kind>B1</kind><date>20140108</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-10775816-A" is-representative="NO"><document-id mxw-id="PAPP154850629" load-source="docdb" format="epo"><country>EP</country><doc-number>10775816</doc-number><kind>A</kind><date>20101108</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140554542" ucid="EP-2010067024-W" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>2010067024</doc-number><kind>W</kind><date>20101108</date></document-id></priority-claim><priority-claim mxw-id="PPC140547839" ucid="US-82117410-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>82117410</doc-number><kind>A</kind><date>20100623</date></document-id></priority-claim></priority-claims><dates-of-public-availability><intention-to-grant-date><date>20130913</date></intention-to-grant-date></dates-of-public-availability><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1989325631" load-source="docdb">G06F  13/28        20060101AFI20130523BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-2085603514" load-source="docdb" scheme="CPC">G06F  12/1081      20130101 LI20150309BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2085603515" load-source="docdb" scheme="CPC">G06F  13/28        20130101 FI20150309BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132369944" lang="DE" load-source="patent-office">MEHRERE ADRESSRÄUME FÜR EINEN ADAPTER</invention-title><invention-title mxw-id="PT132369945" lang="EN" load-source="patent-office">MULTIPLE ADDRESS SPACES PER ADAPTER</invention-title><invention-title mxw-id="PT132369946" lang="FR" load-source="patent-office">ESPACES D'ADRESSE MULTIPLES ATTRIBUÉS À UN ADAPTATEUR</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR919509836" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>IBM</last-name><address><country>US</country></address></addressbook></applicant><applicant mxw-id="PPAR919528210" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>INTERNATIONAL BUSINESS MACHINES CORPORATION</last-name></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR919519522" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>CRADDOCK DAVID</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919507632" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>CRADDOCK, DAVID</last-name></addressbook></inventor><inventor mxw-id="PPAR919023112" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>CRADDOCK, DAVID</last-name><address><street>IBM Corporation Dept E57A 2455 South Road</street><city>Poughkeepsie New York 12601</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919545701" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>GREGG THOMAS</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919514393" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>GREGG, THOMAS</last-name></addressbook></inventor><inventor mxw-id="PPAR919023113" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>GREGG, THOMAS</last-name><address><street>IBM Corporation PS/P314 2455 South Road</street><city>Poughkeepsie New York 12601</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR919510445" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>RAISCH CHRISTOPH</last-name><address><country>DE</country></address></addressbook></inventor><inventor mxw-id="PPAR919522889" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>RAISCH, CHRISTOPH</last-name></addressbook></inventor><inventor mxw-id="PPAR919023114" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>RAISCH, CHRISTOPH</last-name><address><street>IBM Deutschland Research &amp; Development GmbH M/d 09-03, Shcoenaicher Str. 220</street><city>71032 Boeblingen</city><country>DE</country></address></addressbook></inventor></inventors><assignees><assignee mxw-id="PPAR919023116" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>International Business Machines Corporation</last-name><iid>101239613</iid><address><street>New Orchard Road</street><city>Armonk, NY 10504</city><country>US</country></address></addressbook></assignee></assignees><agents><agent mxw-id="PPAR919023115" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Williams, Julian David</last-name><iid>101252233</iid><address><street>IBM United Kingdom Ltd Intellectual Property Dept Mail Point 110 Hursley Park</street><city>GB-Winchester, Hants SO21 2JN</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="EP-2010067024-W"><document-id><country>EP</country><doc-number>2010067024</doc-number><kind>W</kind><date>20101108</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2011160708-A1"><document-id><country>WO</country><doc-number>2011160708</doc-number><kind>A1</kind><date>20111229</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS549802779" load-source="docdb">AL</country><country mxw-id="DS549785454" load-source="docdb">AT</country><country mxw-id="DS549802784" load-source="docdb">BE</country><country mxw-id="DS549879745" load-source="docdb">BG</country><country mxw-id="DS549892934" load-source="docdb">CH</country><country mxw-id="DS549802785" load-source="docdb">CY</country><country mxw-id="DS549785546" load-source="docdb">CZ</country><country mxw-id="DS549924020" load-source="docdb">DE</country><country mxw-id="DS549802786" load-source="docdb">DK</country><country mxw-id="DS549802787" load-source="docdb">EE</country><country mxw-id="DS549875095" load-source="docdb">ES</country><country mxw-id="DS549879750" load-source="docdb">FI</country><country mxw-id="DS549879751" load-source="docdb">FR</country><country mxw-id="DS549924021" load-source="docdb">GB</country><country mxw-id="DS549802792" load-source="docdb">GR</country><country mxw-id="DS549924022" load-source="docdb">HR</country><country mxw-id="DS549785547" load-source="docdb">HU</country><country mxw-id="DS549892935" load-source="docdb">IE</country><country mxw-id="DS549802793" load-source="docdb">IS</country><country mxw-id="DS549879752" load-source="docdb">IT</country><country mxw-id="DS549802794" load-source="docdb">LI</country><country mxw-id="DS549924023" load-source="docdb">LT</country><country mxw-id="DS549785455" load-source="docdb">LU</country><country mxw-id="DS549879753" load-source="docdb">LV</country><country mxw-id="DS549924024" load-source="docdb">MC</country><country mxw-id="DS549785456" load-source="docdb">MK</country><country mxw-id="DS549785461" load-source="docdb">MT</country><country mxw-id="DS549875096" load-source="docdb">NL</country><country mxw-id="DS549870117" load-source="docdb">NO</country><country mxw-id="DS549875097" load-source="docdb">PL</country><country mxw-id="DS549879758" load-source="docdb">PT</country><country mxw-id="DS549785548" load-source="docdb">RO</country><country mxw-id="DS549879759" load-source="docdb">RS</country><country mxw-id="DS549875102" load-source="docdb">SE</country><country mxw-id="DS549892936" load-source="docdb">SI</country><country mxw-id="DS549870118" load-source="docdb">SK</country><country mxw-id="DS549870119" load-source="docdb">SM</country><country mxw-id="DS549785462" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><description mxw-id="PDES63960859" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><b>BACKGROUND</b></heading><p id="p0001" num="0001">This invention relates, in general, to managing system memory of a computing environment, and in particular, to facilitating provision of address spaces within the system memory and the provision of address translation tables, if needed, usable in accessing system memory.</p><p id="p0002" num="0002">System memory is accessible by read and write requests. These requests may come from various components of a computing environment, including central processing units, as well as adapters. Each request includes an address that is to be used to access system memory. This address, however, typically does not have a one-to-one correspondence with a physical location in system memory. Therefore, address translation is performed.</p><p id="p0003" num="0003">Address translation is used to translate an address that is provided in one form not directly usable in accessing system memory to another form that is directly usable in accessing a physical location in system memory. For instance, a virtual address included in a request provided by a central processing unit is translated to a real or absolute address in system memory. As a further example, a Peripheral Component Interconnect (PCI) address provided in a request from an adapter may be translated to an absolute address in system memory.</p><p id="p0004" num="0004">To perform address translation, one or more address translation tables may be used. The tables are configured in a hierarchy, and an entry in the highest level table is located using bits of the address provided in the request. That entry then points to another translation table or to the page, itself, to be accessed.</p><p id="p0005" num="0005"><patcit id="pcit0001" dnum="US20080114906A1"><text>US Publication No. 2008/0114906 A1, published May 15, 2008, Hummel et al.</text></patcit>, "Efficiently Controlling Special Memory Mapped System Accesses," describes in one embodiment, an input/output memory management unit (IOMMU) comprises a control register configured to store a base address of a set of translation tables and control logic coupled to the control register. The control logic is configured to respond to an input/output (I/O) device-initiated request having an address within an address range of an address space corresponding to a peripheral interconnect. One or more operations other than a memory operation are associated with the address range, and the control logic is configured to translate the address<!-- EPO <DP n="2"> --> to a second address outside of the address range if the translation tables specify a translation from the address to the second address, whereby a memory operation is performed in response to the request instead of the one or more operations associated with the address range.</p><p id="p0006" num="0006"><patcit id="pcit0002" dnum="US20070168636A1"><text>US Publication No. 2007/0168636 A1, published July 19, 2007, Hummel et al.</text></patcit>, "Chained Hybrid IOMMU," describes in one embodiment, an input/output (I/O) node comprises an I/O memory management unit (IOMMU) configured to translate memory requests. The I/O node is configured to couple to an interconnect and to operate as a tunnel on the interconnect, and wherein the IOMMU is configured translate memory requests passing through the tunnel in the upstream direction. In another embodiment, a system comprises another I/O node configured to bridge another interconnect to the interconnect, wherein the I/O node is the tunnel for the other I/O node.</p><p id="p0007" num="0007">In <patcit id="pcit0003" dnum="US20060288130A1"><text>US Publication No. 2006/0288130 A1, published December 21, 2006, Madukkarumukumana et al.</text></patcit>, "Address Window Support for Direct Memory Access Translation," a apparatus is disclosed. The apparatus includes a remapping circuit to facilitate access of one or more I/O devices to a memory device for direct memory access (DMA) transactions. The remapping circuit includes a translation mechanism to perform memory address translations for I/O DMA transactions via address window-based translations.</p><p id="p0008" num="0008"><patcit id="pcit0004" dnum="US2007260768A"><text>US 2007/260768</text></patcit> teaches the stalling of DMA operations in order to do memory migration.</p><heading id="h0002"><b>BRIEF SUMMARY</b></heading><p id="p0009" num="0009">The shortcomings of the prior art are overcome and advantages are provided through the provision of a method according to claim 1, a corresponding system of claim 13 and a computer program product of claim 14 for facilitating management of system memory of a computing environment.</p><heading id="h0003"><b>BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS</b></heading><p id="p0010" num="0010">One or more aspects of the present invention are particularly pointed out and distinctly claimed as examples in the claims at the conclusion of the specification. The foregoing and<!-- EPO <DP n="3"> --> x other objects, features, and advantages of the invention are apparent from the following detailed description taken in conjunction with the accompanying drawings in which:
<ul><li><figref idrefs="f0001">FIG. 1</figref> depicts one embodiment of a computing environment to incorporate and use one or more aspects of the present invention;</li><li><figref idrefs="f0002">FIG. 2A</figref> depicts one embodiment of further details of the system memory and input/output (I/O) hub of <figref idrefs="f0001">FIG. 1</figref>, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0003">FIG. 2B</figref> depicts one example of a plurality of address spaces assigned to an adapter function, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0004">FIG. 3A</figref> depicts one embodiment of an overview of the logic to register a DMA (Direct Memory Access) address space for an adapter, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0004">FIG. 3B</figref> depicts one embodiment of various details of registering the DMA address space for the adapter, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0005">FIG. 4</figref> depicts one embodiment of the logic to process a DMA operation, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0006">FIG. 5A</figref> depicts one example of the levels of translation employed when an entire address is used to index into address translation tables to translate the address and to access the page;</li><li><figref idrefs="f0007">FIG. 5B</figref> depicts one example of levels of translation employed when a part of the address is ignored when indexing into the address translation tables, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0008">FIG. 5C</figref> depicts examples of various CPU DAT compatible formats usable in accordance with one or more aspects of the present invention;</li><li><figref idrefs="f0008">FIG. 5D</figref> depicts examples of various I/O extended address translation formats usable in accordance with one or more aspects of the present invention;<!-- EPO <DP n="4"> --></li><li><figref idrefs="f0009">FIG. 6A</figref> depicts one embodiment of a Modify PCI Function Controls instruction used in accordance with an aspect of the present invention;</li><li><figref idrefs="f0009">FIG. 6B</figref> depicts one embodiment of a field used by the Modify PCI Function Controls instruction of <figref idrefs="f0009">FIG. 6A</figref>, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0009">FIG. 6C</figref> depicts one embodiment of another field used by the Modify PCI Function Controls instruction of <figref idrefs="f0009">FIG. 6A</figref>, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0010">FIG. 6D</figref> depicts one embodiment of the contents of a function information block (FIB) used in accordance with an aspect of the present invention;</li><li><figref idrefs="f0011">FIG. 7</figref> depicts one embodiment of an overview of the logic of the Modify PCI Function Controls instruction, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0012">FIG. 8</figref> depicts one embodiment of the logic associated with a register I/O address translation parameters operation that may be specified by the Modify PCI Function Controls instruction, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0013">FIG. 9</figref> depicts one embodiment of the logic associated with an unregister I/O address translation parameters operation that may be specified by the Modify PCI Function Controls instruction, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0014">FIG. 10A</figref> depicts one embodiment of a Call Logical Processor instruction used in accordance with an aspect of the present invention;</li><li><figref idrefs="f0014">FIG. 10B</figref> depicts one embodiment of a request block used by the Call Logical Processor instruction of <figref idrefs="f0014">FIG. 10A</figref>, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0014">FIG. 10C</figref> depicts one embodiment of a response block provided by the Call Logical Processor instruction of <figref idrefs="f0014">FIG. 10A</figref>, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0015">FIG. 11</figref> depicts one embodiment of the logic to enable a PCI function, in accordance with an aspect of the present invention;<!-- EPO <DP n="5"> --></li><li><figref idrefs="f0016">FIG. 12A</figref> depicts one embodiment of a request block used by the Call Logical Processor instruction of <figref idrefs="f0014">FIG. 10A</figref> for a query group operation, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0016">FIG. 12B</figref> depicts one embodiment of a response block for the query group operation of <figref idrefs="f0016">FIG. 12A</figref>, in accordance with an aspect of the present invention;</li><li><figref idrefs="f0017">FIG. 13</figref> depicts one embodiment of a computer program product incorporating one or more aspects of the present invention;</li><li><figref idrefs="f0018">FIG. 14</figref> depicts one embodiment of a host computer system to incorporate and use one or more aspects of the present invention;</li><li><figref idrefs="f0019">FIG. 15</figref> depicts a further example of a computer system to incorporate and use one or more aspects of the present invention;</li><li><figref idrefs="f0020">FIG. 16</figref> depicts another example of a computer system comprising a computer network to incorporate and use one or more aspects of the present invention;</li><li><figref idrefs="f0021">FIG. 17</figref> depicts one embodiment of various elements of a computer system to incorporate and use one or more aspects of the present invention;</li><li><figref idrefs="f0022">FIG. 18A</figref> depicts one embodiment of the execution unit of the computer system of <figref idrefs="f0021">FIG. 17</figref> to incorporate and use one or more aspects of the present invention;</li><li><figref idrefs="f0023">FIG. 18B</figref> depicts one embodiment of the branch unit of the computer system of <figref idrefs="f0021">FIG. 17</figref> to incorporate and use one or more aspects of the present invention;</li><li><figref idrefs="f0024">FIG. 18C</figref> depicts one embodiment of the load/store unit of the computer system of <figref idrefs="f0021">FIG. 17</figref> to incorporate and use one or more aspects of the present invention; and</li><li><figref idrefs="f0025">FIG. 19</figref> depicts one embodiment of an emulated host computer system to incorporate and use one or more aspects of the present invention.</li></ul><!-- EPO <DP n="6"> --></p><heading id="h0004"><b>DETAILED DESCRIPTION</b></heading><p id="p0011" num="0011">In accordance with an aspect of the present invention, an adapter has associated therewith multiple address spaces. This enables multiple address translation formats to be used by the adapter in accessing system memory, and if needed or desired, enables multiple sets of address translation tables to be used in translating addresses usable in accessing system memory. Specifically, in one example, an adapter includes one or more adapter functions, and a plurality of address spaces are assigned to at least one of the adapter functions.</p><p id="p0012" num="0012">As used herein, the term adapter includes any type of adapter (e.g., storage adapter, network adapter, processing adapter, PCI adapter, cryptographic adapter, other type of input/output adapters, etc.). In one embodiment, an adapter includes one adapter function. However, in other embodiments, an adapter may include a plurality of adapter functions. One or more aspects of the present invention are applicable whether an adapter includes one adapter function or a plurality of adapter functions. Moreover, in the examples presented herein, adapter is used interchangeably with adapter function (e.g., PCI function) unless otherwise noted.</p><p id="p0013" num="0013">One embodiment of a computing environment to incorporate and use one or more aspects of the present invention is described with reference to <figref idrefs="f0001">FIG. 1</figref>. In one example, a computing environment 100 is a System z<sup>®</sup> server offered by International Business Machines Corporation. System z<sup>®</sup> is based on the z/Architecture<sup>®</sup> offered by International Business Machines Corporation. Details regarding the z/Architecture<sup>®</sup> are described in an IBM<sup>®</sup> publication entitled, "z/Architecture Principles of Operation," IBM Publication No. SA22-7832-07, February 2009. IBM<sup>®</sup>, System z<sup>®</sup> and z/Architecture<sup>®</sup> are registered trademarks of International Business Machines Corporation, Armonk, New York. Other names used herein may be registered trademarks, trademarks or product names of International Business Machines Corporation or other companies.</p><p id="p0014" num="0014">In one example, computing environment 100 includes one or more central processing units (CPUs) 102 coupled to a system memory 104 (a.k.a., main memory) via a memory controller 106. To access system memory 104, a central processing unit 102 issues a read or write request that includes an address used to access system memory. The address included in the request is typically not directly usable to access system memory, and therefore, it is<!-- EPO <DP n="7"> --> translated to an address that is directly usable in accessing system memory. The address is translated via a translation mechanism (XLATE) 108. For example, the address is translated from a virtual address to a real or absolute address using, for instance, dynamic address translation (DAT).</p><p id="p0015" num="0015">The request, including the translated address, is received by memory controller 106. In one example, memory controller 106 is comprised of hardware and is used to arbitrate for access to the system memory and to maintain the memory's consistency. This arbitration is performed for requests received from CPUs 102, as well as for requests received from one or more adapters 110. Like the central processing units, the adapters issue requests to system memory 104 to gain access to the system memory.</p><p id="p0016" num="0016">In one example, adapter 110 is a Peripheral Component Interconnect (PCI) or PCI Express (PCIe) adapter that includes one or more PCI functions. A PCI function issues a request that requires access to system memory. The request is routed to an input/output hub 112 (e.g., a PCI hub) via one or more switches (e.g., PCIe switches) 114. In one example, the input/output hub is comprised of hardware, including one or more state machines.</p><p id="p0017" num="0017">The input/output hub includes, for instance, a root complex 116 that receives the request from a switch. The request typically includes an input/output address to be translated, and thus, the root complex provides the address to an address translation and protection unit 118. This unit is, for instance, a hardware unit that translates the I/O address, if needed, to an address directly usable to access system memory 104, as described in further detail below.</p><p id="p0018" num="0018">The request initiated from the adapter, including the address (either translated or not, if translation is not needed), is provided to memory controller 106 via, for instance, an I/O-to-memory bus 120. The memory controller performs its arbitration and forwards the request with the translated address (or initial address, if not translated) to the system memory at the appropriate time.</p><p id="p0019" num="0019">Further details regarding the system memory and the input/output hub are described with reference to <figref idrefs="f0002">FIG. 2A</figref>. In this embodiment, the memory controller is not shown. However, the I/O hub may be coupled to the system memory directly or via a memory controller. In one example, system memory 104 includes one or more address spaces 200. An address space is a particular portion of system memory that has been assigned to a particular<!-- EPO <DP n="8"> --> component of the computing environment, such as a particular adapter or adapter function. In one example, the address space is accessible by direct memory access (DMA) initiated by the adapter (or adapter function), and therefore, the address space is referred to in the examples herein as a DMA address space. However, in other examples, direct memory access is not used to access the address space.</p><p id="p0020" num="0020">Further, in one example, system memory 104 includes address translation tables 202 used to translate an address from one that is not directly usable to access system memory to one that is directly usable. In one embodiment, there are one or more address translation tables assigned to a DMA address space, and those one or more address translation tables are configured based on, for instance, the size of the address space to which it is assigned, the size of the address translation tables themselves, and/or the size of the page (or other unit of memory) to be accessed.</p><p id="p0021" num="0021">In one example, there is a hierarchy of address translation tables. For instance, as shown in <figref idrefs="f0002">FIG. 2A</figref>, there is a first-level table 202a (e.g., a segment table) pointed to by an IOAT pointer 218 (described below), and a second, lower level table 202b (e.g., a page table) pointed to by an entry 206a of the first-level table. One or more bits of a received address 204 are used to index into table 202a to locate a particular entry 206a, which indicates a particular lower level table 202b. Then, one or more other bits of address 204 are used to locate a particular entry 206b in that table. In this example, that entry provides the address used to locate the correct page and additional bits in address 204 are used to locate a particular location 208 in the page to perform a data transfer. That is, the address in entry 206b and selected bits of received PCI address 204 are used to provide the address directly usable to access system memory. For instance, the directly usable address is formed from a concatenation of high order bits of the address in entry 206b (e.g., bits 63:12, in a 4k page example) and selected low order bits from the received PCI address (e.g., bits 11:0 for a 4k page).</p><p id="p0022" num="0022">In accordance with an aspect of the present invention, a plurality of address spaces is assigned to a particular component, such as a particular adapter (or adapter function). For instance, as shown in <figref idrefs="f0003">FIG. 2B</figref>, two or more address spaces 200a...200n of system memory 104 are assigned to an adapter function 220a. In this example, two address spaces are shown, but in other examples, more than two address spaces are assigned. The assignment<!-- EPO <DP n="9"> --> of multiple address spaces to a particular adapter function allows the operating system to segregate DMA address spaces. For example, one address space may be used for control information and queues (e.g., SCSI control data blocks) and one address space may be used for data transfers (e.g., SCSI blocks). Other examples also exist. Moreover, each address space can be smaller than one large address space, thus providing improved translation efficiency and finer granularity protection.</p><p id="p0023" num="0023">In one embodiment, each DMA address space assigned to an adapter function may have associated therewith a different translation format (e.g., bypass, no fetch, CPU DAT compatible, I/O extended address translation (described below), etc.). Further, if the translation format uses translation tables, then a set of one or more address translation tables 250a-250n is assigned to the address space. Each set of one or more address translation tables assigned to an address space is of a particular format (e.g., a CPU DAT compatible format or an I/O extended address translation format). The format for one set of translation tables may be the same or different from another set of translation tables.</p><p id="p0024" num="0024">In one example, it is an operating system that assigns one or more DMA address spaces to a particular adapter. This assignment is performed via a registration process, which causes an initialization (via, e.g., trusted software) of one or more device table entries 210 (<figref idrefs="f0002">FIG. 2A</figref>) for that adapter. The registration process also correlates an address space identifier (e.g., one or more bits of the PCI address) to each address space, as described in further detail below.</p><p id="p0025" num="0025">Each device table entry is located in a device table 211 located in I/O hub 112. For example, device table 211 is located within the address translation and protection unit of the I/O hub.</p><p id="p0026" num="0026">In one example, a device table entry (DTE) 210 includes a number of fields, such as the following:
<ul><li>Format 212: This field includes a plurality of bits to indicate various information, including, for instance, the address translation format of an upper level table of the address translation tables. The address translation format indicates the level of the table (e.g., in the example above, the first-level table), as well as a selected address translation format (a.k.a., a translation format) to be used in providing an address directly usable in accessing system memory (e.g., CPU DAT compatible, I/O extended address, bypass, no fetch, etc.);<!-- EPO <DP n="10"> --></li><li>Page Size 213: This field indicates a size of a page (or other unit of memory) to be accessed;</li><li>PCI base address 214 and PCI limit 216: These values provide a range used to define a DMA address space and verify a received address (e.g., PCI address) is valid;</li><li>IOAT (Input/Output Address Translation) pointer 218: This field includes a pointer to the highest level of address translation table used for the DMA address space;</li><li>Enable 219: This field indicates whether the DTE is enabled; and</li><li>Key 221: A storage key used for storage protection when performing DMA operations in system memory.</li></ul></p><p id="p0027" num="0027">In other embodiments, the DTE may include more, less or different information.</p><p id="p0028" num="0028">In accordance with an aspect of the present invention, there is one device table entry per address space, and therefore, there may be multiple device table entries per adapter (or adapter function). In one embodiment, the device table entry to be used in a particular translation is located using a requestor identifier (RID) (and/or a portion of the address) and an address space identifier. The requestor ID (e.g., a 16-bit value specifying, for instance, a bus number, device number and function number) is included in a request issued by a PCI function 220 associated with an adapter. The address space identifier is one or more bits of the I/O address included in the request. The specific one or more bits used as the address space identifier are previously defmed as the address space identifier. The request, including the RID and I/O address (which includes the address space identifier), is provided to, e.g., a contents addressable memory (CAM) 230 via, e.g., a switch 114. The CAM is used to provide an index value, which is used to index into device table 211 to locate the particular device table entry 210. For instance, the CAM includes multiple entries, with each entry corresponding to an index into the device table. Each CAM entry includes the value of a RID and an address space identifier. If the received RID and address space identifier matches the value contained in an entry in the CAM, the corresponding device table index is used to locate the device table entry. If there is no match, the received packet is discarded with no access to system memory being performed. (In other embodiments, a CAM or other look-up is not needed and the RID and address space identifier are used as the index.)<!-- EPO <DP n="11"> --> Subsequently, fields within the device table entry are used to ensure the validity of the address and the configuration of the address translation tables, if any. For example, the inbound address in the request is checked by the hardware of the I/O hub (e.g., the address translation and protection unit) to ensure that it is within the bounds defined by PCI base address 214 and PCI limit 216 stored in the device table entry located using the RID and address space identifier of the request that provided the address. This ensures that the address is within the range previously registered and for which address translation tables, if any, are validly configured.</p><p id="p0029" num="0029">One embodiment of the registration process is described with reference to <figref idrefs="f0004">FIGs. 3A-3B</figref>. In this example, the registration process is performed for each address space to be assigned to the adapter (or specifically, the adapter function). As one example, this logic is performed by one of the central processing units coupled to system memory, responsive to an operating system request.</p><p id="p0030" num="0030">Referring initially to <figref idrefs="f0004">FIG. 3A</figref>, a size and location of the address space that the adapter function is to access is determined, STEP 300. In one example, the size of the address space is determined by the PCI base address and PCI limit set by the operating system. The operating system determines the base and limit using one or more criteria. For instance, if the operating system wishes to have PCI addresses map directly to CPU virtual addresses, then the base and limit are set as such. In a further example, if additional isolation between adapters and/or operating system images is desired, then the addresses being used are selected to provide non-overlapping and disjoint address spaces. The location is also specified by the operating system, and is based, for instance, on the characteristics of the adapter.</p><p id="p0031" num="0031">Further, as part of the registration process, a determination is made as to which address translation format is to be registered for the adapter function, STEP 301. That is, a determination is made as to which format is to be used to provide addresses for the adapter function that are directly usable in accessing system memory.</p><p id="p0032" num="0032">In one embodiment, a plurality of address translation formats are available and from that plurality of formats, the operating system selects one format for the adapter function. This<!-- EPO <DP n="12"> --> selection is based on, for instance, the configuration of the address spaces, the adapter type, etc. Various possible formats include:
<ol><li>(a) A bypass format in which address translation is bypassed. This format may be used when the adapter for which registration is being performed is a trusted adapter. An adapter is considered a trusted adapter, if, for instance, the hardware design of the adapter is sufficiently robust and protected that the addresses could not be corrupted. For example, an internally developed adapter that provides its own translation and protection mechanisms, or an adapter that is managed by trusted firmware may be considered a trusted adapter.
<br/>
As used herein, firmware includes, e.g., the microcode, millicode and/or macrocode of the processing unit. It includes, for instance, the hardware-level instructions and/or data structures used in implementation of higher-level machine code. In one embodiment, it includes, for instance, proprietary code that is typically delivered as microcode that includes trusted software or microcode specific to the underlying hardware and controls operating system access to the system hardware.
<br/>
With the native attachment of I/O adapters on, for instance, System z<sup>®</sup>, I/O Address Translation (IOAT) is employed to provide protection and isolation of DMA access of system memory by the adapter. However, there are classes of adapters that do not need this extra level of protection, including those described above. Thus, for those adapters, the bypass format may be selected;
</li><li>(b) A no fetch format in which an address included in an initial request from the adapter is usable without fetching any translation tables. This format may be selected when the memory is contiguous, the page size is known, and the address is for a constrained area (e.g., 4k or 1M page) in which no fetch of any translation tables from system memory is needed. The address usable to access system memory (i.e., the resulting address when the no fetch format is selected) is derived from the address of the IOAT pointer. For instance, for a 4k page size, the low order bits of the PCI address (e.g., bits 11:0) are concatenated with the upper 52 bits of the IOAT pointer to obtain a resulting address usable to access system memory;</li><li>(c) A CPU DAT compatible format in which the translation tables used for translating the I/O addresses are compatible with translation tables used for CPU DAT<!-- EPO <DP n="13"> --> translations. That is, address translation tables are to be used that are similar and compatible with what is already being used for CPU dynamic address translation. This provides ease of use for those operating systems that are familiar with using these types of tables; enables sharing of the tables between the CPU and the I/O adapter; and provides certain operating system (e.g., z/VM<sup>®</sup>) efficiencies in managing the DMA spaces of its pageable guests. There are various CPU DAT compatible formats available, as described in further detail below with reference to <figref idrefs="f0008">FIG. 5C</figref>;</li><li>(d) An I/O extended address translation format in which extended address translation tables are used for the I/O address translations. With this format, the address translation tables are dedicated to I/O operations and may be larger in size than typically used in CPU address translation. For instance, there may be 1M or even larger page tables and/or other translation tables. Further, the sizes of the different levels of translation tables, including page tables, may differ from one another, and they may differ from the pages themselves. Increasing the traditional sizes reduces bus transactions and helps improve I/O translation caching. The size of the page table and other translation tables, as well as the size of the page, will determine how many levels of translation are needed. Examples of different I/O extended address translation formats are described in further detail below with reference to <figref idrefs="f0008">FIG. 5D</figref>.</li></ol></p><p id="p0033" num="0033">Thereafter, one or more address translation tables, if needed, are created to cover that DMA address space, STEP 302. In one example, the creation includes building the tables and placing the appropriate addresses within the table entries. As an example, one of the translation tables is a 4k page table having 512 64-bit entries, and each entry includes a 4k page address compatible with the assigned address space.</p><p id="p0034" num="0034">Thereafter, the DMA address space is registered for the adapter (or adapter function), STEP 304, as described in further detail with reference to <figref idrefs="f0004">FIG. 3B</figref>. In this example, it is assumed there is one PCI function per adapter, and therefore, one requestor ID per adapter. This logic is performed, for instance, by a central processing unit coupled to the system memory, responsive to an operating system request.</p><p id="p0035" num="0035">Initially, in one embodiment, an available device table entry is selected that is to correspond to the requestor ID and address space identifier of the adapter, STEP 310. That is, the<!-- EPO <DP n="14"> --> request ID and address space identifier will be used to locate a device table entry. In one embodiment, the firmware of one of the central processing units determines which bits of the address are to represent the address space identifier, and this information is provided to the operating system requesting registration (which may be executing on that CPU or another CPU), which uses the information to select the device table entry.</p><p id="p0036" num="0036">Additionally, the PCI base address and the PCI limit are stored in the device table entry, STEP 312. Further, the format of the highest level address translation table, if any, is stored in the format field of device table entry, STEP 314. For instance, the format field includes a plurality of bits, and one or more of those bits indicate the format of the highest level table and the selected address translation format (e.g., segment level, CPU DAT compatible). In a further embodiment, one or more bits indicate the highest level, and one or more other bits indicate the determined translation format (e.g., bypass, no fetch, a particular CPU DAT compatible format, a particular I/O extended address translation format, etc.).</p><p id="p0037" num="0037">Additionally, the input/output address translation (IOAT) pointer used to point to the highest level address translation table (or page, in the case of no fetch) is stored in the device table entry, STEP 316. This completes the registration process.</p><p id="p0038" num="0038">Responsive to performing registration, a DMA address space and corresponding address translation tables, if any, are ready for use, as well as a device table entry. Details regarding processing a request issued by a requestor, such as an adapter, to access system memory are described with reference to <figref idrefs="f0005">FIG. 4</figref>. The processing described below is performed by the I/O hub. In one example, it is the address translation and protection unit that performs the logic.</p><p id="p0039" num="0039">In one embodiment, initially, a DMA request is received at the input/output hub, STEP 400. For instance, a PCI function issues a request that is forwarded to the PCI hub via, for instance, a PCI switch. Using the requestor ID in the request and the address space identifier (which is one or more bits of the I/O address in the request), the appropriate device table entry is located, STEP 402. For instance, the CAM knows which bits are designated as the address space identifier and it uses those bits and the RID to create an index into the device table to select the appropriate device table entry.</p><p id="p0040" num="0040">Thereafter, a determination is made as to whether the device table entry is valid, INQUIRY 404. In one example, validity is determined by checking a validity bit in the entry itself.<!-- EPO <DP n="15"> --> This bit is set, for instance, in response to execution of an enable function request by the operating system. If enabled, the bit is set to, e.g., one (i.e., valid); otherwise, it remains at zero (i.e., invalid). In a further example, the bit may be set when the registration process is complete.</p><p id="p0041" num="0041">If the device table entry is invalid, an error is presented, STEP 405. Otherwise, a further determination is made as to whether the PCI address provided in the request is less than the PCI base address stored in the device table entry, INQUIRY 406. If it is, then the address is outside a valid range and an error is provided, STEP 407. However, if the PCI address is greater than or equal to the base address, then another determination is made as to whether the PCI address is greater than the PCI limit value in the device table entry, INQUIRY 408. If the PCI address is greater than the limit, then once again, an error is presented since the address is outside the valid range, STEP 409. However, if the address is within a valid range, then processing continues.</p><p id="p0042" num="0042">In one example, a determination is made as to whether the address translation format specified in the device table entry indicates bypass translation, INQUIRY 410. If so, then the address is passed directly to the memory controller over the I/O bus to access memory without any fetching of translation entries. The I/O hub continues processing to enable a fetch/store of the data at the address, STEP 426.</p><p id="p0043" num="0043">Returning to INQUIRY 410, if the format does not indicate bypass, then a further inquiry is made as to whether the format indicates the ability to directly access the memory based on the IOAT pointer without requiring any fetches of address translation tables, INQUIRY 412. If no fetch is indicated, then the resulting address is derived from the IOAT pointer and no fetching of address translation tables from system memory is needed, STEP 414. The resulting address is sent to the memory controller and used to locate the page and a particular entry in the page. For instance, if the page size is 4k, then bits 11:0 are used as an offset from the IOAT pointer. The I/O hub continues processing to enable a fetch/store of the data at that page entry, STEP 426.</p><p id="p0044" num="0044">Returning to INQUIRY 412, on the other hand, if use of translation tables is needed, then the format provided in the device table entry is used to determine the type of translation table (e.g., a CPU DAT compatible or an I/O extended address translation) and to determine the<!-- EPO <DP n="16"> --> PCI address bits in the address to be used for address translation, STEP 416. For instance, if the format indicates an I/O extended address translation format with 4k pages and 4k address translation tables, which are described below, and the upper level table is a first-level table with 4k pages, then bits 29:21 of the address are used to index into the first-level table; bits 20:12 are used to index into the page table; and bits 11:0 are used to index into the page. The bits used depend on how many bits are needed to index into the given size page or table. For instance, for a 4k page with byte level addressing, 12 bits are used to address 4096 bytes; and for a 4k page table with 512 entries, 8 bytes each, 9 bits are used to address 512 entries, etc.</p><p id="p0045" num="0045">Next, the PCI hub fetches the appropriate address translation table entry, STEP 418. For instance, initially, the highest level translation table is located using the IOAT pointer of the device table entry. Then, bits of the address (those after the high order bits used for validity and not translation; e.g., bits 29:21 in the above example) are used to locate the particular entry within that table.</p><p id="p0046" num="0046">A determination is then made based, for instance, on the format provided in the device table entry, as to whether the located address translation entry has a correct format, INQUIRY 420. For instance, the format in the device table entry is compared with a format indicated in the address translation entry. If equal, then the format in the device table entry is valid. If not, an error is indicated, STEP 422; otherwise, processing continues with a determination as to whether this is the last table to be processed, INQUIRY 424. That is, a determination is made as to whether there are other address translation tables needed to obtain the real or absolute address or whether the lowest level table entry has been located. This determination is made based on the provided format and size of the tables already processed. If it is not the last table, then processing continues with STEP 418. Otherwise, the I/O hub continues processing to enable a fetch or store of the data at the translated address, STEP 426. In one example, the I/O hub forwards the translated address to the memory controller, which uses the address to fetch or store data at the DMA location designated by the translated address.</p><p id="p0047" num="0047">In one embodiment, the number of levels of translation, and therefore, the number of fetches required to perform translation are reduced. This is accomplished by, for instance, ignoring the high order bits of an address during translation and only using the low order bits to traverse the translation tables, which are based, for instance, on the size of the DMA address<!-- EPO <DP n="17"> --> space assigned to the adapter. The use of a partial address versus the full address is further shown in the following examples.</p><p id="p0048" num="0048">Referring initially to <figref idrefs="f0006">FIG. 5A</figref>, an example is depicted in which the entire address is used in address translation/memory access. With this prior technique, six levels of translation tables are needed, including the page table. The beginning of the highest level table (e.g., the 5th-level table in this example) is pointed to by an IOAT pointer, and then bits of the PCI address are used to locate an entry in the table. Each translation table entry points to the start of a lower level translation table or to a page (e.g., an entry in the 5th-level table points to the start of a 4th-level table, etc.)</p><p id="p0049" num="0049">In this example, the DMA address space (DMAAS) is 6M in size, and each table is 4k bytes having a maximum of 512 8-byte entries (except the 5th-level table, which only supports 128 entries based on the size of the address). The address is, for instance, 64 bits: FFFF C000 0009 C600. The beginning of the 5th-level table is pointed to by the IOAT pointer and bits 63:57 of the PCI address are used to index into the 5th-level table to locate the beginning of the 4th-level table; bits 56:48 of the PCI address are used to index into the 4th-level table to locate the beginning of the 3rd-level table; bits 47:39 are used to index into the 3rd-level table to locate the beginning of the 2nd-level table; bits 38:30 are used to index into the 2nd-level table to locate the beginning of the 1st-level table; bits 29:21 are used to index into the 1st-level table to locate the beginning of the page table; bits 20:12 are used to index the page table to locate the beginning of the page; and bits 11:0 are used to locate the entry in the 4k page. Thus, in this example, all of the address bits are used for translation/access.</p><p id="p0050" num="0050">This is in contrast to the example in <figref idrefs="f0007">FIG. 5B</figref>, in which the address space is the same size (e.g., 6M) and the address is the same, but the translation technique ignores some of the address bits during translation. In this example, bits 63:30 of the address are ignored for translation. The IOAT pointer points to the beginning of the 1st-level table and bits 29:21 of the PCI address are used to index into the 1st-level table to locate the beginning of the page table; bits 20:12 are used to index into the appropriate page table to locate the beginning of the page; and bits 11:0 are used to index into the 4k page.</p><p id="p0051" num="0051">As shown, 1st-level table 500 includes three entries 502, each providing an address to one of the three page tables 504. The number of page tables needed, and therefore, the number of<!-- EPO <DP n="18"> --> other level tables, depends, for instance, on the size of the DMA address space, the size of the translation tables, and/or the size of the pages. In this example, the DMA address space is 6M, and each page table is 4k, having up to 512 entries. Therefore, each page table can map up to 2M of memory (4k x 512 entries). Thus, three page tables are needed for the 6M address space. The 1st-level table is able to hold the three entries, one for each page table, and thus, no further levels of address translation tables are needed, in this example.</p><p id="p0052" num="0052">Additionally, as described above, different formats of address translation tables may be used for address translation, and there may be variations within the formats. For instance, there may be various CPU DAT compatible formats, examples of which are described with reference to <figref idrefs="f0008">FIG. 5C</figref>. As shown, one CPU DAT compatible format is a 4k page CPU DAT compatible format 550, and another is a 1M page CPU DAT compatible format 552, as examples. The number of bits shown are the number of address bits used to index into that page or table (or otherwise locate an entry in that page or table). For instance, 12 bits 554 of a PCI address are used as a byte offset into a 4k page 556; 8 bits 558 are used as an index into a page table 560; 11 bits 562 are used as an index into a segment table 564, etc. Located under the designated address translation table is the maximum size of the address space supported by that address translation table. For instance, page table 560 supports a 1M DMA address space; segment table 564 supports a 2G DMA address space, etc. In this figure, as well as in <figref idrefs="f0008">FIG. 5D</figref>, K = kilobytes, M = megabytes, G = gigabytes, T = terabytes, P = petabytes, and E = exabytes.</p><p id="p0053" num="0053">As depicted, as the size of the page increases, the number of levels of translation tables decreases. For instance, for 4k page 556, a page table is needed, but it is not needed for the 1M page. Other examples and variations are possible.</p><p id="p0054" num="0054">Various examples of I/O extended address translation formats are depicted in <figref idrefs="f0008">FIG. 5D</figref>. For example, the following formats are shown: a 4k address translation table with 4k pages 570; 1M address translation tables with 4k pages 572; and 1M address translation tables with 1M pages 574. As with the CPU DAT compatible formats, the number of bits listed are those bits used to locate an entry in the particular table. For instance, at reference number 576, the 12 bits are an offset into the 4k page. Similarly, at reference number 578, the 9 bits are used to index into an I/O page table. This I/O page table allows for a DMA address space that has a size of 2M. Many other examples exist.<!-- EPO <DP n="19"> --></p><p id="p0055" num="0055">As described herein, one address translation format of one address space may be different from the address translation format of another address space. For instance, the formats may be of different types (e.g., a bypass format for one address space and a CPU DAT compatible format for another address space; a CPU DAT compatible format for one and an I/O extended address translation format for another; or any other combination), or may be variations of a particular type of format (e.g., a 4k page CPU DAT compatible format for one address space and a 1M page DAT compatible format for another address space; a 4k table with 4k pages I/O extended address translation for one and a 1M table with 4k pages I/O extended address translation format for another; etc.) Further, the address spaces may be of the same format, be of different (or even the same) length, yet be identified by unique address identifiers. The number of address spaces supported may be greater than two with the number supported being dependent on the implementation.</p><p id="p0056" num="0056">In one particular implementation, to perform the registration of a DMA address space to the adapter, an instruction referred to as a Modify PCI Function Controls (MPFC) instruction, is used. For example, the operating system determines which address translation format it wishes to use, builds the address translation tables for that format, and then issues the MPFC instruction with that format included as an operand of the instruction. In one example, the format and other operands of the instruction are included in a function information block (described below), which is an operand of the instruction. The function information block is then used to update the DTE and, in one embodiment, optionally, a function table entry (FTE) that includes operational parameters of the adapter.</p><p id="p0057" num="0057">One embodiment of the details related to this instruction, and particularly the registration process, are described with reference to <figref idrefs="f0009 f0010 f0011 f0012 f0013">FIGs. 6A-9</figref>. Referring to <figref idrefs="f0009">FIG. 6A</figref>, a Modify PCI Function Controls instruction 600 includes, for instance, an op code 602 indicating the Modify PCI Function Controls instruction; a first field 604 specifying a location at which various information is included regarding the adapter function for which the operational parameters are being established; and a second field 606 specifying a location from which a PCI function information block (FIB) is fetched. The contents of the locations designated by Fields 1 and 2 are further described below.</p><p id="p0058" num="0058">In one embodiment, Field 1 designates a general register that includes various information. As shown in <figref idrefs="f0009">FIG. 6B</figref>, the contents of the register include, for instance, a function handle 610<!-- EPO <DP n="20"> --> that identifies the handle of the adapter function on behalf of which the modify instruction is being performed; an address space 612 designating an address space in system memory associated with the adapter function designated by the function handle; an operation control 614 which specifies the operation to be performed for the adapter function; and status 616 which provides status regarding the instruction when the instruction completes with a predefined code.</p><p id="p0059" num="0059">In one embodiment, the function handle includes, for instance, an enable indicator indicating whether the handle is enabled, a function number that identifies an adapter function (this is a static identifier and may be used to index into a function table); and an instance number specifying the particular instance of this function handle. There is one function handle for each adapter function, and it is used to locate a function table entry (FTE) within the function table. Each function table entry includes operational parameters and/or other information associated with its adapter function. As one example, a function table entry includes:
<ul><li>Instance Number: This field indicates a particular instance of the adapter function handle associated with the function table entry;</li><li>Device Table Entry (DTE) Index 1...n: There may be one or more device table indices, and each index is an index into a device table to locate a device table entry (DTE). There are one or more device table entries per adapter function, and each entry includes information associated with its adapter function, including information used to process requests of the adapter function (e.g., DMA requests, MSI requests) and information relating to requests associated with the adapter function (e.g., PCI instructions). Each device table entry is associated with one address space within system memory assigned to the adapter function. An adapter function may have one or more address spaces within system memory assigned to the adapter function.</li><li>Busy Indicator: This field indicates whether the adapter function is busy;</li><li>Permanent Error State Indicator: This field indicates whether the adapter function is in a permanent error state;<!-- EPO <DP n="21"> --></li><li>Recovery Initiated Indicator: This field indicates whether recovery has been initiated for the adapter function;</li><li>Permission Indicator: This field indicates whether the operating system trying to control the adapter function has authority to do so;</li><li>Enable Indicator: This field indicates whether the adapter function is enabled (e.g., 1=enabled, 0=disabled);</li><li>Requestor Identifier (RID): This is an identifier of the adapter function, and includes, for instance, a bus number, a device number and a function number.
<br/>
In one example, this field is used for accesses of a configuration space of the adapter function. (Memory of an adapter may be defined as address spaces, including, for instance, a configuration space, an I/O space, and/or one or more memory spaces.) In one example, the configuration space may be accessed by specifying the configuration space in an instruction issued by the operating system (or other configuration) to the adapter function. Specified in the instruction is an offset into the configuration space and a function handle used to locate the appropriate function table entry that includes the RID. The firmware receives the instruction and determines it is for a configuration space. Therefore, it uses the RID to generate a request to the I/O hub, and the I/O hub creates a request to access the adapter. The location of the adapter function is based on the RID, and the offset specifies an offset into the configuration space of the adapter function.
<br/>
Base Address Register (BAR) (1 to n): This field includes a plurality of unsigned integers, designated as BAR<sub>0</sub> - BAR<sub>n</sub>, which are associated with the originally specified adapter function, and whose values are also stored in the base address registers associated with the adapter function. Each BAR specifies the starting address of a memory space or I/O space within the adapter function, and also indicates the type of address space, that is whether it is a 64 or 32 bit memory space, or a 32 bit I/O space, as examples;
<br/>
In one example, it is used for accesses to memory space and/or I/O space of the adapter function. For instance, an offset provided in an instruction to access the<!-- EPO <DP n="22"> --> adapter function is added to the value in the base address register associated with the address space designated in the instruction to obtain the address to be used to access the adapter function. The address space identifier provided in the instruction identifies the address space within the adapter function to be accessed and the corresponding BAR to be used;
<br/>
Size 1....n: This field includes a plurality of unsigned integers, designated as SIZE<sub>0</sub> - SIZE<sub>n</sub>. The value of a Size field, when non-zero, represents the size of each address space with each entry corresponding to a previously described BAR.
</li></ul></p><p id="p0060" num="0060">Further details regarding BAR and Size are described below.
<ol><li>1. When a BAR is not implemented for an adapter function, the BAR field and its corresponding size field are both stored as zeros.</li><li>2. When a BAR field represents either an I/O address space or a 32-bit memory address space, the corresponding size field is non-zero and represents the size of the address space.</li><li>3. When a BAR field represents a 64-bit memory address space,
<ol><li>a. The BAR<sub>n</sub> field represents the least significant address bits.</li><li>b. The next consecutive BAR<sub>n+1</sub> field represents the most significant address bits.</li><li>c. The corresponding SIZE<sub>n</sub> field is non-zero and represents the size of the address space.</li><li>d. The corresponding SIZE<sub>n+1</sub> field is not meaningful and is stored as zero.</li></ol>
<br/>
Internal Routing Information: This information is used to perform particular routing to the adapter. It includes, for instance, node, processor chip, and hub addressing information, as examples.
<br/>
Status Indication: This provides an indication of, for instance, whether load/store operations are blocked or the adapter is in the error state, as well as other indications.
</li></ol><!-- EPO <DP n="23"> --></p><p id="p0061" num="0061">In one example, the busy indicator, permanent error state indicator, and recovery initiated indicator are set based on monitoring performed by the firmware. Further, the permission indicator is set, for instance, based on policy; and the BAR information is based on configuration information discovered during a bus walk by the processor (e.g., firmware of the processor). Other fields may be set based on configuration, initialization, and/or events. In other embodiments, the function table entry may include more, less or different information. The information included may depend on the operations supported by or enabled for the adapter function.</p><p id="p0062" num="0062">Referring to <figref idrefs="f0009">FIG. 6C</figref>, in one example, Field 2 designates a logical address 620 of a PCI function information block (FIB), which includes information regarding an associated adapter function. The function information block is used to update a device table entry and/or function table entry (or other location) associated with the adapter function. The information is stored in the FIB during initialization and/or configuration of the adapter, and/or responsive to particular events.</p><p id="p0063" num="0063">Further details regarding a function information block (FIB) are described with reference to <figref idrefs="f0010">FIG. 6D</figref>. In one embodiment, a function information block 650 includes the following fields:
<ul><li>Format 651: This field specifies the format of the FIB.</li><li>Interception Control 652: This field is used to indicate whether guest execution of specific instructions by a pageable mode guest results in instruction interception;</li><li>Error Indication 654: This field includes the error state indication for direct memory access and adapter interruptions. When the bit is set (e.g., 1), one or more errors have been detected while performing direct memory access or adapter interruption for the adapter function;</li><li>Load/Store Blocked 656: This field indicates whether load/store operations are blocked;<!-- EPO <DP n="24"> --></li><li>PCI Function Valid 658: This field includes an enablement control for the adapter function. When the bit is set (e.g., 1), the adapter function is considered to be enabled for I/O operations;</li><li>Address Space Registered 660: This field includes a direct memory access enablement control for an adapter function. When the field is set (e.g., 1) direct memory access is enabled;</li><li>Page Size 661: This field indicates the size of the page or other unit of memory to be accessed by a DMA memory access;</li><li>PCI Base Address (PBA) 662: This field is a base address for an address space in system memory assigned to the adapter function. It represents the lowest virtual address that an adapter function is allowed to use for direct memory access to the specified DMA address space;</li><li>PCI Address Limit (PAL) 664: This field represents the highest virtual address that an adapter function is allowed to access within the specified DMA address space;</li><li>Input/Output Address Translation Pointer (IOAT) 666: The input/output address translation pointer designates the first of any translation tables used by a PCI virtual address translation, or it may directly designate the absolute address of a frame of storage that is the result of translation;</li><li>Interruption Subclass (ISC) 668: This field includes the interruption subclass used to present adapter interruptions for the adapter function;</li><li>Number of Interruptions (NOI) 670: This field designates the number of distinct interruption codes accepted for an adapter function. This field also defines the size, in bits, of the adapter interruption bit vector designated by an adapter interruption bit vector address and adapter interruption bit vector offset fields;</li><li>Adapter Interruption Bit Vector Address (AIBV) 672: This field specifies an address of the adapter interruption bit vector for the adapter function. This vector is used in interrupt processing;<!-- EPO <DP n="25"> --></li><li>Adapter Interruption Bit Vector Offset 674: This field specifies the offset of the first adapter interruption bit vector bit for the adapter function;</li><li>Adapter Interruption Summary Bit Address (AISB) 676: This field provides an address designating the adapter interruption summary bit, which is optionally used in interrupt processing;</li><li>Adapter Interruption Summary Bit Offset 678: This field provides the offset into the adapter interruption summary bit vector;</li><li>Function Measurement Block (FMB) Address 680: This field provides an address of a function measurement block used to collect measurements regarding the adapter function;</li><li>Function Measurement Block Key 682: This field includes an access key to access the function measurement block;</li><li>Summary Bit Notification Control 684: This field indicates whether there is a summary bit vector being used;</li><li>Instruction Authorization Token 686: This field is used to determine whether a pageable storage mode guest is authorized to execute PCI instructions without host intervention.
<br/>
In one example, in the z/Architecture<sup>®</sup>, a pageable guest is interpretively executed via the Start Interpretive Execution (SIE) instruction, at level 2 of interpretation. For instance, the logical partition (LPAR) hypervisor executes the SIE instruction to begin the logical partition in physical, fixed memory. If z/VM<sup>®</sup> is the operating system in that logical partition, it issues the SIE instruction to execute its guests (virtual) machines in its V=V (virtual) storage. Therefore, the LPAR hypervisor uses level-1 SIE, and the z/VM<sup>®</sup> hypervisor uses level-2 SIE; and
<br/>
Address Translation Format 687: This field indicates a selected format for address translation of the highest level translation table to be used in translation (e.g., an indication of highest level table (e.g. segment table, region 3rd, etc.) and an<!-- EPO <DP n="26"> --> indication of the selected format (e.g., CPU DAT compatible, I/O extended address translation format, a bypass format, a no fetch format).
</li></ul></p><p id="p0064" num="0064">The function information block designated in the Modify PCI Function Controls instruction is used to modify a selected device table entry, a function table entry and/or other firmware controls associated with the adapter function designated in the instruction. By modifying the device table entry, function table entry and/or other firmware controls, certain services are provided for the adapter. These services include, for instance, adapter interruptions; address translations; reset error state; reset load/store blocked; set function measurement parameters; and set interception control.</p><p id="p0065" num="0065">One embodiment of the logic associated with the Modify PCI Function Controls instruction is described with reference to <figref idrefs="f0011">FIG. 7</figref>. In one example, the instruction is issued by an operating system (or other configuration) and executed by the processor (e.g., firmware) executing the operating system. In the examples herein, the instruction and adapter functions are PCI based. However, in other examples, a different adapter architecture and corresponding instructions may be used.</p><p id="p0066" num="0066">In one example, the operating system provides the following operands to the instruction (e.g., in one or more registers designated by the instruction): the PCI function handle; the DMA address space identifier; an operation control; and an address of the function information block.</p><p id="p0067" num="0067">Referring to <figref idrefs="f0011">FIG. 7</figref>, initially, a determination is made as to whether the facility allowing for a Modify PCI Function Controls instruction is installed, INQUIRY 700. This determination is made by, for instance, checking an indicator stored in, for instance, a control block. If the facility is not installed, an exception condition is provided, STEP 702. Otherwise, a determination is made as to whether the instruction was issued by a pageable storage mode guest (or other guest), INQUIRY 704. If yes, the host operating system will emulate the operation for that guest, STEP 706.</p><p id="p0068" num="0068">Otherwise, a determination is made as to whether one or more of the operands are aligned, INQUIRY 708. For instance, a determination is made as to whether the address of the function information block is on a double word boundary. In one example, this is optional. If the operands are not aligned, then an exception condition is provided, STEP 710.<!-- EPO <DP n="27"> --> Otherwise, a determination is made as to whether the function information block is accessible, INQUIRY 712. If not, then an exception condition is provided, STEP 714. Otherwise, a determination is made as to whether the handle provided in the operands of the Modify PCI Function Controls instruction is enabled, INQUIRY 716. In one example, this determination is made by checking an enable indicator in the handle. If the handle is not enabled, then an exception condition is provided, STEP 718.</p><p id="p0069" num="0069">If the handle is enabled, then the handle is used to locate a function table entry, STEP 720. That is, at least a portion of the handle is used as an index into the function table to locate the function table entry corresponding to the adapter function for which operational parameters are to be established.</p><p id="p0070" num="0070">A determination is made as to whether the function table entry was found, INQUIRY 722. If not, then an exception condition is provided, STEP 724. Otherwise, if the configuration issuing the instruction is a guest, INQUIRY 726, then an exception condition (e.g., interception to the host) is provided, STEP 728. This inquiry may be ignored if the configuration is not a guest or other authorizations may be checked, if designated.</p><p id="p0071" num="0071">A determination is then made as to whether the function is enabled, INQUIRY 730. In one example, this determination is made by checking an enable indicator in the function table entry. If it is not enabled, then an exception condition is provided, STEP 732.</p><p id="p0072" num="0072">If the function is enabled, then a determination is made as to whether recovery is active, INQUIRY 734. If recovery is active as determined by a recovery indicator in the function table entry, then an exception condition is provided, STEP 736. However, if recovery is not active, then a further determination is made as to whether the function is busy, INQUIRY 738. This determination is made by checking the busy indicator in the function table entry. If the function is busy, then a busy condition is provided, STEP 740. With the busy condition, the instruction can be retried, instead of dropped.</p><p id="p0073" num="0073">If the function is not busy, then a further determination is made as to whether the function information block format is valid, INQUIRY 742. For instance, the format field of the FIB is checked to determine if this format is supported by the system. If it is invalid, then an exception condition is provided, STEP 744. If the function information block format is valid, then a further determination is made as to whether the operation control specified in<!-- EPO <DP n="28"> --> the operands of the instruction is valid, INQUIRY 746. That is, is the operation control one of the specified operation controls for this instruction. If it is invalid, then an exception condition is provided, STEP 748. However, if the operation control is valid, then processing continues with the specific operation control being specified.</p><p id="p0074" num="0074">One operation control that may be specified is a register I/O address translation parameters operation used in controlling address translations for an adapter. With this operation, the PCI function parameters relevant to I/O address translation are set in the DTE, FTE and/or other location from the appropriate parameters of the FIB, which is an operand to the instruction. These parameters include, for instance, the PCI base address; the PCI address limit (a.k.a., PCI limit or limit); the address translation format; the page size; and the I/O address translation pointer, which are operands to this operation. There are also implied operands, including a starting DMA address (SDMA) and an ending DMA address (EDMA), which are stored in a location accessible to the processor executing the instruction.</p><p id="p0075" num="0075">One embodiment of the logic to establish the operational parameters for I/O address translation is described with reference to <figref idrefs="f0012">FIG. 8</figref>. Initially, a determination is made as to whether the PCI base address in the FIB is greater than the PCI limit in the FIB, INQUIRY 800. If the comparison of the base address and the limit indicate that the base address is greater than the limit, then an exception condition is recognized, STEP 802. However, if the base address is less than or equal to the limit, then a further determination is made as to whether the address translation format and the page size are valid, INQUIRY 804. If they are invalid, then an exception condition is provided, STEP 806. However, if they are valid, then a further determination is made as to whether the size of the address space (based on the base address and limit) exceeds the translation capacity, INQUIRY 808. In one example, the size of the address space is compared to the maximum address translation capacity possible based on the format of the upper level table. For example, if the upper level table is a DAT compatible segment table, the maximum translation capacity is 2 Gbytes.</p><p id="p0076" num="0076">If the size of the address space exceeds the translation capacity, then an exception condition is provided, STEP 810. Otherwise, a further determination is made as to whether the base address is less than the starting DMA address, INQUIRY 812. If so, then an exception condition is provided, STEP 814. Otherwise, another determination is made as to whether the address limit is greater than the ending DMA address, INQUIRY 816. If so, then an<!-- EPO <DP n="29"> --> exception condition is provided, STEP 818. In one example, the starting DMA address and ending DMA address are based on a system-wide policy.</p><p id="p0077" num="0077">Thereafter, a determination is made as to whether sufficient resources, if any are needed, are available to perform an I/O address translation, INQUIRY 820. If not, then an exception condition is provided, STEP 822. Otherwise, a further determination is made as to whether the I/O address translation parameters have already been registered in the FTE and DTE, INQUIRY 824. This is determined by checking the values of the parameters in the FTE/DTE. For instance, if the values in the FTE/DTE are zero or another defined value, then registration has not been performed. To locate the FTE, the handle provided in the instruction is used, and to locate the DTE, a device index in the FTE is used.</p><p id="p0078" num="0078">If the adapter function has already been registered for address translation, then an exception condition is provided, STEP 826. If not, then a determination is made as to whether the DMA address space that is specified is valid (i.e., is it an address space for which a DTE has been enabled), INQUIRY 828. If not, then an exception condition is provided, STEP 830. If all the checks are successful, then the translation parameters are placed in the device table entry and optionally, in the corresponding function table entry or other designated location, STEP 832. For instance, the PCI function parameters relevant to I/O address translation are copied from the function information block and placed in the DTE/FTE. These parameters include, for instance, the PCI base address, the PCI address limit, the translation format, the page size, and the I/O address translation pointer. This operation enables DMA accesses to the specified DMA address space. It enables I/O address translation for the adapter function.</p><p id="p0079" num="0079">Another operation control that may be specified by the Modify PCI Function Controls instruction is an unregister I/O address translation parameters operation, an example of which is described with reference to <figref idrefs="f0013">FIG. 9</figref>. With this operation, the function parameters relevant to I/O address translation are reset to zeros. This operation disables DMA accesses to the specified DMA address space and causes a purge of I/O translation lookaside buffer entries for that DMA address space. It disables address translation.</p><p id="p0080" num="0080">Referring to <figref idrefs="f0013">FIG. 9</figref>, in one embodiment, a determination is made as to whether the I/O address translation parameters are not registered, INQUIRY 900. In one example, this determination is made by checking the values of the appropriate parameters in the FTE or<!-- EPO <DP n="30"> --> DTE. If those fields are zero or some specified value, they are not registered. Therefore, an exception condition is provided, STEP 902. If they are registered, then a determination is made as to whether the DMA address space is valid, INQUIRY 904. If it is invalid, then an exception condition is provided, STEP 906. If the DMA address space is valid, then the translation parameters in the device table entry and/or corresponding function table entry are cleared, STEP 908.</p><p id="p0081" num="0081">In one embodiment, the registration process is performed for each DMA address space to be assigned to the adapter. As described herein, a number of address spaces may be assigned, and in one particular implementation, the number of address spaces to be assigned is indicated by a Call Logical Processor instruction enable function.</p><p id="p0082" num="0082">One embodiment of this instruction is depicted in <figref idrefs="f0014">FIG. 10A</figref>. As shown, in one example, a Call Logical Processor instruction 1000 includes an operation code 1002 indicating that it is the Call Logical Processor instruction; and an indication for a command 1004. In one example, this indication is an address of a request block that describes the command to be performed. One embodiment of such a request block is depicted in <figref idrefs="f0014">FIG. 10B</figref>.</p><p id="p0083" num="0083">As shown in <figref idrefs="f0014">FIG. 10B</figref>, in one example, a request block 1020 includes a number of parameters, such as, for instance, a length field 1022 indicating the length of the request block; a command field 1024 indicating the set PCI function command; a PCI function handle 1026, which is the handle to be provided to either the enable or disable function; an operation code 1028, which is used to designate either an enable or disable operation; and a number of DMA address spaces (DMAAS) 1030, which indicates the requested number of address spaces to be associated with the particular PCI function. More, less or different information may be included in other embodiments. For instance, in a virtual environment in which the instruction is issued by a host of a pageable storage mode guest, a guest identity is provided.</p><p id="p0084" num="0084">Responsive to issuing and processing the Call Logical Processor instruction, a response block is returned and the information included in the response block is dependent on the operation to be performed. One embodiment of the response block is depicted in <figref idrefs="f0014">FIG. 10C</figref>. In one example, response block 1050 includes a length field 1052 indicating the length of the response block; a response code 1054 indicating a status of the command; and a PCI<!-- EPO <DP n="31"> --> function handle 1056 that identifies the PCI function. Responsive to the enable command, the PCI function handle is an enabled handle of the PCI function. Further, upon completion of the disable operation, the PCI function handle is a general handle that can be enabled by an enable function in the future.</p><p id="p0085" num="0085">One embodiment of the logic to enable a PCI function is described with reference to <figref idrefs="f0015">FIG. 11</figref>. In one example, this logic is initiated responsive to issuing a Call Logical Processor instruction in which the command is set to the set PCI function command and the operation code is set to the enable function. This logic is performed by, for instance, a processor responsive to the operating system or a device driver of the operating system authorized to perform this logic issuing the instruction. In other embodiments, the logic may be performed without the use of the Call Logical Processor instruction.</p><p id="p0086" num="0086">Referring to <figref idrefs="f0015">FIG. 11</figref>, initially, a determination is made as to whether a handle provided in the request block of the Call Logical Processor instruction is a valid handle, INQUIRY 1100. That is, does the handle point to a valid entry in the function table or is it outside the range of valid entries (e.g., does function number portion of handle designate an installed function). If the handle is not known, then a corresponding response code is provided indicating that the handle is not recognized, STEP 1102. However, if the handle is known, then a further inquiry is made as to whether the handle is enabled, INQUIRY 1104. This determination is made by checking the enable indicator in the PCI function handle. If the indication is set indicating the handle is enabled, then a response code is returned indicating such, STEP 1106.</p><p id="p0087" num="0087">However, if the handle is known and not enabled (i.e., valid for enablement), then a further determination is made as to whether the requested number of address spaces to be assigned to the PCI function is greater than a maximum value, INQUIRY 1108. To make this determination, the number of DMA address spaces as specified in the request block is compared against a maximum value (provided based on policy, in one example). If the number of address spaces is greater than the maximum value, then a response code is provided indicating an invalid value for DMA address spaces, STEP 1110. Otherwise, a determination is made as to whether the number of requested address spaces is available, INQUIRY 1112. This determination is made by checking whether there are device table entries available for the requested number of address spaces. If the number of requested<!-- EPO <DP n="32"> --> address spaces is not available, then a response code is returned indicating that there are insufficient resources, STEP 1114. Otherwise, processing continues to enable the PCI function.</p><p id="p0088" num="0088">The provided handle is used to locate a function table entry, STEP 1116. For instance, one or more designated bits of the handle are used as an index into the function table to locate a particular function table entry. Responsive to locating the appropriate function table entry, a determination is made as to whether the function is enabled, INQUIRY 1118. This determination is made by checking the enable indicator in the function table entry. If the function is already enabled (i.e., the indicator is set to one), then a response code is returned indicating that the PCI function is already in the requested state, STEP 1120.</p><p id="p0089" num="0089">If the function is not already enabled, then processing continues with determining whether the function is in a permanent error state, INQUIRY 1122. If the permanent error state indicator in the function table entry indicates it is in a permanent error state, then a response code is returned indicating such, STEP 1124. However, if the function is not in a permanent error state, a further determination is made as to whether error recovery has been initiated for the function, INQUIRY 1126. If the recovery initiated indicator in the function table entry is set, then a response code indicating recovery has been initiated is provided, STEP 1128. Otherwise, a further inquiry is made as to whether the PCI function is busy, INQUIRY 1130. Again, if a check of the busy indicator in the function table entry indicates the PCI function is busy, then such an indication is provided, STEP 1132. However, if the PCI function is not in the permanent error state, recovery is not initiated and it is not busy, then a further inquiry is made as to whether the operating system is permitted to enable this PCI function, STEP 1134. If it is not permitted based on the permission indicator of the function table entry, then a response code indicating an unauthorized action is provided, STEP 1136. However, if all the tests are successfully passed, then a further determination is made as to whether there are any DTEs available for this PCI function, INQUIRY 1138. As examples, the determination of DTEs being available can be based on the DTEs that are not currently enabled in the I/O hub. Additionally, policy could be applied to further limit the number of DTEs available to a given operating system or logical partition. Any available DTE that is accessible to the adapter may be assigned. If there are no available DTEs, then a response code is returned indicating that one or more of the requested DTEs are unavailable, STEP 1140.<!-- EPO <DP n="33"> --></p><p id="p0090" num="0090">If the DTEs are available, then a number of DTEs corresponding to the requested number of address spaces are assigned and enabled, STEP 1142. In one example, the enabling includes setting the enable indicator in each DTE to be enabled. Further, the enabling includes, in this example, setting up the CAM to provide an index to each DTE. For instance, for each DTE, an entry in the CAM is loaded with the index.</p><p id="p0091" num="0091">Further, the DTEs are associated with the function table entry, STEP 1144. This includes, for instance, including each DTE index in the function table entry. The function is then marked as enabled by setting the enable indicator in the function table entry, STEP 1146. Moreover, the enable bit in the handle is set, and the instance number is updated, STEP 1148. This enabled handle is then returned, STEP 1150, allowing use of the PCI adapter. For instance, responsive to enabling the function, registration for address translations and interruptions may be performed, DMA operations may be performed by the PCI function, and/or load, store and store block instructions may be issued to the function.</p><p id="p0092" num="0092">Each address space is identified by an address space identifier, which is one or more bits of an address received by the adapter. The specific bits are indicated in a DMA address space mask, which is retrieved by a CLP query group command. An example of a CLP instruction is described above with reference to <figref idrefs="f0014">FIG. 10A</figref>.</p><p id="p0093" num="0093">One embodiment of a request block for the query PCI function group command is described with reference to <figref idrefs="f0016">FIG. 12A</figref>. In one example, request block 1200 includes the following:
<ul><li>Length field 1202: This field indicates the length of the request block;</li><li>Command Code 1204: This field indicates the query PCI function group command; and</li><li>Function Group ID 1206: This field specifies the PCI function group identifier for which attributes are to be obtained. In one example, it is obtained from a query function command that provides details regarding a selected function.</li></ul></p><p id="p0094" num="0094">Responsive to issuing and processing the Call Logical Processor instruction with a query PCI function group command, a response block is returned. One embodiment of the response block is depicted in <figref idrefs="f0016">FIG. 12B</figref>. In one example, a response block 1250 includes:<!-- EPO <DP n="34"> -->
<ul><li>Length Field 1252: This field indicates the length of the response block;</li><li>Response Code 1254: This field indicates a status of the command;</li><li>Number of Interruptions 1256: This field indicates the maximum number of consecutive MSI vector numbers (i.e., interruption event indicators) that are supported by the PCI facility for each PCI function in the specified PCI function group. The possible valid values of the number of interruptions are in the range of zero to 2,048, in one example;
<ul><li>Version 1258: This field indicates the version of the PCI specification that is supported by the PCI facility to which the group of PCI functions designated by the specified PCI group identifier are attached;</li><li>Frame 1262: This field indicates the frame (or page) sizes supported for I/O address translation;</li><li>Measurement Block Update Interval 1264: This is a value indicating the approximate time interval (e.g., in milliseconds) at which the PCI function measurement block is updating;</li><li>DMA Address Space Mask 1266: This is a value used to indicate which bits in a PCI address are used to identify a DMA address space. It can implicitly defme the maximum number of DMA address spaces supported. That is, it is 2 exponentiated to the number of bits that are one in the mask; and</li><li>MSI Address 1268: This is a value that is to be used for message signal interruption requests.</li></ul></li></ul></p><p id="p0095" num="0095">The group information is based on a given system I/O infrastructure and the capabilities of the firmware and the I/O hub. This may be stored in the FTE or any other convenient location for later retrieval during the query processing. In particular, the query group command retrieves the information and stores it in its response block accessible to the operating system.<!-- EPO <DP n="35"> --></p><p id="p0096" num="0096">Described in detail above is a capability for assigning multiple DMA address spaces to each adapter, and particularly, to each adapter function (which shares a PCI bus with other adapter functions). The use of multiple address spaces per adapter or adapter function enables the use of different size address spaces, the use of different translation formats, and/or the use of different address translation tables, if needed. The use of multiple address spaces is accomplished by associating a DTE with each address space. The DTE defines the characteristics of its associated address space. The appropriate DTE is chosen by a combination of a RID and address space identifier.</p><p id="p0097" num="0097">In the embodiments described herein, the adapters are PCI adapters. PCI, as used herein, refers to any adapters implemented according to a PCI-based specification as defmed by the Peripheral Component Interconnect Special Interest Group (PCI-SIG) (www.pcisig.com/home), including but not limited to, PCI or PCIe. In one particular example, the Peripheral Component Interconnect Express (PCIe) is a component level interconnect standard that defines a bi-directional communication protocol for transactions between I/O adapters and host systems. PCIe communications are encapsulated in packets according to the PCIe standard for transmission on a PCIe bus. Transactions originating at I/O adapters and ending at host systems are referred to as upbound transactions. Transactions originating at host systems and terminating at I/O adapters are referred to as downbound transactions. The PCIe topology is based on point-to-point unidirectional links that are paired (e.g., one upbound link, one downbound link) to form the PCIe bus. The PCIe standard is maintained and published by the PCI-SIG.</p><p id="p0098" num="0098">As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a "circuit," "module" or "system". Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.</p><p id="p0099" num="0099">Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable storage medium. A computer<!-- EPO <DP n="36"> --> readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system, apparatus, or device.</p><p id="p0100" num="0100">Referring now to <figref idrefs="f0017">FIG. 13</figref>, in one example, a computer program product 1300 includes, for instance, one or more computer readable storage media 1302 to store computer readable program code means or logic 1304 thereon to provide and facilitate one or more aspects of the present invention.</p><p id="p0101" num="0101">Program code embodied on a computer readable medium may be transmitted using an appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.</p><p id="p0102" num="0102">Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language, such as Java, Smalltalk, C++ or the like, and conventional procedural programming languages, such as the "C" programming language, assembler or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).<!-- EPO <DP n="37"> --></p><p id="p0103" num="0103">Aspects of the present invention are described herein with reference to flowchart illustrations and/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p><p id="p0104" num="0104">These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function/act specified in the flowchart and/or block diagram block or blocks.</p><p id="p0105" num="0105">The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p><p id="p0106" num="0106">The flowchart and block diagrams in the figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and/or flowchart illustration, and<!-- EPO <DP n="38"> --> combinations of blocks in the block diagrams and/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.</p><p id="p0107" num="0107">In addition to the above, one or more aspects of the present invention may be provided, offered, deployed, managed, serviced, etc. by a service provider who offers management of customer environments. For instance, the service provider can create, maintain, support, etc. computer code and/or a computer infrastructure that performs one or more aspects of the present invention for one or more customers. In return, the service provider may receive payment from the customer under a subscription and/or fee agreement, as examples. Additionally or alternatively, the service provider may receive payment from the sale of advertising content to one or more third parties.</p><p id="p0108" num="0108">In one aspect of the present invention, an application may be deployed for performing one or more aspects of the present invention. As one example, the deploying of an application comprises providing computer infrastructure operable to perform one or more aspects of the present invention.</p><p id="p0109" num="0109">As a further aspect of the present invention, a computing infrastructure may be deployed comprising integrating computer readable code into a computing system, in which the code in combination with the computing system is capable of performing one or more aspects of the present invention.</p><p id="p0110" num="0110">As yet a further aspect of the present invention, a process for integrating computing infrastructure comprising integrating computer readable code into a computer system may be provided. The computer system comprises a computer readable medium, in which the computer medium comprises one or more aspects of the present invention. The code in combination with the computer system is capable of performing one or more aspects of the present invention.</p><p id="p0111" num="0111">Although various embodiments are described above, these are only examples. For example, computing environments of other architectures can incorporate and use one or more aspects of the present invention. As examples, servers other than System z<sup>®</sup> servers, such as Power Systems servers or other servers offered by International Business Machines Corporation, or servers of other companies can include, use and/or benefit from one or more aspects of the<!-- EPO <DP n="39"> --> present invention. Further, although in the example herein, the adapters and PCI hub are considered a part of the server, in other embodiments, they do not have to necessarily be considered a part of the server, but can simply be considered as being coupled to system memory and/or other components of a computing environment. The computing environment need not be a server. Further, although translation tables are described, any data structure can be used and the term table is to include all such data structures. Yet further, although the adapters are PCI based, one or more aspects of the present invention are usable with other adapters or other I/O components. Adapter and PCI adapter are just examples. Moreover, other size address spaces, address tables and/or pages may be used without departing from the spirit of the present invention. Further, the DTE may include more, less or different information. Yet further, other types of addresses may be translated using one or more aspects of the present invention. Moreover, other values may be used for an address space identifier and/or a requestor identifier. Many other variations are possible.</p><p id="p0112" num="0112">Further, other types of computing environments can benefit from one or more aspects of the present invention. As an example, a data processing system suitable for storing and/or executing program code is usable that includes at least two processors coupled directly or indirectly to memory elements through a system bus. The memory elements include, for instance, local memory employed during actual execution of the program code, bulk storage, and cache memory which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.</p><p id="p0113" num="0113">Input/Output or I/O devices (including, but not limited to, keyboards, displays, pointing devices, DASD, tape, CDs, DVDs, thumb drives and other memory media, etc.) can be coupled to the system either directly or through intervening I/O controllers. Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems, cable modems, and Ethernet cards are just a few of the available types of network adapters.</p><p id="p0114" num="0114">Referring to <figref idrefs="f0018">FIG. 14</figref>, representative components of a Host Computer system 5000 to implement one or more aspects of the present invention are portrayed. The representative host computer 5000 comprises one or more CPUs 5001 in communication with computer memory (i.e., central storage) 5002, as well as I/O interfaces to storage media devices 5011<!-- EPO <DP n="40"> --> and networks 5010 for communicating with other computers or SANs and the like. The CPU 5001 is compliant with an architecture having an architected instruction set and architected functionality. The CPU 5001 may have dynamic address translation (DAT) 5003 for transforming program addresses (virtual addresses) into real addresses of memory. A DAT typically includes a translation lookaside buffer (TLB) 5007 for caching translations so that later accesses to the block of computer memory 5002 do not require the delay of address translation. Typically, a cache 5009 is employed between computer memory 5002 and the processor 5001. The cache 5009 may be hierarchical having a large cache available to more than one CPU and smaller, faster (lower level) caches between the large cache and each CPU. In some implementations, the lower level caches are split to provide separate low level caches for instruction fetching and data accesses. In one embodiment, an instruction is fetched from memory 5002 by an instruction fetch unit 5004 via a cache 5009. The instruction is decoded in an instruction decode unit 5006 and dispatched (with other instructions in some embodiments) to instruction execution unit or units 5008. Typically several execution units 5008 are employed, for example an arithmetic execution unit, a floating point execution unit and a branch instruction execution unit. The instruction is executed by the execution unit, accessing operands from instruction specified registers or memory as needed. If an operand is to be accessed (loaded or stored) from memory 5002, a load/store unit 5005 typically handles the access under control of the instruction being executed. Instructions may be executed in hardware circuits or in internal microcode (firmware) or by a combination of both.</p><p id="p0115" num="0115">As noted, a computer system includes information in local (or main) storage, as well as addressing, protection, and reference and change recording. Some aspects of addressing include the format of addresses, the concept of address spaces, the various types of addresses, and the manner in which one type of address is translated to another type of address. Some of main storage includes permanently assigned storage locations. Main storage provides the system with directly addressable fast-access storage of data. Both data and programs are to be loaded into main storage (from input devices) before they can be processed.</p><p id="p0116" num="0116">Main storage may include one or more smaller, faster-access buffer storages, sometimes called caches. A cache is typically physically associated with a CPU or an I/O processor.<!-- EPO <DP n="41"> --> The effects, except on performance, of the physical construction and use of distinct storage media are generally not observable by the program.</p><p id="p0117" num="0117">Separate caches may be maintained for instructions and for data operands. Information within a cache is maintained in contiguous bytes on an integral boundary called a cache block or cache line (or line, for short). A model may provide an EXTRACT CACHE ATTRIBUTE instruction which returns the size of a cache line in bytes. A model may also provide PREFETCH DATA and PREFETCH DATA RELATIVE LONG instructions which effects the prefetching of storage into the data or instruction cache or the releasing of data from the cache.</p><p id="p0118" num="0118">Storage is viewed as a long horizontal string of bits. For most operations, accesses to storage proceed in a left-to-right sequence. The string of bits is subdivided into units of eight bits. An eight-bit unit is called a byte, which is the basic building block of all information formats. Each byte location in storage is identified by a unique nonnegative integer, which is the address of that byte location or, simply, the byte address. Adjacent byte locations have consecutive addresses, starting with 0 on the left and proceeding in a left-to-right sequence. Addresses are unsigned binary integers and are 24, 31, or 64 bits.</p><p id="p0119" num="0119">Information is transmitted between storage and a CPU or a channel subsystem one byte, or a group of bytes, at a time. Unless otherwise specified, in, for instance, the z/Architecture<sup>®</sup>, a group of bytes in storage is addressed by the leftmost byte of the group. The number of bytes in the group is either implied or explicitly specified by the operation to be performed. When used in a CPU operation, a group of bytes is called a field. Within each group of bytes, in, for instance, the z/Architecture<sup>®</sup>, bits are numbered in a left-to-right sequence. In the z/Architecturce<sup>®</sup>, the leftmost bits are sometimes referred to as the "high-order" bits and the rightmost bits as the "low-order" bits. Bit numbers are not storage addresses, however. Only bytes can be addressed. To operate on individual bits of a byte in storage, the entire byte is accessed. The bits in a byte are numbered 0 through 7, from left to right (in, e.g., the z/Architecture<sup>®</sup>). The bits in an address may be numbered 8-31 or 40-63 for 24-bit addresses, or 1-31 or 33-63 for 31-bit addresses; they are numbered 0-63 for 64-bit addresses. Within any other fixed-length format of multiple bytes, the bits making up the format are consecutively numbered starting from 0. For purposes of error detection, and in preferably for correction, one or more check bits may be transmitted with each byte or with a<!-- EPO <DP n="42"> --> group of bytes. Such check bits are generated automatically by the machine and cannot be directly controlled by the program. Storage capacities are expressed in number of bytes. When the length of a storage-operand field is implied by the operation code of an instruction, the field is said to have a fixed length, which can be one, two, four, eight, or sixteen bytes. Larger fields may be implied for some instructions. When the length of a storage-operand field is not implied but is stated explicitly, the field is said to have a variable length. Variable-length operands can vary in length by increments of one byte (or with some instructions, in multiples of two bytes or other multiples). When information is placed in storage, the contents of only those byte locations are replaced that are included in the designated field, even though the width of the physical path to storage may be greater than the length of the field being stored.</p><p id="p0120" num="0120">Certain units of information are to be on an integral boundary in storage. A boundary is called integral for a unit of information when its storage address is a multiple of the length of the unit in bytes. Special names are given to fields of 2, 4, 8, and 16 bytes on an integral boundary. A halfword is a group of two consecutive bytes on a two-byte boundary and is the basic building block of instructions. A word is a group of four consecutive bytes on a four-byte boundary. A doubleword is a group of eight consecutive bytes on an eight-byte boundary. A quadword is a group of 16 consecutive bytes on a 16-byte boundary. When storage addresses designate halfwords, words, doublewords, and quadwords, the binary representation of the address contains one, two, three, or four rightmost zero bits, respectively. Instructions are to be on two-byte integral boundaries. The storage operands of most instructions do not have boundary-alignment requirements.</p><p id="p0121" num="0121">On devices that implement separate caches for instructions and data operands, a significant delay may be experienced if the program stores into a cache line from which instructions are subsequently fetched, regardless of whether the store alters the instructions that are subsequently fetched.</p><p id="p0122" num="0122">In one embodiment, the invention may be practiced by software (sometimes referred to licensed internal code, firmware, micro-code, milli-code, pico-code and the like, any of which would be consistent with the present invention). Referring to <figref idrefs="f0018">FIG. 14</figref>, software program code which embodies the present invention is typically accessed by processor 5001 of the host system 5000 from long-term storage media devices 5011, such as a CD-ROM<!-- EPO <DP n="43"> --> drive, tape drive or hard drive. The software program code may be embodied on any of a variety of known media for use with a data processing system, such as a diskette, hard drive, or CD-ROM. The code may be distributed on such media, or may be distributed to users from computer memory 5002 or storage of one computer system over a network 5010 to other computer systems for use by users of such other systems.</p><p id="p0123" num="0123">The software program code includes an operating system which controls the function and interaction of the various computer components and one or more application programs. Program code is normally paged from storage media device 5011 to the relatively higher-speed computer storage 5002 where it is available for processing by processor 5001. The techniques and methods for embodying software program code in memory, on physical media, and/or distributing software code via networks are well known and will not be further discussed herein. Program code, when created and stored on a tangible medium (including but not limited to electronic memory modules (RAM), flash memory, Compact Discs (CDs), DVDs, Magnetic Tape and the like is often referred to as a "computer program product". The computer program product medium is typically readable by a processing circuit preferably in a computer system for execution by the processing circuit.</p><p id="p0124" num="0124"><figref idrefs="f0019">FIG. 15</figref> illustrates a representative workstation or server hardware system in which the present invention may be practiced. The system 5020 of <figref idrefs="f0016">FIG. 12</figref> comprises a representative base computer system 5021, such as a personal computer, a workstation or a server, including optional peripheral devices. The base computer system 5021 includes one or more processors 5026 and a bus employed to connect and enable communication between the processor(s) 5026 and the other components of the system 5021 in accordance with known techniques. The bus connects the processor 5026 to memory 5025 and long-term storage 5027 which can include a hard drive (including any of magnetic media, CD, DVD and Flash Memory for example) or a tape drive for example. The system 5021 might also include a user interface adapter, which connects the microprocessor 5026 via the bus to one or more interface devices, such as a keyboard 5024, a mouse 5023, a printer/scanner 5030 and/or other interface devices, which can be any user interface device, such as a touch sensitive screen, digitized entry pad, etc. The bus also connects a display device 5022, such as an LCD screen or monitor, to the microprocessor 5026 via a display adapter.<!-- EPO <DP n="44"> --></p><p id="p0125" num="0125">The system 5021 may communicate with other computers or networks of computers by way of a network adapter capable of communicating 5028 with a network 5029. Example network adapters are communications channels, token ring, Ethernet or modems. Alternatively, the system 5021 may communicate using a wireless interface, such as a CDPD (cellular digital packet data) card. The system 5021 may be associated with such other computers in a Local Area Network (LAN) or a Wide Area Network (WAN), or the system 5021 can be a client in a client/server arrangement with another computer, etc. All of these configurations, as well as the appropriate communications hardware and software, are known in the art.</p><p id="p0126" num="0126"><figref idrefs="f0020">FIG. 16</figref> illustrates a data processing network 5040 in which the present invention may be practiced. The data processing network 5040 may include a plurality of individual networks, such as a wireless network and a wired network, each of which may include a plurality of individual workstations 5041, 5042, 5043, 5044. Additionally, as those skilled in the art will appreciate, one or more LANs may be included, where a LAN may comprise a plurality of intelligent workstations coupled to a host processor.</p><p id="p0127" num="0127">Still referring to <figref idrefs="f0020">FIG. 16</figref>, the networks may also include mainframe computers or servers, such as a gateway computer (client server 5046) or application server (remote server 5048 which may access a data repository and may also be accessed directly from a workstation 5045). A gateway computer 5046 serves as a point of entry into each individual network. A gateway is needed when connecting one networking protocol to another. The gateway 5046 may be preferably coupled to another network (the Internet 5047 for example) by means of a communications link. The gateway 5046 may also be directly coupled to one or more workstations 5041, 5042, 5043, 5044 using a communications link. The gateway computer may be implemented utilizing an IBM eServer<sup>™</sup> System z<sup>®</sup> server available from International Business Machines Corporation.</p><p id="p0128" num="0128">Referring concurrently to <figref idrefs="f0019">FIG. 15</figref> and <figref idrefs="f0020">FIG. 16</figref>, software programming code which may embody the present invention may be accessed by the processor 5026 of the system 5020 from long-term storage media 5027, such as a CD-ROM drive or hard drive. The software programming code may be embodied on any of a variety of known media for use with a data processing system, such as a diskette, hard drive, or CD-ROM. The code may be distributed on such media, or may be distributed to users 5050, 5051 from the memory or storage of one<!-- EPO <DP n="45"> --> computer system over a network to other computer systems for use by users of such other systems.</p><p id="p0129" num="0129">Alternatively, the programming code may be embodied in the memory 5025, and accessed by the processor 5026 using the processor bus. Such programming code includes an operating system which controls the function and interaction of the various computer components and one or more application programs 5032. Program code is normally paged from storage media 5027 to high-speed memory 5025 where it is available for processing by the processor 5026. The techniques and methods for embodying software programming code in memory, on physical media, and/or distributing software code via networks are well known and will not be further discussed herein. Program code, when created and stored on a tangible medium (including but not limited to electronic memory modules (RAM), flash memory, Compact Discs (CDs), DVDs, Magnetic Tape and the like is often referred to as a "computer program product". The computer program product medium is typically readable by a processing circuit preferably in a computer system for execution by the processing circuit.</p><p id="p0130" num="0130">The cache that is most readily available to the processor (normally faster and smaller than other caches of the processor) is the lowest (L1 or level one) cache and main store (main memory) is the highest level cache (L3 if there are 3 levels). The lowest level cache is often divided into an instruction cache (I-Cache) holding machine instructions to be executed and a data cache (D-Cache) holding data operands.</p><p id="p0131" num="0131">Referring to <figref idrefs="f0021">FIG. 17</figref>, an exemplary processor embodiment is depicted for processor 5026. Typically one or more levels of cache 5053 are employed to buffer memory blocks in order to improve processor performance. The cache 5053 is a high speed buffer holding cache lines of memory data that are likely to be used. Typical cache lines are 64, 128 or 256 bytes of memory data. Separate caches are often employed for caching instructions than for caching data. Cache coherence (synchronization of copies of lines in memory and the caches) is often provided by various "snoop" algorithms well known in the art. Main memory storage 5025 of a processor system is often referred to as a cache. In a processor system having 4 levels of cache 5053, main storage 5025 is sometimes referred to as the level 5 (L5) cache since it is typically faster and only holds a portion of the non-volatile<!-- EPO <DP n="46"> --> storage (DASD, tape etc) that is available to a computer system. Main storage 5025 "caches" pages of data paged in and out of the main storage 5025 by the operating system.</p><p id="p0132" num="0132">A program counter (instruction counter) 5061 keeps track of the address of the current instruction to be executed. A program counter in a z/Architecture<sup>®</sup> processor is 64 bits and can be truncated to 31 or 24 bits to support prior addressing limits. A program counter is typically embodied in a PSW (program status word) of a computer such that it persists during context switching. Thus, a program in progress, having a program counter value, may be interrupted by, for example, the operating system (context switch from the program environment to the operating system environment). The PSW of the program maintains the program counter value while the program is not active, and the program counter (in the PSW) of the operating system is used while the operating system is executing. Typically, the program counter is incremented by an amount equal to the number of bytes of the current instruction. RISC (Reduced Instruction Set Computing) instructions are typically fixed length while CISC (Complex Instruction Set Computing) instructions are typically variable length. Instructions of the IBM z/Architecture<sup>®</sup> are CISC instructions having a length of 2, 4 or 6 bytes. The Program counter 5061 is modified by either a context switch operation or a branch taken operation of a branch instruction for example. In a context switch operation, the current program counter value is saved in the program status word along with other state information about the program being executed (such as condition codes), and a new program counter value is loaded pointing to an instruction of a new program module to be executed. A branch taken operation is performed in order to permit the program to make decisions or loop within the program by loading the result of the branch instruction into the program counter 5061.</p><p id="p0133" num="0133">Typically an instruction fetch unit 5055 is employed to fetch instructions on behalf of the processor 5026. The fetch unit either fetches "next sequential instructions", target instructions of branch taken instructions, or first instructions of a program following a context switch. Modem Instruction fetch units often employ prefetch techniques to speculatively prefetch instructions based on the likelihood that the prefetched instructions might be used. For example, a fetch unit may fetch 16 bytes of instruction that includes the next sequential instruction and additional bytes of further sequential instructions.<!-- EPO <DP n="47"> --></p><p id="p0134" num="0134">The fetched instructions are then executed by the processor 5026. In an embodiment, the fetched instruction(s) are passed to a dispatch unit 5056 of the fetch unit. The dispatch unit decodes the instruction(s) and forwards information about the decoded instruction(s) to appropriate units 5057, 5058, 5060. An execution unit 5057 will typically receive information about decoded arithmetic instructions from the instruction fetch unit 5055 and will perform arithmetic operations on operands according to the opcode of the instruction. Operands are provided to the execution unit 5057 preferably either from memory 5025, architected registers 5059 or from an immediate field of the instruction being executed. Results of the execution, when stored, are stored either in memory 5025, registers 5059 or in other machine hardware (such as control registers, PSW registers and the like).</p><p id="p0135" num="0135">A processor 5026 typically has one or more units 5057, 5058, 5060 for executing the function of the instruction. Referring to <figref idrefs="f0022">FIG. 18A</figref>, an execution unit 5057 may communicate with architected general registers 5059, a decode/dispatch unit 5056, a load store unit 5060, and other 5065 processor units by way of interfacing logic 5071. An execution unit 5057 may employ several register circuits 5067, 5068, 5069 to hold information that the arithmetic logic unit (ALU) 5066 will operate on. The ALU performs arithmetic operations such as add, subtract, multiply and divide as well as logical function such as and, or and exclusive-or (XOR), rotate and shift. Preferably the ALU supports specialized operations that are design dependent. Other circuits may provide other architected facilities 5072 including condition codes and recovery support logic for example. Typically the result of an ALU operation is held in an output register circuit 5070 which can forward the result to a variety of other processing functions. There are many arrangements of processor units, the present description is only intended to provide a representative understanding of one embodiment.</p><p id="p0136" num="0136">An ADD instruction for example would be executed in an execution unit 5057 having arithmetic and logical functionality while a floating point instruction for example would be executed in a floating point execution having specialized floating point capability. Preferably, an execution unit operates on operands identified by an instruction by performing an opcode defined function on the operands. For example, an ADD instruction may be executed by an execution unit 5057 on operands found in two registers 5059 identified by register fields of the instruction.<!-- EPO <DP n="48"> --></p><p id="p0137" num="0137">The execution unit 5057 performs the arithmetic addition on two operands and stores the result in a third operand where the third operand may be a third register or one of the two source registers. The execution unit preferably utilizes an Arithmetic Logic Unit (ALU) 5066 that is capable of performing a variety of logical functions such as Shift, Rotate, And, Or and XOR as well as a variety of algebraic functions including any of add, subtract, multiply, divide. Some ALUs 5066 are designed for scalar operations and some for floating point. Data may be Big Endian (where the least significant byte is at the highest byte address) or Little Endian (where the least significant byte is at the lowest byte address) depending on architecture. The IBM z/Architecture<sup>®</sup> is Big Endian. Signed fields may be sign and magnitude, 1's complement or 2's complement depending on architecture. A 2's complement number is advantageous in that the ALU does not need to design a subtract capability since either a negative value or a positive value in 2's complement requires only an addition within the ALU. Numbers are commonly described in shorthand, where a 12 bit field defines an address of a 4,096 byte block and is commonly described as a 4 Kbyte (Kilobyte) block, for example.</p><p id="p0138" num="0138">Referring to <figref idrefs="f0023">FIG. 18B</figref>, branch instruction information for executing a branch instruction is typically sent to a branch unit 5058 which often employs a branch prediction algorithm such as a branch history table 5082 to predict the outcome of the branch before other conditional operations are complete. The target of the current branch instruction will be fetched and speculatively executed before the conditional operations are complete. When the conditional operations are completed the speculatively executed branch instructions are either completed or discarded based on the conditions of the conditional operation and the speculated outcome. A typical branch instruction may test condition codes and branch to a target address if the condition codes meet the branch requirement of the branch instruction, a target address may be calculated based on several numbers including ones found in register fields or an immediate field of the instruction for example. The branch unit 5058 may employ an ALU 5074 having a plurality of input register circuits 5075, 5076, 5077 and an output register circuit 5080. The branch unit 5058 may communicate with general registers 5059, decode dispatch unit 5056 or other circuits 5073, for example.</p><p id="p0139" num="0139">The execution of a group of instructions can be interrupted for a variety of reasons including a context switch initiated by an operating system, a program exception or error causing a<!-- EPO <DP n="49"> --> context switch, an I/O interruption signal causing a context switch or multi-threading activity of a plurality of programs (in a multi-threaded environment), for example. Preferably a context switch action saves state information about a currently executing program and then loads state information about another program being invoked. State information may be saved in hardware registers or in memory for example. State information preferably comprises a program counter value pointing to a next instruction to be executed, condition codes, memory translation information and architected register content. A context switch activity can be exercised by hardware circuits, application programs, operating system programs or firmware code (microcode, pico-code or licensed internal code (LIC)) alone or in combination.</p><p id="p0140" num="0140">A processor accesses operands according to instruction defined methods. The instruction may provide an immediate operand using the value of a portion of the instruction, may provide one or more register fields explicitly pointing to either general purpose registers or special purpose registers (floating point registers for example). The instruction may utilize implied registers identified by an opcode field as operands. The instruction may utilize memory locations for operands. A memory location of an operand may be provided by a register, an immediate field, or a combination of registers and immediate field as exemplified by the z/Architecture<sup>®</sup> long displacement facility wherein the instruction defines a base register, an index register and an immediate field (displacement field) that are added together to provide the address of the operand in memory for example. Location herein typically implies a location in main memory (main storage) unless otherwise indicated.</p><p id="p0141" num="0141">Referring to <figref idrefs="f0024">FIG. 18C</figref>, a processor accesses storage using a load/store unit 5060. The load/store unit 5060 may perform a load operation by obtaining the address of the target operand in memory 5053 and loading the operand in a register 5059 or another memory 5053 location, or may perform a store operation by obtaining the address of the target operand in memory 5053 and storing data obtained from a register 5059 or another memory 5053 location in the target operand location in memory 5053. The load/store unit 5060 may be speculative and may access memory in a sequence that is out-of-order relative to instruction sequence, however the load/store unit 5060 is to maintain the appearance to programs that instructions were executed in order. A load/store unit 5060 may communicate with general registers 5059, decode/dispatch unit 5056, cache/memory interface 5053 or<!-- EPO <DP n="50"> --> other elements 5083 and comprises various register circuits, ALUs 5085 and control logic 5090 to calculate storage addresses and to provide pipeline sequencing to keep operations in- order. Some operations may be out of order but the load/store unit provides functionality to make the out of order operations to appear to the program as having been performed in order, as is well known in the art.</p><p id="p0142" num="0142">Preferably addresses that an application program "sees" are often referred to as virtual addresses. Virtual addresses are sometimes referred to as "logical addresses" and "effective addresses". These virtual addresses are virtual in that they are redirected to physical memory location by one of a variety of dynamic address translation (DAT) technologies including, but not limited to, simply prefixing a virtual address with an offset value, translating the virtual address via one or more translation tables, the translation tables preferably comprising at least a segment table and a page table alone or in combination, preferably, the segment table having an entry pointing to the page table. In the z/Architecture<sup>®</sup>, a hierarchy of translation is provided including a region first table, a region second table, a region third table, a segment table and an optional page table. The performance of the address translation is often improved by utilizing a translation lookaside buffer (TLB) which comprises entries mapping a virtual address to an associated physical memory location. The entries are created when the DAT translates a virtual address using the translation tables. Subsequent use of the virtual address can then utilize the entry of the fast TLB rather than the slow sequential translation table accesses. TLB content may be managed by a variety of replacement algorithms including LRU (Least Recently used).</p><p id="p0143" num="0143">In the case where the processor is a processor of a multi-processor system, each processor has responsibility to keep shared resources, such as I/O, caches, TLBs and memory, interlocked for coherency. Typically, "snoop" technologies will be utilized in maintaining cache coherency. In a snoop environment, each cache line may be marked as being in any one of a shared state, an exclusive state, a changed state, an invalid state and the like in order to facilitate sharing.</p><p id="p0144" num="0144">I/O units 5054 (<figref idrefs="f0021">FIG. 17</figref>) provide the processor with means for attaching to peripheral devices including tape, disc, printers, displays, and networks for example. I/O units are often presented to the computer program by software drivers. In mainframes, such as the System<!-- EPO <DP n="51"> --> z<sup>®</sup> from IBM<sup>®</sup>, channel adapters and open system adapters are I/O units of the mainframe that provide the communications between the operating system and peripheral devices.</p><p id="p0145" num="0145">Further, other types of computing environments can benefit from one or more aspects of the present invention. As an example, an environment may include an emulator (e.g., software or other emulation mechanisms), in which a particular architecture (including, for instance, instruction execution, architected functions, such as address translation, and architected registers) or a subset thereof is emulated (e.g., on a native computer system having a processor and memory). In such an environment, one or more emulation functions of the emulator can implement one or more aspects of the present invention, even though a computer executing the emulator may have a different architecture than the capabilities being emulated. As one example, in emulation mode, the specific instruction or operation being emulated is decoded, and an appropriate emulation function is built to implement the individual instruction or operation.</p><p id="p0146" num="0146">In an emulation environment, a host computer includes, for instance, a memory to store instructions and data; an instruction fetch unit to fetch instructions from memory and to optionally, provide local buffering for the fetched instruction; an instruction decode unit to receive the fetched instructions and to determine the type of instructions that have been fetched; and an instruction execution unit to execute the instructions. Execution may include loading data into a register from memory; storing data back to memory from a register; or performing some type of arithmetic or logical operation, as determined by the decode unit. In one example, each unit is implemented in software. For instance, the operations being performed by the units are implemented as one or more subroutines within emulator software.</p><p id="p0147" num="0147">More particularly, in a mainframe, architected machine instructions are used by programmers, usually today "C" programmers, often by way of a compiler application. These instructions stored in the storage medium may be executed natively in a z/Architecture<sup>®</sup> IBM<sup>®</sup> Server, or alternatively in machines executing other architectures. They can be emulated in the existing and in future IBM<sup>®</sup> mainframe servers and on other machines of IBM<sup>®</sup> (e.g., Power Systems servers and System x<sup>®</sup> Servers). They can be executed in machines running Linux on a wide variety of machines using hardware manufactured by IBM<sup>®</sup>, Intel<sup>®</sup>, AMD<sup>™</sup>, and others. Besides execution on that hardware<!-- EPO <DP n="52"> --> under a z/Architecture<sup>®</sup>, Linux can be used as well as machines which use emulation by Hercules (see www.hercules-390.org), or FSI (Fundamental Software, Inc) (see www.funsoft.com), where generally execution is in an emulation mode. In emulation mode, emulation software is executed by a native processor to emulate the architecture of an emulated processor.</p><p id="p0148" num="0148">The native processor typically executes emulation software comprising either firmware or a native operating system to perform emulation of the emulated processor. The emulation software is responsible for fetching and executing instructions of the emulated processor architecture. The emulation software maintains an emulated program counter to keep track of instruction boundaries. The emulation software may fetch one or more emulated machine instructions at a time and convert the one or more emulated machine instructions to a corresponding group of native machine instructions for execution by the native processor: These converted instructions may be cached such that a faster conversion can be accomplished. Notwithstanding, the emulation software is to maintain the architecture rules of the emulated processor architecture so as to assure operating systems and applications written for the emulated processor operate correctly. Furthermore, the emulation software is to provide resources identified by the emulated processor architecture including, but not limited to, control registers, general purpose registers, floating point registers, dynamic address translation function including segment tables and page tables for example, interrupt mechanisms, context switch mechanisms, Time of Day (TOD) clocks and architected interfaces to I/O subsystems such that an operating system or an application program designed to run on the emulated processor, can be run on the native processor having the emulation software.</p><p id="p0149" num="0149">A specific instruction being emulated is decoded, and a subroutine is called to perform the function of the individual instruction. An emulation software function emulating a function of an emulated processor is implemented, for example, in a "C" subroutine or driver, or some other method of providing a driver for the specific hardware as will be within the skill of those in the art after understanding the description of the preferred embodiment. Various software and hardware emulation patents including, but not limited to U.S. Letters Patent No. 5,551,013, entitled "Multiprocessor for Hardware Emulation", by Beausoleil et al.; and <patcit id="pcit0005" dnum="US6009261A"><text>U.S. Letters Patent No. 6,009,261</text></patcit>, entitled "Preprocessing of Stored Target Routines for<!-- EPO <DP n="53"> --> Emulating Incompatible Instructions on a Target Processor", by Scalzi et al; and <patcit id="pcit0006" dnum="US5574873A"><text>U.S. Letters Patent No. 5,574,873</text></patcit>, entitled "Decoding Guest Instruction to Directly Access Emulation Routines that Emulate the Guest Instructions", by Davidian et al; and <patcit id="pcit0007" dnum="US6308255B"><text>U.S. Letters Patent No. 6,308,255</text></patcit>, entitled "Symmetrical Multiprocessing Bus and Chipset Used for Coprocessor Support Allowing Non-Native Code to Run in a System", by Gorishek et al; and <patcit id="pcit0008" dnum="US6463582B"><text>U.S. Letters Patent No. 6,463,582</text></patcit>, entitled "Dynamic Optimizing Object Code Translator for Architecture Emulation and Dynamic Optimizing Object Code Translation Method", by Lethin et al; and <patcit id="pcit0009" dnum="US5790825A"><text>U.S. Letters Patent No. 5,790,825</text></patcit>, entitled "Method for Emulating Guest Instructions on a Host Computer Through Dynamic Recompilation of Host Instructions", by Eric Traut; and many others, illustrate a variety of known ways to achieve emulation of an instruction format architected for a different machine for a target machine available to those skilled in the art.</p><p id="p0150" num="0150">In <figref idrefs="f0025">FIG. 19</figref>, an example of an emulated host computer system 5092 is provided that emulates a host computer system 5000' of a host architecture. In the emulated host computer system 5092, the host processor (CPU) 5091 is an emulated host processor (or virtual host processor) and comprises an emulation processor 5093 having a different native instruction set architecture than that of the processor 5091 of the host computer 5000'. The emulated host computer system 5092 has memory 5094 accessible to the emulation processor 5093. In the example embodiment, the memory 5094 is partitioned into a host computer memory 5096 portion and an emulation routines 5097 portion. The host computer memory 5096 is available to programs of the emulated host computer 5092 according to host computer architecture. The emulation processor 5093 executes native instructions of an architected instruction set of an architecture other than that of the emulated processor 5091, the native instructions obtained from emulation routines memory 5097, and may access a host instruction for execution from a program in host computer memory 5096 by employing one or more instruction(s) obtained in a sequence &amp; access/decode routine which may decode the host instruction(s) accessed to determine a native instruction execution routine for emulating the function of the host instruction accessed. Other facilities that are defined for the host computer system 5000' architecture may be emulated by architected facilities routines, including such facilities as general purpose registers, control registers, dynamic address translation and I/O subsystem support and processor cache, for example. The emulation routines may also take advantage of functions available in the emulation processor 5093<!-- EPO <DP n="54"> --> (such as general registers and dynamic translation of virtual addresses) to improve performance of the emulation routines. Special hardware and off-load engines may also be provided to assist the processor 5093 in emulating the function of the host computer 5000'.</p><p id="p0151" num="0151">The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention as claimed. As used herein, the singular forms "a", "an" and "the" are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms "comprises" and/or "comprising", when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components and/or groups thereof.</p></description><claims mxw-id="PCLM56985314" lang="DE" load-source="patent-office"><!-- EPO <DP n="58"> --><claim id="c-de-01-0001" num="0001"><claim-text>Verfahren zum Unterstützen der Verwaltung eines Systemspeichers einer Computerumgebung, wobei das Verfahren folgende Schritte umfasst:
<claim-text>in Reaktion auf das Ausführen eines Anruf-Logikprozessor-Befehls (1000), im Weiteren CLP-Befehl genannt, zum Freigeben eines Adapters (110) und zum Anfordern einer Anzahl (1030) von Direktspeicherzugriff-(DMA)-Adressräumen, die dem Adapter zuzuordnen sind, wobei der CLP-Befehl ein Funktions-Handle umfasst, das den Adapter identifiziert, wobei das Funktions-Handle ein Adapter-nicht-freigegeben-Kennzeichen aufweist, Freigeben der durch den CLP-Befehl für den Adapter angeforderten Anzahl der DMA-Adressräume, wobei die Anzahl größer ist als eins, und Zurücksenden des Funktions-Handles mit einem Adapter-freigegeben-Kennzeichen, wobei ein für den Adapter freigegebener DMA-Adressraum eine ihm zugeordnete Gruppe von Umwandlungstabellen aufweist und ein weiterer für den Adapter freigegebener DMA-Adressraum eine weitere ihm zugeordnete Gruppe von Umwandlungstabellen aufweist, die sich von der einen Gruppe von Umwandlungstabellen unterscheidet,</claim-text>
<claim-text>in Reaktion auf das Ausführen eines Modifizieren-der-PCI-Funktionssteuerungen-Befehls (600), im Weiteren MPFC-Befehl genannt, der eine Operation des Registrierens von Adressenumwandlungsparametern spezifiziert, Definieren eines ersten DMA-Adressraums des einen oder der mehreren für den Adapter freigegebenen DMA-Adressräume,</claim-text>
<claim-text>Empfangen einer Anforderung vom Adapter für einen Systemspeicherzugriff und</claim-text>
<claim-text>Verwenden einer in der Anforderung bereitgestellten Anfordererkennung und Adressraumkennung, um den beim Zugriff zu verwendenden DMA-Adressraum auszuwählen, wobei der DMA-Adressraum aus dem einen oder den mehreren für den Adapter freigegebenen DMA-Adressräumen ausgewählt wird.</claim-text></claim-text></claim><claim id="c-de-01-0002" num="0002"><claim-text>Verfahren nach Anspruch 1, wobei die Adressraumkennung ein oder mehrere Bits umfasst und wobei das Verfahren ferner in Reaktion auf das<!-- EPO <DP n="59"> --> Ausführen eines CLP-Befehls zum Abfragen einer Gruppe das Bestimmen umfasst, welches eine oder welche mehreren Bits einer durch den Adapter bereitgestellten Adresse das eine oder die mehreren Bits der Adressraumkennung sind.</claim-text></claim><claim id="c-de-01-0003" num="0003"><claim-text>Verfahren nach Anspruch 1, wobei das Verwenden das Verwenden der Anfordererkennung und der Adressraumkennung umfasst, um einen Eintrag in einer dem Adapter zugeordneten Datenstruktur aufzufinden, wobei der Eintrag ein oder mehrere Merkmale bezüglich des Adressraums bereitstellt.</claim-text></claim><claim id="c-de-01-0004" num="0004"><claim-text>Verfahren nach Anspruch 3, wobei der Eintrag in einer Gerätetabelle eines Eingabe-/Ausgabe-Hubs angeordnet ist, der mit dem Adapter und dem Systemspeicher gekoppelt ist.</claim-text></claim><claim id="c-de-01-0005" num="0005"><claim-text>Verfahren nach Anspruch 1, wobei das Verfahren ferner das Zuordnen einer oder mehrerer Adressenumwandlungstabellen zum Adressraum umfasst, wobei die eine oder die mehreren Adressumwandlungstabellen ein erstes Format aufweisen.</claim-text></claim><claim id="c-de-01-0006" num="0006"><claim-text>Verfahren nach Anspruch 5, wobei das Verfahren ferner das Auswählen eines weiteren Adressraums für den Adapter umfasst und das Zuordnen einer oder mehrerer weiterer Adressumwandlungstabellen zum weiteren Adressraum, wobei die eine oder die mehreren weiteren Adressumwandlungstabellen ein zweites Format aufweisen, wobei sich das zweite Format vom ersten Format unterscheidet.</claim-text></claim><claim id="c-de-01-0007" num="0007"><claim-text>Verfahren nach Anspruch 6, wobei das erste Format eine erste Variante eines Adressumwandlungsformats umfasst und das zweite Format eine zweite Variante des Adressumwandlungsformats umfasst.</claim-text></claim><claim id="c-de-01-0008" num="0008"><claim-text>Verfahren nach Anspruch 6, wobei das zweite Adressumwandlungsformat von einer anderen Art Adressumwandlungsformat als das erste Format ist.<!-- EPO <DP n="60"> --></claim-text></claim><claim id="c-de-01-0009" num="0009"><claim-text>Verfahren nach Anspruch 1, wobei der Adapter eine Adapterfunktion umfasst und wobei die Anforderung von der Adapterfunktion empfangen wird, wobei die Adapterfunktion mehrere ihr zugeordnete Adressräume aufweist.</claim-text></claim><claim id="c-de-01-0010" num="0010"><claim-text>Verfahren nach Anspruch 1, wobei die Adressraumkennung ein Bit einer in der Anforderung bereitgestellten Adresse umfasst, wobei ein erster Wert des Bits in Kombination mit der Anfordererkennung einen ersten Adressraum anzeigt und ein zweiter Wert des Bit in Kombination mit der Anfordererkennung einen zweiten Adressraum anzeigt.</claim-text></claim><claim id="c-de-01-0011" num="0011"><claim-text>Verfahren nach Anspruch 1, wobei die Adressraumkennung ein oder mehrere Bits der in der Anforderung bereitgestellten Adresse umfasst.</claim-text></claim><claim id="c-de-01-0012" num="0012"><claim-text>Verfahren nach Anspruch 1, wobei das Verfahren ferner Folgendes umfasst:
<claim-text>Empfangen einer weiteren Anforderung vom Adapter und</claim-text>
<claim-text>Verwenden einer weiteren Anfordererkennung und einer weiteren Adressraumkennung, die in der weiteren Anforderung bereitgestellt sind, um einen weiteren Adressraum auszuwählen, wobei der Adressraum ein erstes, ihm zugeordnetes Adressumwandlungsformat und der weitere Adressraum ein zweites, ihm zugeordnetes Adressumwandlungsformat aufweist, wobei sich das erste Adressumwandlungsformat vom zweiten Adressumwandlungsformat unterscheidet.</claim-text></claim-text></claim><claim id="c-de-01-0013" num="0013"><claim-text>System, Mittel umfassend, die zum Ausführen aller Schritte des Verfahrens nach einem der vorhergehenden Verfahrensansprüche eingerichtet sind.</claim-text></claim><claim id="c-de-01-0014" num="0014"><claim-text>Computerprogramm, Befehle umfassend, um alle Schritte des Verfahrens nach einem der vorhergehenden Verfahrensansprüche auszuführen, wenn das Computerprogramm auf einem Computersystem abgearbeitet wird.</claim-text></claim></claims><claims mxw-id="PCLM56985315" lang="EN" load-source="patent-office"><!-- EPO <DP n="55"> --><claim id="c-en-01-0001" num="0001"><claim-text>A method of facilitating management of system memory of a computing environment, the method comprising steps of:
<claim-text>responsive to executing a Call Logical Processor instruction (1000) called CLP instruction hereinafter, for enabling an adapter (110) and requesting a number (1030) of direct memory access (DMA) address spaces to be assigned to the adapter, the CLP instruction comprising a function handle identifying the adapter, the function handle having an adapter not enabled indicator, enabling the number of DMA address spaces requested by the CLP instruction for the adapter, wherein the number is greater than one and returning the function handle having an adapter enabled indicator, wherein one DMA address space enabled for the adapter has one set of translation tables associated therewith and another DMA address space enabled for the adapter has another set of translation tables associated therewith that differ from the one set of translation tables;</claim-text>
<claim-text>responsive to executing a Modify PCI Function Controls instruction (600) called MPFC instruction hereinafter, that specifies a register address translation parameters operation, defining a first DMA address space of the one or more DMA address spaces enabled for the adapter;</claim-text>
<claim-text>receiving a request from the adapter to access system memory; and</claim-text>
<claim-text>using a requestor identifier and an address space identifier provided in the request to select the DMA address space to be used in the access, the DMA address space being selected from the one or more DMA address spaces enabled for the adapter.</claim-text></claim-text></claim><claim id="c-en-01-0002" num="0002"><claim-text>The method of claim 1, wherein the address space identifier comprises one or more bits, and wherein the method further comprises responsive to executing a CLP instruction for querying a group, determining which one or more bits of an address provided by the adapter are the one or more bits of the address space identifier.</claim-text></claim><claim id="c-en-01-0003" num="0003"><claim-text>The method claim 1, wherein the using comprises using the requestor identifier and address space identifier to locate an entry in a data structure associated with the adapter, the entry providing one or more characteristics regarding the address space.</claim-text></claim><claim id="c-en-01-0004" num="0004"><claim-text>The method of claim 3, wherein the entry is located in a device table of an input/output hub coupled to the adapter and system memory.<!-- EPO <DP n="56"> --></claim-text></claim><claim id="c-en-01-0005" num="0005"><claim-text>The method of claim 1, wherein the method further comprises associating one or more address translation tables with the address space, the one or more address translation tables being of a first format.</claim-text></claim><claim id="c-en-01-0006" num="0006"><claim-text>The method of claim 5, wherein the method further comprises selecting another address space for the adapter, and associating one or more other address translation tables with the another address space, the one or more other address translation tables being of a second format, the second format being different from the first format.</claim-text></claim><claim id="c-en-01-0007" num="0007"><claim-text>The method of claim 6, wherein the first format comprises a first variation of an address translation format and the second format comprises a second variation of the address translation format.</claim-text></claim><claim id="c-en-01-0008" num="0008"><claim-text>The method of claim 6, wherein the second format is of a different type of address translation format than the first format.</claim-text></claim><claim id="c-en-01-0009" num="0009"><claim-text>The method of claim 1, wherein the adapter comprises an adapter function, and wherein the request is received from the adapter function, the adapter function having a plurality of address spaces assigned thereto.</claim-text></claim><claim id="c-en-01-0010" num="0010"><claim-text>The method of claim 1, wherein the address space identifier comprises a bit of an address provided in the request, wherein a first value of the bit in combination with the requestor identifier indicates a first address space, and a second value of the bit in combination with the requestor identifier indicates a second address space.</claim-text></claim><claim id="c-en-01-0011" num="0011"><claim-text>The method of claim 1, wherein the address space identifier comprises one or more bits of the address provided in the request.</claim-text></claim><claim id="c-en-01-0012" num="0012"><claim-text>The method of claim 1, wherein the method further comprises:
<claim-text>receiving another request from the adapter; and</claim-text>
<claim-text>using another requestor identifier and another address space identifier provided in the another request to select another address space, wherein the address space has a first address translation format associated therewith and the another address space has a second address translation format associated therewith, the first address translation format being different than the second address translation format.</claim-text><!-- EPO <DP n="57"> --></claim-text></claim><claim id="c-en-01-0013" num="0013"><claim-text>A system comprising means adapted for carrying out all the steps of the method according to any preceding method claim.</claim-text></claim><claim id="c-en-01-0014" num="0014"><claim-text>A computer program comprising instructions for carrying out all the steps of the method according to any preceding method claim, when said computer program is executed on a computer system.</claim-text></claim></claims><claims mxw-id="PCLM56985316" lang="FR" load-source="patent-office"><!-- EPO <DP n="61"> --><claim id="c-fr-01-0001" num="0001"><claim-text>Procédé pour faciliter la gestion de la mémoire système d'un environnement informatique, le procédé comprenant les étapes de :
<claim-text>en réponse à l'exécution d'une instruction d'Appel de Processeur Logique (1000), appelée instruction CLP dans la suite du document, pour valider un adaptateur (110) et demander un nombre (1030) d'espaces d'adresses d'accès direct à la mémoire (DMA) à attribuer à l'adaptateur, l'instruction CLP comprenant un descripteur de fonction identifiant l'adaptateur, le descripteur de fonction ayant un indicateur d'adaptateur non validé, validation du nombre d'espaces d'adresses de DMA demandés par l'instruction CLP pour l'adaptateur, dans lequel le nombre est supérieur à un et renvoi du descripteur de fonction ayant un indicateur d'adaptateur validé, dans lequel un espace d'adresses de DMA validé pour l'adaptateur a un ensemble de tables de translation associées à celui-ci et un autre espace d'adresses de DMA validé pour l'adaptateur a un autre ensemble de tables de translation associées à celui-ci qui diffère du premier ensemble de tables de translation ;</claim-text>
<claim-text>en réponse à l'exécution d'une instruction de Modification de Commandes de Fonction PCI (600), appelée instruction MPFC dans la suite du document, qui spécifie une mise en oeuvre de paramètres de translation d'adresse de registre, définition d'un premier espace d'adresses de DMA du ou des plusieurs espaces d'adresses de DMA validés pour l'adaptateur ;</claim-text>
<claim-text>réception d'une demande provenant de l'adaptateur pour avoir accès à la mémoire système ; et</claim-text>
<claim-text>utilisation d'un identificateur de demandeur et d'un identificateur d'espace d'adresses fournis dans la<!-- EPO <DP n="62"> --> demande pour sélectionner l'espace d'adresses de DMA à utiliser lors de l'accès, l'espace d'adresses de DMA étant sélectionné à partir du ou des plusieurs espaces d'adresses de DMA validés pour l'adaptateur.</claim-text></claim-text></claim><claim id="c-fr-01-0002" num="0002"><claim-text>Procédé selon la revendication 1, dans lequel l'identificateur d'espace d'adresses comprend un ou plusieurs bits, et dans lequel le procédé comprend en outre en réponse à l'exécution d'une instruction CLP pour interroger un groupe, la détermination duquel d'un ou de plusieurs bits d'une adresse fournie par l'adaptateur est/sont le ou les plusieurs bits de l'identificateur d'espace d'adresses.</claim-text></claim><claim id="c-fr-01-0003" num="0003"><claim-text>Procédé selon la revendication 1, dans lequel l'utilisation comprend l'utilisation de l'identificateur de demandeur et de l'identificateur d'espace d'adresses pour localiser une entrée dans une structure de données associée à l'adaptateur, l'entrée fournissant une ou plusieurs caractéristiques concernant l'espace d'adresses.</claim-text></claim><claim id="c-fr-01-0004" num="0004"><claim-text>Procédé selon la revendication 3, dans lequel l'entrée est située dans une table de dispositif d'un concentrateur d'entrée / sortie relié à la mémoire système et à l'adaptateur.</claim-text></claim><claim id="c-fr-01-0005" num="0005"><claim-text>Procédé selon la revendication 1, dans lequel le procédé comprend en outre l'association d'une ou plusieurs tables de translation d'adresse avec l'espace d'adresses, la ou les plusieurs tables de translation d'adresse ayant un premier format.</claim-text></claim><claim id="c-fr-01-0006" num="0006"><claim-text>Procédé selon la revendication 5, dans lequel le procédé comprend en outre la sélection d'un autre espace d'adresses pour l'adaptateur, et l'association de l'une ou de plusieurs autres tables de translation d'adresse avec l'autre espace d'adresses, la ou les plusieurs autres tables de translation d'adresse ayant un second format, le second format étant différent du<!-- EPO <DP n="63"> --> premier format.</claim-text></claim><claim id="c-fr-01-0007" num="0007"><claim-text>Procédé selon la revendication 6, dans lequel le premier format comprend une première variation d'un format de translation d'adresse et le second format comprend une seconde variation du format de translation d'adresse.</claim-text></claim><claim id="c-fr-01-0008" num="0008"><claim-text>Procédé selon la revendication 6, dans lequel le second format est d'un type différent de format de translation d'adresse que le premier format.</claim-text></claim><claim id="c-fr-01-0009" num="0009"><claim-text>Procédé selon la revendication 1, dans lequel l'adaptateur comprend une fonction d'adaptateur, et dans lequel la demande est reçue en provenance de la fonction d'adaptateur, la fonction d'adaptateur ayant une pluralité d'espaces d'adresse qui lui sont attribués.</claim-text></claim><claim id="c-fr-01-0010" num="0010"><claim-text>Procédé selon la revendication 1, dans lequel l'identificateur d'espace d'adresses comprend un bit d'une adresse fournie dans la demande, dans lequel une première valeur du bit en combinaison avec l'identificateur de demandeur indique un premier espace d'adresses, et une seconde valeur du bit en combinaison avec l'identificateur de demandeur indique un second espace d'adresses.</claim-text></claim><claim id="c-fr-01-0011" num="0011"><claim-text>Procédé selon la revendication 1, dans lequel l'identificateur d'espace d'adresses comprend un ou plusieurs bits de l'adresse fournie dans la demande.</claim-text></claim><claim id="c-fr-01-0012" num="0012"><claim-text>Procédé selon la revendication 1, dans lequel le procédé comprend en outre :
<claim-text>la réception d'une autre demande en provenance de l'adaptateur ; et</claim-text>
<claim-text>l'utilisation d'un autre identificateur de demandeur et d'un autre identificateur d'espace d'adresses fournis dans l'autre demande pour sélectionner un autre espace d'adresses, dans lequel l'espace d'adresses a un premier format de translation<!-- EPO <DP n="64"> --> d'adresse associé à celui-ci et l'autre espace d'adresses a un second format de translation d'adresse associé à celui-ci, le premier format de translation d'adresse étant différent du second format de translation d'adresse.</claim-text></claim-text></claim><claim id="c-fr-01-0013" num="0013"><claim-text>Système comprenant un moyen conçu pour effectuer toutes les étapes du procédé selon l'une quelconque des revendications précédentes.</claim-text></claim><claim id="c-fr-01-0014" num="0014"><claim-text>Programme informatique comprenant des instructions pour effectuer toutes les étapes du procédé selon l'une quelconque des revendications précédentes, lorsque ledit programme informatique est exécuté sur un système informatique.</claim-text></claim></claims><drawings mxw-id="PDW16672127" load-source="patent-office"><!-- EPO <DP n="65"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="165" he="211" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="66"> --><figure id="f0002" num="2A"><img id="if0002" file="imgf0002.tif" wi="165" he="216" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="67"> --><figure id="f0003" num="2B"><img id="if0003" file="imgf0003.tif" wi="165" he="138" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="68"> --><figure id="f0004" num="3A,3B"><img id="if0004" file="imgf0004.tif" wi="116" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="69"> --><figure id="f0005" num="4"><img id="if0005" file="imgf0005.tif" wi="165" he="210" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="70"> --><figure id="f0006" num="5A"><img id="if0006" file="imgf0006.tif" wi="164" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="71"> --><figure id="f0007" num="5B"><img id="if0007" file="imgf0007.tif" wi="143" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="72"> --><figure id="f0008" num="5C,5D"><img id="if0008" file="imgf0008.tif" wi="165" he="232" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="73"> --><figure id="f0009" num="6A,6B,6C"><img id="if0009" file="imgf0009.tif" wi="133" he="216" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="74"> --><figure id="f0010" num="6D"><img id="if0010" file="imgf0010.tif" wi="165" he="162" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="75"> --><figure id="f0011" num="7"><img id="if0011" file="imgf0011.tif" wi="165" he="227" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="76"> --><figure id="f0012" num="8"><img id="if0012" file="imgf0012.tif" wi="165" he="226" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="77"> --><figure id="f0013" num="9"><img id="if0013" file="imgf0013.tif" wi="131" he="179" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="78"> --><figure id="f0014" num="10A,10B,10C"><img id="if0014" file="imgf0014.tif" wi="165" he="206" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="79"> --><figure id="f0015" num="11"><img id="if0015" file="imgf0015.tif" wi="164" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="80"> --><figure id="f0016" num="12A,12B"><img id="if0016" file="imgf0016.tif" wi="165" he="164" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="81"> --><figure id="f0017" num="13"><img id="if0017" file="imgf0017.tif" wi="149" he="164" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="82"> --><figure id="f0018" num="14"><img id="if0018" file="imgf0018.tif" wi="160" he="211" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="83"> --><figure id="f0019" num="15"><img id="if0019" file="imgf0019.tif" wi="165" he="166" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="84"> --><figure id="f0020" num="16"><img id="if0020" file="imgf0020.tif" wi="165" he="183" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="85"> --><figure id="f0021" num="17"><img id="if0021" file="imgf0021.tif" wi="165" he="153" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="86"> --><figure id="f0022" num="18A"><img id="if0022" file="imgf0022.tif" wi="165" he="207" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="87"> --><figure id="f0023" num="18B"><img id="if0023" file="imgf0023.tif" wi="162" he="195" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="88"> --><figure id="f0024" num="18C"><img id="if0024" file="imgf0024.tif" wi="165" he="212" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="89"> --><figure id="f0025" num="19"><img id="if0025" file="imgf0025.tif" wi="165" he="233" img-content="drawing" img-format="tif"/></figure></drawings><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
