<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-1690421-B1" country="EP" doc-number="1690421" kind="B1" date="20140108" family-id="30439605" file-reference-id="299936" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="146589081" ucid="EP-1690421-B1"><document-id><country>EP</country><doc-number>1690421</doc-number><kind>B1</kind><date>20140108</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-04808859-A" is-representative="NO"><document-id mxw-id="PAPP154851273" load-source="docdb" format="epo"><country>EP</country><doc-number>04808859</doc-number><kind>A</kind><date>20041126</date><lang>EN</lang></document-id><document-id mxw-id="PAPP219977282" load-source="docdb" format="original"><country>EP</country><doc-number>04808859.5</doc-number><date>20041126</date></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC140554012" ucid="NO-20035322-A" load-source="docdb"><document-id format="epo"><country>NO</country><doc-number>20035322</doc-number><kind>A</kind><date>20031128</date></document-id></priority-claim><priority-claim mxw-id="PPC140548317" ucid="NO-2004000365-W" linkage-type="W" load-source="docdb"><document-id format="epo"><country>NO</country><doc-number>2004000365</doc-number><kind>W</kind><date>20041126</date></document-id></priority-claim></priority-claims><dates-of-public-availability><intention-to-grant-date><date>20130726</date></intention-to-grant-date></dates-of-public-availability><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL1989327539" load-source="docdb">H04N   7/15        20060101AFI20050614BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989327540" load-source="docdb">H04N   7/12        20060101ALI20050614BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989327541" load-source="docdb">G06T   9/00        20060101ALN20050614BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989621682" load-source="docdb">H04N   7/36        20060101A I20051008RMEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989623773" load-source="docdb">H04N   7/46        20060101A I20051008RMEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989634997" load-source="docdb">G06T   5/20        20060101A I20051008RMEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989643206" load-source="docdb">H04N   7/26        20060101A I20051008RMEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989643385" load-source="docdb">H04N   5/14        20060101A I20060506RMEP        </classification-ipcr><classification-ipcr mxw-id="PCL1989652031" load-source="docdb">H04N               20060101S I20051110RMEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-2137627939" load-source="docdb" scheme="CPC">H04N  19/523       20141101 LI20141108BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2137637491" load-source="docdb" scheme="CPC">H04N  19/51        20130101 LI20141108BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2137642277" load-source="docdb" scheme="CPC">H04N  19/80        20141101 LI20141108BHEP        </classification-cpc><classification-cpc mxw-id="PCL-2137646536" load-source="docdb" scheme="CPC">H04N  19/59        20141101 FI20141108BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT132371876" lang="DE" load-source="patent-office">VERFAHREN ZUR KORREKTUR INTERPOLIERTER PIXELWERTE</invention-title><invention-title mxw-id="PT132371877" lang="EN" load-source="patent-office">METHOD FOR CORRECTING INTERPOLATED PIXEL VALUES</invention-title><invention-title mxw-id="PT132371878" lang="FR" load-source="patent-office">PROCEDE DE CORRECTION DE VALEURS DE PIXELS INTERPOLES</invention-title><citations><patent-citations><patcit mxw-id="PCIT370249038" load-source="docdb" ucid="EP-1353514-A2"><document-id format="epo"><country>EP</country><doc-number>1353514</doc-number><kind>A2</kind><date>20031015</date></document-id><sources><source name="EXA" created-by-npl="N"/></sources></patcit></patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR919536909" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>CISCO SYSTEMS INT SARL</last-name><address><country>CH</country></address></addressbook></applicant><applicant mxw-id="PPAR919521830" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>CISCO SYSTEMS INTERNATIONAL SARL</last-name></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR919507164" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>BJOENTEGAARD GISLE</last-name><address><country>NO</country></address></addressbook></inventor><inventor mxw-id="PPAR919534482" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>BJOENTEGAARD, GISLE</last-name></addressbook></inventor><inventor mxw-id="PPAR919026242" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>BJØNTEGAARD, Gisle</last-name><address><street>Haukeliveien 12b</street><city>N-1415 Oppeg rd</city><country>NO</country></address></addressbook></inventor></inventors><assignees><assignee mxw-id="PPAR919026244" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Cisco Systems International Sarl</last-name><iid>101255005</iid><address><street>Avenue des Uttins 5</street><city>1180 Rolle</city><country>CH</country></address></addressbook></assignee></assignees><agents><agent mxw-id="PPAR919026243" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Kazi, Ilya</last-name><suffix>et al</suffix><iid>100042044</iid><address><street>Mathys &amp; Squire LLP 120 Holborn</street><city>London EC1N 2SQ</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="NO-2004000365-W"><document-id><country>NO</country><doc-number>2004000365</doc-number><kind>W</kind><date>20041126</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2005053312-A1"><document-id><country>WO</country><doc-number>2005053312</doc-number><kind>A1</kind><date>20050609</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS549926330" load-source="docdb">AT</country><country mxw-id="DS549890526" load-source="docdb">BE</country><country mxw-id="DS549884062" load-source="docdb">BG</country><country mxw-id="DS549875346" load-source="docdb">CH</country><country mxw-id="DS549890527" load-source="docdb">CY</country><country mxw-id="DS549926331" load-source="docdb">CZ</country><country mxw-id="DS549899316" load-source="docdb">DE</country><country mxw-id="DS549890528" load-source="docdb">DK</country><country mxw-id="DS549890533" load-source="docdb">EE</country><country mxw-id="DS549793314" load-source="docdb">ES</country><country mxw-id="DS549884063" load-source="docdb">FI</country><country mxw-id="DS549875347" load-source="docdb">FR</country><country mxw-id="DS549899317" load-source="docdb">GB</country><country mxw-id="DS549890534" load-source="docdb">GR</country><country mxw-id="DS549926332" load-source="docdb">HU</country><country mxw-id="DS549875348" load-source="docdb">IE</country><country mxw-id="DS549890535" load-source="docdb">IS</country><country mxw-id="DS549884064" load-source="docdb">IT</country><country mxw-id="DS549890536" load-source="docdb">LI</country><country mxw-id="DS549807089" load-source="docdb">LU</country><country mxw-id="DS549884065" load-source="docdb">MC</country><country mxw-id="DS549793315" load-source="docdb">NL</country><country mxw-id="DS549793316" load-source="docdb">PL</country><country mxw-id="DS549884066" load-source="docdb">PT</country><country mxw-id="DS549926333" load-source="docdb">RO</country><country mxw-id="DS549793321" load-source="docdb">SE</country><country mxw-id="DS549875349" load-source="docdb">SI</country><country mxw-id="DS549791047" load-source="docdb">SK</country><country mxw-id="DS549807090" load-source="docdb">TR</country></ep-contracting-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><description mxw-id="PDES63961495" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><b><u>Field of the invention</u></b></heading><p id="p0001" num="0001">The invention is related to video compression systems, and in particular to a method for calculating interpolation pixel values when determining predictions of pixel blocks in a video picture.</p><heading id="h0002"><b><u>Background of the invention</u></b></heading><p id="p0002" num="0002">Transmission of moving pictures in real-time is employed in several applications like e.g. video conferencing, net meetings, TV broadcasting and video telephony.</p><p id="p0003" num="0003">However, representing moving pictures requires bulk information as digital video typically is described by representing each pixel in a picture with 8 bits (1 Byte). Such uncompressed video data results in large bit volume, and can not be transferred over conventional communication networks and transmission lines in real time due to limited bandwidth.</p><p id="p0004" num="0004">Thus, enabling real time video transmission requires a large extent of data compression. Data compression may, however, compromise with picture quality. Therefore, great efforts have been made to develop compression techniques allowing real time transmission of high quality video over bandwidth limited data connections.</p><p id="p0005" num="0005">In video compression systems, the main goal is to represent the video information with as tittle capacity as possible. Capacity is defined with bits, either as a constant value or as bits/time unit. In both cases, the main goal is to reduce the number of bits.<!-- EPO <DP n="2"> --></p><p id="p0006" num="0006">The most common video.coding method is described in the MPEG* and H.26* standards, all of which using block based prediction from previously encoded and decoded pictures.</p><p id="p0007" num="0007">The video data undergo four main processes before transmission, namely prediction, transformation, quantization and entropy coding.</p><p id="p0008" num="0008">The prediction process significantly reduces the amount of bits required for each picture in a video sequence to be transferred. It takes advantage of the similarity of parts of the sequence with other parts of the sequence. Since the predictor part is known to both encoder and decoder, only the difference has to be transferred. This difference typically requires much less capacity for its representation. The prediction is mainly based on picture content from previously reconstructed pictures where the location of the content is defined by motion vectors.</p><p id="p0009" num="0009">In a typical video sequence, the content of a present block M would be similar to a corresponding block in a previously decoded picture. If no changes have occurred since the previously decoded picture, the content of M would be equal to a block of the same location in the previously decoded picture. In other cases, an object in the picture may have been moved so that the content of M is more equal to a block of a different location in the previously decoded picture. Such movements are represented by motion vectors (V). As an example, a motion vector of (3;4) means that the content of M has moved 3 pixels to the left and 4 pixels upwards since the previously decoded picture.</p><p id="p0010" num="0010">A motion vector associated with a block is determined by executing a motion search. The search is carried out by consecutively comparing the content of the block with blocks in previous pictures of different spatial offsets. The offset relative to the present block<!-- EPO <DP n="3"> --> associated with the comparison block having the best match compared with the present block, is determined to be the associated motion vector.</p><p id="p0011" num="0011">In H.262, H.263, MPEG1, MPEG2 the same concept is extended so that motion vectors also can take ½ pixel values. A vector component of 5.5 then imply that the motion is midway between 5 and 6 pixels. More specifically the prediction is obtained by taking the average between the pixel representing a motion of wand the pixel representing a motion of 6. This is called a 2-tap filter due to the operation on 2 pixels to obtain prediction of a pixel in between. Motion vectors of this kind are often referred to as having fractional pixel resolution or fractional motion vectors. All filter operations can be defined by an impulse response. The operation of averaging 2 pixels can be expressed with an impulse response of (½, ½). Similarly, averaging over 4 pixels implies an impulse response of (¼,¼,¼,¼).</p><p id="p0012" num="0012"><patcit id="pcit0001" dnum="EP1353514A"><text>EP 1 353,514</text></patcit> describes sub-pixel interpolation in motion estimation and compensation. Various techniques are described. In an example, a video encoder or decoder computes a pixel value as a sub-pixel sample position using intermediate pixel values having a dynamic range (in bits) greater than the final value. The encoder or decoder may at least partially defer shifting, first stage to a second stage or skip clamping in a first or other intermediate stage of the multi-stage interpolation. A rounding control value may be used that alternates from stage to stage.</p><heading id="h0003"><b><u>Summary of the invention</u></b></heading><p id="p0013" num="0013">The present invention is set out in the appended claims. Described herein is a method in video coding or decoding for calculating interpolation ½ position pixel values and ¼ position pixel values located between integer pixel positions when determining a<!-- EPO <DP n="4"> --> prediction of a first pixel block in a video picture from a second pixel block in a previous decoded video picture with a spatial offset relative to the first pixel block according to a motion vector in a set of motion vectors, carried out by calculating the 4 position pixel values by an n-tap filter on neighboring integer pixel position values including a rounding addition value, calculating the ¼ position pixel values by averaging two neighboring<!-- EPO <DP n="5"> --> ½ position pixel values or one neighboring ½ position pixel value and one integer position pixel value followed by rounding or truncation, and sufficiently adjusting the rounding addition value for introducing a corrective shift in the ½ position pixel and ¼ position pixel values to compensate for an erroneous shift in the pixel values introduced by the rounding or truncation of the ¼ position pixel values.</p><p id="p0014" num="0014">Described herein is a method in<br/>
video coding or decoding for calculating interpolation ½ position pixel values and ¼ position pixel values located between integer pixel positions when determining a prediction of a first pixel block in a video picture from a second pixel block in a previous decoded video picture with a spatial offset relative to the first pixel block according to a motion vector in a set of motion vectors. The method comprises the steps of calculating the ½ position pixel values by an n-tap filter on neighboring integer pixel position values including a rounding addition value, calculating the ¼ position pixel values by averaging two neighboring ½ position pixel values followed by rounding, assigning a first or a second notation to respective motion vectors in the set of motion vectors, converting decimal interpolation values, which respectively have a fractional part of 0.5, to corresponding nearest lower integer values when calculating interpolation values in the second pixel block if the motion vector is assigned said first notation, and converting decimal interpolation values, which respectively have a fractional part of 0.5, to corresponding nearest upper integer values when calculating interpolation values in the second pixel block if the_motion vector is assigned said second notation.<!-- EPO <DP n="6"> --></p><p id="p0015" num="0015">The invention also relates to the use of such a method in pixel motion compensation according to the coding standard H.264/AVC.</p><heading id="h0004"><b><u>Detailed description of the present invention</u></b></heading><p id="p0016" num="0016">in the following, the present invention will be discussed by describing a preferred embodiment. However, a person skilled in the art will realize other applications and modifications within the scope of the invention as defined in the enclosed independent claims.</p><p id="p0017" num="0017">A new video compression standard has recently been developed as a joint effort between ITU and ISO/IEC. The formal titles of the common standard in the two standardization bodies are: "ITU-T Recommendation H.264" and "ISO/IEC MPEG-4(Part 10) Advanced Video Coding".. In the following this common standard will be referred to as H.264/AVC.</p><p id="p0018" num="0018">In H.264/AVC coding methods have improved both in terms of motion resolution and number of pixels for each interpolation. The methods use motion compensated prediction with up to ¼ pixel accuracy. Even 1/8 pixel accuracy is defined, but not included in any profile. The integer- and fractional pixel positions are indicated below (for simplicity, interpolations are only shown between A, E, U and Y):
<tables id="tabl0001" num="0001"><table frame="none"><tgroup cols="9" colsep="0" rowsep="0"><colspec colnum="1" colname="col1" colwidth="14mm"/><colspec colnum="2" colname="col2" colwidth="14mm"/><colspec colnum="3" colname="col3" colwidth="14mm"/><colspec colnum="4" colname="col4" colwidth="14mm"/><colspec colnum="5" colname="col5" colwidth="14mm"/><colspec colnum="6" colname="col6" colwidth="14mm"/><colspec colnum="7" colname="col7" colwidth="14mm"/><colspec colnum="8" colname="col8" colwidth="14mm"/><colspec colnum="9" colname="col9" colwidth="14mm"/><tbody><row><entry align="center">A"</entry><entry align="center">E'</entry><entry align="center">A</entry><entry align="center">b</entry><entry align="center">c</entry><entry align="center">d</entry><entry align="center">E</entry><entry align="center">A'</entry><entry align="center">E"</entry></row><row><entry align="center"/><entry align="center"/><entry align="center">f</entry><entry align="center">g</entry><entry align="center">h</entry><entry align="center">i</entry><entry align="center">j</entry><entry align="center"/><entry align="center"/></row><row><entry align="center"/><entry align="center"/><entry align="center">k</entry><entry align="center">l</entry><entry align="center">m</entry><entry align="center">n</entry><entry align="center">o</entry><entry align="center"/><entry align="center"/></row><row><entry align="center"/><entry align="center"/><entry align="center">p</entry><entry align="center">q</entry><entry align="center">r</entry><entry align="center">s</entry><entry align="center">t</entry><entry align="center"/><entry align="center"/></row><row><entry align="center"/><entry align="center"/><entry align="center">U</entry><entry align="center">v</entry><entry align="center">w</entry><entry align="center">x</entry><entry align="center">Y</entry><entry align="center"/><entry align="center"/></row></tbody></tgroup></table></tables></p><p id="p0019" num="0019">The positions A E U Y indicate integer pixel positions, and A", E', A' and E" indicates additional integer positions on the A-E line. c k m o w indicate half pixel positions. The interpolated values in these positions are obtained by using a 6-tap filter with impulse response (1/32, -5/32, 20/32, 20/32, -5/32, 1/32)<!-- EPO <DP n="7"> --> operating on integer pixel values. As an example, c is then calculated by the following expression: <maths id="math0001" num=""><math display="block"><mi>c</mi><mo>=</mo><mmultiscripts><msub><mo>/</mo><mn>32</mn></msub><mprescripts/><none/><mn>1</mn></mmultiscripts><mo>⋅</mo><mi mathvariant="italic">Aʺ</mi><mo>-</mo><mmultiscripts><msub><mo>/</mo><mn>32</mn></msub><mprescripts/><none/><mn>5</mn></mmultiscripts><mo>⋅</mo><mi mathvariant="italic">Eʹ</mi><mo>+</mo><mmultiscripts><msub><mo>/</mo><mn>32</mn></msub><mprescripts/><none/><mn>20</mn></mmultiscripts><mo>⋅</mo><mi>A</mi><mo>+</mo><mmultiscripts><msub><mo>/</mo><mn>32</mn></msub><mprescripts/><none/><mn>20</mn></mmultiscripts><mo>⋅</mo><mi>E</mi><mo>-</mo><mmultiscripts><msub><mo>/</mo><mn>32</mn></msub><mprescripts/><none/><mn>5</mn></mmultiscripts><mo>⋅</mo><mi mathvariant="italic">Aʹ</mi><mo>+</mo><mmultiscripts><msub><mo>/</mo><mn>32</mn></msub><mprescripts/><none/><mn>1</mn></mmultiscripts><mo>⋅</mo><mi mathvariant="italic">Eʺ</mi></math><img id="ib0001" file="imgb0001.tif" wi="83" he="9" img-content="math" img-format="tif"/></maths></p><p id="p0020" num="0020">Note that the dividend is chosen to be 32 to make the average operation adapted for data processing, as dividing with 32 can easily be implemented by a simple shift operation. The right shift operation leaves a truncated value in the data shift register, as the least significant bits fall out from the register. To provide rounding rather than truncation in digital data processing, a rounding addition value of 0.5 is conventionally included in the operation, which implies to add 16 before the right shift operation.</p><p id="p0021" num="0021">Alternatively, a 4-tap filter could also calculate the interpolated values using the following expression: <maths id="math0002" num=""><math display="block"><mi>c</mi><mo>=</mo><mo>-</mo><mmultiscripts><msub><mo>/</mo><mn>8</mn></msub><mprescripts/><none/><mn>1</mn></mmultiscripts><mo>⋅</mo><mi mathvariant="italic">Eʹ</mi><mo>+</mo><mmultiscripts><msub><mo>/</mo><mn>8</mn></msub><mprescripts/><none/><mn>5</mn></mmultiscripts><mo>⋅</mo><mi>A</mi><mo>+</mo><mmultiscripts><msub><mo>/</mo><mn>8</mn></msub><mprescripts/><none/><mn>5</mn></mmultiscripts><mo>⋅</mo><mi>E</mi><mo>-</mo><mmultiscripts><msub><mo>/</mo><mn>8</mn></msub><mprescripts/><none/><mn>1</mn></mmultiscripts><mo>⋅</mo><mi mathvariant="italic">Aʹ</mi></math><img id="ib0002" file="imgb0002.tif" wi="56" he="10" img-content="math" img-format="tif"/></maths></p><p id="p0022" num="0022">The filter is operated horizontally or vertically as appropriate. Further, to obtain the value for m, the filter is not operated on integer values, but on already interpolated values in the other direction. The remaining positions in the square depicted above are obtained by averaging respective integer- and half neighbor pixel positions (2 tap filter):
<tables id="tabl0002" num="0002"><table frame="none"><tgroup cols="1" colsep="0" rowsep="0"><colspec colnum="1" colname="col1" colwidth="112mm"/><tbody><row><entry>b=(A+c)/2, d=(c+E)/2, f=(A+k)/2, g=(c+k)/2, h=(c+m)/2, i=(c+o)/2, j=(E+o)/2</entry></row><row><entry>l=(k+m)/2, n=(m+o)/2, p=(U+k)/2, q=(k+w)/2, r=(m+w)/2, s=(w+o)/2, t=(Y+o)/2</entry></row><row><entry/></row><row><entry>v=(U+w)/2, x=(w+Y)/2</entry></row></tbody></tgroup></table></tables></p><p id="p0023" num="0023">All calculations of interpolations may result in decimal values, i.e. values with fractional parts. Normally, if the fractional parts were evenly distributed, conversion to the nearest integer would not introduce overall offset<!-- EPO <DP n="8"> --> errors. However, in many cases, as when applying a 2 tap filter for calculating the ¼ pixel positions, all the decimal values would include a fractional part of 0.5. When applying a normal rounding procedure on these decimal values, all would be rounded up. Referring to the pixel denotations defined above, if A=100 and c=101, then b=101.</p><p id="p0024" num="0024">As already indicated, in H.264/AVC, the ¼ position pixels are obtained as the average of two positions, which may be integer position pixel or ½ position pixel. As the values of these pixels are integers, the exact calculated values are either integer or having a decimal contribution of 0.5 The 0.5 value will then be rounded up or truncated resulting in a positive or negative rounding offset of calculated prediction. The rounding offset introduces a prediction error, which represents an expected add-on to the difference between a real picture and the associated prediction. This expected add-on results in a noticeable loss of coding gain as larger differences require transmission of larger bit amounts. Similarly, consequent truncation would lead to a similar negative offset.</p><p id="p0025" num="0025">According to the present invention, the rounding offset described above is attenuated by properly shifting up or down (dependent on whether the ¼ position pixels were rounded up or truncated) the result of the calculation of the ½ position pixel values.</p><p id="p0026" num="0026">In one embodiment of the present invention, this is accomplished by introducing a slight negative or positive shift in the calculation of ½ position pixels to compensate for the above-discussed positive or negative rounding offset introduced when rounding or truncating the average of two ½ position pixel values (or one integer position pixel and one ½ position pixel value).<!-- EPO <DP n="9"> --> Consequently, the equation for ½ position pixel value calculation must be modified.</p><p id="p0027" num="0027">According to prior art, the ¼ position pixel values are usually rounded up. This implies a positive rounding offset, which is assumed to be the case in the following example</p><p id="p0028" num="0028">The modification of the equation for ½ pixel value calculation may be implemented in various ways, but experience has shown that this compensation could be introduced by reducing the rounding addition value added to the equation above. This will lower the overall values of the ½ position pixels, so that a proper reduction of the rounding addition value will balance the rounding error of the ¼ pixel position values, as the ¼ position pixel values are calculate from the lowered ½ position pixel values. Experiments have shown that a proper reduction of the rounding addition value will be to lower the value from 16/32 to 6/32. In the case of a 4-tap filter, the rounding addition value is lowered from 4/8 to 1/8.</p><p id="p0029" num="0029">In another embodiment of the present invention the rounding offset described above is attenuated by alternately converting to the upper and lower nearest integer value for the decimal values having a fractional part of 0.5.</p><p id="p0030" num="0030">As an example, a result of the present invention will be that the average between 100 and 101 in some cases will be converted to 100 and in other cases to 101, depended on what is defined for the certain interpolated pixel position.</p><p id="p0031" num="0031">The definition of which interpolated pixel positions to be converted upwards and which to be converted downwards (from now on referred to as 0.5-conversion) can be<!-- EPO <DP n="10"> --> implemented in different ways. However, it is to prefer that the same 0.5-conversion for every pixel in a block for the same motion vector is used. Experience has shown that alternating 0.5-conversion internally within a block introduces high frequency content, which typically leads to larger bit usage.</p><p id="p0032" num="0032">Thus, in a preferred embodiment of the present invention, one 0.5-conversion is assigned to each motion vector value, but the 0.5-conversion may vary between adjacent motion vectors. In this way, biased rounding causing an offset in the pixel values is avoided.</p><p id="p0033" num="0033">To further illustrate the preferred embodiment, consider that a motion search is carried out for a certain block of pixels. In a motion search, the block is consecutively compared with the content of blocks in the previous picture of different spatial offsets relative to the present block. These offsets are associated with respective motion vectors. E.g. a motion vector of (0, ¼) corresponds to comparing the present block with the block in the previous picture shifted ¼ position in the vertical direction. All mean values with a fractional of 0.5 in the shifted block will then either be converted upwards or downwards depended on what kind of 0.5-conversion the motion vector in question is assigned. Thus, the type of 0.5-conversion of the prediction of a block is in the preferred embodiment depended on the position relative to the block of a previous picture, from which the prediction is taken, and the 0.5-conversion assignment of the corresponding motion vector.</p><p id="p0034" num="0034">Moreover, it is considered to be preferable that there is a high degree of shifting in the 0.5-conversion between nearby motion vectors. One reason for this is that a typical encoder would do final vector search in a small local area of vector positions. During this final search it is preferable that the tested vector positions<!-- EPO <DP n="11"> --> represent a reasonable mixture of converting 0.5 fractional values upwards and downwards.</p><p id="p0035" num="0035">The rules for assigning 0.5-conversions may vary. The simplest way is to have a fixed pattern of the distribution of 0.5-conversion types in the motion vector plane. This is illustrated below. Here, each ¼ pixel vector position is assigned one of the notations "up" and "down", which defines whether decimal values with a fraction of 0.5 is to be converted upward or downward to the nearest integer. Capital letters indicate integer positions, while small letters indicate ½ pixel positions. In this case, ½ pixel positions do not have any notation since the effect is considered to be insignificant.
<tables id="tabl0003" num="0003"><table frame="none"><tgroup cols="5" colsep="0" rowsep="0"><colspec colnum="1" colname="col1" colwidth="14mm"/><colspec colnum="2" colname="col2" colwidth="14mm"/><colspec colnum="3" colname="col3" colwidth="14mm"/><colspec colnum="4" colname="col4" colwidth="14mm"/><colspec colnum="5" colname="col5" colwidth="14mm"/><tbody><row><entry>A</entry><entry align="center">down</entry><entry align="center">c</entry><entry align="center">down</entry><entry align="right">E</entry></row><row><entry>down</entry><entry align="center">up</entry><entry align="center">down</entry><entry align="center">up</entry><entry align="right">down</entry></row><row><entry>k</entry><entry align="center">down</entry><entry align="center">m</entry><entry align="center">down</entry><entry align="right">o</entry></row><row><entry>down</entry><entry align="center">up</entry><entry align="center">down</entry><entry align="center">up</entry><entry align="right">down</entry></row><row><entry>U</entry><entry align="center">down</entry><entry align="center">w</entry><entry align="center">down</entry><entry align="right">Y</entry></row></tbody></tgroup></table></tables></p><p id="p0036" num="0036">Note that the illustrated pattern is only an example, other pattern may be useful as well.</p><p id="p0037" num="0037">An alternative to a fixed pattern of 0.5-conversions is to have a random or pseudo random definition of the assignment of 0.5-conversions to the different motion vectors. This can be a process that is defined in a way so that both encoder and decoder is able to deduce which pixel position to be converted up and which to be converted down. This process may depend on picture data, which is known to both encoder and decoder. Such data can be (but are not limited to) block numbering, motion vector values, and coding mode. The data may be input to a procedure determining a pseudo random pattern of alternating 0.5-conversion assignments over the motion vector plane.<!-- EPO <DP n="12"> --></p><p id="p0038" num="0038">Still another alternative to fixed pattern is a none-predefined pattern, which is communicated from the encoder to the decoder at the time of transmission. In this case, it is preferable that the amount of data dedicated for this purpose is limited so that it doesn't compromise with coding efficiency.</p><p id="p0039" num="0039">Note that there are many possible values of the fractional part of the interpolation values, as for instance when using the 6-tap filter described above for the ½ pixel positions, the fractional part of 0.5 occurs seldom and it normally does not make much difference which 0.5-conversion is applied. On the other hand, when averaging between 2 pixels, which is the case for 1-4 pixel positions, the fractional part of 0.5 could typically occur in about half of the events. The difference between doing a consequent 0.5-conversion is therefore much larger, and present invention is therefore most useful when calculating ¼ pixel positions.</p><p id="p0040" num="0040">The main advantage of the invention is that it removes the offset introduced by biased rounding, and thereby increase the coding efficiency.</p></description><claims mxw-id="PCLM56987225" lang="DE" load-source="patent-office"><!-- EPO <DP n="15"> --><claim id="c-de-01-0001" num="0001"><claim-text>Verfahren bei Video-Codierung oder Decodierung zum Berechnen interpolierter 1-2-Positionspixelwerte und ¼-Positionspixelwerte zwischen ganzzahligen Pixelpositionen beim Bestimmen einer Vorhersage eines ersten Pixelblocks in einem Videofilm gegenüber einem zweiten Pixelblock in einem früher decodierten Videofilm mit einem räumlichen Versatz bezogen auf den ersten Pixelblock gemäß eines Bewegungsvektors in einem Satz von Bewegungsvektoren, umfassend folgende Schritte:
<claim-text>Berechnen der ½-Positionspixelwerte unter Einsatz eines 6-Tap bzw. 4-Tap Filters auf benachbarten ganzzahligen Pixelpositionswerten einschließlich eines Rundungsadditionswerts von 16/32 im Falle eines 6-Tap Filters bzw. eines Rundungsadditionswerts von 4/8 im Falle eines 4-Tap Filters, und</claim-text>
<claim-text>Berechnen der ¼-Positionspixelwerte durch Mittelung von zwei benachbarten ½-Positionspixelwerten oder eines benachbarten ½-Positionspixelwerts und eines ganzzahligen Positionspixelwerts mit anschließender Rundung oder Kürzung, und</claim-text>
<claim-text>Angleichen des Rundungsadditionswerts zur Einbringung eine korrektiven Verschiebung in die ½-Positions- und ¼-Positionspixelwerte zum Ausgleich einer fehlerhaften Verschiebung in den Pixelwerten aufgrund der Rundung oder Kürzung der ¼-Positionspixelwerte, indem der Rundungsadditionswert auf einen unter 16/32 liegenden Wert im Falle des 6-Tap Filters bzw. auf einen unter 4/8 liegenden Wert im Falle des 4-Tap Filters reduziert wird.</claim-text></claim-text></claim><claim id="c-de-01-0002" num="0002"><claim-text>Verfahren nach Anspruch 1, wobei der Rundungsadditionswert bei Einsatz des 6-Tap Filters von 16/32<!-- EPO <DP n="16"> --> auf 6/32 reduziert wird und bei Einsatz des 4-Tap Filters von 4/8 auf 1/8 reduziert wird.</claim-text></claim><claim id="c-de-01-0003" num="0003"><claim-text>Verfahren nach Anspruch 1 oder 2, wobei das 6-Tap Filter verwendet wird und eine Impulsantwort von (1/32, -5/32, 20/32, -5/32, 1/32) hat und der Rundungsadditionswert von 16/32 auf 6/32 reduziert wird.</claim-text></claim><claim id="c-de-01-0004" num="0004"><claim-text>Verfahren nach Anspruch 1 oder 2, wobei das 4-Tap Filter verwendet wird und eine Impulsantwort von (-1/8, 5/8, 5/8, -1/8) hat und der Rundungsadditionswert von 4/8 auf 1/8 reduziert wird.</claim-text></claim><claim id="c-de-01-0005" num="0005"><claim-text>Verfahren nach einem der Ansprüche 1 bis 4, wobei die Videofilme gemäß des Codierstandards H. 264/AVC codiert werden.</claim-text></claim><claim id="c-de-01-0006" num="0006"><claim-text>Einsatz eines Verfahrens nach einem der vorhergehenden Ansprüche bei einem Pixel Bewegungsausgleich nach dem Codierstandard H. 264/AVC.</claim-text></claim></claims><claims mxw-id="PCLM56987226" lang="EN" load-source="patent-office"><!-- EPO <DP n="13"> --><claim id="c-en-01-0001" num="0001"><claim-text>A method in video coding or decoding for calculating interpolation ½ position pixel values and ¼ position pixel values located between integer pixel positions when determining a prediction of a first pixel block in a video picture from a second pixel block in a previous decoded video picture with a spatial offset relative to the first pixel block according to a motion vector in a set of motion vectors, comprising the steps of<br/>
calculating the ½ position pixel values using a 6-tap or 4-tap filter on neighboring integer pixel position values including a rounding addition value of 16/32 where the filter is a 6-tap filter or a rounding addition value of 4/8 where the filter is a 4-tap filter, and<br/>
calculating the ¼ position pixel values by averaging two neighboring ½ position pixel values or one neighboring ½ position pixel value and one integer position pixel value followed by rounding or truncation, and<br/>
adjusting the rounding addition value to introduce a corrective shift in the ½ position pixel and ¼ position pixel values to compensate for an erroneous shift in the pixel values introduced by the rounding or truncation of the ¼ position pixel values by reducing the rounding addition value to a value less than 16/32 where the 6-tap filter is used or reducing the rounding addition value to a value less than 4/8 where the 4-tap filter is used.<!-- EPO <DP n="14"> --></claim-text></claim><claim id="c-en-01-0002" num="0002"><claim-text>A method according to claim 1, wherein the rounding addition value is reduced from 16/32 to 6/32 if the six-tap filter is used and the rounding addition value is reduced from 4/8 to 1/8 if the four-tap filter is used.</claim-text></claim><claim id="c-en-01-0003" num="0003"><claim-text>A method according to claim 1 or 2, wherein the 6-tap filter is used and has an impulse response of (1/32, -5/32, 20/32,20/32,-5/32, 1/32) and the rounding addition value is reduced from 16/32 to 6/32.</claim-text></claim><claim id="c-en-01-0004" num="0004"><claim-text>A method according to claim 1 or 2, wherein the 4-tap filter is used and has an impulse response of (-1/8, 5/8, 5/8,-1/8) and the rounding addition value is reduced from 4/8 to 1/8.</claim-text></claim><claim id="c-en-01-0005" num="0005"><claim-text>A method according to any one of the claims 1 to 4, wherein the video pictures are encoded according to the coding standard H. 264/AVC.</claim-text></claim><claim id="c-en-01-0006" num="0006"><claim-text>Use of a method according to one of the preceding claims in pixel motion compensation according to the coding standard H. 264/AVC.</claim-text></claim></claims><claims mxw-id="PCLM56987227" lang="FR" load-source="patent-office"><!-- EPO <DP n="17"> --><claim id="c-fr-01-0001" num="0001"><claim-text>Procédé de codage ou de décodage vidéo permettant de calculer des valeurs de demi-pixels de position et des valeurs de quarts de pixels de position par interpolation se trouvant entre les positions de pixels à nombre entier lors de la détermination d'une prédiction d'un premier bloc de pixels dans une image vidéo à partir d'un second bloc de pixels dans une image vidéo précédente décodée avec un décalage spatial par rapport au premier bloc de pixels en fonction d'un vecteur de mouvement dans un ensemble de vecteurs de mouvement, comportant les étapes consistant à<br/>
calculer les valeurs de demi-pixels de position en utilisant un filtre de dimension 6 ou de dimension 4 sur des valeurs de pixels de position voisins à nombre entier comprenant une valeur d'addition d'arrondi de 16/32 quand le filtre est un filtre de dimension 6 ou une valeur d'addition d'arrondi de 4/8 quand le filtre est un filtre de dimension 4, et<br/>
calculer les valeurs de quarts de pixels de position en faisant la moyenne entre deux valeurs de demi-pixels de position voisins et une valeur de demi-pixels de position voisins et une valeur de pixels de position à nombre entier, moyenne suivie d'un arrondi ou d'une troncature, et<br/>
ajuster la valeur d'addition d'arrondi pour introduire un décalage correctif des valeurs de demi-pixels de position et de quarts de pixels de position à des fins de compensation en cas de décalage erroné au niveau des valeurs de pixels introduites par l'arrondi ou la troncature des valeurs de quarts de pixels de position en réduisant la valeur d'addition d'arrondi à une valeur inférieure à 16/32 quand le filtre de dimension 6 est utilisé ou pour réduire la valeur<!-- EPO <DP n="18"> --> d'addition d'arrondi à une valeur inférieure à 4/8 quand le filtre de dimension 4 est utilisé</claim-text></claim><claim id="c-fr-01-0002" num="0002"><claim-text>Procédé selon la revendication 1, dans lequel la valeur d'addition d'arrondi est réduite de 16/32 à 6/32 si le filtre de dimension 6 est utilisé et la valeur d'addition d'arrondi est réduite de 4/8 à 1/8 si le filtre de dimension 4 est utilisé.</claim-text></claim><claim id="c-fr-01-0003" num="0003"><claim-text>Procédé selon la revendication 1 ou la revendication 2, dans lequel le filtre de dimension 6 est utilisé et a une réponse impulsionnelle de (1/32, -5/32, 20/32, 20/32, -5/32, 1/32) et la valeur d'addition d'arrondi est réduite de 16/32 à 6/32.</claim-text></claim><claim id="c-fr-01-0004" num="0004"><claim-text>Procédé selon la revendication 1 ou 2, dans lequel le filtre de dimension 4 est utilisé et a une réponse impulsionnelle de (-1/8, 5/8, 5/8, -1/8) et la valeur d'addition d'arrondi est réduite de 4/8 à 1/8.</claim-text></claim><claim id="c-fr-01-0005" num="0005"><claim-text>Procédé selon l'une quelconque des revendications 1 à 4, dans lequel les images vidéo sont codées en fonction de la norme de codage H.264/AVC.</claim-text></claim><claim id="c-fr-01-0006" num="0006"><claim-text>Utilisation d'un procédé selon l'une quelconque des revendications précédentes, à des fins de compensation de mouvement de pixels en fonction de la norme de codage H.264/AVC.</claim-text></claim></claims><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
