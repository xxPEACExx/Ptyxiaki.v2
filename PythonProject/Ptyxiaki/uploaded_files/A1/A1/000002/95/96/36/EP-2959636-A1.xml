<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2959636-A1" country="EP" doc-number="2959636" kind="A1" date="20151230" family-id="50424696" file-reference-id="252649" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="160452540" ucid="EP-2959636-A1"><document-id><country>EP</country><doc-number>2959636</doc-number><kind>A1</kind><date>20151230</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-14714814-A" is-representative="NO"><document-id mxw-id="PAPP193868048" load-source="patent-office" format="original"><country>EP</country><doc-number>14714814.2</doc-number><date>20140225</date><lang>EN</lang></document-id><document-id mxw-id="PAPP193868049" load-source="docdb" format="epo"><country>EP</country><doc-number>14714814</doc-number><kind>A</kind><date>20140225</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC162035682" ucid="US-201313775994-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201313775994</doc-number><kind>A</kind><date>20130225</date></document-id></priority-claim><priority-claim mxw-id="PPC162027441" ucid="US-201313776012-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201313776012</doc-number><kind>A</kind><date>20130225</date></document-id></priority-claim><priority-claim mxw-id="PPC162031088" ucid="US-2014018421-W" linkage-type="W" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>2014018421</doc-number><kind>W</kind><date>20140225</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1988523086" load-source="docdb">H04L  12/24        20060101AFI20140910BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1987769811" load-source="docdb" scheme="CPC">H04L  45/64        20130101 LI20140602BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987796171" load-source="docdb" scheme="CPC">H04L  41/0803      20130101 FI20140929BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT165549086" lang="DE" load-source="patent-office">STATISCHE ÜBERSETZUNG VON NETZWERKWEITERLEITUNGSEBENENMODELLEN IN EINE ZIELIMPLEMENTIERUNG IN DER HARDWARE-ABSTRAKTIONSSCHICHT</invention-title><invention-title mxw-id="PT165549087" lang="EN" load-source="patent-office">STATIC TRANSLATION OF NETWORK FORWARDING PLANE MODELS INTO TARGET IMPLEMENTATION IN THE HARDWARE ABSTRACTION LAYER</invention-title><invention-title mxw-id="PT165549088" lang="FR" load-source="patent-office">TRADUCTION STATIQUE DE MODÈLES DE PLAN D'ACHEMINEMENT DE RÉSEAU EN UNE IMPLÉMENTATION CIBLE DANS LA COUCHE D'ABSTRACTION MATÉRIELLE</invention-title><citations><non-patent-citations><nplcit><text>See references of WO 2014131044A1</text><sources><source mxw-id="PNPL67567841" load-source="docdb" name="SEA"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR1103308594" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>GOOGLE INC</last-name><address><country>US</country></address></addressbook></applicant><applicant mxw-id="PPAR1103312735" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>GOOGLE INC.</last-name></addressbook></applicant><applicant mxw-id="PPAR1101652078" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Google, Inc.</last-name><iid>100132113</iid><address><street>1600 Amphitheatre Parkway</street><city>Mountain View, CA 94043</city><country>US</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR1103330782" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>YADAV NAVINDRA</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103308032" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>YADAV, NAVINDRA</last-name></addressbook></inventor><inventor mxw-id="PPAR1101639433" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>YADAV, NAVINDRA</last-name><address><street>1600 Amphitheatre Parkway</street><city>Mountain View, California 94043</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103320238" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>COHN DANIEL TODD</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103335520" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>COHN, DANIEL TODD</last-name></addressbook></inventor><inventor mxw-id="PPAR1101650702" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>COHN, DANIEL TODD</last-name><address><street>1600 Amphitheatre Parkway</street><city>Mountain View, California 94043</city><country>US</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR1101649846" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Boult Wade Tennant</last-name><iid>101370347</iid><address><street>Verulam Gardens 70 Gray's Inn Road</street><city>London WC1X 8BT</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="US-2014018421-W"><document-id><country>US</country><doc-number>2014018421</doc-number><kind>W</kind><date>20140225</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2014131044-A1"><document-id><country>WO</country><doc-number>2014131044</doc-number><kind>A1</kind><date>20140828</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS660788783" load-source="docdb">AL</country><country mxw-id="DS660725069" load-source="docdb">AT</country><country mxw-id="DS660625612" load-source="docdb">BE</country><country mxw-id="DS660624159" load-source="docdb">BG</country><country mxw-id="DS660703266" load-source="docdb">CH</country><country mxw-id="DS660625613" load-source="docdb">CY</country><country mxw-id="DS660624953" load-source="docdb">CZ</country><country mxw-id="DS660788785" load-source="docdb">DE</country><country mxw-id="DS660625614" load-source="docdb">DK</country><country mxw-id="DS660625619" load-source="docdb">EE</country><country mxw-id="DS660709603" load-source="docdb">ES</country><country mxw-id="DS660624160" load-source="docdb">FI</country><country mxw-id="DS660624161" load-source="docdb">FR</country><country mxw-id="DS660788786" load-source="docdb">GB</country><country mxw-id="DS660625620" load-source="docdb">GR</country><country mxw-id="DS660788787" load-source="docdb">HR</country><country mxw-id="DS660624954" load-source="docdb">HU</country><country mxw-id="DS660703271" load-source="docdb">IE</country><country mxw-id="DS660625621" load-source="docdb">IS</country><country mxw-id="DS660624162" load-source="docdb">IT</country><country mxw-id="DS660625622" load-source="docdb">LI</country><country mxw-id="DS660624163" load-source="docdb">LT</country><country mxw-id="DS660725070" load-source="docdb">LU</country><country mxw-id="DS660624164" load-source="docdb">LV</country><country mxw-id="DS660624165" load-source="docdb">MC</country><country mxw-id="DS660725075" load-source="docdb">MK</country><country mxw-id="DS660725076" load-source="docdb">MT</country><country mxw-id="DS660709604" load-source="docdb">NL</country><country mxw-id="DS660703370" load-source="docdb">NO</country><country mxw-id="DS660709605" load-source="docdb">PL</country><country mxw-id="DS660725077" load-source="docdb">PT</country><country mxw-id="DS660703272" load-source="docdb">RO</country><country mxw-id="DS660725078" load-source="docdb">RS</country><country mxw-id="DS660709606" load-source="docdb">SE</country><country mxw-id="DS660624963" load-source="docdb">SI</country><country mxw-id="DS660703495" load-source="docdb">SK</country><country mxw-id="DS660703496" load-source="docdb">SM</country><country mxw-id="DS660624166" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><abstract mxw-id="PA139071699" ref-ucid="WO-2014131044-A1" lang="EN" load-source="patent-office"><p num="0000">A routing controller in a communication network may be responsible for generating a device model that defines intended forwarding behavior of the network. The device model may be generated using a target-independent universal language of network primitives. The controller may send the device model to a target device. The device controller may include one or more known identifiers associated with one or more portions of the model. The target device may know the mapping between the known identifiers and the capabilities of the target device. Upon receiving the device model from the controller, the target device may retrieve the known mapping to statically translate the device model to implementation. The static translation of the device model provides reusability of the previously determined mappings. The target device is not required to have a translator for dynamically translating the device model each time that the device model is received from the controller. An embodiment shows a Hardware Abstraction Layer (HAL) for OpenFlow.</p></abstract><abstract mxw-id="PA139539348" ref-ucid="WO-2014131044-A1" lang="EN" source="national office" load-source="docdb"><p>A routing controller in a communication network may be responsible for generating a device model that defines intended forwarding behavior of the network. The device model may be generated using a target-independent universal language of network primitives. The controller may send the device model to a target device. The device controller may include one or more known identifiers associated with one or more portions of the model. The target device may know the mapping between the known identifiers and the capabilities of the target device. Upon receiving the device model from the controller, the target device may retrieve the known mapping to statically translate the device model to implementation. The static translation of the device model provides reusability of the previously determined mappings. The target device is not required to have a translator for dynamically translating the device model each time that the device model is received from the controller. An embodiment shows a Hardware Abstraction Layer (HAL) for OpenFlow.</p></abstract><abstract mxw-id="PA139071700" ref-ucid="WO-2014131044-A1" lang="FR" load-source="patent-office"><p num="0000">Un organe de commande de routage d'un réseau de communication est chargé de produire un modèle de dispositif qui définit le comportement d'acheminement prévu du réseau. Le modèle de dispositif peut être produit au moyen d'un langage universel de primitives de réseau indépendant de la cible. L'organe de commande envoie le modèle de dispositif à un dispositif cible. L'organe de commande comprend un ou plusieurs identifiant(s) connu(s), associé(s) à une ou plusieurs partie(s) du modèle. Le dispositif cible peut connaître le mappage entre les identifiants connus et les capacités du dispositif cible. A la réception du modèle de dispositif provenant de l'organe de commande, le dispositif cible peut récupérer le mappage connu afin de traduire statiquement le modèle de dispositif en une implémentation. La traduction statique du modèle de dispositif permet de réutiliser des mappages déterminés précédemment. Le dispositif cible n'a pas besoin d'être équipé d'un traducteur pour traduire dynamiquement le modèle de dispositif à chaque fois que celui-ci est reçu en provenance de l'organe de commande. Un mode de réalisation présente une couche d'abstraction matérielle (HAL) pour OpenFlow.</p></abstract><abstract mxw-id="PA139539349" ref-ucid="WO-2014131044-A1" lang="FR" source="national office" load-source="docdb"><p>Un organe de commande de routage d'un réseau de communication est chargé de produire un modèle de dispositif qui définit le comportement d'acheminement prévu du réseau. Le modèle de dispositif peut être produit au moyen d'un langage universel de primitives de réseau indépendant de la cible. L'organe de commande envoie le modèle de dispositif à un dispositif cible. L'organe de commande comprend un ou plusieurs identifiant(s) connu(s), associé(s) à une ou plusieurs partie(s) du modèle. Le dispositif cible peut connaître le mappage entre les identifiants connus et les capacités du dispositif cible. A la réception du modèle de dispositif provenant de l'organe de commande, le dispositif cible peut récupérer le mappage connu afin de traduire statiquement le modèle de dispositif en une implémentation. La traduction statique du modèle de dispositif permet de réutiliser des mappages déterminés précédemment. Le dispositif cible n'a pas besoin d'être équipé d'un traducteur pour traduire dynamiquement le modèle de dispositif à chaque fois que celui-ci est reçu en provenance de l'organe de commande. Un mode de réalisation présente une couche d'abstraction matérielle (HAL) pour OpenFlow.</p></abstract><description mxw-id="PDES78476185" ref-ucid="WO-2014131044-A1" lang="EN" load-source="patent-office"><!-- EPO <DP n="3"/>--><p id="p0001" num="0001"> STATIC TRANSLATION OF NETWORK FORWARDING PLANE MODELS INTO TARGET IMPLEMENTATION IN THE HARDWARE ABSTRACTION LAYER </p><p id="p0002" num="0002">RELATED APPLICATIONS </p><p id="p0003" num="0003">This application claims priority to and the benefit of U.S. Patent Application No. 13/776,012, entitled "STATIC TRANSLATION OF NETWORK FORWARDING PLANE MODELS INTO TARGET IMPLEMENTATION IN THE HARDWARE ABSTRACTION LAYER," filed February 25, 2013, as well as priority to and the benefit of U.S. Patent Application No. 13/775,994, entitled "TRANSLATING NETWORK FORWARDING PLANE MODELS INTO TARGET IMPLEMENTATION USING NETWORK PRIMITIVES," filed February 25, 2013, the entirety of both of which are hereby </p><p id="p0004" num="0004">incorporated by reference. </p><p id="p0005" num="0005">Background </p><p id="p0006" num="0006">[0001] In communication networks, such as telephone networks and data networks, including the Internet, information may be sent along a path from a source device to a destination device. The source device and the destination device may be, for example personal computers, servers such as email servers, web servers, or file servers, or other electronic devices capable of sending and/or receiving information via the network. </p><p id="p0007" num="0007">[0002] The information may pass through one or more forwarding devices, such as routers or other electronic devices having the ability to forward the information to another device. The intermediate devices may receive the information and use functions, algorithms, data structures, and rules to determine where and how to forward the information so that the information moves towards its intended destination. These functions, algorithms, data structures, and rules form the "forwarding plane" of the network. The functions, algorithms, data structures, and rules of the forwarding plane may be implemented and/or enforced by one or more forwarding devices in the network. </p><p id="p0008" num="0008">[0003] For example, a forwarding device may receive a packet on an inbound interface, look up the destination address of the packet, and apply a rule which causes the forwarding device to look up the destination address in a particular routing table. The routing table may provide 
<!-- EPO <DP n="4"/>-->
 a list of "next destinations" which represent a device to which the packet should be sent. The next destination for a particular packet might be, for example, the final destination device or another intermediate forwarding device. The next destination may be identified by an address stored in the routing table. The next destinations stored in the routing table may be indexed by a final destination of the packet - thus, by looking up the final destination of the packet (e.g., as identified by a header of the packet), the next destination can be retrieved from the routing table. The forwarding device may then forward the packet on an outbound interface to the identified next destination. </p><p id="p0009" num="0009">[0004] Certain aspects of the forwarding plane can affect the efficiency of the network. These aspects include the specific rules, algorithms, data structures, and functions employed, the manner in which the forwarding plane is implemented, and the location at which the forwarding plane is implemented and/or enforced. </p><p id="p0010" num="0010">Summary </p><p id="p0011" num="0011">[0005] A routing controller in a communication network may be responsible for generating a device model for a target device using a universal language of network primitives. The target device may have forwarding capabilities. Exemplary embodiments allow the target device to determine how to forward the incoming data packets based on the intended behavior of the network. The target device may translate the desired behavior described using the universal language into implementation based on the capabilities of the target device. The translation may generate a mapping between the desired behaviors and the implementations thereof. </p><p id="p0012" num="0012">[0006] The universal language is a target-independent description that is used to define the intent of the network, i.e. the intended forwarding behavior. The universal language may describe a requested capability (e.g., "find the longest prefix match of a subnet mask in a routing table") without specifying how to implement the requested capability (e.g., without specifying a particular algorithm for performing a longest prefix match). The universal language may support multiple implementations of the specified functionality (e.g., a first algorithm for finding a longest prefix match, and a second algorithm for finding a longest prefix match). </p><p id="p0013" num="0013">[0007] According to exemplary embodiments, the device model may be generated using a target-independent universal language of network primitives. Network primitives are building blocks of the device model. The network primitives can be grouped to form submodels to 
<!-- EPO <DP n="5"/>-->
 create modularity within the device model. The network primitives and the submodels can be stored in libraries. The controller may send the device model to a target device. Upon receiving the device model from the controller, the target device may translate the device model to implementation </p><p id="p0014" num="0014">[0008] According to exemplary embodiments, the device model may include one or more known identifiers associated with one or more portions of the model. The mapping between the known identifiers and the capabilities of a target device is known. The known mappings may be stored, for example, in a database of known mappings. The target device, upon receiving the device model with known identifiers from the controller, may retrieve and use the mapping to statically translate the device model to implementation. Absent a known mapping, the translator of the target device would have to dynamically translate intents described in the device model to implementation. Accordingly, the device model provides reusability of the previously determined mappings and does not require the translator to dynamically translate the device model each time the device model is received from the controller. </p><p id="p0015" num="0015">[0009] In some embodiments, a non-transitory electronic device readable storage medium is provided. The storage medium further holds instructions that, when executed, cause one or more processors to receive a device model described in a target-independent format. The device model includes one or more network primitives. The device model describes an intended forwarding behavior for a target device. The storage medium also holds instructions that, when executed, cause one or more processors to translate the device model to the one or more capabilities of the target device, the target device having a forwarding capability. The translating includes mapping the one or more network primitives to the one or more capabilities of the target device. The storage medium further holds instructions that, when executed, cause one or more processors to configure the target device based on the translating and receive one or more input packets. The storage medium also holds instructions that, when executed, cause one or more processors to forward one or more input packets to one or more elements of the network based on the configuring. </p><p id="p0016" num="0016">[0010] According to various embodiments, a non-transitory electronic device readable storage medium is provided. The storage medium further holds instructions that, when executed, cause one or more processors to generate a device model in a target-independent format. The device model includes one or more network primitives. The device model 
<!-- EPO <DP n="6"/>-->
 describes an intended forwarding behavior for a target device. The storage medium also further holds instructions that, when executed, cause one or more processors to send the device model to the target device in the network for implementation, the target device having a forwarding capability. </p><p id="p0017" num="0017">[0011] In some embodiments, a system is provided. The system comprises a routing controller, a target device and a storage. The routing controller generates a device model described in a target-independent format. The device model includes one or more network primitives. The target device receives the device model. The device model describes an intended forwarding behavior for the target device. The target device has a forwarding or switching capability. The storage stores a plurality of network primitives. The device model is generated using the one or more network primitives retrieved from the storage. The target device is configured to map the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device. </p><p id="p0018" num="0018">[0012] In some embodiments, a non-transitory electronic device readable storage medium is provided. The storage medium holds instructions that, when executed, cause one or more processors to receive a device model described in a target-independent format. The device model describes an intended forwarding behavior for a target device. The device model includes one or more known identifiers associated with one or more portions of the device model. The storage medium further holds instructions that, when executed, cause one or more processors to retrieve a mapping that maps the one or more known identifiers of the device model to implementation of one or more capabilities of a target device having a forwarding or switching capability. The storage medium further holds instructions that, when executed, cause one or more processors to configure the target device by statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping. </p><p id="p0019" num="0019">[0013] According to various embodiments, a method is provided. The method entails receiving a device model described in a target-independent format. The device model describes an intended forwarding behavior for a target device. The method further entails retrieving a mapping that maps one or more elements of the device model to implementation of one or more capabilities of the target device having a forwarding or switching capability. The method also involves configuring the target device by statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more 
<!-- EPO <DP n="7"/>-->
 capabilities of the target device using the retrieved mapping. The method further involves receiving one or more input packets and forwarding the one or more input packets to one or more elements of the network based on the configuring. </p><p id="p0020" num="0020">[0014] In some embodiments, a system is provided. The system comprises a routing controller, a target device and a storage. The routing controller generates a device model described in a target-independent format. The target device receives the device model. The device model describes an intended forwarding behavior for the target device. The target device has a forwarding or switching capability. The storage stores one or more mappings that map one or more portions of the device model to implementation of one or more capabilities of the target device. The target device is configured to retrieve one or more mappings from the storage for statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping. </p><p id="p0021" num="0021">Brief Description of the Drawings </p><p id="p0022" num="0022">[0015] Figure 1 depicts an exemplary network 100 including a routing controller and a target device according to an exemplary embodiment. </p><p id="p0023" num="0023">[0016] Figure 2 depicts an exemplary manner how elements of the exemplary network 100 interact according to an exemplary embodiment. </p><p id="p0024" num="0024">[0017] Figure 3 depicts an exemplary device model generated by a controller according to an exemplary embodiment. </p><p id="p0025" num="0025">[0018] Figure 4 is a flowchart describing exemplary steps performed by a controller in accordance with an exemplary embodiment. </p><p id="p0026" num="0026">[0019] Figure 5 is a flowchart describing exemplary steps performed by a target device in accordance with an exemplary embodiment. </p><p id="p0027" num="0027">[0020] Figure 6 depicts an exemplary electronic device suitable for use with exemplary embodiments described herein. </p><p id="p0028" num="0028">[0021] Figure 7 depicts an exemplary network implementation of processing performed according to an exemplary embodiment. 
<!-- EPO <DP n="8"/>-->
 Detailed Description </p><p id="p0029" num="0029">[0022] As described in more detail below, exemplary embodiments allow abstracting of the forwarding plane of a software defined network. Conventionally, the abstraction of setting forwarding table entries loses too much information about the intents of the application developer. Thus, conventional techniques cannot leverage all the features of the forwarding device to deliver scalable and efficient end-to-end implementations. The present application aims at mapping high-level forwarding intents to low-level features of the forwarding device. </p><p id="p0030" num="0030">[0023] A routing controller in the network may be responsible for generating a device model using a universal language of network primitives. The device model may define the intent of the network, i.e. the intended forwarding behavior. The device model may include one or more identifiers associated with one or more portions of the model. </p><p id="p0031" num="0031">[0024] The controller may send the device model to a target device. The target device translates the desired behavior described in the device model into an implementation based on the capabilities of the target device. For example, the target device may include predetermined hardware or software logic for implementing the desired behavior defined in the device model. Accordingly, the target device may implement a requested capability defined in the device model without receiving instructions prescribing how to implement the requested capability. If the identifiers included in the device model are known to the target device, i.e. the target device previously received and translated the identifiers, the target device would also know the mapping between the identifiers and the implementation for the identifiers. The target device, upon receiving the device model from the controller, may retrieve and use the known mapping to statically translate the device model into an implementation. Absent known mapping, the translator of the target device would have to translate the device model into an implementation dynamically. Accordingly, static translation of the device model provides reusability of the previously determined mappings and does not require the translator to dynamically translate the device model each time the device model is received from the routing controller. </p><p id="p0032" num="0032">[0025] Figure 1 depicts an exemplary network 100 including a routing controller 110 and a target device 120 according to an exemplary embodiment. The controller 1 10 may include a processor, a server or other device implemented in hardware, software or a combination thereof. The network 100 may be a communications network such as the Internet, an 
<!-- EPO <DP n="9"/>-->
 intranet, or a telephone network, among other possibilities. The network 100 may include one or more optical, electronic, or other transmission mediums. </p><p id="p0033" num="0033">[0026] The controller 110 of the network 100 may be in communication with the target device 120. The controller 110 may be connected to the target device 120 directly or indirectly. It is understood that the network 100 is for explanatory purposes only, and a network suitable for use with the exemplary embodiments described herein may have other elements or capabilities. For example, the controller may generate a plurality of device models according to various embodiments. </p><p id="p0034" num="0034">[0027] According to an exemplary embodiment, the target device 120 may have forwarding functionality such that the target device 120 is capable of receiving incoming information on an inbound interface, processing the information to determine a next destination of the information, and forwarding the information to the next destination on an outbound interface. </p><p id="p0035" num="0035">[0028] The controller 1 10 may generate a device model 112 using a universal language. The device model 1 12 may define the intent of the network 100 (e.g., the intended forwarding behavior within the network 100) using the universal language. For example, the device model 1 12 may describe a desired behavior of a node of the network 100 under certain conditions, such as upon the receipt of an incoming packet. </p><p id="p0036" num="0036">[0029] As used herein, the universal language is a target-independent language that can be interpreted by all recipient devices. The universal language may be formed of building blocks called "network primitives". The device model 1 12 may include one or more network primitives 1 14. A network primitive 114 is a basic unit of functionality to be implemented by elements of the network 100. A network primitive 1 14 may be, for example, a description of a particular functionality to be used in the network 100. A network primitive 114 may describe what actions elements of the network 100 are meant to perform, but typically will not include requirements for how those actions are to be carried out. Thus, a networking primitive 114 may describe a desired outcome without providing implementation details for achieving the outcome. The implementation details may be left to the particular device implementing the network primitive 114, or may be specified by an external device. The device model 1 12 may be constructed as a collection of one or more network primitives 114. A same network primitive may appear multiple times in a given device model. 
<!-- EPO <DP n="10"/>-->
 [0030] According to various embodiments, network primitives can pass information between themselves. A network primitive may produce information for another network primitive to consume. The information that is exchanged between the primitives may be assigned a name. The named information may be referred as a handle. Naming the information allows the information to be referred to symbolically. Naming the information further improves the readability of the device model. The information may also be typed, i.e. one or more attributes, such as the size of the information, may be associated with the information. </p><p id="p0037" num="0037">[0031] According to various embodiments, a network primitive 114 related to queuing may specify that a recipient device of the device model 1 12 is to implement flat queuing, hierarchical queuing, buffer resource sharing, dynamic buffer sizing, tail drop queue management, weighted tail drop queue management, or queue high and low watermarks. Scheduling primitives may specify that scheduling should be in a round robin fashion, as a weighted round robin, low latency queuing or strict priority queuing, weighted fair queuing, or class-based weighted fair queuing. Metering primitives may make use of one rate two color (1R2C) IP packet marking, 1R3C marking, or 2R3C marking. Numerous other networking primitives may also be utilized. The details of the implementations of these networking primitives may be unspecified and left up to the device that implements the primitives. </p><p id="p0038" num="0038">[0032] For example, the network primitives may include core network primitives and control network primitives. The core network primitives may describe an independent thread of data path functionality. For example, a core network primitive may describe packet forwarding. The core primitives may be used to build a device model for network elements including but not limited to a switch, router, load balancer, flow device. The core primitives may be used to represent fragmentation, reassembly, cryptographic processing, etc. The control network primitives may describe administrative functionality such as the interaction between the independent threads, event handling, exception handling, etc. </p><p id="p0039" num="0039">[0033] Exemplary core network primitives may include the parse primitives, the table primitives, the logic primitive, the arithmetic primitive, the packet replicate primitive, the rewrite primitives, the meter primitive, the queue primitive, the scheduler primitive, the discard primitive, the counter primitive and the external primitive. Some of these exemplary core primitives are discussed below. 
<!-- EPO <DP n="11"/>-->
 [0034] The parse primitives may define the constraints and the information extracted from a packet header field of an input packet. According to various embodiments, the parse primitives may not be required to describe deep packet inspection on unstructured packet content. The parse primitives may include a parse header order sub-primitive that may be used to describe an acceptable parse graph. A header may be defined as a contiguous set of bytes from the input packet from which one or more pieces of information (fields) can be extracted in without performing a. lookup operation for determining the next header. The parse header order primitive may take one or more arguments. For example, the header order primitive may take current parse anchor as an argument. The current parse anchor may determine where in the packet the parsing should start. The header order primitive may also take well known header name/ID as an argument. This argument represents a name or ID assigned to the header. The header handle ID argument may represent a handle assigned to the header for reference in the device model. The next parse anchor argument represents an anchor refening to the location of the payioad of the header or sub hea der after the particular header has been parsed successfully. The header order primitive may also take header parse status handle as an argument. The argument defines the handle which refers to a Boolean and captures the parsing status. The argument is set to TRUE in case the header was present and was valid. Otherwise, the argument is set to FALSE. The header parse status may be an optional argument and can be skipped if the model writer has no interest in looking at the parse status. </p><p id="p0040" num="0040">[0035] The table primitives include a table definition primitive that may provide the typing and other miscellaneous information about a data, store, i.e. a. table. The typing information and constraints associated with the data store allows the consumer of the device model, e.g. the target device, to verify that the forwarding plane instantiation meets the requirements. The typing information and constraints associated with the data store may also allow the forwarding plane to perform one or more optimizations in implementing the data store. The table definition primitive may take one or more arguments such as the table type indicating whether the table includes an array, a tree, a set or a list. The arguments may also include an argument indicating whether table sharing is enabled, the table size, the table size tolerance, the table key definition list, the mask associated with each key list, the table result definition and the table handle (table ID/name). 
<!-- EPO <DP n="12"/>-->
 [0036] The table primitives may also include the table operation sub-primitive that may describe the forwarding plane actions that are taken on the data store defined by the table definition primitive. The table match sub-primitive describes a match or a search operation on the table. The table insert sub-primitive describes the data store insert operation performed by the data plane. </p><p id="p0041" num="0041">[0037] The logic primitive may allow the device model to express simple boolean logic or conditional operations that are used in forwarding the input packets. Logic operators may take handles as input and may produce output handles with the result of the logic operation. The logic primitives may support operations like integer comparisons including greater than operation, less than operation, equal to operation, Boolean logic operations like and operation, or operation, not operation, etc. The logic primitive may take one or more arguments including an ordered input handle that become the operands. The order and semantics of the operands are defined by the arithmetic operation. The logic primitive may also take output handle as an argument. The output handle may store the results of the operation performed by the logic primitive. </p><p id="p0042" num="0042">[0038] Exemplary control network primitives may include the scope primitive, the event handler primitive, the semaphore primitive, the event primitive and the raise primitive. </p><p id="p0043" num="0043">Some of these exemplary core primitives are discussed below. </p><p id="p0044" num="0044">[0039] The Scope primitive may allow the device model writer to indicate an order of operations to be performed in a set of primitives. For example, a scope primitive may be used in connection with the logic primitive to define an order of logic operations to be performed. </p><p id="p0045" num="0045">[0040] The event handler primitive may bind an event to a collection of cooperative primitives representing some defined functionality. The collection of primitives with a defined functionality may be given a 'name'. The event handler may bind a named event to a named collection of primitives. </p><p id="p0046" num="0046">[0041] A semaphore primitive may allow the model writer to describe mutual exclusion, critical sections, etc. within the device model. The semaphore primitive may allow for more than one primitive collection to access a resource. The semaphore primitive may also be used to allow for multiple individual primitive collections to access different instances of a shared resource safely if available. 
<!-- EPO <DP n="13"/>-->
 [0042] A raise primitive may be used to raise an exception. The raise primitive may be used to define how processing should proceed when a certain exception condition is encountered. The raise primitive may have two modes: a first mode which asks that processing of the packet be stopped and exception be taken, and a second mode which allows the main processing to continue and the exception is also taken. </p><p id="p0047" num="0047">[0043] In some embodiments, one or more network primitives 114 may be grouped together to form a submodel. The submodel may represent a desired functionality within the device model 1 12. Submodels promote modularity within a given device model. As discussed in greater detail below, a plurality of submodels may be stored in a submodel library. The controller 110 may retrieve the desired submodel from the submodel library and use the retrieved submodel in a device model. Similarly, if the controller 1 10 generates a new submodel by grouping one or more network primitives, the controller 110 may store the new submodel in the submodel library. One of ordinary skill in the art will appreciate that the use of submodels in a device model is optional. A device model may be generated without using any submodels. However, the submodels promote modularity and allow for a user-friendly visualization of the device model. </p><p id="p0048" num="0048">[0044] The device model 1 12 generated by the controller 1 10 may specify all the </p><p id="p0049" num="0049">routing/forwarding functionality within the network 100. In some embodiments, the controller 110 may generate a plurality of device models. For example, the controller 1 10 may generate a first device model 112 to be used under certain circumstances, such as periods of high or low network traffic or upon the receipt of certain types of packets. The controller 110 may generate a second device model 112' formed of network primitives 1 14' where the second device model 1 12' may be used under other circumstances. By modifying the device model 1 12 or 112', a network administrator may cause the network 100 to exhibit different network forwarding behaviors. </p><p id="p0050" num="0050">[0045] The controller 110 may send the generated device model 112 and/or 112' to the target device 120. The device model 1 12 and/or 112' may represent a complete set of functionality required of the target device 120. Where applicable, the target device 120 may interpret the information contained in the device model 112 and/or 1 12' within constraints known to the target device 120. Upon receiving the device model 1 12 and/or 112', the target device 120 may translate the intended behavior described in the device model 112 and/or 1 12' into implementation. The target device 120 may include a translator 126 provided at a hardware 
<!-- EPO <DP n="14"/>-->
 abstraction layer (HAL) 122 of the target device 120. The translator 126 may translate the target-independent device model 1 12 and/or 1 12' into implementation on the target device 120 based on the capabilities of, for example, the application specific integrated circuit (ASIC) 124 of the target device 120. Accordingly, high-level generic desired forwarding behaviors may be mapped to low-level ASIC features. </p><p id="p0051" num="0051">[0046] The device model 112 and/or 1 12' may include one or more identifiers associated with one or more portions of the device model 112 and/or 112'. The target device 120 may be familiar with the identifiers of the device model 112 and/or 112'. For example, the target device 120 may have previously received the one or more identifiers and translated the identifiers into implementation. Thus, the target device 120 may know the mapping between the one or more known identifiers and their implementations on the target device. The known mappings may be stored, for example, in a database of known mappings. If the target device 120 knows the mapping, the translator 126 may retrieve the known mapping from the database and statically translate the device model 112 and/or 1 12' to implementation on the target device 120. That is, instead of dynamically translating one or more portions of the received device model 1 12 and/or 112' to implementation, the target device 120 may statically translate the device model 112 and/or 1 12' into implementation using a pre- mapping. </p><p id="p0052" num="0052">[0047] Figure 2 depicts how elements of the exemplary network 100 may interact according to an exemplary embodiment. The controller 202 provided in a network 200 may send at least one device model 204 to a target device 250. The device model 204 may include one or more identifiers. Upon receiving the device model with identifiers 202, the target device 250 checks a storage 208, such as a database, for pre-determined mappings between identifiers and their implementations. If the target device 250 finds pre-determined mappings for the identifiers in the received device model 204, the target device 250 may retrieve the mappings. The translator 210 of the target device 250 may statically translate the identifiers into implementation using the pre-determined mappings retrieved from the storage 208. If the target device 250 does not find pre-determined mappings for the identifiers in the received device model 204, the translator 210 of the target device 250 may dynamically translate the identifiers into implementation based on the capabilities of the target device 250. When the translation is complete, the intended behavior described in the device model 202 is passed to implementation 212 on the target device. 
<!-- EPO <DP n="15"/>-->
 [0048] Figure 3 depicts an exemplary device model 300 generated by a controller according to an exemplary embodiment. The device model 300 is provided as a unified modeling language (UML) activity diagram. It is understood that UML activity diagram is used for illustrative purposed and that the device model 300 may be provided using other graphical and/or textual modeling languages. The device model 300 illustrates a representation of the network behavior for implementing a media access control (MAC) bridge. The device model 300 includes a plurality of network primitives 302-318. When the device model 300 is sent to a target device, the ASIC of the target device is given the specific behavior expected of the network for an efficient implementation by the target device. </p><p id="p0053" num="0053">[0049] According to various embodiments, the device model 300 may also be expressed using textual code, such as a pseudo code. A portion of an exemplary pseudo code representing the device model 300 is provided below. One of ordinary skill in the art will appreciate that the pseudo code is provided for exemplary purposes and should not be construed as limiting. </p><p id="p0054" num="0054">{ primitive TABLEDEF( ame = "MACTable" /* Data Structure Name */, </p><p id="p0055" num="0055"> TableShared = TRUE, TableType = ExactMatch, </p><p id="p0056" num="0056"> SearchKey = { { /*Bridging Search Key */ (Vlan, 12), (MACAddress, 48) }, </p><p id="p0057" num="0057"> {/* Learning Search Key */ (PortID, 8), (VlanID, 12), (MACAddress, 48) } }, TableResult= {BridgingResult, LearningResult} , </p><p id="p0058" num="0058"> TableSize = MacTableSize); primitive TABLEOPS_MATCH(MatchName = BridgeForwardingMatch, </p><p id="p0059" num="0059">TABLE- 'MACTable", </p><p id="p0060" num="0060"> consumes(VlanID, MACDestAddress), </p><p id="p0061" num="0061"> SearchKeyMap={(Vlan:VlanID),(MACAddress:MACDestAddress)}, </p><p id="p0062" num="0062"> produces(outPortID, DropPacket), ResultMap = { (BridgingResult. oPort: outPortID), (BridgingResult. drop: DropPacket)} ); primitive TABLEOPS_MATCH(MatchName = BridgeLearningMatch, </p><p id="p0063" num="0063">TABLE- 'MACTable", 
<!-- EPO <DP n="16"/>-->
 consumes(PortID, VlanID, MACSrcAddress), </p><p id="p0064" num="0064"> SearchKeyMap={( (PortID: PortID), (Vlan:VlanID), </p><p id="p0065" num="0065">(MACAddress:MACSrcAddress)}, </p><p id="p0066" num="0066"> produces(LearningHit), ResultMap = {(LearningResult.Hit: LearningHit) } ); if (LearningHit == TRUE &amp;&amp; STPLearningEnabled == TRUE) { /* Conditional Logic Primitive */ </p><p id="p0067" num="0067">/* Record Activity for the Src MAC address */ </p><p id="p0068" num="0068"> primitive TABLEOPS_MODIFY(MatchName = UpdateMACActivity, </p><p id="p0069" num="0069">TABLE- 'MACTable", </p><p id="p0070" num="0070"> consumes(PortID, VlanID, MACSrcAddress, CurrentTimeStamp), </p><p id="p0071" num="0071"> SearchKeyMap={ (PortID: PortID), (Vlan: VlanID), </p><p id="p0072" num="0072"> (MACAddress:MACSrcAddress)}, </p><p id="p0073" num="0073"> produces(), ResultMap = {(LearningResult.LastSeen: CurrentTimeStamp) } ); </p><p id="p0074" num="0074">} else if (LearningHit == FALSE &amp;&amp; STPLearningEnabled == TRUE) { /* Logic */ /* Learn the Src MAC address */ </p><p id="p0075" num="0075"> primitive TABLEOPS_INSERT(MatchName = LearnMAC, TABLE="MACTable", consumes(PortID, VlanID, MACSrcAddress, CurrentTimeStamp), </p><p id="p0076" num="0076"> SearchKeyMap={ (PortID : PortID), (Vlan: VlanID), </p><p id="p0077" num="0077"> (MACAddress:MACSrcAddress)}, </p><p id="p0078" num="0078"> produces(), ResultMap = {(LearningResult.LastSeen: CurrentTimeStamp), (BridgingResult.oPort: PortID), (BridgingResult.drop: FALSE)} ); </p><p id="p0079" num="0079">} </p><p id="p0080" num="0080">[0050] As illustrated above, the pseudo code may have an entry for the network primitives of the device model 300. For example, the portion of the pseudo code provided above has an entry for table definition network primitive 306, the tableops match network primitive 304, the tableops modify network primitive 308 and the tableops insert network primitive 310. 
<!-- EPO <DP n="17"/>-->
 [0051] The target device, upon receiving the device model 300 in the graphical format or in the pseudo code format, translates the device model 300 into an implementation. The translation of the exemplary device model 300 in the implementation of a MAC bridge will allow communications between one or more end stations coupled to the target device in the network. Specifically, the intended behavior represented in the device model 300 allows the interconnection of one or more end stations as if they were attached to a single local area network (LAN), even if the one or more end satiations are attached to separate LANs. </p><p id="p0081" num="0081">[0052] When the controller generates a device model, the controller may send the device model to the target device for implementation. The controller may send the device model in the graphical format and/or in a textual format such as a pseudo code. Both the graphical format and the pseudo code include one or more network primitives generated in a target- independent universal language. The steps performed by the controller and the target device are discussed below. </p><p id="p0082" num="0082">[0053] Figure 4 is a flowchart describing exemplary steps performed by a controller in accordance with an exemplary embodiment. The controller may generate a device model in a target-independent format (step 402). The device model may describe the intended forwarding behavior for the target device. The intended forwarding behavior may be a high- level indication of the intent of the developer. The controller may send the generated device model to the target device for implementation (step 404). </p><p id="p0083" num="0083">[0054] Figure 5 is a flowchart describing exemplary steps performed by a target device in accordance with an exemplary embodiment. The target device receives the device model generated by the controller (step 502). The device model may be described in target- independent format. The device model may include one or more identifiers associated with one or more portions of the device model. The one or more identifiers may be known to the target device. For example, the target device may have previously received the one or more identifiers. The target device may retrieve, for example from a storage, a previously- generated mapping between the one or more known identifiers and implementations thereof on the target device (step 504). The target device may statically translate the device model into implementation using the mapping retrieved from the storage (step 506). The target device may be configured based on the translating (step 508). When the target device receives one or more input packets (step 510), the target device may forward the received input packets to one or more elements of the network based on the configuring (step 512). 
<!-- EPO <DP n="18"/>-->
 [0055] One or more of the above-described acts may be encoded as computer-executable instructions executable by processing logic. The computer-executable instructions may be stored on one or more non-transitory computer readable media. One or more of the above described acts may be performed in a suitably -programmed electronic device. Figure 6 depicts an example of an electronic device 600 that may be suitable for use with one or more acts disclosed herein. </p><p id="p0084" num="0084">[0056] The electronic device 600 may take many forms, including but not limited to a computer, workstation, server, network computer, quantum computer, optical computer, Internet appliance, mobile device, a pager, a tablet computer, a smart sensor, application specific processing device, etc. </p><p id="p0085" num="0085">[0057] The electronic device 600 is illustrative and may take other forms. For example, an alternative implementation of the electronic device 600 may have fewer components, more components, or components that are in a configuration that differs from the configuration of Figure 6. The components of Figure 6 and/or other figures described herein may be implemented using hardware based logic, software based logic and/or logic that is a combination of hardware and software based logic (e.g., hybrid logic); therefore, components illustrated in Figure 6 and/or other figures are not limited to a specific type of logic. </p><p id="p0086" num="0086">[0058] The processor 602 may include hardware based logic or a combination of hardware based logic and software to execute instructions on behalf of the electronic device 600. The processor 602 may include logic that may interpret, execute, and/or otherwise process information contained in, for example, the memory 604. The information may include computer-executable instructions and/or data that may implement one or more embodiments of the invention. The processor 602 may comprise a variety of homogeneous or </p><p id="p0087" num="0087">heterogeneous hardware. The hardware may include, for example, some combination of one or more processors, microprocessors, field programmable gate arrays (FPGAs), application specific instruction set processors (ASIPs), application specific integrated circuits (ASICs), complex programmable logic devices (CPLDs), graphics processing units (GPUs), or other types of processing logic that may interpret, execute, manipulate, and/or otherwise process the information. The processor may include a single core or multiple cores 603. Moreover, the processor 602 may include a system-on-chip (SoC) or system-in-package (SiP). 
<!-- EPO <DP n="19"/>-->
 [0059] The electronic device 600 may include one or more tangible non-transitory computer- readable storage media for storing one or more computer-executable instructions or software that may implement one or more embodiments of the invention. The non-transitory computer-readable storage media may be, for example, the memory 604 or the storage 618. The memory 604 may comprise a ternary content addressable memory (TCAM) and/or a RAM that may include RAM devices that may store the information. The RAM devices may be volatile or non-volatile and may include, for example, one or more DRAM devices, flash memory devices, SRAM devices, zero-capacitor RAM (ZRAM) devices, twin transistor RAM (TTRAM) devices, read-only memory (ROM) devices, ferroelectric RAM (FeRAM) devices, magneto-resistive RAM (MRAM) devices, phase change memory RAM (PRAM) devices, or other types of RAM devices. </p><p id="p0088" num="0088">[0060] One or more computing devices 600 may include a virtual machine (VM) 605 for executing the instructions loaded in the memory 604. A virtual machine 605 may be provided to handle a process running on multiple processors so that the process may appear to be using only one computing resource rather than multiple computing resources. </p><p id="p0089" num="0089">Virtualization may be employed in the electronic device 600 so that infrastructure and resources in the electronic device may be shared dynamically. Multiple VMs 605 may be resident on a single computing device 600. </p><p id="p0090" num="0090">[0061] A hardware accelerator 606, may be implemented in an ASIC, FPGA, or some other device. The hardware accelerator 606 may be used to reduce the general processing time of the electronic device 600. </p><p id="p0091" num="0091">[0062] The electronic device 600 may include a network interface 608 to interface to a Local Area Network (LAN), Wide Area Network (WAN) or the Internet through a variety of connections including, but not limited to, standard telephone lines, LAN or WAN links (e.g., Tl, T3, 56kb, X.25), broadband connections (e.g., integrated services digital network (ISDN), Frame Relay, asynchronous transfer mode (ATM), wireless connections (e.g., 802.1 1), highspeed interconnects (e.g., InfiniBand, gigabit Ethernet, Myrinet) or some combination of any or all of the above. The network interface 608 may include a built-in network adapter, network interface card, personal computer memory card international association (PCMCIA) network card, card bus network adapter, wireless network adapter, universal serial bus (USB) network adapter, modem or any other device suitable for interfacing the electronic device 600 
<!-- EPO <DP n="20"/>-->
 to any type of network capable of communication and performing the operations described herein. </p><p id="p0092" num="0092">[0063] The electronic device 600 may include one or more input devices 610, such as a keyboard, a multi-point touch interface, a pointing device (e.g., a mouse), a gyroscope, an accelerometer, a haptic device, a tactile device, a neural device, a microphone, or a camera that may be used to receive input from, for example, a user. Note that electronic device 600 may include other suitable I/O peripherals. </p><p id="p0093" num="0093">[0064] The input devices 610 may allow a user to provide input that is registered on a visual display device 614. A graphical user interface (GUI) 616 may be shown on the display device 614. </p><p id="p0094" num="0094">[0065] A storage device 618 may also be associated with the computer 600. The storage device 618 may be accessible to the processor 602 via an I/O bus. The information may be executed, interpreted, manipulated, and/or otherwise processed by the processor 602. The storage device 618 may include, for example, a storage device, such as a magnetic disk, optical disk (e.g., CD-ROM, DVD player), random-access memory (RAM) disk, tape unit, and/or flash drive. The information may be stored on one or more non-transient tangible computer-readable media contained in the storage device. This media may include, for example, magnetic discs, optical discs, magnetic tape, and/or memory devices (e.g., flash memory devices, static RAM (SRAM) devices, dynamic RAM (DRAM) devices, or other memory devices). The information may include data and/or computer-executable instructions that may implement one or more embodiments of the invention </p><p id="p0095" num="0095">[0066] The storage device 618 may further store applications 624, and the electronic device 600 can be running an operating system (OS) 626. Examples of OS 626 may include the Microsoft® Windows® operating systems, the Unix and Linux operating systems, the MacOS® for Macintosh computers, an embedded operating system, such as the Symbian OS, a real-time operating system, an open source operating system, a proprietary operating system, operating systems for mobile electronic devices, or other operating system capable of running on the electronic device and performing the operations described herein. The operating system may be running in native mode or emulated mode. </p><p id="p0096" num="0096">[0067] The storage device 618 may further include rules 628 which describe how messages should be forwarded in a communications network. The rules 628 may be used to forward 
<!-- EPO <DP n="21"/>-->
 messages or information received at the electronic device 628. Accordingly, the electronic device 600 may serve as a forwarding device, switch, or router. </p><p id="p0097" num="0097">[0068] The storage device 618 may store an implementation database 630. The </p><p id="p0098" num="0098">implementation database 630 may be a data structure, such as a table or matrix, which stores identifiers identifying predetermined functions that are implemented by the electronic device 630. The implementation database may further store the implementation details of the predetermined functions. </p><p id="p0099" num="0099">[0069] The storage device 618 may further include logic for implementing a communications protocol 640. The communications protocol 640 may be a protocol which provides an interface for accessing and modifying the functionality of the forwarding plane of the electronic device 600. Exemplary communications protocols 640 include, but are not limited to, the OpenFlow protocol (see, e.g., McKeown, Nick et ah, "OpenFlow: Enabling </p><p id="p0100" num="0100">Innovation in Campus Networks," ACM SIGCOMM Computer Communication Review Archive, vol. 38 issue 2, pp. 69-74 (April 2008), the contents of which are incorporated herein by reference) or custom communications protocols. Thus, the electronic device 600 may serve as a remote controller, such as the controller 1 10 described above with respect to Figure 1. </p><p id="p0101" num="0101">[0070] The communications protocol 640 may allow the details of the forwarding plane implemented by the electronic device 600 to be defined and/or modified. Accordingly, the communications protocol 640 allows a communications network to be made programmable. </p><p id="p0102" num="0102">[0071] The communications protocol 640 may support the use of one or more device models 642 to implement the functionality of the forwarding plane. A device model 642 may represent the complete set of network routing functionality to be implemented by the electronic device 640. For example, the device model 642 may define the functionality and performance of the forwarding plane. </p><p id="p0103" num="0103">[0072] The device model 642 may include one or more network primitives. A network primitive is a basic unit of functionality to be implemented by the electronic device 600. A network primitive may be, for example, a description of a particular functionality to be used in the communications network. A network primitive may describe what actions the electronic device 600 is meant to perform, but typically will not include requirements for how those actions are to be carried out. Thus, a network primitive may describe a desired 
<!-- EPO <DP n="22"/>-->
 outcome without providing implementation details for achieving the outcome. The implementation details may be left to the particular device implementing the network primitive, or may be specified by an external device. </p><p id="p0104" num="0104">[0073] For example, a network primitive related to queuing may specify that the electronic device 600 (acting as a forwarding device) is to implement flat queuing, hierarchical queuing, buffer resource sharing, dynamic buffer sizing, tail drop queue management, weighted tail drop queue management, or queue high and low watermarks. Scheduling primitives may specify that scheduling should be in a round robin fashion, as a weighted round robin, low latency queuing or strict priority queuing, weighted fair queuing, or class-based weighted fair queuing. Metering primitives may make use of one rate two color (1R2C) IP packet marking, 1R3C marking, or 2R3C marking. Numerous other network primitives may also be utilized. The details of the implementations of these network primitives may be unspecified and left up to the device that implements the primitives. </p><p id="p0105" num="0105">[0074] A device model 642 may be constructed as a collection of one or more network primitives. For example, one device model 642 might specify that the electronic device 600 is to use flat queuing with round robin scheduling. </p><p id="p0106" num="0106">[0075] One or more device models 642 may specify all the network routing/forwarding functionality of the electronic device 600. For example, a first device model 642 may be used under certain circumstances, such as periods of high or low network traffic or upon the receipt of certain types of packets, and that a second device model 642 may be used under other circumstances. By modifying the device model 642, a network administrator may cause the electronic device 600 to exhibit different network forwarding behaviors. </p><p id="p0107" num="0107">[0076] The communications protocol 640 may reference a device model 642 and implement the functionality defined by the device model 642 using the functionality defined by the implementation database 630. Alternatively, the communications protocol 640 may use default or generic implementations stored locally with the communications protocol 640 or provided from a remote location, such as a remote controller. </p><p id="p0108" num="0108">[0077] One or more embodiments of the invention may be implemented using computer- executable instructions and/or data that may be embodied on one or more non-transitory tangible computer-readable mediums. The mediums may be, but are not limited to, a hard disk, a compact disc, a digital versatile disc, a flash memory card, a Programmable Read 
<!-- EPO <DP n="23"/>-->
 Only Memory (PROM), a Random Access Memory (RAM), a Read Only Memory (ROM), Magnetoresistive Random Access Memory (MRAM), a magnetic tape, or other computer- readable media. </p><p id="p0109" num="0109">[0078] Figure 7 depicts a network implementation that may implement one or more embodiments of the invention. A system 700 may include a computing device 600, a network 712, a service provider 713, a target environment 714, and a cluster 715. The embodiment of Figure 7 is exemplary, and other embodiments can include more devices, fewer devices, or devices in arrangements that differ from the arrangement of Figure 7. </p><p id="p0110" num="0110">[0079] The network 712 may transport data from a source to a destination. Embodiments of the network 712 may use network devices, such as routers, switches, firewalls, and/or servers (not shown) and connections (e.g., links) to transport data. Data may refer to any type of machine-readable information having substantially any format that may be adapted for use in one or more networks and/or with one or more devices (e.g., the computing device 600, the service provider 713, etc.). Data may include digital information or analog </p><p id="p0111" num="0111">information. Data may further be packetized and/or non-packetized. </p><p id="p0112" num="0112">[0080] The network 712 may be a hardwired network using wired conductors and/or optical fibers and/or may be a wireless network using free-space optical, radio frequency (RF), and/or acoustic transmission paths. In one implementation, the network 712 may be a substantially open public network, such as the Internet. In another implementation, the network 712 may be a more restricted network, such as a corporate virtual network. The network 712 may include Internet, intranet, Local Area Network (LAN), Wide Area Network (WAN), Metropolitan Area Network (MAN), wireless network (e.g., using IEEE 802.1 1), or other type of network The network 712 may use middleware, such as Common Object Request Broker Architecture (CORBA) or Distributed Component Object Model </p><p id="p0113" num="0113">(DCOM). Implementations of networks and/or devices operating on networks described herein are not limited to, for example, any particular data type, protocol, and/or </p><p id="p0114" num="0114">architecture/configuration. </p><p id="p0115" num="0115">[0081] The service provider 713 may include a device that makes a service available to another device. For example, the service provider 713 may include an entity (e.g., an individual, a corporation, an educational institution, a government agency, etc.) that provides one or more services to a destination using a server and/or other devices. Services may 
<!-- EPO <DP n="24"/>-->
 include instructions that are executed by a destination to perform an operation (e.g., an optimization operation). Alternatively, a service may include instructions that are executed on behalf of a destination to perform an operation on the destination's behalf. </p><p id="p0116" num="0116">[0082] The server 714 may include a device that receives information over the network 712. For example, the server 714 may be a device that receives user input from the computer 600. </p><p id="p0117" num="0117">[0083] The cluster 715 may include a number of units of execution (UEs) 716 and may perform processing on behalf of the computer 500 and/or another device, such as the service provider 713 or server 714. For example, the cluster 715 may perform parallel processing on an operation received from the computer 600. The cluster 715 may include UEs 716 that reside on a single device or chip or that reside on a number of devices or chips. </p><p id="p0118" num="0118">[0084] The units of execution (UEs) 716 may include processing devices that perform operations on behalf of a device, such as a requesting device. A UE may be a </p><p id="p0119" num="0119">microprocessor, field programmable gate array (FPGA), and/or another type of processing device. UE 716 may include code, such as code for an operating environment. For example, a UE may run a portion of an operating environment that pertains to parallel processing activities. The service provider 713 may operate the cluster 715 and may provide interactive optimization capabilities to the computer 500 on a subscription basis (e.g., via a web service). </p><p id="p0120" num="0120">[0085] Units of Execution (UEs) may provide remote/distributed processing capabilities for the applications 724. A hardware unit of execution may include a device (e.g., a hardware resource) that may perform and/or participate in parallel programming activities. For example, a hardware unit of execution may perform and/or participate in parallel </p><p id="p0121" num="0121">programming activities in response to a request and/or a task it has received (e.g., received directly or via a proxy). A hardware unit of execution may perform and/or participate in substantially any type of parallel programming (e.g., task, data, stream processing, etc.) using one or more devices. For example, a hardware unit of execution may include a single processing device that includes multiple cores or a number of processors. A hardware unit of execution may also be a programmable device, such as a field programmable gate array (FPGA), an application specific integrated circuit (ASIC), a digital signal processor (DSP), or other programmable device. Devices used in a hardware unit of execution may be arranged 
<!-- EPO <DP n="25"/>-->
 in many different configurations (or topologies), such as a grid, ring, star, or other configuration. A hardware unit of execution may support one or more threads (or processes) when performing processing operations. </p><p id="p0122" num="0122">[0086] A software unit of execution may include a software resource (e.g., a technical computing environment) that may perform and/or participate in one or more parallel programming activities. A software unit of execution may perform and/or participate in one or more parallel programming activities in response to a receipt of a program and/or one or more portions of the program. A software unit of execution may perform and/or participate in different types of parallel programming using one or more hardware units of execution. A software unit of execution may support one or more threads and/or processes when performing processing operations. </p><p id="p0123" num="0123">[0087] The term 'parallel programming' may be understood to include multiple types of parallel programming, e.g. task parallel programming, data parallel programming, and stream parallel programming. Parallel programming may include various types of processing that may be distributed across multiple resources (e.g., software units of execution, hardware units of execution, processors, microprocessors, clusters, labs) and may be performed at the same time. </p><p id="p0124" num="0124">[0088] For example, parallel programming may include task parallel programming where a number of tasks may be processed at the same time on a number of software units of execution. In task parallel programming, a task may be processed independently of other tasks executing, for example, at the same time. </p><p id="p0125" num="0125">[0089] Parallel programming may include data parallel programming, where data (e.g., a data set) may be parsed into a number of portions that may be executed in parallel using, for example, software units of execution. In data parallel programming, the software units of execution and/or the data portions may communicate with each other as processing progresses. </p><p id="p0126" num="0126">[0090] Parallel programming may include stream parallel programming (sometimes referred to as pipeline parallel programming). Stream parallel programming may use a number of software units of execution arranged, for example, in series (e.g., a line) where a first software unit of execution may produce a first result that may be fed to a second software unit of execution that may produce a second result given the first result. Stream parallel 
<!-- EPO <DP n="26"/>-->
 programming may also include a state where task allocation may be expressed in a directed acyclic graph (DAG) or a cyclic graph. </p><p id="p0127" num="0127">[0091] Other parallel programming techniques may involve some combination of task, data, and/or stream parallel programming techniques alone or with other types of processing techniques to form hybrid-parallel programming techniques. </p><p id="p0128" num="0128">[0092] The foregoing description may provide illustration and description of various embodiments of the invention, but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations may be possible in light of the above teachings or may be acquired from practice of the invention. For example, while a series of acts has been described above, the order of the acts may be modified in other implementations consistent with the principles of the invention. Further, non-dependent acts may be performed in parallel. </p><p id="p0129" num="0129">[0093] In addition, one or more implementations consistent with principles of the invention may be implemented using one or more devices and/or configurations other than those illustrated in the Figures and described in the Specification without departing from the spirit of the invention. One or more devices and/or components may be added and/or removed from the implementations of the figures depending on specific deployments and/or applications. Also, one or more disclosed implementations may not be limited to a specific combination of hardware. </p><p id="p0130" num="0130">[0094] Furthermore, certain portions of the invention may be implemented as logic that may perform one or more functions. This logic may include hardware, such as hardwired logic, an application-specific integrated circuit, a field programmable gate array, a microprocessor, software, or a combination of hardware and software. </p><p id="p0131" num="0131">[0095] No element, act, or instruction used in the description of the invention should be construed critical or essential to the invention unless explicitly described as such. </p><p id="p0132" num="0132">[0096] Also, as used herein, the article "a" is intended to include one or more items. Where only one item is intended, the term "a single" or similar language is used. Further, the phrase "based on," as used herein is intended to mean "based, at least in part, on" unless explicitly stated otherwise. In addition, the term "user", as used herein, is intended to be broadly 
<!-- EPO <DP n="27"/>-->
 interpreted to include, for example, an electronic device (e.g., a workstation) or a user of an electronic device, unless otherwise stated. </p><p id="p0133" num="0133">[0097] It is intended that the invention not be limited to the particular embodiments disclosed above, but that the invention will include any and all particular embodiments and equivalents falling within the scope of the following appended claims. 
</p></description><claims mxw-id="PCLM70076424" ref-ucid="WO-2014131044-A1" lang="EN" load-source="patent-office"><claim-statement><!-- EPO <DP n="28"/>-->Claims </claim-statement><claim id="clm-0001" num="1"><claim-text>1. A non-transitory electronic device readable storage medium holding instructions that, when executed, cause one or more processors to: </claim-text><claim-text> receive a device model described in a target-independent format, where the device model: </claim-text><claim-text> includes one or more network primitives, and </claim-text><claim-text> describes an intended forwarding behavior for a target device; translate the device model to the one or more capabilities of the target device, the target device having a forwarding capability, wherein the translating includes mapping the one or more network primitives to the one or more capabilities of the target device; </claim-text><claim-text> configure the target device based on the translating; </claim-text><claim-text> receive one or more input packets; and </claim-text><claim-text> forward one or more input packets to one or more elements of the network based on the configuring. </claim-text></claim><claim id="clm-0002" num="2"><claim-text>2. The medium of claim 1, wherein a network primitive is a target device independent building block for the device model. </claim-text></claim><claim id="clm-0003" num="3"><claim-text>3. The medium of claim 1, wherein the device model includes a submodel formed by grouping one or more network primitives, the submodel defining a functionality. </claim-text></claim><claim id="clm-0004" num="4"><claim-text>4. The medium of claim 3, wherein the submodel is stored in a submodel library. </claim-text></claim><claim id="clm-0005" num="5"><claim-text>5. The medium of claim 4, wherein additional submodels are added to the submodel library. </claim-text></claim><claim id="clm-0006" num="6"><claim-text>6. The medium of claim 1 , wherein the device model includes two or more instances of a first network primitive. </claim-text></claim><claim id="clm-0007" num="7"><claim-text>7. The medium of claim 1, the one or more network primitives include a core network primitive that describes an independent thread of data path functionality. 
<!-- EPO <DP n="29"/>-->
</claim-text></claim><claim id="clm-0008" num="8"><claim-text>8. The medium of claim 1, wherein the one or more network primitives include a control primitive that describe control flow functionality within the network. </claim-text></claim><claim id="clm-0009" num="9"><claim-text>9. The medium of claim 1, further holding one or more instructions to: </claim-text><claim-text> parse the received device model. </claim-text></claim><claim id="clm-0010" num="10"><claim-text>10. The medium of claim 1, wherein the device model further includes one or more known identifiers associated with one or more portions of the device model </claim-text></claim><claim id="clm-0011" num="11"><claim-text>11. The medium of claim 10, wherein the medium further storing instructions that, when executed, cause one or more processors to: </claim-text><claim-text> retrieve a mapping that maps the one or more known identifiers of the device model to implementation of one or more capabilities of a target device having a forwarding or switching capability. </claim-text></claim><claim id="clm-0012" num="12"><claim-text>12. The medium of claim 1 1, wherein the translating includes statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping </claim-text></claim><claim id="clm-0013" num="13"><claim-text>13. A non-transitory electronic device readable storage medium holding instructions that, when executed, cause one or more processors to: </claim-text><claim-text> generate a device model in a target-independent format, where the device model: includes one or more network primitives, and </claim-text><claim-text> describes an intended forwarding behavior for a target device; and send the device model to the target device in the network for implementation, the target device having a forwarding capability. </claim-text></claim><claim id="clm-0014" num="14"><claim-text>14. The medium of claim 10, wherein the device model includes two or more instances of a first network primitive. </claim-text></claim><claim id="clm-0015" num="15"><claim-text>15. A system comprising: </claim-text><claim-text> a routing controller for generating a device model described in a target-independent format, wherein the device model includes one or more network primitives; 
<!-- EPO <DP n="30"/>-->
 a target device for receiving the device model, wherein: </claim-text><claim-text> the device model describes an intended forwarding behavior for the target device, </claim-text><claim-text> the target device has a forwarding or switching capability; and a storage for storing a plurality of network primitives, wherein the device model is generated using the one or more network primitives retrieved from the storage, </claim-text><claim-text> wherein the target device is configured to map the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device. </claim-text></claim><claim id="clm-0016" num="16"><claim-text>16. The system of claim 15, wherein the target device is configured to: </claim-text><claim-text> receive one or more input packets, and </claim-text><claim-text> forward the one or more input packets to one or more elements of the network based on mapping. </claim-text></claim><claim id="clm-0017" num="17"><claim-text>17. The system of claim 15, wherein the device model includes a submodel formed by grouping one or more network primitives, the submodel defining a functionality. </claim-text></claim><claim id="clm-0018" num="18"><claim-text>18. A non-transitory electronic device readable storage medium holding instructions that, when executed, cause one or more processors to: </claim-text><claim-text> receive a device model described in a target-independent format, wherein: </claim-text><claim-text> the device model describes an intended forwarding behavior for a target device, and </claim-text><claim-text> the device model includes one or more known identifiers associated with one or more portions of the device model; </claim-text><claim-text> retrieve a mapping that maps the one or more known identifiers of the device model to implementation of one or more capabilities of a target device having a forwarding or switching capability; and </claim-text><claim-text> configure the target device by statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping. </claim-text></claim><claim id="clm-0019" num="19"><claim-text>19. The medium of claim 18, wherein the static mapping occurs in a hardware abstraction layer (HAL) implemented in the target device. 
<!-- EPO <DP n="31"/>-->
</claim-text></claim><claim id="clm-0020" num="20"><claim-text>20. The medium of claim 18, wherein the mapping is used for subsequent implementations of the one or more identifiers on the target device. </claim-text></claim><claim id="clm-0021" num="21"><claim-text>21. The medium of claim 18, wherein the mapping is stored at a storage device. </claim-text></claim><claim id="clm-0022" num="22"><claim-text>22. The medium of claim 21, wherein the storage device stores additional mappings. </claim-text></claim><claim id="clm-0023" num="23"><claim-text>23. The medium of claim 21, wherein one or more mappings can be added to the storage device. </claim-text></claim><claim id="clm-0024" num="24"><claim-text>24. The medium of claim 18, wherein the mapping is retrieved among a plurality of mappings. </claim-text></claim><claim id="clm-0025" num="25"><claim-text>25. The medium of claim 18, further storing instructions for: </claim-text><claim-text> determining a forwarding scheme for forwarding one or more input packets in the network based on the device model. </claim-text></claim><claim id="clm-0026" num="26"><claim-text>26. The medium of claim 18, further storing instructions for: </claim-text><claim-text> receiving one or more input packets; </claim-text><claim-text> forwarding the one or more input packets to one or more elements of the network based on the mapping. </claim-text></claim><claim id="clm-0027" num="27"><claim-text>27. The medium of claim 18, wherein the target-independent format comprises a universal language formed of one or more network primitives. </claim-text></claim><claim id="clm-0028" num="28"><claim-text>28. A method comprising: </claim-text><claim-text> receiving a device model described in a target-independent format, wherein the device model describes an intended forwarding behavior for a target device; </claim-text><claim-text> retrieving a mapping that maps one or more elements of the device model to implementation of one or more capabilities of the target device having a forwarding or switching capability; 
<!-- EPO <DP n="32"/>-->
 configuring the target device by statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping; </claim-text><claim-text> receiving one or more input packets; and </claim-text><claim-text> forwarding the one or more input packets to one or more elements of the network based on the configuring. </claim-text></claim><claim id="clm-0029" num="29"><claim-text>29. The method of claim 28, wherein the static mapping occurs in a hardware abstraction layer (HAL) implemented in the target device. </claim-text></claim><claim id="clm-0030" num="30"><claim-text>30. The method of claim 28, wherein the mapping is used for subsequent implementations of one or more portions of the device model on the target device. </claim-text></claim><claim id="clm-0031" num="31"><claim-text>31. The method of claim 28, wherein the mapping is stored at a storage device. </claim-text></claim><claim id="clm-0032" num="32"><claim-text>32. The method of claim 31, wherein one or more a mappings can be added to the storage device. </claim-text></claim><claim id="clm-0033" num="33"><claim-text>33. The method of claim 28, wherein the mapping is retrieved among a plurality of mappings. </claim-text></claim><claim id="clm-0034" num="34"><claim-text>34. The method of claim 28, further comprising: </claim-text><claim-text> determining a forwarding scheme for forwarding the one or more input packets in the network based on the device model. </claim-text></claim><claim id="clm-0035" num="35"><claim-text>35. The method of claim 28, wherein the target-independent format comprises a universal language formed of one or more network primitives. </claim-text></claim><claim id="clm-0036" num="36"><claim-text>36. A system comprising: </claim-text><claim-text> a routing controller for generating a device model described in a target-independent format; </claim-text><claim-text> a target device for receiving the device model, wherein: </claim-text><claim-text> the device model describes an intended forwarding behavior for the target device, 
<!-- EPO <DP n="33"/>-->
 the target device has a forwarding or switching capability; and </claim-text><claim-text> a storage for storing one or more mappings that map one or more portions of the device model to implementation of one or more capabilities of the target device, </claim-text><claim-text> wherein the target device is configured to retrieve one or more mappings from the storage for statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping. </claim-text></claim><claim id="clm-0037" num="37"><claim-text>37. The system of claim 36 wherein the device model includes one or more known identifiers associated with the one or more portions of the device model. </claim-text></claim><claim id="clm-0038" num="38"><claim-text>38. The system of claim 36 wherein the target device is configured to: </claim-text><claim-text> receive one or more input packets, and </claim-text><claim-text> forward the one or more input packets to one or more elements of the network based on the retrieved mapping. 
</claim-text></claim></claims><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
