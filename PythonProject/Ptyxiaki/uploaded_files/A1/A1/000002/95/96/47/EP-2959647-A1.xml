<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2959647-A1" country="EP" doc-number="2959647" kind="A1" date="20151230" family-id="51388095" file-reference-id="315106" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="160452529" ucid="EP-2959647-A1"><document-id><country>EP</country><doc-number>2959647</doc-number><kind>A1</kind><date>20151230</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-14711607-A" is-representative="NO"><document-id mxw-id="PAPP193868026" load-source="docdb" format="epo"><country>EP</country><doc-number>14711607</doc-number><kind>A</kind><date>20140212</date><lang>EN</lang></document-id><document-id mxw-id="PAPP193868027" load-source="patent-office" format="original"><country>EP</country><doc-number>14711607.3</doc-number><date>20140212</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC162031165" ucid="IB-2014058946-W" linkage-type="W" load-source="docdb"><document-id format="epo"><country>IB</country><doc-number>2014058946</doc-number><kind>W</kind><date>20140212</date></document-id></priority-claim><priority-claim mxw-id="PPC162033795" ucid="US-201313855611-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201313855611</doc-number><kind>A</kind><date>20130402</date></document-id></priority-claim><priority-claim mxw-id="PPC162029526" ucid="US-201361769083-P" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201361769083</doc-number><kind>P</kind><date>20130225</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1833755357" load-source="docdb">H04L  12/741       20130101ALI20170321BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-1833755358" load-source="docdb">H04L  12/721       20130101ALI20170321BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-1833755359" load-source="docdb">H04L  12/715       20130101AFI20170321BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1987765184" load-source="docdb" scheme="CPC">H04L  45/64        20130101 LI20151204BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987768639" load-source="docdb" scheme="CPC">H04L  45/38        20130101 LI20150225BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987769665" load-source="docdb" scheme="CPC">H04L  45/54        20130101 LI20150225BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987791516" load-source="docdb" scheme="CPC">H04L  45/745       20130101 FI20141003BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT165549053" lang="DE" load-source="patent-office">VERFAHREN UND SYSTEM ZUR FLIESSTABELLENSUCHPARALLELISIERUNG IN EINEM SOFTWAREDEFINIERTEN NETZWERKSYSTEM</invention-title><invention-title mxw-id="PT165549054" lang="EN" load-source="patent-office">METHOD AND SYSTEM FOR FLOW TABLE LOOKUP PARALLELIZATION IN A SOFTWARE DEFINED NETWORKING (SDN) SYSTEM</invention-title><invention-title mxw-id="PT165549055" lang="FR" load-source="patent-office">PROCÉDÉ ET SYSTÈME DE PARALLÉLISATION DE CONSULTATION DE TABLE DE FLUX DANS UN SYSTÈME DE RÉSEAU DÉFINI PAR LOGICIEL (SDN)</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR1103316235" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>ERICSSON TELEFON AB L M</last-name><address><country>SE</country></address></addressbook></applicant><applicant mxw-id="PPAR1103302605" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>TELEFONAKTIEBOLAGET L M ERICSSON (PUBL)</last-name></addressbook></applicant><applicant mxw-id="PPAR1101642011" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Telefonaktiebolaget L M Ericsson (Publ)</last-name><iid>101460901</iid><address><city>164 83 Stockholm</city><country>SE</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR1103330577" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>ZHANG YING</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103335935" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>ZHANG, YING</last-name></addressbook></inventor><inventor mxw-id="PPAR1101645608" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>ZHANG, YING</last-name><address><street>5474 Midday Common</street><city>Fremont, California 94555</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103309664" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>BEHESHTI-ZAVAREH NEDA</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103312665" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>BEHESHTI-ZAVAREH, NEDA</last-name></addressbook></inventor><inventor mxw-id="PPAR1101653220" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>BEHESHTI-ZAVAREH, NEDA</last-name><address><street>3500 Palmilla Dr. Unit 1026</street><city>San Jose, California 95134</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103343825" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>BELIVEAU LUDOVIC</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR1103333933" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>BELIVEAU, LUDOVIC</last-name></addressbook></inventor><inventor mxw-id="PPAR1101647898" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>BELIVEAU, LUDOVIC</last-name><address><street>214 rue Riopelle</street><city>St-Constant, Québec J5A 0G7</city><country>CA</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR1101643972" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Rees, Simon John Lewis</last-name><iid>100819336</iid><address><street>Haseltine Lake LLP Redcliff Quay 120 Redcliff Street</street><city>Bristol BS1 6HU</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="IB-2014058946-W"><document-id><country>IB</country><doc-number>2014058946</doc-number><kind>W</kind><date>20140212</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2014128598-A1"><document-id><country>WO</country><doc-number>2014128598</doc-number><kind>A1</kind><date>20140828</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS660624010" load-source="docdb">AL</country><country mxw-id="DS660625458" load-source="docdb">AT</country><country mxw-id="DS660624024" load-source="docdb">BE</country><country mxw-id="DS660709463" load-source="docdb">BG</country><country mxw-id="DS660703166" load-source="docdb">CH</country><country mxw-id="DS660624742" load-source="docdb">CY</country><country mxw-id="DS660625467" load-source="docdb">CZ</country><country mxw-id="DS660624025" load-source="docdb">DE</country><country mxw-id="DS660624751" load-source="docdb">DK</country><country mxw-id="DS660624752" load-source="docdb">EE</country><country mxw-id="DS660724965" load-source="docdb">ES</country><country mxw-id="DS660709464" load-source="docdb">FI</country><country mxw-id="DS660709465" load-source="docdb">FR</country><country mxw-id="DS660624026" load-source="docdb">GB</country><country mxw-id="DS660624753" load-source="docdb">GR</country><country mxw-id="DS660624047" load-source="docdb">HR</country><country mxw-id="DS660625468" load-source="docdb">HU</country><country mxw-id="DS660703167" load-source="docdb">IE</country><country mxw-id="DS660624754" load-source="docdb">IS</country><country mxw-id="DS660709466" load-source="docdb">IT</country><country mxw-id="DS660624759" load-source="docdb">LI</country><country mxw-id="DS660788729" load-source="docdb">LT</country><country mxw-id="DS660703246" load-source="docdb">LU</country><country mxw-id="DS660788730" load-source="docdb">LV</country><country mxw-id="DS660788731" load-source="docdb">MC</country><country mxw-id="DS660703251" load-source="docdb">MK</country><country mxw-id="DS660703252" load-source="docdb">MT</country><country mxw-id="DS660724966" load-source="docdb">NL</country><country mxw-id="DS660709471" load-source="docdb">NO</country><country mxw-id="DS660703253" load-source="docdb">PL</country><country mxw-id="DS660703168" load-source="docdb">PT</country><country mxw-id="DS660724971" load-source="docdb">RO</country><country mxw-id="DS660703169" load-source="docdb">RS</country><country mxw-id="DS660703254" load-source="docdb">SE</country><country mxw-id="DS660624048" load-source="docdb">SI</country><country mxw-id="DS660709472" load-source="docdb">SK</country><country mxw-id="DS660703259" load-source="docdb">SM</country><country mxw-id="DS660624760" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><abstract mxw-id="PA139077590" ref-ucid="WO-2014128598-A1" lang="EN" load-source="patent-office"><p num="0000">A method implemented in a Software Defined Networking (SDN) network for flow table lookup parallelization is disclosed. The SDN network contains at least a SDN controller and at least a forwarding element and the SDN network utilizes a plurality of flow tables to perform lookup for forwarding traffic. The method starts with determining dependency of flow tables within the forwarding element using a set of dependency determination rules. A dependency graph is then constructed based on determined dependency of flow tables. A dependency degree count for each flow table within the forwarding element is determined based on the dependency graph. Based on the dependency degree count determination for each flow table, a plurality of parallel lookup groups (PLGs) for the forwarding element is formed, where each parallel lookup group contains one or more flow tables having a same dependency degree count.</p></abstract><abstract mxw-id="PA139544326" ref-ucid="WO-2014128598-A1" lang="EN" source="national office" load-source="docdb"><p>A method implemented in a Software Defined Networking (SDN) network for flow table lookup parallelization is disclosed. The SDN network contains at least a SDN controller and at least a forwarding element and the SDN network utilizes a plurality of flow tables to perform lookup for forwarding traffic. The method starts with determining dependency of flow tables within the forwarding element using a set of dependency determination rules. A dependency graph is then constructed based on determined dependency of flow tables. A dependency degree count for each flow table within the forwarding element is determined based on the dependency graph. Based on the dependency degree count determination for each flow table, a plurality of parallel lookup groups (PLGs) for the forwarding element is formed, where each parallel lookup group contains one or more flow tables having a same dependency degree count.</p></abstract><abstract mxw-id="PA139077591" ref-ucid="WO-2014128598-A1" lang="FR" load-source="patent-office"><p num="0000">L'invention porte sur un procédé de parallélisation de consultation de table de flux mis en œuvre dans un réseau défini par logiciel (SDN). Le réseau SDN contient au moins un contrôleur SDN et au moins un élément d'acheminement, et le réseau SDN utilise une pluralité de tables de flux pour effectuer une consultation pour acheminer du trafic. Le procédé commence par la détermination d'une dépendance de tables de flux dans l'élément d'acheminement à l'aide d'un ensemble de règles de détermination de dépendance. Un graphe de dépendance est ensuite construit sur la base de la dépendance déterminée de tables de flux. Un compte de degré de dépendance pour chaque table de flux dans l'élément d'acheminement est déterminé sur la base du graphe de dépendance. Sur la base du compte de degré de dépendance déterminé pour chaque table de flux, une pluralité de groupes de consultation parallèle (PLG) pour l'élément d'acheminement sont formés, chaque groupe de consultation parallèle contenant une ou plusieurs tables de flux ayant un même compte de degré de dépendance.</p></abstract><abstract mxw-id="PA139544327" ref-ucid="WO-2014128598-A1" lang="FR" source="national office" load-source="docdb"><p>L'invention porte sur un procédé de parallélisation de consultation de table de flux mis en œuvre dans un réseau défini par logiciel (SDN). Le réseau SDN contient au moins un contrôleur SDN et au moins un élément d'acheminement, et le réseau SDN utilise une pluralité de tables de flux pour effectuer une consultation pour acheminer du trafic. Le procédé commence par la détermination d'une dépendance de tables de flux dans l'élément d'acheminement à l'aide d'un ensemble de règles de détermination de dépendance. Un graphe de dépendance est ensuite construit sur la base de la dépendance déterminée de tables de flux. Un compte de degré de dépendance pour chaque table de flux dans l'élément d'acheminement est déterminé sur la base du graphe de dépendance. Sur la base du compte de degré de dépendance déterminé pour chaque table de flux, une pluralité de groupes de consultation parallèle (PLG) pour l'élément d'acheminement sont formés, chaque groupe de consultation parallèle contenant une ou plusieurs tables de flux ayant un même compte de degré de dépendance.</p></abstract><description mxw-id="PDES78477430" ref-ucid="WO-2014128598-A1" lang="EN" load-source="patent-office"><!-- EPO <DP n="2"/>--><p id="p0001" num="0001"> METHOD AND SYSTEM FOR FLOW TABLE LOOKUP </p><p id="p0002" num="0002"> PARALLELIZATION IN A SOFTWARE DEFINED NETWORKING (SDN) </p><p id="p0003" num="0003"> SYSTEM CROSS-REFERENCE TO RELATED APPLICATION </p><p id="p0004" num="0004"> This application claims priority from U.S. Provisional Patent Application No. 61/769,083, filed on February 25, 2013. </p><p id="p0005" num="0005">FIELD </p><p id="p0006" num="0006"> The embodiments of the invention are related to the field of packet forwarding in a data network. More specifically, the embodiments of the invention relate to a method and system to improve efficiency of flow table lookup at a Software Defined Networking (SDN) system. </p><p id="p0007" num="0007">BACKGROUND </p><p id="p0008" num="0008"> In a traditional data network, the functions relating forwarding traffic and determining where to send traffic is done by a single apparatus. For example, an Ethernet switch in a data network is commonly said to contain a control plane and a data plane. The data plane sometimes referred to as a forwarding plane or a media plane. Data networks are sometimes referred to as computer networks, computing networks, or simply networks. These terms are used interchangeably in this specification. </p><p id="p0009" num="0009"> For an Ethernet switch in a traditional data network for example, a control plane typically determines how an Ethernet frame is to be forwarded (e.g., the next hop for the frame and the outgoing port for the frame), and the data plane is in charge of forwarding the frame. The control plane typically includes one or more forwarding/routing protocols (e.g., Border Gateway Protocol (BGP), Interior Gateway Protocol(s) (IGP) (e.g., Open Shortest Path First (OSPF), Spanning Tree Protocol (STP), Intermediate System to Intermediate System (IS-IS), Label Distribution Protocol (LDP), Internet Control Message Protocol (ICMP)) that communicate with other network devices to exchange paths and select those paths based on one or more metrics. The data plane forwards frames based on input from the control plane. 
<!-- EPO <DP n="3"/>-->
 The traditional integrated approach of the control plane and the data plane being tightly coupled in a single box may result in an overly complicated control plane and complex network management. Due to high complexity, equipment vendors and network operators are often reluctant to initiate changes and the network itself can become fragile and hard to manage over time. This is known to create a large burden and high barrier to new protocol and technology developments. </p><p id="p0010" num="0010"> Software Defined Networking (SDN) is a network architecture that aims at decoupling control plane functions from data plane functions such that separate apparatuses may be utilized for different functions. In the SDN architecture, network intelligence and states are logically centralized, and the underlying network infrastructure is abstracted from the applications. As a result, networking may be simplified and new applications become feasible. For example, network virtualization can be accomplished by implementing it in a software application where the control plane is separated from the data plane. Also, a network administrator of a SDN system may have programmable central control of network traffic without requiring physical access to the system's hardware devices. With these benefits, SDN architecture based systems (referred to as SDN systems or SDN networks exchangeably herein below) are gaining popularity among carriers and enterprises. </p><p id="p0011" num="0011"> One approach to popularize SDN architecture is to apply globally aware and topology decoupled software control at the edges of a core network. The assumption is that traditional topology-coupled network devices drive core networks (often an IP based networks), and SDN architecture should keep scalability, interoperability, high- availability, and extensibility of the core network intact. Thus a set of open commands for forwarding traffic has been defined in the form of a protocol known as OpenFlow (OF). The OpenFlow protocol enables globally aware centralized or distributed software controllers to drive the network edge hardware in order to create an easily programmable identity based overlay on top of the traditional core networks. The OpenFlow protocol has been standardized by specifications. For example, the Open Networking Foundation (ONF), an industrial consortium focusing on commercializing SDN and its underlying technologies, has been promoting OpenFlow specifications (latest version being 1.3.2, approved in September 2012). 
<!-- EPO <DP n="4"/>-->
 In a SDN network, flow tables are used to direct traffic routing, where a field of a flow table matching with a field of an incoming traffic directs an incoming traffic to take instructions within the flow table. In early SDN architectures, a large flat table has been proposed to forward traffic. Yet a single table for traffic forwarding comes with complex rules associated with the single table. Thus, later SDN architectures (e.g., one complying with OpenFlow specification version 1.1.0) utilize multiple tables for traffic processing in a SDN network. When multiple tables are utilized, how to optimize multiple flow table lookup is a challenge. </p><p id="p0012" num="0012">SUMMARY </p><p id="p0013" num="0013"> A method implemented in a Software Defined Networking (SDN) network for flow table lookup parallelization is disclosed. The SDN network contains at least a SDN controller to coordinate traffic forwarding and at least a forwarding element to forward traffic and the SDN network utilizes a plurality of flow tables to perform lookup for forwarding traffic at the forwarding element. The method starts with determining dependency of flow tables within the forwarding element using a set of one or more dependency determination rules. A dependency graph is then constructed based on determined dependency of flow tables. A dependency degree count for each flow table within the forwarding element is determined based on the dependency graph. Based on the dependency degree count determination for each flow table, a plurality of parallel lookup groups (PLGs) for flow tables on the same forwarding element is formed, where each parallel lookup group contains one or more flow tables, and the one or more flow tables of each parallel lookup group thus can be looked up simultaneously. </p><p id="p0014" num="0014"> A network device in a Software Defined Networking (SDN) network is disclosed. The SDN network contains at least a SDN controller to coordinate traffic forwarding and at least a forwarding element to forward traffic, where the SDN network utilizes a plurality of flow tables to perform lookup for forwarding traffic at the forwarding element. The network device (such as a SDN controller) contains a flow table interface logic configured to receive a set of flow tables and a dependency determination logic configured to determine dependency of flow tables within a forwarding element using a set of dependency determination rules. The network device 
<!-- EPO <DP n="5"/>-->
 further contains a dependency degree computing logic configured to construct a dependency graph based on determined dependency of flow tables, the dependency degree computing logic further configured to determine a dependency degree count for each flow table within the forwarding element based on the dependency graph, and the dependency degree computing logic further configured to form a plurality of parallel lookup groups (PLGs) for the forwarding element based on the dependency degree count for each flow table, where each parallel lookup group contains one or more flow tables, and wherein the one or more flow tables of each parallel lookup group has a same dependency degree count. The network device further contains a parallel lookup group database configured to store the PLGs computed by the dependency degree computing logic. </p><p id="p0015" num="0015">BRIEF DESCRIPTION OF THE DRAWINGS </p><p id="p0016" num="0016"> The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that different references to "an" or "one" embodiment in this specification are not necessarily to the same embodiment, and such references mean at least one. Further, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the art to affect such feature, structure, or characteristic in connection with other embodiments whether or not explicitly described. </p><p id="p0017" num="0017"> Figure 1 is a block diagram illustrating a SDN network. </p><p id="p0018" num="0018"> Figure 2 is a block diagram illustrating multiple flow tables. </p><p id="p0019" num="0019"> Figure 3 is a block diagram illustrating flow table lookup parallelization according to one embodiment of the invention. </p><p id="p0020" num="0020"> Figure 4 is a flow diagram illustrating a method of effective flow table lookup parallelization according to one embodiment of the invention. </p><p id="p0021" num="0021"> Figures 5A-C illustrate scenarios causing flow table dependency according to embodiments of the invention. </p><p id="p0022" num="0022"> Figure 6 illustrates a method for determining flow table dependency according to one embodiment of the invention. 
<!-- EPO <DP n="6"/>-->
 Figure 7 is a flow diagram illustrating a method for determining flow table dependency degree count according to one embodiment of the invention. </p><p id="p0023" num="0023"> Figures 8A-D illustrate a method for determining flow table dependency degree count according to one embodiment of the invention. </p><p id="p0024" num="0024"> Figure 9 illustrates an implementation of parallel lookup groups (PLGs) according to one embodiment of the invention. </p><p id="p0025" num="0025"> Figure 10 is a block diagram illustrating a network device containing a processor implementing flow table lookup parallelization according to one embodiment of the invention. DETAILED DESCRIPTION </p><p id="p0026" num="0026"> In the following description, numerous specific details are set forth. However, it is understood that embodiments of the invention may be practiced without these specific details. In other instances, well-known circuits, structures and techniques have not been shown in detail in order not to obscure the understanding of this description. It will be appreciated, however, by one skilled in the art that the invention may be practiced without such specific details. Those of ordinary skill in the art, with the included descriptions, will be able to implement appropriate functionality without undue experimentation. </p><p id="p0027" num="0027"> References in the specification to "one embodiment," "an embodiment," "an example embodiment," etc., indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic. Moreover, such phrases are not necessarily referring to the same embodiment. Further, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the art to effect such feature, structure, or characteristic in connection with other embodiments whether or not explicitly described. </p><p id="p0028" num="0028"> In the following description and claims, the terms "coupled" and "connected," along with their derivatives, may be used. It should be understood that these terms are not intended as synonyms for each other. "Coupled" is used to indicate that two or more elements, which may or may not be in direct physical or electrical contact with 
<!-- EPO <DP n="7"/>-->
 each other, co-operate or interact with each other. "Connected" is used to indicate the establishment of communication between two or more elements that are coupled with each other. </p><p id="p0029" num="0029"> As used herein, a network device (e.g., a switch) is a piece of networking equipment, including hardware and software that communicatively interconnects other equipment on the network (e.g., other network devices, end systems). Some network devices are "multiple services network devices" that provide support for multiple networking functions (e.g., routing, bridging, VLAN (virtual LAN) switching, Layer 2 aggregation, session border control, Quality of Service, and/or subscriber management), and/or provide support for multiple application services (e.g., data, voice, and video). Subscriber end systems (e.g., servers, workstations, laptops, netbooks, palm tops, mobile phones, smartphones, multimedia phones, Voice Over Internet Protocol (VOIP) phones, user equipment, terminals, portable media players, GPS units, gaming systems, set-top boxes) access content/services provided over the Internet and/or content/services provided on virtual private networks (VPNs) overlaid on (e.g., tunneled through) the Internet. The content and/or services are typically provided by one or more end systems (e.g., server end systems) belonging to a service or content provider or end systems participating in a peer to peer service, and may include, for example, public webpages (e.g., free content, store fronts, search services), private webpages (e.g., username/password accessed webpages providing email services), and/or corporate networks over VPNs. Typically, subscriber end systems are coupled (e.g., through customer premise equipment coupled to an access network (wired or wirelessly)) to edge network devices, which are coupled (e.g., through one or more core network devices) to other edge network devices, which are coupled to other end systems (e.g., server end systems). A network device is generally identified by its media access (MAC) address, Internet protocol (IP) address/subnet, network sockets/ports, and/or upper OSI layer identifiers. </p><p id="p0030" num="0030"> Network Configuration and Operations </p><p id="p0031" num="0031"> Figure 1 is a block diagram illustrating a SDN network. SDN network 100 comprises a number of forwarding elements and a number of controllers that instruct the forwarding elements' forwarding behavior. Note a SDN network may contain a much larger number of network devices and existing network devices may be 
<!-- EPO <DP n="8"/>-->
 implemented with SDN compatible protocols thus become a part of a SDN network (e.g., an existing IP router may support OpenFlow protocol and thus become a SDN forwarding element or a SDN controller). Thus SDN network 100 is for illustrating logical SDN network configuration only. </p><p id="p0032" num="0032"> Forwarding Elements </p><p id="p0033" num="0033"> The main task of a SDN forwarding element (referred to as an OpenFlow switch or simply switch in OpenFlow parlance when the SDN complies with OpenFlow standards), is to forward packets within the SDN forwarding element from an ingress port to an egress port, according to the rules in flow tables programmed by one or more SDN controllers. Each flow entry contains a set of actions such as forwarding packets to a given port, modifying certain bits in a packet header, encapsulating packets to the SDN controller, or dropping the packets. For the first packet in a new flow, the forwarding element often forwards the packet to the SDN controller to trigger the new flow being programmed. It can also be used to forward slow-path packets such as Internet Control Message Protocol (ICMP) packets to the SDN controller for processing. Note that the concept of a flow can be defined broadly, e.g., a TCP connection, or all traffic from a particular MAC address or IP address. Also note that a packet within a SDN network is defined broadly and it may be an Ethernet frame, an IP network packet, or a message in a proprietary format. </p><p id="p0034" num="0034"> SDN Controllers </p><p id="p0035" num="0035"> A SDN controller (often referred to as a remote controller or controller) adds and removes flow-entries from a flow table. It defines the interconnection and routing among a set of SDN forward elements and other network devices. It also handles network state distribution, such as collecting information from the set of SDN forward elements and distributing forwarding/routing instructions to them. The SDN controller can also be programmed to support new addressing, routing, and complex packet processing applications. The SDN controllers are the "brains" of a SDN network. A forwarding element needs to connect to at least one SDN controller to function correctly. </p><p id="p0036" num="0036"> Referring to Figure 1, SDN network 100 contains SDN controllers 102 and 104 and a set of forwarding elements (or switches, the terms "forwarding element," "SDN 
<!-- EPO <DP n="9"/>-->
 switch," and "switch" are used interchangeably herein below) A - F. Controller 102 (the terms "controller" and "SDN controller" are used interchangeably herein below) manages switches A - C and controller 104 manages switches D - G respectively, and a switch connects to its managing controller through a communication channel and the switch not necessarily has a direct connectivity to a controller (thus the term "remote" controller). </p><p id="p0037" num="0037"> A SDN switch can be viewed logically as containing two main components. One is a control plane and the other is a forwarding plane. A zoom-in view of switch C illustrates the two planes. Switch C contains control plane 162 and forwarding plane 164. Control plane 162 coordinates management and configuration of switch C. Configuration of forwarding plane 164 is achieved by running applications on host processor 152. Host processor 152 usually runs an operating system in order to provide a well-known development environment. Commands from host processor 152 are sent to the switch processor 154 using an interconnect (e.g., a peripheral component interconnect (PCI) bus). Exception packets (e.g., packet for routing and management) are often processed on host processor 152. Switch processor 154 interacts with various forwarding ports 158 of switch C to forward and otherwise process incoming and outgoing packets. </p><p id="p0038" num="0038"> Forwarding plane 164 is responsible for forwarding traffic (forwarding operations includes switching, routing, learning, etc.). It contains switch processor 154 that is designed to provide high throughput at the detriment of a more complex and flexible development environment. Different types high performance memory and hardware accelerator are often found on board of switch processor 154 for achieving the high throughput. In contrast, host processor 152 can be more complex and flexible at the detriment of providing high throughput as it processes more control packets (often referred to as slow path packets) than data packet thus throughput is less mission critical. </p><p id="p0039" num="0039"> When a switch (e.g., switch C) receives a packet associated with a new flow, it does not know where to forward the packet. Thus it sends the packet to its managing SDN controller, controller 102 in this example. Controller 102 receives the packet, and it programs a new flow entry and sends to switch C. Switch C then forwards the packet according to the new flow entry. 
<!-- EPO <DP n="10"/>-->
 A flow entry comprises match fields, counters, and a set of instructions to apply to matching packets. A SDN controller can add, update, and delete flow entries either reactively (in response to a receiving packet) or proactively. A set of flow entries may form a flow table (often referred to simply as table, the terms "flow table" and "table" are used interchangeably herein below), which can be used for a SDN switch to process packets. The earlier SDN networks designed around a large flat table that was vaguely inspired by the functionality provided by a TCAM (Ternary Content Addressable Memory). One major drawback with the approach is that a flat table creates a Cartesian product problem (also known as rule explosion, caused by cross product of rules). </p><p id="p0040" num="0040"> Thus, later SDN networks introduced the concept of multiple flow tables.</p><p id="p0041" num="0041">Multiple flow tables circumvent the table size restrictions of switching hardware (e.g. TCAM has major memory size limitations, in the order of a few megabits). The new approach of multiple flow tables also leads to a better resource utilization, provides opportunities to exploit multiple hardware tables, simplifies SDN controller logic, and allows more intuitive thinking in network design. In a SDN network with multiple flow tables, metadata is used between tables to pass information (often referred to as context). </p><p id="p0042" num="0042"> Figure 2 is a block diagram illustrating multiple flow tables according to one embodiment. In Figure 2, a packet is processed sequentially through multiple tables, one after another. The totality of sequential multiple tables sometimes is referred to as a "forwarding pipeline" or simply "pipeline," i.e. a set of linked flow tables that provide matching, forwarding, packet modification, and etc. in a SDN forwarding element (switch). </p><p id="p0043" num="0043"> Referring to Figure 2, forwarding element 250 is a forwarding element of a SDN network. It receives a packet at reference 252. The packet is sent to ingress port 212. Ingress port 212 is where a packet enters the forwarding element pipeline of forwarding element 250. Table 0 at reference 202 is the first flow table and matching starts at table 0. If a matching entry is found, the instructions associated with the matching entry of table 0, action set 222, will be executed. A flow entry may modify the action set 222 using a Write-Action instruction or a Clear- Action instruction associated with a particular match. The instruction in the matching flow entry may also explicitly direct the packet to another flow table (using a Goto Instruction), where the 
<!-- EPO <DP n="11"/>-->
 same process is repeated again. A flow entry can only direct a packet to a flow table number which is greater than its own flow table number. In other words, pipeline can only go forward and not backward. If the matching flow entry does not direct packets to another flow table, pipeline processing stops at the table. When pipeline processing stops, the packet is processed with an associated action set and usually forwarded. </p><p id="p0044" num="0044"> When action set 222 is applied to the packet, several instructions may be performed. The packet may be modified and match fields may be updated. Action set may be updated (e.g., clear actions and/or write actions instructions) to form action set 224. In addition, metadata, with a maskable register value that is used to carry information from one flow table to the next, may be updated to form metadata 214. The updated metadata 214 and action set 224 are then being utilized for lookup at table 1 (reference 204) to further process the packet. The process may continue until the packet goes through the pipeline at the last table, table n at reference 206 and finish with execution action set at reference 208. Then the packet completes processing at forwarding element 250 and exit at reference 254. </p><p id="p0045" num="0045"> This forwarding model often results in an implementation where the packet is resubmitted to the beginning of a pipeline (e.g., a pipeline implemented in a TCAM or another kind of memories) after it is implied that a packet needs to be sent to a subsequent table. Resubmitting packets at the beginning of the pipeline results in degradation in performance. That is because packets that come from a port have to compete for the same resources as the resubmitted packets. </p><p id="p0046" num="0046"> Another approach to implement multiple table lookup is to use a "run to completion" model where a hardware thread or engine handles the lifecycle of a packet. Each lookup results in stalling the hardware thread or engine until the result of the lookup is returned. Executing a high amount of lookups will most likely results in starving the processing resources while much of the hardware thread or engine is idle. </p><p id="p0047" num="0047"> Flow Table Lookup Parallelization </p><p id="p0048" num="0048"> Sequential flow table lookup approaches may not utilize network resources efficiently as discussed herein above. A few examples may provide a perspective about an alternative approach that will make multiple flow table lookup more effective, and the alternative approach is referred to as flow table lookup parallelization. 
<!-- EPO <DP n="12"/>-->
 (a) . For network maintenance, it is often useful for an operator of a network to be able to troubleshoot errors that may occur in her network. A flow table may be used to increment counters based on some tuples (e.g., a tuple for all HTTP traffic). This flow table is for debugging and monitoring; and it may be executed independently from other packet execution operations. </p><p id="p0049" num="0049"> (b) . In order to comply with legal intercept requirements (e.g., in the United States, the intercept requirements based on the Communications Assistance for Law Enforcement Act (CALEA)), an operator of a network may be mandated by law to mirror traffic matching a certain pattern within the network. A flow table may be used to define one or more intercepted patterns using a tuple. Once incoming packet matches the flow table upon lookup, a flow associated with the incoming packet may be sent to the SDN controller or another external server. The flow table here may apply to only certain packets with specific characteristics and the associated table lookup process is likely independent from other table lookups of the packet. </p><p id="p0050" num="0050"> (c). In order to provide diverse service offerings to customers, an operator of a network may offer service chaining. A customer may specify the parameters of services required. For example, a customer may require Deep Packet Inspection (DPI) or firewall for its services due to heighten network security concerns. A SDN network operator may form a flow table lookup sequence for traffic destined to a particular customer. Indeed, even a single customer may have multiple corresponding flow table look up chains for different packet types (e.g., web traffic and email traffic for a single customer follows different service chains for flow table lookups). The difference service chains likely can be processed through a forwarding element independent from each other. </p><p id="p0051" num="0051"> Figure 3 is a block diagram illustrating flow table lookup parallelization according to one embodiment of the invention. Forwarding element 390 contains three parallel processing flows. In each processing flow, packet goes through processes similar to the illustration in Figure 2. With table lookup parallelization, forwarding element 390 may perform multiple flow table lookups concurrently for independent flow tables. For example, in the example (a) above, a packet destined to a customer may go through the processing flow containing tables 0 - Q - ... for normal forwarding process, while the same packet may concurrently go through the processing flow 
<!-- EPO <DP n="13"/>-->
 containing tables J - L for debugging/monitoring (e.g., counting packet number to determine whether or not there is a deny-of-service attack). As debugging/monitoring can be processed independently from packet forwarding process, such parallelization adds little complexity for great performance improvement. Note that flow tables are often referred to by numeric orders such as tables 0, 1, and 2 in prior art in a SDN network. In this specification, flow tables are also referred to by letter as numeric reference of flow table implies the order of which flow tables are being looked up. Within the embodiments of the invention, the order of flow tables being looked up sometimes is unknown and the determination is an aspect of embodiments of the invention, thus letters sometimes are used to refer flow tables. For example, in Figure 3, flow table J may be looked up prior or after flow table K by a packet - the letter referring to flow tables does not imply an order of flow table lookup. </p><p id="p0052" num="0052"> For flow table lookup parallelization to improve SDN network performance, parallel flow tables for lookup need to be independent. Thus, one important consideration of parallelization is to determine dependency among flow tables. Several options are available for determining flow table dependency. </p><p id="p0053" num="0053"> A (simple) first approach is to provide information to a forwarding plane of a forwarding element about which flow tables are independent/dependent in a manual way. For example, in a SDN network complying with OpenFlow protocol, an extension (or a proprietary variation) of OpenFlow protocol may be implemented to provide the information. A drawback of this approach is that a rule enforcement point would need to be introduced in the SDN controller to make sure that a rule breaking the table dependencies would not be introduced. </p><p id="p0054" num="0054"> A second approach is for the SDN controller to analyze the rules within flow tables and determine the flow table dependencies of a forwarding element it manages. In this approach, the information needs to be transported to the forwarding plane and it would require a new interface or an extension to the existing protocol. However, a processor within a SDN controller may possess the computing power for the determination. </p><p id="p0055" num="0055"> A third approach is that a host processor (e.g., host processor 152 in Figure 1) at a SDN forwarding element (switch) can analyze the rules within flow tables that are 
<!-- EPO <DP n="14"/>-->
 sent to it and determine table dependencies. This approach does not require any modification on the existing protocol and it is transparent to the SDN controller. </p><p id="p0056" num="0056"> The embodiments of the invention discussed herein below follow the second or the third approach. That is, a SDN controller or a SDN forwarding element may perform flow table dependency determination based on rules within the flow tables without depending on other processing unit. While sequence of flow table lookup in a forwarding element is unknown a priori, the sequence of flow table lookup is fixed as in a forwarding pipeline or a section of the forwarding pipeline. One goal is to determine the fixed flow table lookup sequence such that field modifications or other operations are not conflicted between tables. </p><p id="p0057" num="0057"> Embodiments of Effective Flow Table Parallelization </p><p id="p0058" num="0058"> Figure 4 is a flow diagram illustrating a method of effective flow table lookup parallelization according to one embodiment of the invention. Method 400 may be performed on a SDN controller or a SDN forwarding element (switch) of a SDN network. The SDN network may comply with OpenFlow specifications. The method may be performed during a system initiation. For example, when a SDN controller or a SDN switch initiates services. The method may also be performed after an event trigger flow table dependency changes. In addition, the method may be performed once a forwarding element receives a packet and needs to determine how to perform flow table lookup - in other words, the method may be run at or near real-time. </p><p id="p0059" num="0059"> At reference 402, method 400 determines dependency of flow tables within a forwarding element using a set of rules. In order to form effective parallel flow table lookup, the method may determine which flow tables of the multiple flow tables in the forwarding pipeline are independent from each other; and when flow tables are dependent, how the dependency relationships exist. The determination may be achieved by considering the match fields and actions in each flow table. The applying the set of rules is discussed in more detail herein below. From reference 402, the dependency between given two flow tables are determined. A flow table may be independent, thus it does not depend on any flow table. Yet an independent (or dependent) flow table may be depended on by another flow table. When two flow tables have a dependency relationship, the flow table being depended on may be referred to as a "dependee" flow table while the dependent flow table is referred to as the "depender" flow table. 
<!-- EPO <DP n="15"/>-->
 At reference 404, a dependency graph is constructed based on dependency determination from reference 402. In the dependency graph, each node is a flow table and a link between two nodes indicates a dependency between two flow tables. A direction of a link from node X to node Y indicates flow table X needs to be looked up before flow table Y. That is, flow table Y depends on flow table X. Through drawing links between all dependency pairs of flow tables, a dependency graph captures all known dependency relationships of flow tables within a forwarding element. </p><p id="p0060" num="0060"> At reference 406, the method determines a dependency degree count of each flow table of the forwarding element. A dependency degree count of a flow table is a numeric number denoting how many flow tables the flow table depends on. For example, a flow table with zero dependency degree count means the flow table does not depend on any other flow table within the forwarding element. Sometimes dependency degree count is referred to as in-degree count, which is a term used in directed graph. The determination of a dependency degree count of flow tables will be discussed in more details herein below. </p><p id="p0061" num="0061"> Onward to reference 408, parallel lookup groups (PLGs) are formed based on a dependency degree count determination of each flow table in reference 406. Each PLG contains one or more flow tables having a same number of dependency degree counts. Thus flow tables within a PLG can be executed in parallel. The PLG membership information may be saved in a variety of data structures, such as a table, an array, or a set. The PLG membership information may be stored at the forwarding element so that a forwarding processor (such as switch processor 156 in Figure 1) may utilize the information for parallelized lookup processing. </p><p id="p0062" num="0062"> When a packet of a flow first comes in a port of a forwarding element, a forwarding processor of the forwarding element may examine the PLG information and execute the flow table lookups included in a first PLG, where the flow tables within the first PLG do not depend on another flow table (thus dependency degree is zero). Note that in particular processor implementation, a forwarding processor (e.g., a processor with an application-specific integrated circuit (ASIC) or a network processor unit (NPU)) may have a limit on how many flow table lookups it can execute in parallel thus only a specifically limited lookups can be executed in the forwarding processor. 
<!-- EPO <DP n="16"/>-->
 After the first PLG is looked up, the flow table lookups included in the following PLGs with increasing dependency degrees are executed. </p><p id="p0063" num="0063"> Once the flow table lookups are completed, the results are examined in order of the flow table IDs, which are in numeric orders. The Apply Actions are executed in order and the Write Actions are stored in the packet context in order. Also, each statistics corresponding to the match entries should be incremented accordingly (table match, flow match, etc.). If one of the lookups results in a no match, the procedure is not executed. If on a particular table match, the resulted match entry contains an output port action, the rest of the table results are ignored. The current PLG information is kept in the context of the packet. If there is more lookups to be done, the packet is recirculated at the beginning of the pipeline or a subsequent lookup phase. </p><p id="p0064" num="0064"> Embodiments of Flow Table Dependency Determination </p><p id="p0065" num="0065"> Figures 5A-C illustrate scenarios causing flow table dependency according to embodiments of the invention. In each Figure, a portion of a flow table, which contains one or more flow entries, is shown. Each flow entry contains a match field entry and an instruction field entry (sometimes referred to as action field entry). Note other fields, e.g., counter field, are ignored, as they are not essential to the embodiments of the invention. Match fields are to match against packets in a lookup and contain ingress port and packet headers, and optionally metadata specified by a previous table. Instruction field contain instruction/action to modify the action set or pipeline processing. </p><p id="p0066" num="0066"> Figure 5 A illustrates two entries in flow table 502, which has different Goto- Table actions in their instruction sets. The first entry has flow table j as its next table, and the second entry has flow table k as its next table. In other words, two different flow entries with two different tables as their next tables in the pipeline. In this example, flow table 502 should be looked up before both flow table j and flow table k - both flow table j and flow table k depend on flow table 502. </p><p id="p0067" num="0067"> Figure 5B illustrates a union of actions in one flow table overlapping with a union of matching fields in another flow table. A union of actions in one flow table is the superset of all actions in the flow table and a union of matching fields is the superset of all matching fields. When there is an overlap of an action in one flow table with a match field in another, the two flow tables can't be executed in parallel. 
<!-- EPO <DP n="17"/>-->
 Referring to Figure 5B, flow table 504 sets source IP address for a packet with matching source Ethernet identifier (ID). Flow table 506 sets multiprotocol label switching (MPLS) label for a packet with matching source IP address. The matching field of flow table 506 (source IP address) is a result of action of flow table 504 (setting source IP address), thus flow table 504 and flow table 506 cannot be looked up independently - the former should be looked up prior to the latter. In this example, flow table 504 is the dependee and flow table 506 is the depender in the dependency relationship between flow tables 504 and 506. </p><p id="p0068" num="0068"> Note match field may contain wildcard (i.e., "don't care") bits. For example, an IP address field in a match field may be like "192.168.X.X." This will be treated as an exact match. That is, regardless of whether there is an exact match or a wildcard match, if the field is among both the action set of the first table and the match fields of the second table, the second table depends on the first table thus should be looked up after the first table. </p><p id="p0069" num="0069"> Figure 5C illustrates a union of actions in one flow table overlapping with a union of actions in another flow table. When there is an overlap of actions in two flow tables, the two flow tables can't be executed in parallel. Referring to Figure 5C, flow table 508 sets source IP address with match field of source Ethernet ID; flow table 510 also sets source IP address with match field of source VLAN ID. The two flow tables need to be looked up serially (sequentially) to make sure the corresponding field (source IP address in this example) is updated correctly. In this example, the dependency relationship is determined by the numeric flow table identifiers (IDs), the flow table with the smaller ID is the dependee and the other flow table is the depender. </p><p id="p0070" num="0070"> While Figures 5A-C provide examples of determining flow table dependency, the illustrated scenarios may not be exhaustive and other factors to determine flow table dependency may apply to embodiments of the invention according to the principle disclosed herein. </p><p id="p0071" num="0071"> Figure 6 illustrates a method for determining flow table dependency according to embodiments of the invention. Method 600 may be implemented in a SDN controller or a SDN forwarding element (switch). In a SDN forwarding element, method 600 may be implemented in a host processor like host processor 152 in Figure 1. Method 600 may process through all flow tables in a forwarding element. 
<!-- EPO <DP n="18"/>-->
 At reference 604, the method examines that for any given two flow tables, whether a flow table modifies a metadata the other flow table used for lookup. Metadata carries information from one flow table to the next, and when the former flow table modifies metadata (e.g., through instruction as illustrated in Figure 5B) that the other flow table used for lookup (e.g., utilizing match field), the two flow tables have a dependency relationship with the former flow table being the dependee. Note the two flow tables can be looked up and modified part of the metadata where there is no overlap (e.g., determined by using metadata bit mask). In which case the two flow tables are not dependent on each other. The examination in reference 604 may be performed in all permutations of two flow tables within a forwarding element. </p><p id="p0072" num="0072"> At reference 606, the method examines that for any given two flow tables, whether a flow table contains an action in its instructions that the other flow table also contains. When two flow tables perform same actions, they need to be looked up sequentially to maintain data integrity. Similar to the examination in reference 604, the examination in reference 606 may be performed in all permutations of two flow tables within a forwarding element. </p><p id="p0073" num="0073"> After method 600 completes, dependency of all flow tables within a forwarding element is determined and the dependency then can be used in an intelligent flow table parallelization. Note the three separate examinations may be performed in an order differently than illustrated in Figure 6 as the examinations do not depend on each other, and the principle within can be applied to other implementations for dependency determination. Also, in some embodiments of the invention, not all three examinations are performed, while in other embodiments of the invention, more than the three examinations are performed. </p><p id="p0074" num="0074"> Embodiments of Determining Flow Table Dependency Degree Count </p><p id="p0075" num="0075"> Figure 7 is a flow diagram illustrating a method for determining flow table dependency degree count according to one embodiment of the invention. As discussed herein above, based on dependency determination of all flow tables within a forwarding element, a dependency graph may be constructed. In the dependency graph, each node is a flow table and a link between two nodes indicates a dependency between two flow tables. A direction of a link from node X to node Y indicates flow table X needs to be looked up before flow table Y. That is, flow table Y depends on flow table X. Through 
<!-- EPO <DP n="19"/>-->
 drawing links between all dependency pairs of flow tables, a dependency graph captures all known dependency relationships of flow tables within a forwarding element. With a known dependency graph, Figure 7 discloses a method of determining flow table dependency degree count. Method 700 may be performed by a SDN forwarding element (e.g., host processor 152 in Figure 1) or a SDN controller (e.g., controller 102 in Figure 1). </p><p id="p0076" num="0076"> Method 700 starts with selecting a dependency graph at reference 701. With known dependencies of flow tables, a dependency graph for a forwarding element can be constructed. In the dependency graph, a node with no dependency is found at reference 702. A node with no dependency has zero in-degree and depends on no other nodes in the dependency graph. When there are multiple nodes with zero in-degree, a node with the maximum out-degree is selected. That is, the method selects a dependee node with the most depender nodes. The rationale is that the larger out-degree a dependee node has, the more depender nodes are waiting for the dependee node to finish before any of the depender nodes can be executed. </p><p id="p0077" num="0077"> The found node then is marked as processed at reference 704 with its current degree count being recorded. If the found node has not been processed before, its current degree count will be zero. Being "processed" means that the relative time to process the node has been determined. Once the found node is processed, all links from the found node to its depender nodes are removed at reference 706. Thus, in the updated dependency graph, the dependencies of depender nodes to the depender node are reduced. Then at reference 708, the dependency degree count associated with each dependee node is increased by one. That is, the dependee node is recorded with a known dependency degree count. Onward to reference 710, the found dependee node is removed from the process queue, and another node with no dependency in the updated dependency graph is selected and the process repeated starting at reference 702. Since more links are removed at each iteration, all links between links will be removed eventually, at which point the process completes. After method 700 completes, each node will contain a dependency degree count indicates the node's dependency degree. </p><p id="p0078" num="0078"> Figures 8A-D illustrate a method for determining flow table dependency degree count according to one embodiment of the invention. Figure 8 A illustrate a dependency graph for a forwarding element with seven nodes representing seven flow tables. Node 
<!-- EPO <DP n="20"/>-->
 A does not depend on any other nodes and it is the only node does not depend on any other nodes, thus it is selected for processing at Figure 8B. In Figure 8B, node A is marked as processed, and the marking is represented by changing the node representation from a square to a circle. After node A is processed, its current dependency degree count is recorded. Since it does not depend on any other nodes, its dependency degree count is zero. </p><p id="p0079" num="0079"> Then at Figure 8C, all links from node A to other nodes are removed, and the dependee nodes increase their dependency degree count by one. Since none of the nodes has dependency degree count set at this point, the counter is default at zero before the increasing of dependency degree count. Thus both nodes B and C now have dependency degree counts of one after removing links from node A to nodes B and C. </p><p id="p0080" num="0080"> Onward to Figure 8D, the processed node, node A is removed from the process queue and the process starts over again to select a node with no dependency. Now both nodes and C have zero in-degree. In this case, the node with the most out-degree is selected for processing. Node B has out-degree of two as both nodes D and E depend on node B while node C only has out-degree of one, thus node B is selected for processing. Node B is marked as processed. The same process for node A then is repeated for node B. After node B is processed, nodes C and F go through the same process. After the full process, dependency counts for all seven nodes are determined. </p><p id="p0081" num="0081"> Embodiments of Parallel Lookup Groups (PLGs) </p><p id="p0082" num="0082"> Figure 9 illustrates an implementation of parallel lookup groups according to one embodiment of the invention. After dependency degree counts are determined for each node (flow table) of a forwarding element, the dependency degree counts are then used to form parallel lookup groups (PLGs) for the forwarding element. The PLG membership information of a forwarding element may be saved in a variety of data structures, such as a table, an array, or a set. The PLG membership information may be stored at the forwarding element so that a forwarding processor may utilize the information for parallelized lookup processing. </p><p id="p0083" num="0083"> Referring to Figure 9, flow tables 0, 1, 5, and 7 do not depend on any other flow table in a forwarding element, and thus they are in the PLG of dependency degree of zero at reference 902. The lookups of these flow tables will be executed ahead of tables 2, 3, and 8, The lookups of which will in turn be executed ahead of tables 4, 6, and 9, as 
<!-- EPO <DP n="21"/>-->
 the former group is in PLG of dependency degree of one at reference 904 and the latter group is in PLG of dependency degree of two at reference 906. </p><p id="p0084" num="0084"> With parallelized table lookups, a forwarding element may execute independent lookups concurrently without degrading system performance. In this example, up to four independent flow tables may be looked up concurrently (tables 0, 1, 5, and 7 at PLG of zero dependency), and the parallelization improves the efficiency of a SDN network. </p><p id="p0085" num="0085"> An embodiment of the invention is illustrated with pseudo code below. Note that conditions 1, 2, or 3 are the three tests illustrated in Figure 6. 
<!-- EPO <DP n="22"/>-->
</p><p id="p0086" num="0086">Algorithm I Parallel .lookup optimization algorithm</p><p id="p0087" num="0087"> rocedure Optimize_Lookup{T} </p><p id="p0088" num="0088"> for Table i in T do </p><p id="p0089" num="0089"> for Table j T, j≠ i do </p><p id="p0090" num="0090"> Create node i mid j in G </p><p id="p0091" num="0091"> for every entry e*,.<sub>(</sub> and e¾, in i j do </p><p id="p0092" num="0092"> if ReiationshipCe^, e&amp;) satisfies condition 1 or 2 or 3 then Create i j, break; </p><p id="p0093" num="0093"> end if </p><p id="p0094" num="0094"> if Reialionship(ei, e<sup>z</sup><sub>m</sub>) satisfies condition 1 or 2 or 3 then</p><p id="p0095" num="0095">Create j i<sub>t</sub> break: </p><p id="p0096" num="0096"> end if </p><p id="p0097" num="0097"> end for </p><p id="p0098" num="0098"> end for </p><p id="p0099" num="0099"> end for </p><p id="p0100" num="0100"> gixnipNura ~ 0; </p><p id="p0101" num="0101"> while 3 unprocessed n in G do </p><p id="p0102" num="0102"> for every oode ninG do </p><p id="p0103" num="0103"> if then</p><p id="p0104" num="0104"><img id="imgf000022_0001" he="13" wi="32" file="imgf000022_0001.tif" img-format="tif" img-content="drawing" orientation="portrait" inline="no"/></p><p id="p0105" num="0105"> end if </p><p id="p0106" num="0106"> end i r </p><p id="p0107" num="0107"> Sort 1G according to the oisldegre </p><p id="p0108" num="0108"> groupNmn 4- - for Every node n<sup>(</sup>€ Sortetil do </p><p id="p0109" num="0109"> En ueue </p><p id="p0110" num="0110"> group{n?) = groupNmn </p><p id="p0111" num="0111"> end for </p><p id="p0112" num="0112"> while QUEUE d </p><p id="p0113" num="0113"> dequeue the top node nf </p><p id="p0114" num="0114"> for every node k with edge h do</p><p id="p0115" num="0115"> m ve the dge nf — ^ fe </p><p id="p0116" num="0116"> end fo </p><p id="p0117" num="0117"> end while </p><p id="p0118" num="0118"> end while 
<!-- EPO <DP n="23"/>-->
 Network Devices Implementing Flow Table Lookup Parallelization </p><p id="p0119" num="0119"> Figure 10 is a block diagram illustrating a network device containing a processor implementing flow table lookup parallelization according to one embodiment of the invention. Dependency processor 1000 may be a standalone processor or a part of a processor within a SDN forwarding element or a SDN controller, i.e., network device 1050 may be a forwarding element or a controller. When dependency processor 1000 is a part of a larger processor, it may have dedicated NPU or share processing unit with other application. When dependency processor 1000 is a part of a SDN forwarding element, it's likely implemented in the control plane, for example, as a part of a host processor of the SDN forwarding element. </p><p id="p0120" num="0120"> Processor 1000 may contain flow table interface logic 1002, dependency determination logic 1006, dependency degree computing logic 1020, and parallel lookup groups (PLGs) database 1052. Various logics are interconnected through interconnect 1022. Note that various logics can be implemented as a single unit or multiple units, the unit or units integrate various logics and perform similar function as the logics of Node 1000, and these logics can be implemented in software, hardware or a combination thereof. In addition, some logics illustrated in Figure 10 may be implemented outside of processor 1000 but communicatively coupled with processor 1000. </p><p id="p0121" num="0121"> Flow table interface logic 1002 is configured to interface various flow tables. It receives flow tables from other elements of a SDN network, and it outputs dependency determination for optimizing flow table lookup parallelization. Dependency determination logic is configured to determine flow table lookup dependency for a given pair of flow tables. Dependency degree computing logic computes dependency degrees after dependency determination logic determines dependency relationships of flow tables with a forwarding element. The result of dependency degree computing logic 1020 is saved to parallel lookup group (PLG) database 1052, which stores PLG membership information for the forwarding element. </p><p id="p0122" num="0122"> In one embodiment, flow table interface logic 1002 is configured to receive flow tables in a forwarding element, and it forwards the information to dependency determination logic 1006, which determines all dependency relationships between all flow tables of the forwarding element. The determination of dependency determination 
<!-- EPO <DP n="24"/>-->
 logic 1006 then is used to construct a dependency graph. The dependency graph is passed to dependency degree computing logic 1020 to compute dependency degree of each flow table. The determination then is used to form parallel lookup groups (PLG) and the PLG membership information is stored to PLG database 1052, which can be used for parallelizing flow table lookups. </p><p id="p0123" num="0123"> The operations of the flow diagram will be described with reference to the exemplary embodiment of Figure 10. However, it should be understood that the operations of flow diagrams can be performed by embodiments of the invention other than those discussed with reference to Figures 4, 6, and 7, and the embodiments discussed with reference to Figure 10 can perform operations different than those discussed with reference to the flow diagrams of Figures 4, 6, and 7. </p><p id="p0124" num="0124"> While the flow diagrams in the figures herein above show a particular order of operations performed by certain embodiments of the invention, it should be understood that such order is exemplary (e.g., alternative embodiments may perform the operations in a different order, combine certain operations, overlap certain operations, etc.). </p><p id="p0125" num="0125"> Different embodiments of the invention may be implemented using different combinations of software, firmware, and/or hardware. Thus, the techniques shown in the figures can be implemented using code and data stored and executed on one or more electronic devices (e.g., an end system, a network device). Such electronic devices store and communicate (internally and/or with other electronic devices over a network) code and data using computer-readable media, such as non-transitory computer-readable storage media (e.g., magnetic disks; optical disks; random access memory; read only memory; flash memory devices; phase-change memory) and transitory computer-readable transmission media (e.g., electrical, optical, acoustical or other form of propagated signals - such as carrier waves, infrared signals, digital signals). In addition, such electronic devices typically include a set of one or more processors coupled to one or more other components, such as one or more storage devices (non-transitory machine-readable storage media), user input/output devices (e.g., a keyboard, a touchscreen, and/or a display), and network connections. The coupling of the set of processors and other components is typically through one or more busses and bridges (also termed as bus controllers). Thus, the storage device of a given 
<!-- EPO <DP n="25"/>-->
 electronic device typically stores code and/or data for execution on the set of one or more processors of that electronic device. </p><p id="p0126" num="0126"> While the invention has been described in terms of several embodiments, those skilled in the art will recognize that the invention is not limited to the embodiments described, can be practiced with modification and alteration within the spirit and scope of the appended claims. The description is thus to be regarded as illustrative instead of limiting. 
</p></description><claims mxw-id="PCLM70077702" ref-ucid="WO-2014128598-A1" lang="EN" load-source="patent-office"><claim-statement><!-- EPO <DP n="26"/>-->CLAIMS What is claimed is: </claim-statement><claim id="clm-0001" num="1"><claim-text>1. A method implemented in a Software Defined Networking (SDN) network, wherein the SDN network contains at least a SDN controller to coordinate traffic forwarding and at least a forwarding element to forward traffic, wherein the SDN network utilizes a plurality of flow tables to perform lookup for forwarding traffic at the forwarding element, the method comprising: </claim-text><claim-text> determining (402) dependency of flow tables within the forwarding element using a set of one or more dependency determination rules; </claim-text><claim-text> constructing (404) a dependency graph based on determined dependency of flow tables; </claim-text><claim-text> determining (406) a dependency degree count for each flow table within the forwarding element based on the dependency graph; and </claim-text><claim-text> forming (408) a plurality of parallel lookup groups (PLGs) for the forwarding element based on the dependency degree count for each flow table, wherein each PLG contains one or more flow tables, and wherein the one or more flow tables of each PLG has a same dependency degree count. </claim-text></claim><claim id="clm-0002" num="2"><claim-text>2. The method of claim 1, wherein determining dependency of flow tables within the forwarding element includes at least one of: </claim-text><claim-text> determining (602) that a flow table is not independent in response to a finding that the flow table has at least two entries containing different Goto table actions; </claim-text><claim-text> determining (604) that a flow table is not independent in response to a finding that the flow table modifies a metadata used for table lookup by another flow table; and </claim-text><claim-text> determining (606) that a flow table is not independent in response to a finding that the flow table contains an action that another second flow table contains. 
<!-- EPO <DP n="27"/>-->
</claim-text></claim><claim id="clm-0003" num="3"><claim-text>3. The method of claim 1, wherein each node in the dependency graph is a flow table, wherein a link between two nodes in the dependency graph indicates a depender-dependee relationship, and wherein a dependee flow table is place in front of a depender flow table in a flow table pipeline. </claim-text></claim><claim id="clm-0004" num="4"><claim-text>4. The method of claim 1, wherein determining a dependency degree count for each flow table within the forwarding element includes: </claim-text><claim-text> finding (702) a node with no dependency (referred to as zero in-degree); </claim-text><claim-text> marking (704) the found node as processed with a degree count being recorded for the found node; </claim-text><claim-text> removing (706) all links from the found node to one or more depender nodes; increasing (708) a degree count associated with a depender node when a link to the depender node is removed; and </claim-text><claim-text> removing (710) the found node from the process queue. </claim-text></claim><claim id="clm-0005" num="5"><claim-text>5. The method of claim 1, wherein the operations of the method are performed on a forwarding element. </claim-text></claim><claim id="clm-0006" num="6"><claim-text>6. The method of claim 1, wherein the operations of the method are performed on a SDN controller. </claim-text></claim><claim id="clm-0007" num="7"><claim-text>7. The method of claim 1, wherein the operations of the method are performed after a flow table dependency changing event occurs. </claim-text></claim><claim id="clm-0008" num="8"><claim-text>8. The method of claim 1, wherein the operations of the method are performed after a packet is received at the forwarding element. </claim-text></claim><claim id="clm-0009" num="9"><claim-text>9. The method of claim 1, wherein the SDN network complies with OpenFlow specifications. 
<!-- EPO <DP n="28"/>-->
</claim-text></claim><claim id="clm-0010" num="10"><claim-text>10. A network device in a Software Defined Networking (SDN) network, wherein the SDN network contains at least a SDN controller to coordinate traffic forwarding and at least a forwarding element to forward traffic, wherein the SDN network utilizes a plurality of flow tables to perform lookup for forwarding traffic at the forwarding element, the network device comprising: a flow table interface logic (1002) configured to receive a set of flow tables; </claim-text><claim-text> a dependency determination logic (1006) configured to determine dependency of flow tables within a forwarding element using a set of dependency determination rules; </claim-text><claim-text> a dependency degree computing logic (1020) configured to construct a dependency graph based on determined dependency of flow tables, the dependency degree computing logic further configured to determine a dependency degree count for each flow table within the forwarding element based on the dependency graph, and the dependency degree computing logic further configured to form a plurality of parallel lookup groups (PLGs) for the forwarding element based on the dependency degree count for each flow table, wherein each PLG contains one or more flow tables, and wherein the one or more flow tables of each PLG has a same dependency degree count; and </claim-text><claim-text> a parallel lookup group database (1052) configured to store the PLGs computed by the dependency degree computing logic. </claim-text></claim><claim id="clm-0011" num="11"><claim-text>11. The network device of claim 10, wherein the dependency determination logic determines dependency of flow tables within a forwarding element based on at least one of the following rules: </claim-text><claim-text> determining that a flow table is not independent in response to a finding that the flow table has at least two entries containing different Goto table actions; </claim-text><claim-text> determining that a flow table is not independent in response to a finding that the flow table modifies a metadata used for table lookup by another flow table; and 
<!-- EPO <DP n="29"/>-->
 determining that a flow table is not independent in response to a finding that the flow table contains an action that another second flow table contains. </claim-text></claim><claim id="clm-0012" num="12"><claim-text>12. The network device of claim 10, wherein each node in the dependency graph is a flow table, wherein a link between two nodes in the dependency graph indicates a depender-dependee relationship, and wherein a dependee flow table is place in front of a depender flow table in a flow table pipeline. </claim-text></claim><claim id="clm-0013" num="13"><claim-text>13. The network device of claim 10, wherein the dependency degree computing logic determines a dependency degree count for each flow table within the forwarding element based on the dependency graph by performing the following: </claim-text><claim-text> finding a node with no dependency (referred to as zero in-degree); </claim-text><claim-text> marking the found node as processed with a degree count being recorded for the found node; </claim-text><claim-text> removing all links from the found node to one or more depender nodes; </claim-text><claim-text> increasing a degree count associated with a depender node when a link to the depender node is removed; and </claim-text><claim-text> removing the found node from the process queue. </claim-text></claim><claim id="clm-0014" num="14"><claim-text>14. The network device of claim 10, wherein the network device is a forwarding element of the SDN network. </claim-text></claim><claim id="clm-0015" num="15"><claim-text>15. The network device of claim 10, wherein the network device is a SDN controller. </claim-text></claim><claim id="clm-0016" num="16"><claim-text>16. The network device of claim 10, wherein the operations of dependency determination logic and dependency degree computing logic are performed after a flow table dependency changing event occurs. 
<!-- EPO <DP n="30"/>-->
</claim-text></claim><claim id="clm-0017" num="17"><claim-text>17. The network device of claim 10, wherein the operations of dependency determination logic and dependency degree computing logic are performed after a packet is received at the forwarding element. </claim-text></claim><claim id="clm-0018" num="18"><claim-text>18. The network device of claim 10, wherein the SDN network complies with OpenFlow specifications. </claim-text></claim><claim id="clm-0019" num="19"><claim-text>19. A method implemented in a Software Defined Networking (SDN) network, wherein the SDN network contains at least a SDN controller to coordinate traffic forwarding and at least a forwarding element to forward traffic, wherein the SDN network utilizes a plurality of flow tables to perform lookup for forwarding traffic at the forwarding element, the method comprising: </claim-text><claim-text> determining (402) dependency of flow tables within the forwarding element using a set of one or more dependency determination rules, including at least one of: </claim-text><claim-text> determining (602) that a flow table is not independent in response to a finding that the flow table has at least two entries containing different Goto table actions; </claim-text><claim-text> determining (604) that a flow table is not independent in response to a finding that the flow table modifies a metadata used for table lookup by another flow table; and </claim-text><claim-text> determining (606) that a flow table is not independent in response to a finding that the flow table contains an action that another second flow table contains; </claim-text><claim-text> constructing (404) a dependency graph based on determined dependency of flow tables; </claim-text><claim-text> determining (406) a dependency degree count for each flow table within the forwarding element based on the dependency graph by: </claim-text><claim-text> finding (702) a node with no dependency (referred to as zero in-degree); marking (704) the found node as processed with a degree count being recorded for the found node; 
<!-- EPO <DP n="31"/>-->
 removing (706) all links from the found node to one or more depender nodes; </claim-text><claim-text> increasing (708) a degree count associated with a depender node when a link to the depender node is removed; and </claim-text><claim-text> removing (710) the found node from the process queue; </claim-text><claim-text> forming (408) a plurality of parallel lookup groups (PLGs) for the forwarding element based on the dependency degree count for each flow table, wherein each PLG contains one or more flow tables, and wherein the one or more flow tables of each PLG has a same dependency degree count. </claim-text></claim><claim id="clm-0020" num="20"><claim-text>20. A network device in a Software Defined Networking (SDN) network, wherein the SDN network contains at least a SDN controller to coordinate traffic forwarding and at least a forwarding element to forward traffic, wherein the SDN network utilizes a plurality of flow tables to perform lookup for forwarding traffic at the forwarding element, the network device comprising: a flow table interface logic (1002) configured to receive a set of flow tables; a dependency determination logic (1006) configured to determine dependency of flow tables within a forwarding element using a set of dependency determination rules, wherein the dependency determination logic determines dependency of flow tables within a forwarding element based on at least one of the following rules: </claim-text><claim-text> determining that a flow table is not independent in response to a finding that the flow table has at least two entries containing different Goto table actions; </claim-text><claim-text> determining that a flow table is not independent in response to a finding that the flow table modifies a metadata used for table lookup by another flow table; and </claim-text><claim-text> determining that a flow table is not independent in response to a finding that the flow table contains an action that another second flow table contains; 
<!-- EPO <DP n="32"/>-->
 a dependency degree computing logic (1020) configured to construct a dependency graph based on determined dependency of flow tables, the dependency degree computing logic further configured to determine a dependency degree count for each flow table within the forwarding element based on the dependency graph by: </claim-text><claim-text> finding a node with no dependency (referred to as zero in-degree); </claim-text><claim-text> marking the found node as processed with a degree count being recorded for the found node; </claim-text><claim-text> removing all links from the found node to one or more depender nodes; increasing a degree count associated with a depender node when a link to the depender node is removed; and </claim-text><claim-text> removing the found node from the process queue, </claim-text><claim-text> and the dependency degree computing logic further configured to form a plurality of parallel lookup groups (PLGs) for the forwarding element based on the dependency degree count for each flow table, wherein each PLG contains one or more flow tables, and wherein the one or more flow tables of each PLG has a same dependency degree count; and a parallel lookup group database (1052) configured to store the PLGs computed by the dependency degree computing logic. 
</claim-text></claim></claims><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
