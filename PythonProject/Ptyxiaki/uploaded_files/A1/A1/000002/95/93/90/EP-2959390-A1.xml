<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2959390-A1" country="EP" doc-number="2959390" kind="A1" date="20151230" family-id="50272693" file-reference-id="310471" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="160452579" ucid="EP-2959390-A1"><document-id><country>EP</country><doc-number>2959390</doc-number><kind>A1</kind><date>20151230</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-14709777-A" is-representative="NO"><document-id mxw-id="PAPP193868126" load-source="docdb" format="epo"><country>EP</country><doc-number>14709777</doc-number><kind>A</kind><date>20140212</date><lang>EN</lang></document-id><document-id mxw-id="PAPP193868127" load-source="patent-office" format="original"><country>EP</country><doc-number>14709777.8</doc-number><date>20140212</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC162031296" ucid="US-201313772400-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201313772400</doc-number><kind>A</kind><date>20130221</date></document-id></priority-claim><priority-claim mxw-id="PPC162036341" ucid="US-2014015994-W" linkage-type="W" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>2014015994</doc-number><kind>W</kind><date>20140212</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1988520142" load-source="docdb">G06F  12/02        20060101AFI20140910BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-1988521505" load-source="docdb">G06F  12/08        20060101ALI20140910BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1804359970" load-source="docdb" scheme="CPC">G06F  12/0246      20130101 LI20170608BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987043439" load-source="docdb" scheme="CPC">G06F2212/7211      20130101 LA20151230BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987043440" load-source="docdb" scheme="CPC">G06F  12/0891      20130101 LI20151230BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987043441" load-source="docdb" scheme="CPC">G06F  12/0864      20130101 LI20151230BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987788064" load-source="docdb" scheme="CPC">G06F  12/0802      20130101 LI20140821BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987800893" load-source="docdb" scheme="CPC">G06F  12/0238      20130101 FI20140822BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT165549203" lang="DE" load-source="patent-office">ABNUTZUNGSAUSGLEICH ZWISCHEN SÄTZEN FÜR CACHESPEICHER MIT BEGRENZTER SCHREIBDAUERHAFTIGKEIT</invention-title><invention-title mxw-id="PT165549204" lang="EN" load-source="patent-office">INTER-SET WEAR-LEVELING FOR CACHES WITH LIMITED WRITE ENDURANCE</invention-title><invention-title mxw-id="PT165549205" lang="FR" load-source="patent-office">NIVELLEMENT D'USURE ENTRE ENSEMBLES POUR DES ANTÉMÉMOIRES À ENDURANCE D'ÉCRITURE LIMITÉE</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR1103339586" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>QUALCOMM INC</last-name><address><country>US</country></address></addressbook></applicant><applicant mxw-id="PPAR1103334954" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>QUALCOMM INCORPORATED</last-name></addressbook></applicant><applicant mxw-id="PPAR1101651097" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Qualcomm Incorporated</last-name><iid>101331414</iid><address><street>5775 Morehouse Drive</street><city>San Diego, CA 92121</city><country>US</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR1103343188" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>DONG XIANGYU</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103319488" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>DONG, Xiangyu</last-name></addressbook></inventor><inventor mxw-id="PPAR1101646754" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>DONG, Xiangyu</last-name><address><street>5775 Morehouse Drive</street><city>San Diego California 92121</city><country>US</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR1101654031" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Dunlop, Hugh Christopher</last-name><suffix>et al</suffix><iid>101206041</iid><address><street>RGC Jenkins &amp; Co. 26 Caxton Street</street><city>London SW1H 0RJ</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="US-2014015994-W"><document-id><country>US</country><doc-number>2014015994</doc-number><kind>W</kind><date>20140212</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2014130317-A1"><document-id><country>WO</country><doc-number>2014130317</doc-number><kind>A1</kind><date>20140828</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS660625113" load-source="docdb">AL</country><country mxw-id="DS660710211" load-source="docdb">AT</country><country mxw-id="DS660625127" load-source="docdb">BE</country><country mxw-id="DS660626214" load-source="docdb">BG</country><country mxw-id="DS660625439" load-source="docdb">CH</country><country mxw-id="DS660703762" load-source="docdb">CY</country><country mxw-id="DS660710212" load-source="docdb">CZ</country><country mxw-id="DS660625128" load-source="docdb">DE</country><country mxw-id="DS660703767" load-source="docdb">DK</country><country mxw-id="DS660703768" load-source="docdb">EE</country><country mxw-id="DS660725996" load-source="docdb">ES</country><country mxw-id="DS660626219" load-source="docdb">FI</country><country mxw-id="DS660626220" load-source="docdb">FR</country><country mxw-id="DS660625129" load-source="docdb">GB</country><country mxw-id="DS660703769" load-source="docdb">GR</country><country mxw-id="DS660625130" load-source="docdb">HR</country><country mxw-id="DS660710213" load-source="docdb">HU</country><country mxw-id="DS660625440" load-source="docdb">IE</country><country mxw-id="DS660703770" load-source="docdb">IS</country><country mxw-id="DS660626221" load-source="docdb">IT</country><country mxw-id="DS660703771" load-source="docdb">LI</country><country mxw-id="DS660788974" load-source="docdb">LT</country><country mxw-id="DS660704008" load-source="docdb">LU</country><country mxw-id="DS660788975" load-source="docdb">LV</country><country mxw-id="DS660788976" load-source="docdb">MC</country><country mxw-id="DS660704009" load-source="docdb">MK</country><country mxw-id="DS660704010" load-source="docdb">MT</country><country mxw-id="DS660725997" load-source="docdb">NL</country><country mxw-id="DS660626222" load-source="docdb">NO</country><country mxw-id="DS660704015" load-source="docdb">PL</country><country mxw-id="DS660625441" load-source="docdb">PT</country><country mxw-id="DS660725998" load-source="docdb">RO</country><country mxw-id="DS660625442" load-source="docdb">RS</country><country mxw-id="DS660704016" load-source="docdb">SE</country><country mxw-id="DS660625139" load-source="docdb">SI</country><country mxw-id="DS660626231" load-source="docdb">SK</country><country mxw-id="DS660704017" load-source="docdb">SM</country><country mxw-id="DS660703772" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><abstract mxw-id="PA139072463" ref-ucid="WO-2014130317-A1" lang="EN" load-source="patent-office"><p num="0000">A cache controller includes a first register that updates after every memory location swap operation on a number of cache sets in a cache memory and resets every N-1 memory location swap operations. N is a number of the cache sets in the cache memory. The memory controller also has a second register that updates after every N-1 memory location swap operations, and resets every (N<sup>2</sup>-N) memory location swap operations. The first and second registers track a relationship between logical locations and physical locations of the cache sets.</p></abstract><abstract mxw-id="PA139540112" ref-ucid="WO-2014130317-A1" lang="EN" source="national office" load-source="docdb"><p>A cache controller includes a first register that updates after every memory location swap operation on a number of cache sets in a cache memory and resets every N-1 memory location swap operations. N is a number of the cache sets in the cache memory. The memory controller also has a second register that updates after every N-1 memory location swap operations, and resets every (N2-N) memory location swap operations. The first and second registers track a relationship between logical locations and physical locations of the cache sets.</p></abstract><abstract mxw-id="PA139072464" ref-ucid="WO-2014130317-A1" lang="FR" load-source="patent-office"><p num="0000">L'invention concerne un contrôleur d'antémémoire comprenant un premier registre qui exécute une mise jour, après chaque opération de permutation d'emplacement de mémoire, sur un certain nombre d'ensembles d'antémémoire dans l'antémémoire et réinitialise chaque opération de permutation d'emplacement de mémoire N-1. N est le nombre d'ensembles d'antémémoire dans l'antémémoire. Le contrôleur de mémoire comprend un second registre qui exécute une mise à jour après chaque opération de permutation d'emplacement de mémoire N-1, et réinitialise chaque opération de permutation d'emplacement de mémoire (N<sup>2</sup>-N). Le premier et le second registre suivent une relation entre des emplacements logiques et les emplacements physiques des ensembles d'antémémoire.</p></abstract><abstract mxw-id="PA139540113" ref-ucid="WO-2014130317-A1" lang="FR" source="national office" load-source="docdb"><p>L'invention concerne un contrôleur d'antémémoire comprenant un premier registre qui exécute une mise jour, après chaque opération de permutation d'emplacement de mémoire, sur un certain nombre d'ensembles d'antémémoire dans l'antémémoire et réinitialise chaque opération de permutation d'emplacement de mémoire N-1. N est le nombre d'ensembles d'antémémoire dans l'antémémoire. Le contrôleur de mémoire comprend un second registre qui exécute une mise à jour après chaque opération de permutation d'emplacement de mémoire N-1, et réinitialise chaque opération de permutation d'emplacement de mémoire (N2-N). Le premier et le second registre suivent une relation entre des emplacements logiques et les emplacements physiques des ensembles d'antémémoire.</p></abstract><description mxw-id="PDES78476568" ref-ucid="WO-2014130317-A1" lang="EN" load-source="patent-office"><!-- EPO <DP n="3"/>--><p id="p0001" num="0001"> INTER-SET WEAR-LEVELING FOR CACHES </p><p id="p0002" num="0002"> WITH LIMITED WRITE ENDURANCE</p><p id="p0003" num="0003">TECHNICAL FIELD </p><p id="p0004" num="0004"> [0001] The present disclosure generally relates to memories and caches. More specifically, the present disclosure relates to inter-set wear-leveling for caches with limited write endurance. </p><p id="p0005" num="0005">BACKGROUND </p><p id="p0006" num="0006"> [0002] For high-speed digital electronics that may be used for wireless </p><p id="p0007" num="0007">communications or other application, non-volatile memories are used. Non-volatile memories, such as resistive random access memory (ReRAM) and phase-change random access memory (PCRAM), however, have limited write endurance. Write endurance can be defined as the number of program/ cycles that can be applied to a block of memory before the storage media becomes unreliable, and is usually calculated by estimating how often and how thoroughly the memory is used. In other words, write endurance measures the service life of a certain type of storage media. </p><p id="p0008" num="0008">[0003] Wear-leveling is a technique that is used to prolong the write endurance (e.g., service life) of storage media, and is part of cache design. One wear-leveling approach arranges data so that re-writes are evenly distributed across the storage medium. In this way, no single block fails due to a high concentration of write cycles. Other approaches to wear-leveling may include dynamically updating a map every time a write occurs, the map subsequently linking the written block to a new block. Another approach statically keeps the blocks the same without replacing them, but periodically rotates the blocks so they may be used by other data. </p><p id="p0009" num="0009">[0004] Wear-leveling for non-volatile memories (e.g., which may also be used in the main memories for computers) is well known and well explored. Nevertheless, when using wear-leveling for on-chip caches, traditional wear-leveling approaches that are usually employed for non-volatile memories exhibit too much performance overhead. Therefore, the high performance overhead inhibits the effectiveness of wear- leveling techniques for caches having limited write endurance. 
<!-- EPO <DP n="4"/>-->
 SUMMARY </p><p id="p0010" num="0010">[0005] According to one aspect of the present disclosure, a cache controller to inter- set wear-level a cache memory is described. The cache controller includes a first register that updates after each memory location swap operation on cache sets of the cache memory, and resets at each N-1 memory location swap operations. N is a number of cache sets in the cache memory. The cache controller further includes a second register that updates after every N-1 memory location swap operations on the cache sets of the cache memory, and resets every (N<sup>2</sup>-N) memory location swap operations. The first register and the second register may track a relationship between logical locations and physical locations of the cache sets. </p><p id="p0011" num="0011">[0006] According another aspect of the present disclosure, a method for inter-set wear-leveling a cache memory is described. The method includes dynamically rotating cache sets of the cache memory by performing memory location swap operations on the cache sets when a number of memory write operations to the cache memory reaches a threshold value. Each swap operation may include clearing the contents from only the swapped cache sets, while leaving memory contents of other cache sets intact. The method also includes tracking the swapped cache sets to convert a logical cache set number to a physical cache set number. </p><p id="p0012" num="0012">[0007] According to a further aspect of the present disclosure, a cache controller to inter-set wear-level a cache memory is described. The cache controller includes a means for dynamically rotating cache sets of the cache memory by performing memory location swap operations on the cache sets when a number of memory write operations to the cache memory reaches a threshold value. Each swap operation may include clearing the contents from only the swapped cache sets, while leaving memory contents of other cache sets intact. The cache controller further includes a means for tracking the swapped cache sets to convert a logical cache set number to a physical cache set number. </p><p id="p0013" num="0013">[0008] According another aspect of the present disclosure, a method for inter-set wear-leveling a cache memory is described. The method includes the step of dynamically rotating cache sets of the cache memory by performing memory location swap operations on the cache sets when a number of memory write operations to the 
<!-- EPO <DP n="5"/>-->
 cache memory reaches a threshold value. Each swap operation may include clearing the contents from only the swapped cache sets, while leaving memory contents of other cache sets intact. The method also includes the step of tracking the swapped cache sets to convert a logical cache set number to a physical cache set number. </p><p id="p0014" num="0014">[0009] This has outlined, rather broadly, the features and technical advantages of the present disclosure in order that the detailed description that follows may be better understood. Additional features and advantages of the disclosure will be described below. It should be appreciated by those skilled in the art that this disclosure may be readily utilized as a basis for modifying or designing other structures for carrying out the same purposes of the present disclosure. It should also be realized by those skilled in the art that such equivalent constructions do not depart from the teachings of the disclosure as set forth in the appended claims. The novel features, which are believed to be characteristic of the disclosure, both as to its organization and method of operation, together with further objects and advantages, will be better understood from the following description when considered in connection with the accompanying figures. It is to be expressly understood, however, that each of the figures is provided for the purpose of illustration and description only and is not intended as a definition of the limits of the present disclosure. </p><p id="p0015" num="0015">BRIEF DESCRIPTION OF THE DRAWINGS </p><p id="p0016" num="0016"> [0010] For a more complete understanding of the present disclosure, reference is now made to the following description taken in conjunction with the accompanying drawings. </p><p id="p0017" num="0017">[0011] FIGURE 1 is a diagram of an example cache memory including a cache controller for wear-leveling of the cache memory according to an aspect of the present disclosure. </p><p id="p0018" num="0018">[0012] FIGURE 2 is a diagram showing an example rotation for wear-leveling according to an aspect of the present disclosure. </p><p id="p0019" num="0019">[0013] FIGURE 3 is a logic flowchart showing operation of wear-leveling according to an aspect of the present disclosure. 
<!-- EPO <DP n="6"/>-->
 [0014] FIGURE 4 is a logic flowchart showing the operation of wear-leveling according to an aspect of the present disclosure. </p><p id="p0020" num="0020">[0015] FIGURE 5 is a process flow diagram illustrating a method for wear-leveling according to an aspect of the present disclosure. </p><p id="p0021" num="0021">[0016] FIGURE 6 is a process flow diagram illustrating a method for wear-leveling according to an aspect of the present disclosure. </p><p id="p0022" num="0022">[0017] FIGURE 7 is a block diagram showing an exemplary wireless </p><p id="p0023" num="0023">communication system in which a configuration of the disclosure may be </p><p id="p0024" num="0024">advantageously employed. </p><p id="p0025" num="0025">[0018] FIGURE 8 is a block diagram illustrating a design workstation used for circuit, layout, and logic design of a semiconductor component according to one configuration. </p><p id="p0026" num="0026">DETAILED DESCRIPTION </p><p id="p0027" num="0027"> [0019] The detailed description set forth below, in connection with the appended drawings, is intended as a description of various configurations and is not intended to represent the only configurations in which the concepts described herein may be practiced. The detailed description includes specific details for the purpose of providing a thorough understanding of the various concepts. However, it will be apparent to those skilled in the art that these concepts may be practiced without these specific details. In some instances, well-known structures and components are shown in block diagram form in order to avoid obscuring such concepts. As described herein, the use of the term "and/or" is intended to represent an "inclusive OR", and the use of the term "or" is intended to represent an "exclusive OR". </p><p id="p0028" num="0028">[0020] Memories such as static random access (SRAM) and embedded dynamic RAM (eDRAM) are commonly used for on-chip cache design in modern </p><p id="p0029" num="0029">microprocessors. Modern computers and devices also specify larger on-chip caches, but the scalability of traditional SRAM or eDRAM caches is increasingly constrained by technology limitations such as leakage power and cell density. Recently, new nonvolatile memory (NVM) technologies such as, for example, phase-change random access memory (RAM,) spin-torque transfer RAM, and resistive RAM have been 
<!-- EPO <DP n="7"/>-->
 explored as promising alternative memory technologies to be used for on-chip caches. Compared to traditional memories such as SRAM and eDRAM, these emerging nonvolatile memory technologies have common advantages of high density, low standby power, low voltage, better scalability and non-volatility. However, their adoption is hampered by their limited write endurance. This problem will be amplified by the existing cache management policies resulting in unbalanced write traffic on cache blocks because such policies are not write variation aware. These policies were originally designed for SRAM caches and result in significant non-uniformity in terms of writing to cache blocks, which causes heavily- written cache blocks to fail much faster or earlier than most other blocks. </p><p id="p0030" num="0030">[0021] Many wear-leveling techniques have been proposed to extend the lifetime of non-volatile memory technologies, but the difference between cache and main memory operational mechanisms make the existing wear-leveling techniques for non- volatile memories inadequate for non-volatile caches. To address these issues and to reduce inter-set write variations, a swap-shift scheme is provided to reduce cache inter-set write variations for non-volatile memory caches. The scheme has a very small hardware overhead, only using one global counter and two global registers. By adopting this scheme, the lifetime of low-level on-chip non- volatile memory caches can be improved. </p><p id="p0031" num="0031">[0022] Write variation is a significant concern in designing any cache or memory subsystem that use non- volatile memories with limited write endurance. Large write variation may greatly degrade product lifetime, because only a small subset of memory cells that experience the worst-case write traffic can result in a dead cache or memory subsystem even when the majority of the cells are far from wear-out. </p><p id="p0032" num="0032">[0023] FIGURE 1 is a diagram of an example cache memory 100 including a cache controller 140 for inter-set wear-leveling of the cache memory 100 according to an aspect of the present disclosure. A cache memory 100 includes a page number 102, a set number 104, a byte number 106, a cache way 108, a tag portion 1 10, a data portion 112, a cache block 114, cache sets 1 16, a tag sense amplifier 1 18a, a data sense amplifier 118b, a tag output 120, a comparator 122, a logic gate 124, a cache group 126, a select circuitry 128 and a word output 130. 
<!-- EPO <DP n="8"/>-->
 [0024] An address in the cache memory 100 may include a page number 102, a set number 104 and a byte number 106. In one implementation, the page number 102 may be a virtual page number. The set number 104 corresponds to one of the cache sets 1 16. A cache block 114 includes a tag portion 1 10 and a data portion 1 12. The tag portion 110 may contain part of the address of the actual data in the data portion 112, or other identifying information to locate the data in the data portion 112. The data portion 1 12 contains the actual data. The one of the cache sets 1 16 is one set of cache blocks 114, as can be seen by the horizontal grouping in FIGURE 1. The cache way 108 is another group of cache blocks 114, but in a vertical grouping, as can be seen in FIGURE 1. The tag sense amplifier 118a and data sense amplifier 118b sense logic levels from the cache entries so the data is properly interpreted (as a 1 or 0) when output. </p><p id="p0033" num="0033">[0025] The data at the tag output 120, which is the output of the tag sense amplifier 118a, may contain a page frame number, a valid bit and coherence bits. The data from the tag output 120 is then compared to the page number 102 by the comparator 122, which sees if the two values are equal. If the values are equal and there is a hit, then the output of the comparator 122 is input, along with the output of the data sense amplifier 118b, into the logic gate 124. The output of the logic gate 124 appears in the cache group 126. In one implementation, one of the cache groups 126 contains multiple words. The cache group 126 is input into a select circuitry 128 which uses the byte number 106 as a select input. The output of the select circuitry 128 using the byte number 106 as the select input is the word output 130. </p><p id="p0034" num="0034">[0026] FIGURE 1 is also an example block diagram for an n-way set-associative cache, and there may be other types of caches used for the present disclosure. A set- associative cache can be made of several direct-mapped caches operated in parallel (for example, one direct-mapped cache could be a cache entry including the tag portion 1 10 and the data portion 112). The data read-out may be controlled by a tag comparison with the page number 102 as well as the block-valid bit (which can be part of the tag or metadata entry) and the page permissions (part of the page number 102). The cache column size may also equal the virtual memory page size, and the cache index may not use pits from the page number 102 or virtual page number. </p><p id="p0035" num="0035">[0027] Individual ones of the cache blocks 1 14 are grouped into one of the cache sets 1 16 in one direction, and into a cache way 108 in another direction. The cache 
<!-- EPO <DP n="9"/>-->
 blocks 1 14 may also have load distributions, depending on how often they are written to. Some of the cache blocks 114 are heavily written to and others of the cache blocks 114 are rarely written. Therefore, this causes inter-set write variation. Inter-set write variation occurs among the cache sets 1 16 that vary in terms of writing activity. That is, the cache blocks 114 from one of the cache sets 116 may be written more or less than the cache blocks 114 from another of the cache sets 116. Furthermore, when different cache sets 1 16 are written to as a whole compared to others of the cache sets 1 16, inter- set write variation also occurs. </p><p id="p0036" num="0036">[0028] In this configuration, the cache controller 140 evenly distributes writing traffic to the different rows and to the different columns for the cache ways 108. </p><p id="p0037" num="0037">Although the cache ways 108 are shown as occupying columns and the cache sets 116 are shown as occupying rows in FIGURE 1, the implementation of the cache memory 100 is not limited to this configuration. In particular, the cache ways 108 may occupy rows or other structures that may not be columns within the cache memory 100, and the cache sets 1 16 may occupy columns or other structures that may not be rows within the cache memory 100. </p><p id="p0038" num="0038">[0029] Main memory wear-leveling techniques usually use data movement to implement the address re-mapping. This is because in main memory, the data cannot be lost and can be moved to a new position after each re -mapping. Nevertheless, data movement operations always incur area and performance overhead. First, data movement needs a temporary data storage location to receive the data. Second, one cache set movement involves several block read and write operations. Therefore, the cache port is blocked during the data movement and system performance is </p><p id="p0039" num="0039">consequentially degraded. When one example data movement scheme is extended from main memory to being applied to memory caches, one additional cache set (the gap set) is added and the data from one set to the gap set is moved periodically. Because cache techniques are more performance sensitive, main memory wear-leveling techniques cannot be used directly. Therefore, the use of data movement may be reconsidered when designing cache inter-set wear-leveling techniques. </p><p id="p0040" num="0040">[0030] Another option for implementing set address re -mapping for non-volatile memory caches is to perform data invalidation. Cache line invalidations can be used because the data in caches can be read back again later from lower-level memories. 
<!-- EPO <DP n="10"/>-->
 This special feature of caches provides a new opportunity for designing cache inter-set wear-leveling techniques. </p><p id="p0041" num="0041">[0031] Compared to data movement, invalidations do not incur any area overhead. Therefore, one aspect of the present disclosure modifies previous main memory wear- leveling techniques and enhances them by using a swap-shift wear-leveling scheme to reduce the inter-set write variation in non-volatile memory caches using invalidations. </p><p id="p0042" num="0042">[0032] In contrast to existing wear-leveling techniques for non-volatile main memories, the swap-shift scheme is designed for non-volatile memory caches. The swap-shift scheme uses data invalidation instead of data movement when changing the set address mapping in order to decrease both the area and the performance overhead. </p><p id="p0043" num="0043">[0033] One configuration of the swap-shift scheme shifts the mapping of cache physical sets to rotate the stored data between sets. Nevertheless, shifting all cache sets at one time results in a significant performance overhead. To solve this problem, the swap-shift scheme of the cache controller 140 only swaps the mapping of two sets at one time, and all cache sets can be shifted by one step after a complete swap rotation. </p><p id="p0044" num="0044">[0034] In this configuration, the cache controller 140 includes a global counter 142 that is used in the swap-shift scheme to store the number of memory write operations to the cache, which is denoted by the variable name "num Write." The cache controller 140 also includes a swap register 144 (SwapReg) the is used to store the current swapping value. SwapReg is initially set to 0 and cyclically changed from 0 to N-l, where Nis the number of sets in the cache. The cache controller 140 further includes a shift register 146 (ShiftReg) that stores the current shifting value. ShiftReg is changed from 0 to N cyclically. These two values, SwapReg and ShiftReg, are used by the cache controller 140 to control two types of rotations in the shift-swap scheme, the swap rotation and the shift rotation. </p><p id="p0045" num="0045">[0035] First, the swap rotation is described. SwapReg is incremented by 1 when num Write is equal to a specific predefined threshold ("threshold"), and one swap rotation occurs when SwapReg is moved by N - 1 steps. Therefore, one swap rotation consists of N -l swaps. 
<!-- EPO <DP n="11"/>-->
 [0036] Second, the shift rotation will be described. ShiftReg is incremented by 1 after each swap rotation, and one shift rotation occurs when ShiftReg is moved by N steps. Therefore, each shift rotation consists of N swap rotations. </p><p id="p0046" num="0046">[0037] FIGURE 2 is a diagram 200 showing an example rotation for wear-leveling according to an aspect of the present disclosure. The diagram 200 includes a cache structure 202 and a set of rotation boxes 204, 206, 208, 210, 212, 214, 216 and 218. The cache structure 202 is any structure that includes cache blocks 114, cache ways 108 or cache sets 116, and may include the entirety of the cache memory 100 itself, although for simplicity the cache structure 202 is represented as having a group of cache sets 202a, 202b, 202c and 202d. The first cache set 202a, the second cache set 202b, the third cache set 202c and the fourth cache set 202d are example cache sets shown for the rotation example of the diagram 200, although the number of cache sets or substructures of the cache structure 202 is not limited to four. The rotation process is now be described. </p><p id="p0047" num="0047">[0038] In rotation box 204, the cache structure 202 is in its initial position, with the first cache set 202a labeled with a "0", the second cache set 202b labeled with a "1", the third cache set 202c labeled with a "2", and the fourth cache set labeled with a "3". There may also be data stored within each of the cache sets 202a, 202b, 202c and 202d. A SwapReg counter counts the number of times the cache sets have been swapped. The counter may be initialized to 0. A ShiftReg counter counts the number of times the entirety of the cache structure 202 has shifted positions (in that all of the cache sets within the cache structure 202 has been moved one position) may also be initialized and set to 0. The conventional approach for rotation uses a temporary block and clears all the cache sets or cache structures over time. Nevertheless, with the implementation shown in the diagram 200, a temporary block is not used, nor are the data contents of the cache sets deleted or flushed. This is true because the data is not actually swapped and kept in the same location or position. Only the positions of the cache sets are being swapped, and only the contents from the swapped cache sets are cleared, leaving the contents of all the other cache sets intact. Each of the cache sets are also moved to their new location and new data is auto-loaded into the new cache set, without having to move any data. Again, the only thing that is swapped is the location of the cache sets. Everything is done with swap operations, instead of actually moving data. 
<!-- EPO <DP n="12"/>-->
 [0039] In rotation box 206, the position of the first cache set 202a (0) is swapped with the position of the second cache set 202b (1). As a result, the second cache set 202b (1) is now the very first or top cache set, and the first cache set 202a (0) becomes the second cache set, next to or below the first cache set 202a (0). In one </p><p id="p0048" num="0048">implementation, once this swap occurs, new data will be auto-reloaded into the new cache sets once in their new positions. In one implementation, the swapped cache sets will retain their data, so new data will not be auto-reloaded into the cache sets once they are swapped. The SwapReg counter, which counts the number of times the cache sets have been swapped, may also be incremented by 1. In rotation box 208, the position of the first cache set 202a (0) (now in the second position, the old position of the second cache set 202b (1)) is swapped with the position of the third cache set 202c (2). Now, the third cache set 202c (2) becomes the second position (former position of the second cache set 202b (1)), and the first cache set 202a (0) becomes the third position (former position of the third cache set 202c (2)). The SwapReg counter may be then be incremented by 1 again. </p><p id="p0049" num="0049">[0040] In the rotation box 210, the position of the first cache set 202a (0) (now in the third position, the old position of the third cache set 202c (2)) is swapped with the position of the fourth cache set 202d (3). Now, the fourth cache set 202d (3) becomes the third position (former position of the third cache set 202c (2)), and the first cache set 202a (0) becomes the fourth position (former position of the fourth cache set 202d (3)). The SwapReg counter may then be initialized because all the cache sets have been shifted, and the ShiftReg counter becomes incremented because after three rounds of swapping, all the registers within the cache structure 202 have been shifted by one position. </p><p id="p0050" num="0050">[0041] Continuing on to the rotation box 212, the position of the second cache set 202b (1) is swapped with the position of the third cache set 202c (2). Now, the second cache set 202(b) (1) becomes the second position (former position of the third cache set 202c (2)), and the third cache set 202c (2) becomes the first position (former position of the second cache set 202b (1)). The SwapReg counter also becomes incremented by 1. In rotation box 214, the position of the second cache set 202b (1) is swapped with the position of the fourth cache set 202d (3). Now, the fourth cache set 202d (3) becomes the second position (former position of the second cache set 202b (1)), and the fourth cache set 202d (3) becomes the second position (former position of the second cache set 
<!-- EPO <DP n="13"/>-->
 202b (1)). The SwapReg counter also increments by 1. In rotation box 216, the position of the second cache set 202(b) (1) is swapped with the position of the first cache set 202(a) (0). Now, the second cache set 202(b) (1) becomes the fourth position (former position of the first cache set 202a (0)), and the first cache set 202a (0) becomes the third position (former position of the second cache set 202b (1)). The SwapReg counter is then initialized and the ShiftReg counter increments by 1 because after another three rounds of swapping, all the registers within the cache structure 202 have been shifted by two positions. </p><p id="p0051" num="0051">[0042] In one implementation, the contents of the entire cache are not flushed because everything is done by swap operations. Furthermore, swap operations do not involve any performance degradation. By using swap operations to perform the swapping, "shift up" operations and/or tracking does not occur. In one implementation, the data is not swapped, just the positions, and the data is then reloaded into the new swapped location. In one implementation, the data in un-used positions is simply discarded, such as invalid cache sets. In one implementation, for one swap, the contents of the cache set corresponding to the SwapReg counter position (e.g., cache- register[SwapReg]) and the contents of the cache set corresponding to the SwapReg counter plus one (e.g., cache-register[SwapReg + 1]) may be discarded. Then, their physical locations are swapped. After N-l swaps, where N is the number of cache sets in the cache structure, all the physical locations within the cache structure (each of the cache sets) are all shifted by 1. </p><p id="p0052" num="0052">[0043] In one implementation, the SwapReg and ShiftReg counters may be implemented as the swap register 144 and the shift register 146 of the cache controller 140 for storing data, as shown in FIGURE 1. In this case, the registers are implemented as some sort of numerical data that keeps track of the value for their respective counters. </p><p id="p0053" num="0053">[0044] FIGURE 3 is a logic flowchart 300 showing the operation of a cache controller for wear-leveling a cache memory according to an aspect of the present disclosure. FIGURE 3 shows how the ShiftReg and SwapReg counters are updated in a wear-leveling system with respect to writing activity. In block 302, it is determined whether there has been a cache write. If there is a cache write, then in block 304, a cache write counter known as "num Write" is incremented by one. If there is not a cache write, the process goes back to before block 302. The num Write counter also triggers 
<!-- EPO <DP n="14"/>-->
 when to swap. There is also some predetermined threshold value that determines how many writes is enough to initiate a swap of a cache set. For example, in block 306, it is determined whether the num Write counter is equal to the predetermined threshold. If so, then in block 308, a swap is initiated, updating the num Write counter to a zero value and updating the SwapReg counter to the value of (SwapReg + 1) mod (N-l). Mod is the modulo operator and N is the total number of cache sets in the selected cache structure. In block 306, if the num Write counter is not equal to the predetermined threshold, then the process goes back to block 304. In block 310, it is determined whether the SwapReg counter is equal to zero. If so, then in block 312, the ShiftReg counter is updated to the value of (ShiftReg + 1) mod N. This shifts the entire cache structure by one. In block 310, if the value of the SwapReg counter is not equal to zero, then the process goes back to block 308. </p><p id="p0054" num="0054">[0045] FIGURE 3 may also be expressed by the following pseudo code: </p><p id="p0055" num="0055"> If (there is a cache write), </p><p id="p0056" num="0056"> then: numWrite++; </p><p id="p0057" num="0057"> If (num Write == threshold), </p><p id="p0058" num="0058"> then: num Write = 0; </p><p id="p0059" num="0059"> then: SwapReg = (SwapReg + 1) mod (N-l); </p><p id="p0060" num="0060"> if (SwapReg ==0), </p><p id="p0061" num="0061"> then: ShiftReg = (ShiftReg + 1) mod (N). </p><p id="p0062" num="0062">[0046] FIGURE 4 is a logic flowchart 400 showing the operation of a cache controller for wear-leveling a cache memory according to an aspect of the present disclosure. FIGURE 4 shows a global counter 404 storing a num Write counter that represents the number of writes, each write represented by the cache write action 402. The SwapReg counter (reflected as "SwapReg") and the ShiftReg counter (expressed as "ShiftReg") may be implemented as data registers for respectively storing the SwapReg and ShiftReg values. </p><p id="p0063" num="0063">[0047] As described with respect to FIGURE 3, if there is a cache write 402, then the global counter 404 is increased. If the global counter is equal to a predetermined threshold value at 406, at block 408 a swap occurs, updating the SwapReg counter to the value of (SwapReg + 1) mod (N-l), where mod is the modulo operator and N is the 
<!-- EPO <DP n="15"/>-->
 number of total cache sets. If SwapReg is zero (410), then in block 412, the ShiftReg counter is updated to the value of (ShiftReg + 1) mod N. </p><p id="p0064" num="0064">[0048] When a logical set (LS) number comes in as a logical set number input 414, the physical set (PS) number can be computed as a physical set number output 418 based on three different situations. </p><p id="p0065" num="0065">[0049] First, as shown in logic box 416, if the logical set number input 414 is equal to the SwapReg value, it means that this logical set is exactly the cache set that should be swapped in this rotation. Therefore, the physical set is mapped to the current shift value of ShiftReg and output as the physical set number output 418. </p><p id="p0066" num="0066">[0050] Second, as also shown in logic box 416, if the logical set number input 414 is larger than the SwapReg value, it means that this cache set has not been shifted in this rotation and keeps the same mapping as the last rotation. Therefore, the physical set is mapped to LS + ShiftReg. In one implementation, the mapping is done by taking the (LS + ShiftReg) value and performing a modulo operation with N, the number of cache sets, and then assigning the resulting value to the physical set. </p><p id="p0067" num="0067">[0051] Third, as also shown in logic box 416, if the logical set number input 414 is smaller than the SwapReg value (the else clause), it means that this cache set has been shifted in this rotation. Therefore, the physical set is mapped to LS + ShiftReg + 1. In one implementation, mapping is done by taking the (LS + ShiftReg + 1) value and performing a modulo operation with N, the number of cache sets, and then assigning the resulting value to physical set. </p><p id="p0068" num="0068">[0052] Three operations similar to the operations discussed above occur in logic box 422, but for the physical set input number 424 in order to compute a logical set number output 420. </p><p id="p0069" num="0069">[0053] When the cache line needs to be written back into the lower level memory, the logical set address is re-generated. The mapping from physical set to logical set is symmetrical. This mapping scheme can also be verified as can be seen in FIGURE 2. Because SwapReg and ShiftReg are changed along with increasing write counts, the mapping between logical set and physical set is changing all the time, which ensures the writes to different physical sets are balanced, reducing write variations. 
<!-- EPO <DP n="16"/>-->
 [0054] Compared to conventional cache architectures, the set index translation in the shift-swap wear-leveling scheme only adds a simple arithmetic operation and can be merged into the row-decoder. In addition, this one-cycle latency overhead is only paid on higher-level cache misses that access lower-level caches. </p><p id="p0070" num="0070">[0055] FIGURE 5 is a process flow diagram 500 illustrating a method for wear- leveling according to an aspect of the present disclosure. In block 502, a number of memory write operations are counted by a global counter by incrementing the global counter by one for every memory write operation. In block 504, when the global counter is equal to a predetermined threshold value, a swap operation is performed and a swap counter is incremented by one. Also, performing the swap operation includes remapping the swapped cache sets, which in turn includes placing dirty data within the two swapped cache sets into the write back buffer and invalidating the other data in the two swapped cache sets. </p><p id="p0071" num="0071"> [0056] In block 506, when the swap counter is equal to N-l, a shift counter is incremented by one and the swap counter is set back to zero. N is the number of cache sets in the cache memory. In block 508, when the shift counter is equal to N, the shift counter is set back to zero. In block 510, an input cache set number is converted into an output cache set number. The input or output cache set number may be the logical set number or the physical set number. </p><p id="p0072" num="0072"> [0057] FIGURE 6 is a process flow diagram 600 illustrating a method for wear- leveling according to an aspect of the present disclosure. In block 610, it is determined whether a number of memory write operations to a cache memory (e.g., num Writes) has reached a predetermined threshold. If so, in block 612 a memory location swap operation is performed on two cache sets. In block 614, the contents from one of the two swapped cache sets are cleared. In block 616, the memory contents of the other of the swapped two cache sets are left intact. In block 618, the swapping of the cache set is tracked. In block 620, a logical cache set number is converted to a physical cache set number. If the number of write operations has not reached the threshold, the process remains at block 610. </p><p id="p0073" num="0073"> [0058] In the swap-shift wear-leveling scheme, the inter-set write variation reduction is related to the number of shift rotations during the experimental time. </p><p id="p0074" num="0074">Assuming there are N sets in the cache, one shift rotation includes N swap rotations and 
<!-- EPO <DP n="17"/>-->
 one swap rotation in the swap-shift scheme needs N - 1 swaps. After each shift rotation, all cache sets are shifted by N steps and logical set indices are mapped to their original positions. Therefore, the more rounds the cache is shifted, the more evenly the write accesses are distributed to each cache set. </p><p id="p0075" num="0075">[0059] According to a further aspect of the present disclosure, a cache controller for wear-leveling of a cache memory is described. The cache controller includes a means for dynamically rotating cache sets of the cache memory by performing a plurality of memory location swap operations on the cache sets when a number of memory write operations to the cache memory reaches a threshold value. Each swap operation may include clearing contents from only swapped cache sets, while leaving memory contents of other cache sets intact. The dynamically rotating means may be the cache controller 140. The apparatus further includes a means for tracking the swapped cache sets to convert a logical cache set number to a physical cache set number. The tracking means may be the cache controller 140, the global counter 142, the swap register 144, and/or the shift register 146. In another aspect, the aforementioned means may be any module or any apparatus configured to perform the functions recited by the aforementioned means. </p><p id="p0076" num="0076">[0060] FIGURE 7 is a block diagram showing an exemplary wireless </p><p id="p0077" num="0077">communication system 700 in which an aspect of the disclosure may be advantageously employed. For purposes of illustration, FIGURE 7 shows three remote units 720, 730, and 750 and two base stations 740. It will be recognized that wireless communication systems may have many more remote units and base stations. Remote units 720, 730, and 750 include IC devices 725A, 725C, and 725B that include the disclosed cache memory. It will be recognized that other devices may also include the disclosed cache memory, such as the base stations, switching devices, and network equipment. </p><p id="p0078" num="0078">FIGURE 7 shows forward link signals 780 from the base station 740 to the remote units 720, 730, and 750 and reverse link signals 790 from the remote units 720, 730, and 750 to base stations 740. </p><p id="p0079" num="0079">[0061] In FIGURE 7, remote unit 720 is shown as a mobile telephone, remote unit 730 is shown as a portable computer, and remote unit 750 is shown as a fixed location remote unit in a wireless local loop system. For example, the remote units may be mobile phones, hand-held personal communication systems (PCS) units, portable data 
<!-- EPO <DP n="18"/>-->
 units such as personal data assistants, global positioning system (GPS) enabled devices, navigation devices, set top boxes, music players, video players, entertainment units, fixed location data units such as meter reading equipment, or other devices that store or retrieve data or computer instructions, or combinations thereof. Although FIGURE 7 illustrates remote units according to the aspects of the disclosure, the disclosure is not limited to these exemplary illustrated units. Aspects of the disclosure may be suitably employed in many devices, which include the disclosed cache memory. </p><p id="p0080" num="0080">[0062] FIGURE 8 is a block diagram illustrating a design workstation used for circuit, layout, and logic design of a semiconductor component, such as the cache memory disclosed above. A design workstation 800 includes a hard disk 801 containing operating system software, support files, and design software such as Cadence or OrCAD. The design workstation 800 also includes a display 802 to facilitate design of a circuit 810 or a semiconductor component 812 such as a cache memory. A storage medium 804 is provided for tangibly storing the circuit design 810 or the semiconductor component 812. The circuit design 810 or the semiconductor component 812 may be stored on the storage medium 804 in a file format such as GDSII or GERBER. The storage medium 804 may be a CD-ROM, digital versatile disc (DVD), hard disk, flash memory, or other appropriate device. Furthermore, the design workstation 800 includes a drive apparatus 803 for accepting input from or writing output to the storage medium 804. </p><p id="p0081" num="0081">[0063] Data recorded on the storage medium 804 may specify logic circuit configurations, pattern data for photolithography masks, or mask pattern data for serial write tools such as electron beam lithography. The data may further include logic verification data such as timing diagrams or net circuits associated with logic simulations. Providing data on the storage medium 804 facilitates the design of the circuit design 810 or the semiconductor component 812 by decreasing the number of processes for designing semiconductor wafers. </p><p id="p0082" num="0082">[0064] For a firmware and/or software implementation, the methodologies may be implemented with modules (e.g., procedures, functions, and so on) that perform the functions described herein. A machine-readable medium tangibly embodying instructions may be used in implementing the methodologies described herein. For example, software codes may be stored in a memory and executed by a processor unit. 
<!-- EPO <DP n="19"/>-->
 Memory may be implemented within the processor unit or external to the processor unit. As used herein, the term "memory" refers to types of long term, short term, volatile, nonvolatile, or other memory and is not to be limited to a particular type of memory or number of memories, or type of media upon which memory is stored. </p><p id="p0083" num="0083">[0065] If implemented in firmware and/or software, the functions may be stored as one or more instructions or code on a computer-readable medium. Examples include computer-readable media encoded with a data structure and computer-readable media encoded with a computer program. Computer-readable media includes physical computer storage media. A storage medium may be an available medium that can be accessed by a computer. By way of example, and not limitation, such computer- readable media can include RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage or other magnetic storage devices, or other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer; disk and disc, as used herein, includes compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk and Blu-ray disc where disks usually reproduce data magnetically, while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer-readable media. </p><p id="p0084" num="0084">[0066] In addition to storage on computer readable medium, instructions and/or data may be provided as signals on transmission media included in a communication apparatus. For example, a communication apparatus may include a transceiver having signals indicative of instructions and data. The instructions and data are configured to cause one or more processors to implement the functions outlined in the claims. </p><p id="p0085" num="0085">[0067] Although the present disclosure and its advantages have been described in detail, it should be understood that various changes, substitutions and alterations can be made herein without departing from the technology of the disclosure as defined by the appended claims. For example, relational terms, such as "above" and "below" are used with respect to a substrate or electronic device. Of course, if the substrate or electronic device is inverted, above becomes below, and vice versa. Additionally, if oriented sideways, above and below may refer to sides of a substrate or electronic device. </p><p id="p0086" num="0086">Moreover, the scope of the present application is not intended to be limited to the particular configurations of the process, machine, manufacture, composition of matter, 
<!-- EPO <DP n="20"/>-->
 means, methods and steps described in the specification. As one of ordinary skill in the art will readily appreciate from the disclosure, processes, machines, manufacture, compositions of matter, means, methods, or steps, presently existing or later to be developed that perform substantially the same function or achieve substantially the same result as the corresponding configurations described herein may be utilized according to the present disclosure. Accordingly, the appended claims are intended to include within their scope such processes, machines, manufacture, compositions of matter, means, methods, or steps. 
</p></description><claims mxw-id="PCLM70076812" ref-ucid="WO-2014130317-A1" lang="EN" load-source="patent-office"><claim-statement><!-- EPO <DP n="21"/>-->CLAIMS  What is claimed is: </claim-statement><claim id="clm-0001" num="1"><claim-text>1. A method for wear-leveling of a cache memory, comprising: </claim-text><claim-text> dynamically rotating cache sets of the cache memory by performing a plurality of memory location swap operations on the cache sets when a number of memory write operations to the cache memory reaches a threshold value, each swap operation including clearing contents from only swapped cache sets, while leaving memory contents of other cache sets intact; and </claim-text><claim-text> tracking the swapped cache sets to convert a logical cache set number to a physical cache set number. </claim-text></claim><claim id="clm-0002" num="2"><claim-text>2. The method of claim 1, in which dynamically rotating the cache sets further comprises: </claim-text><claim-text> counting the number of memory write operations to the cache memory in a global counter; </claim-text><claim-text> initiating the plurality of memory location swap operations when the global counter reaches the threshold value; and </claim-text><claim-text> resetting the global counter. </claim-text></claim><claim id="clm-0003" num="3"><claim-text>3. The method of claim 2, in which dynamically rotating the cache sets comprises: </claim-text><claim-text> setting a swap register (SwapReg) to (the SwapReg + 1) mod (N -1), in which N is a number of the cache sets in the cache memory; and </claim-text><claim-text> setting a shift register (ShiftReg) to (the ShiftReg + 1) mod N when the SwapReg is zero. </claim-text></claim><claim id="clm-0004" num="4"><claim-text>4. The method of claim 1 , further comprising: </claim-text><claim-text> counting the number of memory write operations to the cache memory with a global counter by incrementing the global counter for each memory write operation to the cache memory; </claim-text><claim-text> performing a swap operation and incrementing a swap counter when the global counter equals the threshold value, in which performing the swap operation includes remapping the swapped cache sets; 
<!-- EPO <DP n="22"/>-->
 incrementing a shift counter and resetting the swap counter value when a swap counter value equals N - 1, in which N is a number of the cache sets in the cache memory; and </claim-text><claim-text> when a shift counter value equals N, resetting the shift counter. </claim-text></claim><claim id="clm-0005" num="5"><claim-text>5. The method of claim 4, in which remapping the swapped cache sets comprises: </claim-text><claim-text> storing dirty data within the swapped cache sets into a write back buffer; and invalidating other data in the swapped cache sets. </claim-text></claim><claim id="clm-0006" num="6"><claim-text> 6. The method of claim 4, in which converting an input cache set number to an output cache set number comprises: </claim-text><claim-text> setting an output physical set number to the shift counter value when an input logical set number equals the swap counter value; </claim-text><claim-text> setting the output physical set number to (the input logical set number + the shift counter value) modulo N when the input logical set number is greater than the swap counter value; and </claim-text><claim-text> setting the output physical set number to (the input logical set number + the shift counter value + 1) modulo N when the input logical set number is less than the swap counter value. </claim-text></claim><claim id="clm-0007" num="7"><claim-text>7. The method of claim 4, in which tracking the swapped cache sets comprises: </claim-text><claim-text> setting an output logical set number to the swap counter value when an input physical set number equals the shift counter value; </claim-text><claim-text> setting the output logical set number to (the input physical set number - the shift counter value) modulo N when (the input physical set number - the shift counter value) modulo N is greater than the swap counter value; and </claim-text><claim-text> otherwise, setting the output logical set number to (the input physical set number - the shift counter value - 1) modulo N. </claim-text></claim><claim id="clm-0008" num="8"><claim-text>8. The method of claim 1, further comprising integrating the cache memory into a mobile phone, a set top box, a music player, a video player, an entertainment unit, a navigation device, a computer, a hand-held personal communication systems (PCS) unit, a portable data unit, and/or a fixed location data unit. 
<!-- EPO <DP n="23"/>-->
</claim-text></claim><claim id="clm-0009" num="9"><claim-text>9. A cache controller, comprising: </claim-text><claim-text> a first register that updates after each memory location swap operation on a plurality of cache sets of a cache memory, and resets at each -1 memory location swap operations, in which N is a number of cache sets in the cache memory; and </claim-text><claim-text> a second register that updates after every N-l memory location swap operations on the plurality of cache sets of the cache memory, and resets every (N<sup>2</sup>-N) memory location swap operations, in which the first register and the second register track a relationship between logical locations and physical locations of the cache sets. </claim-text></claim><claim id="clm-0010" num="10"><claim-text>10. The cache controller of claim 9, in which the cache controller is operable to dynamically swap two memory locations and to track the swap operations of the cache sets to convert a logical cache set number to a physical cache set number using the first register and the second register. </claim-text></claim><claim id="clm-0011" num="11"><claim-text>11. The cache controller of claim 9, in which the first register is a swap register (SwapReg) that is set to (the SwapReg + 1) mod (N -1) when a memory swap operation is performed. </claim-text></claim><claim id="clm-0012" num="12"><claim-text>12. The cache controller of claim 11, in which the second register is a shift register (ShiftReg) that is set to (the ShiftReg + 1) mod N when the SwapReg equals zero. </claim-text></claim><claim id="clm-0013" num="13"><claim-text>13. The cache controller of claim 9, </claim-text><claim-text> in which the first register is a swap register (SwapReg) that is set to (the SwapReg + 1) mod (N -l) when a memory swap operation is performed, and </claim-text><claim-text> in which the second register is a shift register (ShiftReg) that is set to (the ShiftReg + 1) mod N when the SwapReg equals zero. </claim-text></claim><claim id="clm-0014" num="14"><claim-text>14. The cache controller of claim 13, in which the cache controller is operable to dynamically swap two memory locations and to track the swap operations of the cache sets to convert a logical cache set number to a physical cache set number using the SwapReg and the ShiftReg. </claim-text></claim><claim id="clm-0015" num="15"><claim-text>15. The cache controller of claim 9, in which the cache controller is operable to initiate the memory location swap operation when a write counter register equals a threshold value. 
<!-- EPO <DP n="24"/>-->
</claim-text></claim><claim id="clm-0016" num="16"><claim-text>16. The cache controller of claim 9, integrated into a mobile phone, a set top box, a music player, a video player, an entertainment unit, a navigation device, a computer, a hand-held personal communication systems (PCS) unit, a portable data unit, and/or a fixed location data unit. </claim-text></claim><claim id="clm-0017" num="17"><claim-text>17. A cache controller for wear-leveling of a cache memory, comprising: means for dynamically rotating cache sets of the cache memory by performing a plurality of memory location swap operations on the cache sets when a number of memory write operations to the cache memory reaches a threshold value, each swap operation including clearing contents from only swapped cache sets, while leaving memory contents of other cache sets intact; and </claim-text><claim-text> means for tracking the swapped cache sets to convert a logical cache set number to a physical cache set number. </claim-text></claim><claim id="clm-0018" num="18"><claim-text>18. The cache controller of claim 17, integrated into a mobile phone, a set top box, a music player, a video player, an entertainment unit, a navigation device, a computer, a hand-held personal communication systems (PCS) unit, a portable data unit, and/or a fixed location data unit. </claim-text></claim><claim id="clm-0019" num="19"><claim-text>19. A method for wear-leveling of a cache memory, comprising: </claim-text><claim-text> the step of dynamically rotating cache sets of the cache memory by performing a plurality of memory location swap operations on the cache sets when a number of memory write operations to the cache memory reaches a threshold value, each swap operation including clearing contents from only swapped cache sets, while leaving memory contents of other cache sets intact; and </claim-text><claim-text> the step of tracking the swapped cache sets to convert a logical cache set number to a physical cache set number. </claim-text></claim><claim id="clm-0020" num="20"><claim-text>20. The method of claim 19, further comprising integrating the cache memory into a mobile phone, a set top box, a music player, a video player, an entertainment unit, a navigation device, a computer, a hand-held personal </claim-text><claim-text>communication systems (PCS) unit, a portable data unit, and/or a fixed location data unit. 
</claim-text></claim></claims><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
