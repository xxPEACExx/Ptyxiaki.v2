<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2959387-A1" country="EP" doc-number="2959387" kind="A1" date="20151230" family-id="51389524" file-reference-id="311200" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="160452582" ucid="EP-2959387-A1"><document-id><country>EP</country><doc-number>2959387</doc-number><kind>A1</kind><date>20151230</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-14708326-A" is-representative="NO"><document-id mxw-id="PAPP193868132" load-source="patent-office" format="original"><country>EP</country><doc-number>14708326.5</doc-number><date>20140211</date><lang>EN</lang></document-id><document-id mxw-id="PAPP193868133" load-source="docdb" format="epo"><country>EP</country><doc-number>14708326</doc-number><kind>A</kind><date>20140211</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC162035429" ucid="IB-2014058920-W" linkage-type="W" load-source="docdb"><document-id format="epo"><country>IB</country><doc-number>2014058920</doc-number><kind>W</kind><date>20140211</date></document-id></priority-claim><priority-claim mxw-id="PPC162032591" ucid="US-201314044206-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201314044206</doc-number><kind>A</kind><date>20131002</date></document-id></priority-claim><priority-claim mxw-id="PPC162030395" ucid="US-201361768003-P" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201361768003</doc-number><kind>P</kind><date>20130222</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1988524394" load-source="docdb">G06F  11/14        20060101AFI20140911BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1987789435" load-source="docdb" scheme="CPC">G06F  11/2035      20130101 LA20151202BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987799782" load-source="docdb" scheme="CPC">G06F  11/1482      20130101 LI20151202BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987800639" load-source="docdb" scheme="CPC">G06F   8/70        20130101 FI20140828BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT165549212" lang="DE" load-source="patent-office">VERFAHREN UND SYSTEM ZUR BEREITSTELLUNG EINER HOHEN VERFÜGBARKEIT FÜR STATUSBEWUSSTE ANWENDUNGEN</invention-title><invention-title mxw-id="PT165549213" lang="EN" load-source="patent-office">METHOD AND SYSTEM FOR PROVIDING HIGH AVAILABILITY FOR STATE-AWARE APPLICATIONS</invention-title><invention-title mxw-id="PT165549214" lang="FR" load-source="patent-office">PROCÉDÉ ET SYSTÈME PERMETTANT D'ASSURER UNE HAUTE DISPONIBILITÉ POUR DES APPLICATIONS ATTENTIVES À LEUR ÉTAT</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR1103326901" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>ERICSSON TELEFON AB L M</last-name><address><country>SE</country></address></addressbook></applicant><applicant mxw-id="PPAR1103328922" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>TELEFONAKTIEBOLAGET L M ERICSSON (PUBL)</last-name></addressbook></applicant><applicant mxw-id="PPAR1101647934" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Telefonaktiebolaget L M Ericsson (publ)</last-name><iid>101537273</iid><address><city>164 83 Stockholm</city><country>SE</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR1103344712" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>KANSO ALI</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR1103322670" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>KANSO, ALI</last-name></addressbook></inventor><inventor mxw-id="PPAR1101650552" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>KANSO, ALI</last-name><address><street>155 Rue Saillant</street><city>Laval, Québec H7H 0A3</city><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR1103322737" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>LEMIEUX YVES</last-name><address><country>CA</country></address></addressbook></inventor><inventor mxw-id="PPAR1103319678" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>LEMIEUX, YVES</last-name></addressbook></inventor><inventor mxw-id="PPAR1101640864" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>LEMIEUX, YVES</last-name><address><street>245 Acres</street><city>Kirkland, Québec H9H 4M1</city><country>CA</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR1101642252" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Röthinger, Rainer</last-name><iid>101205746</iid><address><street>Wuesthoff &amp; Wuesthoff Patentanwälte PartG mbB Schweigerstrasse 2</street><city>81541 München</city><country>DE</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="IB-2014058920-W"><document-id><country>IB</country><doc-number>2014058920</doc-number><kind>W</kind><date>20140211</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2014128597-A1"><document-id><country>WO</country><doc-number>2014128597</doc-number><kind>A1</kind><date>20140828</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS660703794" load-source="docdb">AL</country><country mxw-id="DS660704042" load-source="docdb">AT</country><country mxw-id="DS660726031" load-source="docdb">BE</country><country mxw-id="DS660710246" load-source="docdb">BG</country><country mxw-id="DS660788987" load-source="docdb">CH</country><country mxw-id="DS660726032" load-source="docdb">CY</country><country mxw-id="DS660704051" load-source="docdb">CZ</country><country mxw-id="DS660703800" load-source="docdb">DE</country><country mxw-id="DS660726033" load-source="docdb">DK</country><country mxw-id="DS660726034" load-source="docdb">EE</country><country mxw-id="DS660625203" load-source="docdb">ES</country><country mxw-id="DS660710255" load-source="docdb">FI</country><country mxw-id="DS660788988" load-source="docdb">FR</country><country mxw-id="DS660703801" load-source="docdb">GB</country><country mxw-id="DS660726043" load-source="docdb">GR</country><country mxw-id="DS660703802" load-source="docdb">HR</country><country mxw-id="DS660704052" load-source="docdb">HU</country><country mxw-id="DS660788989" load-source="docdb">IE</country><country mxw-id="DS660726044" load-source="docdb">IS</country><country mxw-id="DS660710256" load-source="docdb">IT</country><country mxw-id="DS660726045" load-source="docdb">LI</country><country mxw-id="DS660710257" load-source="docdb">LT</country><country mxw-id="DS660626266" load-source="docdb">LU</country><country mxw-id="DS660710258" load-source="docdb">LV</country><country mxw-id="DS660710279" load-source="docdb">MC</country><country mxw-id="DS660626271" load-source="docdb">MK</country><country mxw-id="DS660626272" load-source="docdb">MT</country><country mxw-id="DS660726046" load-source="docdb">NL</country><country mxw-id="DS660703808" load-source="docdb">NO</country><country mxw-id="DS660726063" load-source="docdb">PL</country><country mxw-id="DS660710280" load-source="docdb">PT</country><country mxw-id="DS660704053" load-source="docdb">RO</country><country mxw-id="DS660710281" load-source="docdb">RS</country><country mxw-id="DS660726064" load-source="docdb">SE</country><country mxw-id="DS660788990" load-source="docdb">SI</country><country mxw-id="DS660703809" load-source="docdb">SK</country><country mxw-id="DS660703810" load-source="docdb">SM</country><country mxw-id="DS660626273" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><abstract mxw-id="PA139077592" ref-ucid="WO-2014128597-A1" lang="EN" load-source="patent-office"><p num="0000">A middleware that manages high availability of a software application is automatically configured when the software application is added to a system. The method of automatic configuration includes receiving a user input that specifies availability requirements and information of the software application, where the availability requirements include at least a checkpoint service that enables the software application to save and retrieve its state. The method also includes identifying a checkpoint agent for providing the checkpoint service to the software application. The checkpoint agent includes a first interface to the software application and a second interface, different from the first interface, to the middleware. A middleware configuration is generated that satisfies the availability requirements, based on the information of the software application such that the middleware offers the checkpoint service to the software application through the checkpoint agent and directly manages lifecycles of the software application.</p></abstract><abstract mxw-id="PA139544328" ref-ucid="WO-2014128597-A1" lang="EN" source="national office" load-source="docdb"><p>A middleware that manages high availability of a software application is automatically configured when the software application is added to a system. The method of automatic configuration includes receiving a user input that specifies availability requirements and information of the software application, where the availability requirements include at least a checkpoint service that enables the software application to save and retrieve its state. The method also includes identifying a checkpoint agent for providing the checkpoint service to the software application. The checkpoint agent includes a first interface to the software application and a second interface, different from the first interface, to the middleware. A middleware configuration is generated that satisfies the availability requirements, based on the information of the software application such that the middleware offers the checkpoint service to the software application through the checkpoint agent and directly manages lifecycles of the software application.</p></abstract><abstract mxw-id="PA139077593" ref-ucid="WO-2014128597-A1" lang="FR" load-source="patent-office"><p num="0000">L'invention concerne un intergiciel qui gère la haute disponibilité d'une application logicielle et qui est configuré automatiquement lorsque l'application logicielle est ajoutée à un système. Le procédé de configuration automatique consiste à recevoir une entrée utilisateur qui indique des exigences en disponibilité et des informations sur l'application logicielle, les exigences en disponibilité comprenant au moins un service de point de contrôle qui permet de sauvegarder l'application logicielle et d'extraire son état. Le procédé consiste également à identifier un agent de point de contrôle afin de fournir le service de point de contrôle à l'application logicielle. L'agent de point de contrôle comprend une première interface à l'application logicielle et une seconde interface, différente de la première, à l'intergiciel. Une configuration d'intergiciel est générée de façon à satisfaire aux exigences en disponibilité sur la base des informations de l'application logicielle de sorte que l'intergiciel offre le service de point de contrôle à l'application logicielle par l'intermédiaire de l'agent de point de contrôle et gère directement les cycles de vie de l'application logicielle.</p></abstract><abstract mxw-id="PA139544329" ref-ucid="WO-2014128597-A1" lang="FR" source="national office" load-source="docdb"><p>L'invention concerne un intergiciel qui gère la haute disponibilité d'une application logicielle et qui est configuré automatiquement lorsque l'application logicielle est ajoutée à un système. Le procédé de configuration automatique consiste à recevoir une entrée utilisateur qui indique des exigences en disponibilité et des informations sur l'application logicielle, les exigences en disponibilité comprenant au moins un service de point de contrôle qui permet de sauvegarder l'application logicielle et d'extraire son état. Le procédé consiste également à identifier un agent de point de contrôle afin de fournir le service de point de contrôle à l'application logicielle. L'agent de point de contrôle comprend une première interface à l'application logicielle et une seconde interface, différente de la première, à l'intergiciel. Une configuration d'intergiciel est générée de façon à satisfaire aux exigences en disponibilité sur la base des informations de l'application logicielle de sorte que l'intergiciel offre le service de point de contrôle à l'application logicielle par l'intermédiaire de l'agent de point de contrôle et gère directement les cycles de vie de l'application logicielle.</p></abstract><description mxw-id="PDES78477431" ref-ucid="WO-2014128597-A1" lang="EN" load-source="patent-office"><!-- EPO <DP n="2"/>--><p id="p0001" num="0001"> METHOD AND SYSTEM FOR PROVIDING HIGH AVAILABILITY FOR STATE-AWARE APPLICATIONS </p><p id="p0002" num="0002">TECHNICAL FIELD </p><p id="p0003" num="0003">Embodiments of the invention relate to availability management; and more specifically, to the use of high availability middleware for managing system availability. BACKGROUND </p><p id="p0004" num="0004">The advancement in the information technology is changing the way services are being delivered, and is introducing new business models based on broadband internet access, e.g., VoIP (voice over the internet protocol). The services provided by the applications are considered highly available if they are accessible 99.999% of the time (also known as five 9's). High Availability (HA) has become a key requirement for critical applications and revenue generating applications. The Service Availability Forum (also referred to as the "SA Forum" or "SAF"), a consortium of telecom and computing companies, has defined a set of specifications that describe a middleware that manages the HA of the applications. The middleware requires a configuration that describes each of the applications it manages. Moreover, the applications that wish to interact with the middleware (e.g., to checkpoint their state) need to implement the SA Forum Application Programming Interface (API). This process requires deep knowledge of the field from the application developers, as well as from the system integrator that needs to define a complex configuration. </p><p id="p0005" num="0005"> More specifically, the HA middleware defined by the SA Forum comprises a core that is based on the Availability Management Framework (AMF). AMF is responsible for maintaining the service availability by detecting and reacting to failures. AMF performs the availability management according to a system configuration known as the AMF configuration. The AMF configuration is a logical organization of the software </p><p id="p0006" num="0006">components describing their dependencies, the services they provide, the recovery policy that AMF must apply in case of failure, how they are grouped, etc. </p><p id="p0007" num="0007"> In the following, the main elements of the AMF configuration will be described. The basic building block of the AMF configuration is an AMF component (also referred to as a component), which abstracts a deployable instance of an application's component. The service(s) provided by such a component is represented by a component-service- instance. The components that collaborate closely and that must be collocated to provide a 
<!-- EPO <DP n="3"/>-->
 more integrated service are grouped into a service-unit. The workload assigned to the service-unit is referred to as the service-instance, which is a grouping of component- service-instances. The service-units composed of redundant component replicas form a service-group. The service availability management takes place within the service-group, i.e., the service instances are provided by service-units and protected against failures within the scope of the service-group. The AMF configuration also represents the nodes on which the components are deployed. AMF supports the notion of a redundancy model for a service-group. The redundancy model defines the redundancy scheme according to which the service-instances are protected. For instance a 2N redundancy indicates that the service-group can have one active service-unit for all the service-instances and one standby for all the service-instances. For example, a service-unit cannot simultaneously be active for some service-instances and standby for others. </p><p id="p0008" num="0008"> Figure 1 illustrates an example AMF configuration, in which there is one service- group (SGI) with 2N redundancy. The service-group (SGI) contains two redundant service-units (SU1 and SU2), deployed on nodes Nodel and Node2, respectively. One service-unit is active and one is in standby, ready to take over if the active one fails. Each service-unit (SU1 or SU2) has two components ((CI and C2) for SU1; (C3 and C4) for SU2). The service-group (SGI) protects two service-instances (SI1 and SI2). Each service-instance is composed of two component-service-instances ((CSI1 and CSI2) for SI1; (CSI3 and CSI4) for SI2). The AMF configuration also contains attributes that can determine the recovery executed by AMF at runtime in case a failure of a component or a service-instance is detected. All of the elements shown in Figure 1 are represented by objects in the AMF configuration. The structure of these objects has to comply with a Unified Modeling Language (UML) class diagram. The configuration objects are described according to a standardized machine-readable extensible Markup Language (XML) schema. It is the responsibility of a system integrator to define the AMF configuration. </p><p id="p0009" num="0009"> A distinction between a component and an application is explained in the following. From a software engineering perspective, an application (more specifically, the executable code of an application) can have one or more application components. From an HA perspective, each deployment (i.e., installation) of an application component is considered a distinct component. For example, a given application such as a database can be considered as one application composed of one application component (i.e., the 
<!-- EPO <DP n="4"/>-->
 database). However, if the database is replicated on three nodes (for redundancy), then this application is considered to have three components from an HA perspective, and thus the AMF middleware configuration would include the description of three distinct components. In the context described herein, a user describes an application from a software engineering perspective; however, once deployed and managed by the middleware, the application is viewed from an HA perspective. </p><p id="p0010" num="0010"> An example of the services offered by the HA middleware is a checkpoint service. The checkpoint service allows the components at runtime to create checkpoint objects that can store data representing the application state. Once a checkpoint object is created, the checkpoint service makes sure that the checkpoint object is properly replicated within the cluster/computing system to avoid losing the state information in case of failure. The checkpoint service offers various modes of synchronizations between the replicated checkpoint objects (e.g., synchronous and asynchronous). One main objective behind the checkpoint service is to allow an application to have service continuity, by conserving its state in case of the application failure. </p><p id="p0011" num="0011"> In order for a software component to interact with AMF, or other middleware services such as the checkpoint, it needs to implement the service specific APIs defined by the SA Forum specifications, i.e., the API implementation is incorporated in the code of the software component. This requires the application developers to have detailed knowledge of the APIs and the AMF architecture. </p><p id="p0012" num="0012"> A number of approaches for managing the high availability of a software application have been proposed. The approaches generally fall into three categories. In the first category, the middleware does not offer checkpoint service to the application; thus, the application state cannot be preserved by the middleware. In the second category, the application implements the APIs required by the middleware; thus, detailed knowledge of the SA Forum specifications and the APIs is needed. In the third category, the middleware controls and communicates with the application via a proxy; thus, if the proxy fails, the middleware loses the means of communication with the application. All of these approaches have drawbacks in providing high availability for applications that need to preserve their state. Therefore, there is still a need to improve the management of high availability and service continuity of software applications. 
<!-- EPO <DP n="5"/>-->
 SUMMARY </p><p id="p0013" num="0013"> In one embodiment, a method for automatically configuring a middleware is provided to manage high availability of a software application to be added to a system. The method comprises receiving a user input that specifies availability requirements and information of the software application, where the availability requirements include at least a checkpoint service that enables the software application to save and retrieve its state. The method also comprises identifying a checkpoint agent for providing the checkpoint service to the software application. The checkpoint agent includes a first interface to the software application and a second interface, different from the first interface, to the middleware. A middleware configuration is generated that satisfies the availability requirements, based on the information of the software application such that the middleware offers the checkpoint service to the software application through the checkpoint agent and directly manages lifecycles of the software application. </p><p id="p0014" num="0014"> In another embodiment, there is provided a computer system adapted to automatically configure a middleware that manages high availability of a software application to be added to a system. The computer system comprises a processor and a memory, the memory containing instructions executable by the processor. The computer system is operative to receive a user input that specifies availability requirements and information of the software application, where the availability requirements include at least a checkpoint service that enables the software application to save and retrieve its state. The computer system is also operative to identify a checkpoint agent for providing the checkpoint service to the software application. The checkpoint agent includes a first interface to the software application and a second interface, different from the first interface, to the middleware. A middleware configuration is generated that satisfies the availability requirements, based on the information of the software application such that the middleware offers the checkpoint service to the software application through the checkpoint agent and directly manages lifecycles of the software application. 
<!-- EPO <DP n="6"/>-->
 BRIEF DESCRIPTION OF THE DRAWINGS </p><p id="p0015" num="0015"> The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that different references to "an" or "one" embodiment in this disclosure are not necessarily to the same embodiment, and such references mean at least one. Further, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the art to effect such feature, structure, or characteristic in connection with other embodiments whether or not explicitly described. </p><p id="p0016" num="0016"> Figure 1 illustrates an example of a middleware configuration that may be generated according one embodiment. </p><p id="p0017" num="0017"> Figure 2 illustrates a method performed by a state-aware application according to one embodiment. </p><p id="p0018" num="0018"> Figure 3 illustrates a schematic diagram of a system for providing high availability and service continuity to a state-aware application according to one embodiment. </p><p id="p0019" num="0019"> Figure 4 is a message diagram illustrating an example of the method of Figure 2 for providing service continuity according to one embodiment. </p><p id="p0020" num="0020"> Figure 5 is a diagram illustrating a process for adding an application on demand according to one embodiment. </p><p id="p0021" num="0021"> Figure 6 illustrates an example of an integration agent according to one </p><p id="p0022" num="0022">embodiment. </p><p id="p0023" num="0023"> Figure 7 illustrates added extension to the UML according to one embodiment.</p><p id="p0024" num="0024">Figure 8 illustrates an example of a high-level software description based on an extended UML component diagram according to one embodiment. </p><p id="p0025" num="0025"> Figure 9 illustrates a method for automatically configuring a middleware when a software application is added, according one embodiment. </p><p id="p0026" num="0026"> Figure 10 illustrates a block diagram of a computer system according to one embodiment. 
<!-- EPO <DP n="7"/>-->
 DETAILED DESCRIPTION </p><p id="p0027" num="0027"> In the following description, numerous specific details are set forth. However, it is understood that embodiments of the invention may be practiced without these specific details. In other instances, well-known circuits, structures and techniques have not been shown in detail in order not to obscure the understanding of this description. It will be appreciated, however, by one skilled in the art, that the invention may be practiced without such specific details. Those of ordinary skill in the art, with the included descriptions, will be able to implement appropriate functionality without undue experimentation. </p><p id="p0028" num="0028"> High availability of applications is typically managed by specialized software or middleware, e.g., the OpenSAF middleware based on the SAF specifications. The middleware monitors the applications and reacts to their failure by automatically recovering their services. The behavior of the middleware is based on its configuration. For instance, the AMF service of the middleware, which is responsible for maintaining the availability of the applications, operates based on the AMF configuration. The AMF configuration conforms to the SAF standardized models and the constraints defined in the SAF specifications. The applications managed by AMF are described in the AMF configuration. </p><p id="p0029" num="0029"> In order to enable the service continuity of software applications, the state of the applications is to be saved in order for restoration in the case of application failure. </p><p id="p0030" num="0030">Before going further, the notion of state-aware applications is defined. A state-aware application is a stateful application that is aware of its state, and can save and acquire this state as needed. In other words, a state-aware application not only has state, but also saves and retrieves its state as needed. By contrast, a stateless application does not keep track of what has happened since it started executing. Thus, no state information about a stateless application is maintained. </p><p id="p0031" num="0031"> Moreover, for the simplicity of the discussion, unless it is specifically indicated otherwise, a software application ("application") is assumed to have one component. In general cases, an application can have more than one component; thus, a "state-aware application" means that at least one component of the application is state-aware. </p><p id="p0032" num="0032"> Figure 2 illustrates a method 200 performed by a state-aware application according to one embodiment. Upon instantiation (blocks 210-211), the state-aware application acquires its last saved state from a checkpoint agent (block 212). If such a state does not exist, then the application starts from an initial or default state (block 213); otherwise the 
<!-- EPO <DP n="8"/>-->
 application continues executing from the last saved state (block 214). What constitutes a state or data type to be saved depends on the particular applications. Therefore, the state can be synchronous or asynchronous. For instance, if the application is media streaming, then an example of its current state may be the address of the media and the current position of the stream. As long as the application is instantiated, it may send its state to the checkpoint agent (block 215). The method 200 ends when the application terminates. </p><p id="p0033" num="0033"> Now turning to Figure 3, which illustrates a schematic diagram of a system for providing high availability and service continuity to a state-aware application according to an embodiment. This system comprises a state-aware application 310 (shown in Figure 3 as a software (SW) application), an HA agent 320, an integration agent 330, a checkpoint agent 340 and an HA middleware 350. The state-aware application 310 communicates with the checkpoint-agent 340 through a first interface, and the checkpoint-agent 340 communicates with the HA middleware 350 through a second interface. The system can have multiple state-aware applications at any given point in time. This number can change dynamically with time and based on the need. </p><p id="p0034" num="0034"> A system integrator/user interacts directly with the HA agent 320. As used herein, the term "user" may refer to a cloud user, a system administrator/integrator, or who wishes to use an application in a high-availability manner. In some scenarios, a "user" may be a software provider or designer. The user will provide basic information such as the scripts (or commands) to instantiate/cleanup its application, as well as the redundancy model according to which the HA middleware 350 will protect the application. The user can also specify the installation scripts (or commands), which allows the HA middleware 350 within the Software Management Framework (SMF) to automatically deploy the application on several nodes without the user's intervention. In one embodiment, the user may specify application components and HA requirements/policies as input to the HA agent 320. The application components may be specified in an Entity Types File (ETF), or using a high-level software description which can be transformed into an ETF. In one embodiment, the high-level software description may be in a modeling language such as the Unified Modeling Language (UML) with extended constructs, also referred to as an extended UML component diagram. The extended UML component diagram will be described later with reference to Figure 7 and Figure 8. </p><p id="p0035" num="0035"> In one embodiment, the HA agent 320 is responsible for selecting the proper checkpoint agents for an application. In a scenario where the application has multiple 
<!-- EPO <DP n="9"/>-->
 components, these components may be assigned the same or different checkpoint agents. In addition, in a cloud environment, the HA agent 320 is also responsible for calculating the needed number of virtual machines (VMs), and selecting the placement of </p><p id="p0036" num="0036">applications' components in the VMs. </p><p id="p0037" num="0037"> In one embodiment, the integration agent 330 accepts the user input via the HA agent 320, in addition to the results of the decisions made by the HA agent 320. </p><p id="p0038" num="0038">Moreover, in some embodiments, the integration agent 330 is responsible for: (1) generating an ETF and configuration requirements, both of which serve as input to the AMF configuration generation; and (2) generating installation campaigns and removal campaigns of the application to be added. The generated AMF configuration can be used to modify the current configuration of the HA middleware 350 to incorporate the newly added application into the current middleware configuration. </p><p id="p0039" num="0039"> The checkpoint agent 340 is responsible for managing the state of the state-aware application 310. An application's component can only use the checkpoint agent 340 if the application has been authenticated to do so; otherwise the checkpoint agent 340 will ignore the application's requests. In one embodiment, the checkpoint agent 340 has a first interface and a second interface, which are different from each other. The first interface allows the checkpoint agent 340 to interact with the state-aware application 310. Through this first interface, the checkpoint agent 340 receives a state from the state-aware application 310 for storing purposes, and may also receive checkpoint requests from the state-aware application 310 for retrieving the saved state. The first interface uses a simple and generic protocol; as an example, the first interface can implement a Representational State Transfer (REST) interface 341. The second interface allows the checkpoint agent 340 to interact with the HA middleware 350 and use the middleware's checkpoint service to save the state from the state-aware application 310. To do so, the second interface implements the API of the middleware 350 (e.g., the SAF API 342). </p><p id="p0040" num="0040"> From the middleware's perspective, the state-aware application 310 appears to be a non-proxied and non-SA-aware (non-service-availability-aware) application, where non- proxied means that the middleware interacts with the application directly without a proxy, and non-SA-aware means that the application does not implement the SAF API. The checkpoint agent 340 appears to be an SA-aware application, where an SA-aware application is an application that implements the SAF API. 
<!-- EPO <DP n="10"/>-->
 When detecting a failure of the state-aware application 310, the middleware 350 re- instantiates the application 310. After re-instantiation, the state-aware application 310 requests for the state saved in the middleware 350 through the checkpoint agent 340, the state allowing the state-aware application 310 to have service continuity. It should be noted that by re-instantiation, it means that the application 310 can be restarted or that the application (or a spare application) can be re-instantiated on another node. </p><p id="p0041" num="0041"> It should be noted that the lack of checkpointing (in case the checkpoint is done in a periodic manner) can indicate an internal failure or malfunction of the state-aware application 310 that is not necessarily detected by the middleware 350 passive monitoring (i.e., monitoring an application without involving the application in reporting its health state; in other words, the application has a passive role in the monitoring process). </p><p id="p0042" num="0042">Therefore, the checkpoint agent 340 can detect and report this failure to the middleware 350 through an API, notifying it that a recovery is needed for the state-aware application 310. </p><p id="p0043" num="0043"> The REST interface 341 does not define an API, but rather it is an architectural style that defines a client-server communication. From this perspective, the state-aware application 310 would be the client and the checkpoint agent 340 would be the server. The REST interface 341 is widely known by programmers, and already used by the majority of web-based applications. REST is agnostic of the programming language used to develop the application. Thus, it allows the server-client communication in a generic way since it uses Unified Resource Identifiers (URIs). Moreover, REST allows location transparency, where the client does not need to know the physical address of the server. This also allows for replicating checkpoint agents across the cluster, and use virtual addressing solutions (e.g., virtual IP) to access the agents. By so doing, failures of the checkpoint agent 340 can be tolerated, since other checkpoint agents can resume the same task. </p><p id="p0044" num="0044"> In an embodiment that uses REST in the context of Hypertext Transfer Protocol (HTTP), a handful of methods (e.g., Get, Put, Delete, etc.) can be used for the </p><p id="p0045" num="0045">communication between the client (state-aware application 310) and the server (checkpoint agent 340). For example, the state-aware application 310 can acquire its state using the method GET with a URI (or an ID) of the resource representing this state. A resource could be a file, or an object, or any other representation of the state. In response, the checkpoint agent 340 returns this resource to the state-aware application 310. After the state-aware application 310 obtains its last saved state, it uses the method PUT to give its 
<!-- EPO <DP n="11"/>-->
 subsequent states to the checkpoint agent 340. The PUT method comprises the state and the ID of the resource representing the state. It should be noted that other protocols for communication between the state-aware application 310 and the checkpoint agent 340 can be used. </p><p id="p0046" num="0046"> Thus, the state-aware application 310 without implementing the SAF APIs can be highly available, as its state can be saved and restored in case of failure through the checkpoint agent 340 and the REST interface 341. Meanwhile, the HA middleware 350 maintains its direct control over lifecycle management of the applications. The HA middleware 350 can directly install, instantiate and monitor the state-aware application 310 without the application implementing an SAF API. The direct control of the HA middleware 350 is unidirectional; i.e., the application 310 is not aware of the existence of the middleware 350, but the middleware 350 knows how to install, start/stop and monitor the application 310. The install and instantiate can be performed by the middleware 350 through scripts and not APIs. As for the monitoring, the middleware 350 performs a passive monitoring in collaboration with the operating system (or potentially another component) without the involvement of the state-aware application 310 in reporting its health state. </p><p id="p0047" num="0047"> Although not shown in the embodiment of Figure 3, in some alternative </p><p id="p0048" num="0048">embodiments the checkpoint agent 340 has a third interface to a database using a database connection. In these alternative embodiments, the checkpoint agent 340 has the option of storing the state of the application 310 as a record (or object) in the database, or as an object in the checkpoint service of the HA middleware 350. The decision on where to store the state may be based on user preferences or other factors such as current workload; e.g., the checkpoint agent 240 can chose to put more load of saving/retrieving the state on the database and less load on the middleware, or vice versa. Thus, in one embodiment, a computer system that performs the method of the checkpoint agent 340 may allocate a first portion of workload of the checkpoint service on the database for saving and retrieving the state of a software application, and allocate a second portion of workload of the checkpoint service on the middleware for saving and retrieving the state of the software application. </p><p id="p0049" num="0049"> Figure 4 is a message diagram illustrating a more detailed example of the method</p><p id="p0050" num="0050">200 of Figure 2 for providing service continuity according to one embodiment. The message exchanges in the diagram start with a system integrator/user 450 providing (401) basic information about a state-aware application and its availability requirements to the 
<!-- EPO <DP n="12"/>-->
 integration agent 330 (via the HA agent 320 of Figure 3). The integration agent 330 processes this information and produces an AMF configuration for the application 310 to be merged (402) with the running system configuration. Thereafter, the integration agent 330 creates an upgrade campaign that reflects the addition of the application 310, which is then fed to the middleware 350. The upgrade campaign modifies the middleware configuration by extending it to include the configuration for the added application 310. The middleware 350 then realizes that there is a new state-aware application 310; </p><p id="p0051" num="0051">therefore, it deploys the application 310 and instantiates (403) it with the proper arguments; e.g., by specifying in the configuration file a checkpoint agent 340 assigned to the application 310. After being instantiated, the application 310 tries to acquire (404) its last saved state, by using a generic REST interface to communicate with the assigned checkpoint agent 340. In the request (GET), the application 310 tries to acquire its last saved state from the checkpoint agent 340 in the system. If this is an initial instantiation, then such a state does not exist. More specifically, the checkpoint agent 340 sends (405) a message to the middleware 350 using the second interface with the API of the middleware 350 to search for checkpoints associated with the ID of the checkpoint object representing the state. The middleware 350 sends back (406) a message to the checkpoint agent 340 to indicate that no state matching this ID can be found. The checkpoint agent 340 relays this information back to the application 310, which then starts executing from a default state. Subsequently, the application 310 starts checkpointing its state, again using the REST interface. More specifically, the state-aware application 310 sends a PUT method (407) to the checkpoint agent 340 with the state and the ID of the resource representing the state as parameters. Upon receipt of the state, the checkpoint agent 340 sends the state to the middleware 350 to checkpoint (408) this state using the middleware checkpoint service. This can happen on a regular basis for synchronous applications such as video streaming, or it can happen based on a particular event. </p><p id="p0052" num="0052"> In case of a failure of the application, the middleware 350 can detect (409) it, and react to it. The recovery could be a restart of the application 310 or a failover to a spare/redundant application 420. In a scenario where the application 310 has multiple components and one component fails, the recovery could be a restart of the failed component or a failover to a spare/redundant component. In the following, as an example, the recovery uses the spare application 420. After detection of the failure, the middleware 350 directly communicates with the spare application 420 for instantiating (410) the 
<!-- EPO <DP n="13"/>-->
 application 420 on a different cluster node, for example. After instantiation, the spare application 420, being a state-aware application, wants to acquire its state. To do so, the application 420 sends a GET method (411) to the first interface of the checkpoint agent 340. Upon receipt of the request, the checkpoint agent 340 communicates with the middleware 350 using the API to retrieve (412) a previous state of the application 310 before the application 310 failed. The middleware 350 searches in its checkpoint objects for one that has name that is associated (or identical, depending on how the checkpoint agent is implemented to store the state) with the ID of the resource. Once the middleware 350 finds the associated state, it returns (413) it to the checkpoint agent 340, which then returns (414) it to the application 420. The application 420 can start from the previous state that was saved in the middleware 350, instead of the default state. Subsequently, the application 420 can save (415) its state in the middleware 350 as it was the case with the application 310. </p><p id="p0053" num="0053"> It should be noted that the embodiments of the invention may be used in a cloud environment for providing high availability and continuity of the services. In that case, the system integrator would be a cloud user, for example. </p><p id="p0054" num="0054"> The embodiments of the present invention are scalable. Not only the applications can be added or removed on demand, the checkpoint agents can also be added or removed on demand during runtime of the highly available system. This is because the checkpoint agents are generic so their assignments to the applications do not have to be fixed, as any checkpoint agent can take over the role of its peer. In other words, the checkpoint agents are elastic and, depending on the demand, more checkpoint agents can be added to accommodate the requests of the added state-aware applications. When the demand diminishes, the added checkpoint agents can be removed. This leads to offer high availability as a service for cloud users. For instance, not all applications in the cloud need to be highly available around the clock. Certain applications perform critical computation at certain hours; e.g., applications analyzing the stock market based on data-mining typically perform the analysis after the market trading hours, and therefore only need to be instantiated and highly available during specific hours. Other applications, potentially running on the same VMs, may need high availability at different hours. In one embodiment, the demand is based on policies defined by a user of the application, where the policies specify triggers for providing high availability to the application. For 
<!-- EPO <DP n="14"/>-->
 example, the triggers may be defined in terms of traffic thresholds, time of day, or other factors. </p><p id="p0055" num="0055"> In order to offer this high availability on demand, applications can be added or removed through an upgrade campaign that automatically adds or removes the applications from the middleware information model (without necessarily un-installing the application, unless it is needed to save resources). In short, upgrade campaigns can be scheduled in a timely manner, where the cloud user simply needs to specify the time/event which he needs his applications to be instantiated to have high availability. </p><p id="p0056" num="0056"> In one embodiment, a cloud management system may include an HA module, which further includes an HA agent, an integration agent and one or more checkpoint agents. A user can interact with the HA module to add or remove the applications that he/she wishes to deploy in the cloud environment on demand. In one embodiment, the added applications do not need to implement the SAF APIs to become highly available on demand. </p><p id="p0057" num="0057"> Figure 5 illustrates a process for adding an application and making it HA on demand according to one embodiment. The process enables the automatic deployment of applications, monitors their health, manages their recovery, and offers them a checkpoint facility that does not require any middleware APIs implementation. The same process can be applied to stateless and state-aware applications, except that stateless applications do not need checkpoint services and therefore no checkpoint agents will be assigned to stateless applications. </p><p id="p0058" num="0058"> In the embodiment of Figure 5, in the leftmost column under "agent responsible" is a list of agents responsible for the task listed in the middle column. In the rightmost column is the method/implementation to enable the task to be performed. The lists of tasks are shown to include five main tasks, which will be explained in detail as follows. </p><p id="p0059" num="0059"> Task 1 is to accept user input (510). The HA agent accepts the user input that describes an application and the HA requirements. Each application may have a different organization, architecture and HA requirements; therefore, a generic model is needed that defines syntax and semantics for the users to describe their applications and the HA requirements. One embodiment of this genetic model is an extended UML component diagram, which will be described in detail with reference to Figure 7 and Figure 8. </p><p id="p0060" num="0060"> Task 2 is to transform the user input into configuration requirements and automatically generate an ETF (520). The integration agent automatically transforms the 
<!-- EPO <DP n="15"/>-->
 user input into the input of a configuration generator. The input to the configuration generator includes configuration requirements and one or more ETF files. </p><p id="p0061" num="0061"> Task 3 is to generate the middleware configuration including information of checkpoint agents (530). The configuration generator automatically generates a middleware configuration based on its input. In one embodiment, the generated middleware configuration identifies a checkpoint agent which is selected to maintain the state of a state-aware application. The selection of the checkpoint agent can be based on criteria specified by the application according to its needs. For example, if applications (Appl and App2) in nodel require fast checkpoint retrieval, then checkpoint agent CI can be collocated with Appl and App2 in nodel . If another application (App3) in node2 does not require fast checkpoint retrieval, then checkpoint agent CI can be assigned to also handle the requests of App3 as well. When selecting a checkpoint agent for a state-aware application, the factors to be considered include such as checkpoint frequency, data size per checkpoint, network latency, etc., and the factors may be weighed based on given preferences. Note that the checkpoint agent is a stateless component that can be replicated without the application being made aware of it. Thus, in one embodiment, multiple checkpoint agents may be hidden behind a load balancer to scale up the capacity for handling higher frequencies of checkpoint requests. </p><p id="p0062" num="0062"> In one embodiment, the checkpoint agent may be identified by information such as its domain name or address. This information, as well as additional information such as the path to the resources that the application can access and manipulate (to save/retrieve its state using the REST methods), may be included in a command's arguments directed to the state-aware application, such as the instantiate command. This means that, upon instantiation, the state-aware application will be given the information that identifies a checkpoint agent assigned to it. To ensure the service continuity in case of a checkpoint agent failure, multiple checkpoint agents can have the same virtual-address and therefore handle checkpoint requests for the same state-aware application. </p><p id="p0063" num="0063"> Task 4 is to add authentication for the application to authenticate with the assigned checkpoint agent(s) (540). As mentioned before, an application's component can only use a checkpoint agent if the application has been authenticated to do so; otherwise the checkpoint agent will ignore (reject) the application's requests. </p><p id="p0064" num="0064"> Task 5 is to install the application and integrate the generated configuration into the current middleware configuration (550). In one embodiment, the generated middleware 
<!-- EPO <DP n="16"/>-->
 configuration is fed into an upgrade campaign generator to generate an upgrade campaign file. This upgrade campaign file may be used by SMF to install the application and modify the middleware configuration to include the generated configuration. In one embodiment, after the application is installed, the generated configuration may be merged with the existing middleware configuration. </p><p id="p0065" num="0065"> When a state-aware application is removed from the middleware configuration (e.g., due to diminished demand), the middleware stops passively monitoring the application, and removes the application information from the middleware configuration. The HA agent also instructs the checkpoint agent to stop accepting checkpoint requests from the application. </p><p id="p0066" num="0066"> Figure 6 illustrates an example of an integration agent 600 according to one embodiment of the invention. In this embodiment, the integration agent 600 includes an input generator 610, a configuration generator 620 and an upgrade campaign generator 630. The input generator 610 receives a high-level software description 605, which describes a software application to be added to a highly available system. From the software description 605, the input generator 610 generates an ETF file 615 and configuration requirements 616. The configuration generator 620 receives the ETF file 615 and the configuration requirements 616, and generates a middleware configuration 625 (e.g., a SAF middleware configuration such as an AMF configuration). An example of the configuration generator 620 is described in U.S. Patent No. 8,006,130, "Methods and Systems for Generating Availability Management Framework (AMF) Configurations" by Kanso et al. In the embodiment of Figure 6, the middleware configuration 225 is fed into the upgrade campaign generator 630, which generates an upgrade campaign file 635 using existing methods. An example of the existing method is described in U.S. Pre-Grant Publication 20110035738 Al, 'Method for Generating an Upgrade Campaign for a System" by Kohzadi et al. </p><p id="p0067" num="0067"> In the following, the extended UML component diagram is described with reference to Figure 7 and Figure 8. The UML is the de-facto modeling language in the software engineering field; it defines a set of graphic notations or diagrams that can visually model the structure and behavior of complex systems. The UML component diagram depicts how the various components of a software system are linked together. A UML component represents a subsystem (e.g., a software entity) that can interact with other system components by providing or consuming services using its interfaces. 
<!-- EPO <DP n="17"/>-->
 In order to enable a user to define an input describing its application using component diagrams, the UML is extended with additional constructs that capture specific semantics in the context of the SAF domain. Thus, these extensions relieve the user from having to learn the SAF specifications, and allow the user remains at a generic level of modeling its application. </p><p id="p0068" num="0068"> Figure 7 illustrates an embodiment of added constructs in an extended UML component diagram. The extension adds semantics and domain-specific constructs to the UML, through the use of stereotypes, tag definitions and constraints which are applied to specific model elements such as classes or attributes. In an extended UML component diagram, the added interfaces map to the UML standard interface with added semantics. The extension also adds interface colocation dependency to the UML. The interface colocation dependency also maps to the standard dependency with added semantics. The extension to the UML adds at least constructs 720 to UML component diagram main constructs 710. The constructs 720 include: interface colocation dependency, SAF interface, proxy interface, container interface and checkpoint interface. Additional interfaces and dependency may also be included. </p><p id="p0069" num="0069"> Figure 8 illustrates an example of an extended UML component diagram 800 based on the extended UML according one embodiment of the invention. In this example, a designer models its application to include four components (A,B,C,D), where each component provides one or more services through their respective "provides" interfaces (A-l, Bl, C-l, D-l). The designer also specifies a set of attributes for each component (e.g., the instantiate/cleanup commands, the number of active/standby/spare instances needed (i.e., redundancy), the preferred resource allocation for the component, etc.). Part of these attributes will be mapped to the ETF file generated based on the component diagram 800; part of the attributes will be used to create the configuration requirements. In this example, an interface collocation dependency 820 exists between components B and C. Component D offers a proxy interface Pr-D-1. A checkpoint agent 810 (shown in a dotted box) provides a checkpoint interface CH-P. Note that the checkpoint agent 810 is not part of the user's application. Rather, the checkpoint agent 810 interfaces with the user's software components (A,B,C,D) to provide service continuity and high availability to the software. The user can specify in the diagram that he/she requires this interface for certain components. 
<!-- EPO <DP n="18"/>-->
 Table 1 illustrates, at a high level of abstraction, an embodiment of a method for generating the ETF file. Alternative embodiments may include variations to the method to accommodate different user preferences. Some of the following steps may be optional; e.g., certain orphan independent component types are not necessarily grouped by service unit types. In some embodiments, service group types and/or application types may be omitted. </p><p id="p0070" num="0070"><img id="imgf000018_0001" he="201" wi="141" file="imgf000018_0001.tif" img-format="tif" img-content="table" orientation="portrait" inline="no"/><!-- EPO <DP n="19"/>-->
 Create a software • Create an ETF software bundle that the ETF CTs bundle can reference. </p><p id="p0071" num="0071"> Table 1. ETF generation method </p><p id="p0072" num="0072"> In addition to the ETF generation, a high-level software description can also be used to generate configuration requirements. As shown in the embodiment of Figure 6, the inputs needed for generating a middleware configuration include: (1) an ETF file, and (2) configuration requirements in terms of templates (e.g., service instance and component service instance templates). Based on the information specified in the component these templates can be generated. As a simplified example, one service-instance is generated per active service-unit, e.g., if, for component D in Figure 8, the user specifies a redundancy model of 3 active + 1 standby, then a service-instance template of 3 service-instances is defined, where each service instance includes one component-service-instance of each CST provided by component D. </p><p id="p0073" num="0073"> Figure 9 is a flow diagram illustrating a method 900 for automatically configuring a middleware that manages the high availability of a software application that is to be added to a system (such as a highly available system managed by the middleware). </p><p id="p0074" num="0074">Referring to Figure 9, in one embodiment, the method 900 begins with receiving a user input that specifies availability requirements and information of the software application, where the availability requirements include at least a checkpoint service that enables the software application to save and retrieve its state (block 901). The method further includes identifying a checkpoint agent for providing the checkpoint service to the software application (block 902). The checkpoint agent includes a first interface to the software application and a second interface, different from the first interface, to the middleware. The method further includes generating a middleware configuration that satisfies the availability requirements, based on the information of the software application such that the middleware offers the checkpoint service to the software application through the checkpoint agent and directly manages lifecycles of the software application (block 903). </p><p id="p0075" num="0075"> The method 900 may be performed by hardware (e.g., circuitry, dedicated logic, programmable logic, microcode, etc.), software (e.g., instructions run on a processing device), or a combination thereof. In one embodiment, the method 900 is performed by a computer system 1000 of Figure 10. In one embodiment, the computer system 1000 may be part of a network node (e.g., a router, switch, bridge, controller, base station, etc.). In one embodiment, the computer system 1000 may be part of a cloud computing system or cloud management system. 
<!-- EPO <DP n="20"/>-->
 Figure 10 illustrates a diagrammatic representation of a machine in the exemplary form of the computer system 1000 within which a set of instructions, for causing the machine to perform any one or more of the methodologies discussed herein, may be executed. The computer system 1000 may be a server computer, or any machine capable of executing a set of instructions (sequential or otherwise) that specify actions to be taken by that machine. Further, while only a single machine is illustrated, the term "machine" shall also be taken to include any collection of machines (e.g., computers) that individually or jointly execute a set (or multiple sets) of instructions to perform any one or more of the methodologies discussed herein. </p><p id="p0076" num="0076"> The computer system 1000 includes a processing device 1002. The processing device 1002 represents one or more general-purpose processors, each of which can be: a microprocessor, a central processing unit (CPU), a multicore system, or the like. More particularly, the processing device 1002 may be a complex instruction set computing (CISC) microprocessor, reduced instruction set computing (RISC) microprocessor, very long instruction word (VLIW) microprocessor, processor implementing other instruction sets, or processors implementing a combination of instruction sets. The processing device 1002 may also be one or more special -purpose processing devices such as an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), a digital signal processor (DSP), network processor, or the like. In one embodiment, the processing device 1002 is adapted to execute the operations of an HA module 1022 which contains instructions executable by the processor device 1002 to perform the method 900 of Figure 9 for configuring a middleware that manages the high availability of a software application. </p><p id="p0077" num="0077"> In one embodiment, the computer system 1000 is adapted to automatically generate an ETF from a high-level software description, wherein the software description describes software that is to be managed by a middleware to achieve high availability. The computer system 1000 is operative to perform the method 900 of Figure 9 of receiving a user input that specifies availability requirements and information of the software application, where the availability requirements include at least a checkpoint service that enables the software application to save and retrieve its state; identifying a checkpoint agent for providing the checkpoint service to the software application, wherein the checkpoint agent includes a first interface to the software application and a second interface, different from the first interface, to the middleware; and generating a 
<!-- EPO <DP n="21"/>-->
 middleware configuration that satisfies the availability requirements, based on the information of the software application such that the middleware offers the checkpoint service to the software application through the checkpoint agent and directly manages lifecycles of the software application. </p><p id="p0078" num="0078"> In one embodiment, the processor device 1002 is coupled to one or more memory devices such as: a main memory 1004 (e.g., read-only memory (ROM), flash memory, dynamic random access memory (DRAM) such as synchronous DRAM (SDRAM) or Rambus DRAM (RDRAM), etc.), a secondary memory 1018 (e.g., a magnetic data storage device, an optical magnetic data storage device, etc.), and other forms of computer- readable media, which communicate with each other via a bus or interconnect 1030. The memory devices may also include different forms of read-only memories (ROMs), different forms of random access memories (RAMs), static random access memory (SRAM), or any type of media suitable for storing electronic instructions. In one embodiment, the memory devices may store the code and data of the HA module 1022. In the embodiment of Figure 10, the HA module 1022 may be located in one or more of the locations shown as dotted boxes and labeled by the reference numeral 1022. In alternative embodiments the HA module 1022 may be located in other location(s) not shown in Figure 10. </p><p id="p0079" num="0079"> The computer system 1000 may further include a network interface device 1008. A part or all of the data and code of the HA module 1022 may be transmitted or received over a network 1020 via the network interface device 1008. </p><p id="p0080" num="0080"> In one embodiment, the HA module 1022 can be implemented using code and data stored and executed on one or more computer systems (e.g., the computer system 1000). Such computer systems store and transmit (internally and/or with other electronic devices over a network) code (composed of software instructions) and data using computer- readable media, such as non-transitory tangible computer-readable media (e.g., computer- readable storage media such as magnetic disks; optical disks; read only memory; flash memory) and transitory computer-readable transmission media (e.g., electrical, optical, acoustical or other form of propagated signals - such as carrier waves, infrared signals). A non-transitory computer-readable medium of a given computer system typically stores instructions for execution on one or more processors of that computer system. </p><p id="p0081" num="0081"> The operations of the flow diagram of Figure 9 have been described with reference to the exemplary embodiment of Figure 10. However, it should be understood that the 
<!-- EPO <DP n="22"/>-->
 operations of the flow diagram of Figure 9 can be performed by embodiments of the invention other than those discussed with reference to Figure 10, and the embodiment discussed with reference to Figure 10 can perform operations different than those discussed with reference to the flow diagram. While the flow diagram of Figure 9 shows a particular order of operations performed by certain embodiments of the invention, it should be understood that such order is exemplary (e.g., alternative embodiments may perform the operations in a different order, combine certain operations, overlap certain operations, etc.). </p><p id="p0082" num="0082"> While the invention has been described in terms of several embodiments, those skilled in the art will recognize that the invention is not limited to the embodiments described, can be practiced with modification and alteration within the spirit and scope of the appended claims. The description is thus to be regarded as illustrative instead of limiting. 
</p></description><claims mxw-id="PCLM70077703" ref-ucid="WO-2014128597-A1" lang="EN" load-source="patent-office"><claim-statement><!-- EPO <DP n="23"/>-->CLAIMS  What is claimed is: </claim-statement><claim id="clm-0001" num="1"><claim-text>1. A method for automatically configuring a middleware that manages high availability of a software application to be added to a system, the method comprising the steps of: </claim-text><claim-text> receiving, by a computer system, a user input that specifies availability </claim-text><claim-text> requirements and information of the software application, wherein the availability requirements include at least a checkpoint service that enables the software application to save and retrieve its state; </claim-text><claim-text> identifying a checkpoint agent for providing the checkpoint service to the software application, wherein the checkpoint agent includes a first interface to the software application and a second interface, different from the first interface, to the middleware; and </claim-text><claim-text> generating a configuration of the middleware that satisfies the availability </claim-text><claim-text> requirements, based on the information of the software application such that the middleware offers the checkpoint service to the software application through the checkpoint agent and directly manages lifecycles of the software application. </claim-text></claim><claim id="clm-0002" num="2"><claim-text>2. The method of claim 1, wherein the information of the software application is a high-level software description, the method further comprising the step of: </claim-text><claim-text> automatically generating an Entity Types File (ETF) from the high-level software description, wherein the high-level software description describes components of the software application and relationship of the components, and wherein the ETF describes a hierarchy of entity types compliant with middleware specifications. </claim-text></claim><claim id="clm-0003" num="3"><claim-text>3. The method of claim 1, wherein the first interface of the checkpoint agent is a Representational State Transfer (REST) interface. </claim-text></claim><claim id="clm-0004" num="4"><claim-text>4. The method of claim 1, further comprising the steps of: 
<!-- EPO <DP n="24"/>-->
 receiving from the software application, by the checkpoint agent, a state associated with a resource identifier from the software application via the first interface; and </claim-text><claim-text> sending, by the checkpoint agent, the state associated with the resource identifier to the middleware via the second interface for storing by the middleware. </claim-text></claim><claim id="clm-0005" num="5"><claim-text>5. The method of claim 1, wherein the checkpoint agent has a third interface connecting to a database, the method further comprising the step of: </claim-text><claim-text> allocating a first portion of workload of the checkpoint service on the database for saving and retrieving the state of the software application; and allocating a second portion of workload of the checkpoint service on the </claim-text><claim-text> middleware for saving and retrieving the state of the software application. </claim-text></claim><claim id="clm-0006" num="6"><claim-text>6. The method of claim 1, wherein the middleware directly manages the software application to install, instantiate and monitor the software applications without the software application implementing an Application Programming Interface (API) compliant to the middleware specifications. </claim-text></claim><claim id="clm-0007" num="7"><claim-text>7. The method of claim 1, further comprising the steps of: </claim-text><claim-text> adding or removing one or more checkpoint agents on demand during runtime of the system. </claim-text></claim><claim id="clm-0008" num="8"><claim-text>8. The method of claim 1, further comprising the step of: </claim-text><claim-text> selecting the checkpoint agent based, at least in part, on criteria specified by the software application. </claim-text></claim><claim id="clm-0009" num="9"><claim-text>9. The method of claim 1, wherein the software application is added and removed on demand during runtime of the system. </claim-text></claim><claim id="clm-0010" num="10"><claim-text>10. The method of claim 9, wherein the demand is based on policies defined by a user of the software application, wherein the policies specify triggers for providing high availability to the software application. 
<!-- EPO <DP n="25"/>-->
</claim-text></claim><claim id="clm-0011" num="11"><claim-text>11. A computer system adapted to automatically configure a middleware that manages high availability of a software application to be added to a system, the computer system comprising a processor and a memory, the memory containing instructions executable by the processor, wherein the computer system is operative to: </claim-text><claim-text> receive a user input that specifies availability requirements and information of the software application, wherein the availability requirements include at least a checkpoint service that enables the software application to save and retrieve its state; </claim-text><claim-text> identify a checkpoint agent for providing the checkpoint service to the software application, wherein the checkpoint agent includes a first interface to the software application and a second interface, different from the first interface, to the middleware; and </claim-text><claim-text> generate a configuration of the middleware that satisfies the availability </claim-text><claim-text> requirements, based on the information of the software application the middleware such that the middleware offers the checkpoint service to the software application through the checkpoint agent and directly manages lifecycles of the software application. </claim-text></claim><claim id="clm-0012" num="12"><claim-text>12. The computer system of claim 11, wherein the information of the software application is a high-level software description, the computer system is further operative to: </claim-text><claim-text> automatically generate an Entity Types File (ETF) from the high-level software description, wherein the high-level software description describes components of the software application and relationship of the components, and wherein the ETF describes a hierarchy of entity types compliant with middleware specifications. </claim-text></claim><claim id="clm-0013" num="13"><claim-text>13. The computer system of claim 11, wherein the first interface of the checkpoint agent is a Representational State Transfer (REST) interface. </claim-text></claim><claim id="clm-0014" num="14"><claim-text>14. The computer system of claim 11, wherein the computer system is further operative to: 
<!-- EPO <DP n="26"/>-->
 receive from the software application, by the checkpoint agent, a state associated with a resource identifier from the software application via the first interface; and </claim-text><claim-text> send, by the checkpoint agent, the state associated with the resource identifier to the middleware via the second interface for storing by the middleware. </claim-text></claim><claim id="clm-0015" num="15"><claim-text>15. The computer system of claim 11, wherein the checkpoint agent has a third interface to a database, the computer system being further operative to: </claim-text><claim-text> allocate a first portion of workload of the checkpoint service on the database for saving and retrieving the state of the software application; and allocate a second portion of workload of the checkpoint service on the middleware for saving and retrieving the state of the software application. </claim-text></claim><claim id="clm-0016" num="16"><claim-text>16. The computer system of claim 11, wherein the middleware directly manages the software application to install, instantiate and monitor the software applications without the software application implementing an Application Programming Interface (API) compliant to middleware specifications. </claim-text></claim><claim id="clm-0017" num="17"><claim-text>17. The computer system of claim 1 1, wherein one or more checkpoint agents are added and removed on demand during runtime of the system. </claim-text></claim><claim id="clm-0018" num="18"><claim-text>18. The computer system of claim 11, wherein the computer system is further operative to select the checkpoint agent based, at least in part, on criteria specified by the software application. </claim-text></claim><claim id="clm-0019" num="19"><claim-text>19. The computer system of claim 11, wherein the software application is added and removed on demand during runtime of the system. </claim-text></claim><claim id="clm-0020" num="20"><claim-text>20. The computer system of claim 19, wherein the demand is based on policies defined by a user of the software application, wherein the policies specify triggers for providing high availability to the software application. 
</claim-text></claim></claims><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
