<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2959378-A1" country="EP" doc-number="2959378" kind="A1" date="20151230" family-id="50236280" file-reference-id="312929" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="160452591" ucid="EP-2959378-A1"><document-id><country>EP</country><doc-number>2959378</doc-number><kind>A1</kind><date>20151230</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-14708381-A" is-representative="NO"><document-id mxw-id="PAPP193868150" load-source="docdb" format="epo"><country>EP</country><doc-number>14708381</doc-number><kind>A</kind><date>20140213</date><lang>EN</lang></document-id><document-id mxw-id="PAPP193868151" load-source="patent-office" format="original"><country>EP</country><doc-number>14708381.0</doc-number><date>20140213</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC162026904" ucid="US-201361768097-P" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201361768097</doc-number><kind>P</kind><date>20130222</date></document-id></priority-claim><priority-claim mxw-id="PPC162032476" ucid="US-2014016259-W" linkage-type="W" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>2014016259</doc-number><kind>W</kind><date>20140213</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1988519630" load-source="docdb">G06F   9/44        20060101ALI20140910BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-1988520949" load-source="docdb">G06F   9/445       20060101AFI20140910BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1761062674" load-source="docdb" scheme="CPC">G06F   8/66        20130101 LI20170927BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1761062675" load-source="docdb" scheme="CPC">G06F   9/4401      20130101 LI20170927BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987777870" load-source="docdb" scheme="CPC">G06F   9/4406      20130101 FI20140828BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT165549239" lang="DE" load-source="patent-office">PATCHEN VON BOOTCODES EINES FESTWERTSPEICHERS</invention-title><invention-title mxw-id="PT165549240" lang="EN" load-source="patent-office">PATCHING BOOT CODE OF READ-ONLY MEMORY</invention-title><invention-title mxw-id="PT165549241" lang="FR" load-source="patent-office">RETOUCHE DU CODE DE DÉMARRAGE D'UNE MÉMOIRE MORTE</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR1103313065" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>MARVELL WORLD TRADE LTD</last-name><address><country>BB</country></address></addressbook></applicant><applicant mxw-id="PPAR1103306977" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>MARVELL WORLD TRADE LTD.</last-name></addressbook></applicant><applicant mxw-id="PPAR1101646800" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Marvell World Trade Ltd.</last-name><iid>101175738</iid><address><street>L'Horizon, Gunsite Road Brittons Hill</street><city>St. Michael 14027</city><country>BB</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR1103340708" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>AKDEMIR KAHRAMAN D</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103327976" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>AKDEMIR, KAHRAMAN, D.</last-name></addressbook></inventor><inventor mxw-id="PPAR1101653579" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>AKDEMIR, KAHRAMAN, D.</last-name><address><street>8 Independence Way Apt. 211</street><city>Franklin, MA 02038</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103311003" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>AYTEK TOLGA NIHAT</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103331680" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>AYTEK, Tolga, Nihat</last-name></addressbook></inventor><inventor mxw-id="PPAR1101641927" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>AYTEK, Tolga, Nihat</last-name><address><street>6 John Mcquinn Circle</street><city>Framingham, MA 01701</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103310192" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>KARAKOYUNLU DENIZ</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103319972" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>KARAKOYUNLU, DENIZ</last-name></addressbook></inventor><inventor mxw-id="PPAR1101650062" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>KARAKOYUNLU, DENIZ</last-name><address><street>67 Colborne Road Apt. 3</street><city>Boston, MA 02135</city><country>US</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR1101652123" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Grünecker, Kinkeldey, Stockmair &amp; Schwanhäusser Anwaltssozietät</last-name><iid>100060488</iid><address><street>Leopoldstrasse 4</street><city>80802 München</city><country>DE</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="US-2014016259-W"><document-id><country>US</country><doc-number>2014016259</doc-number><kind>W</kind><date>20140213</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2014130338-A1"><document-id><country>WO</country><doc-number>2014130338</doc-number><kind>A1</kind><date>20140828</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS660625538" load-source="docdb">AL</country><country mxw-id="DS660789035" load-source="docdb">AT</country><country mxw-id="DS660625544" load-source="docdb">BE</country><country mxw-id="DS660726150" load-source="docdb">BG</country><country mxw-id="DS660704299" load-source="docdb">CH</country><country mxw-id="DS660626404" load-source="docdb">CY</country><country mxw-id="DS660789036" load-source="docdb">CZ</country><country mxw-id="DS660625545" load-source="docdb">DE</country><country mxw-id="DS660626405" load-source="docdb">DK</country><country mxw-id="DS660626406" load-source="docdb">EE</country><country mxw-id="DS660703935" load-source="docdb">ES</country><country mxw-id="DS660726155" load-source="docdb">FI</country><country mxw-id="DS660704300" load-source="docdb">FR</country><country mxw-id="DS660625546" load-source="docdb">GB</country><country mxw-id="DS660626415" load-source="docdb">GR</country><country mxw-id="DS660625555" load-source="docdb">HR</country><country mxw-id="DS660789037" load-source="docdb">HU</country><country mxw-id="DS660710408" load-source="docdb">IE</country><country mxw-id="DS660626416" load-source="docdb">IS</country><country mxw-id="DS660704301" load-source="docdb">IT</country><country mxw-id="DS660626417" load-source="docdb">LI</country><country mxw-id="DS660726156" load-source="docdb">LT</country><country mxw-id="DS660625360" load-source="docdb">LU</country><country mxw-id="DS660726157" load-source="docdb">LV</country><country mxw-id="DS660726158" load-source="docdb">MC</country><country mxw-id="DS660625361" load-source="docdb">MK</country><country mxw-id="DS660625362" load-source="docdb">MT</country><country mxw-id="DS660710409" load-source="docdb">NL</country><country mxw-id="DS660703936" load-source="docdb">NO</country><country mxw-id="DS660710410" load-source="docdb">PL</country><country mxw-id="DS660726163" load-source="docdb">PT</country><country mxw-id="DS660789038" load-source="docdb">RO</country><country mxw-id="DS660726164" load-source="docdb">RS</country><country mxw-id="DS660710411" load-source="docdb">SE</country><country mxw-id="DS660704302" load-source="docdb">SI</country><country mxw-id="DS660703937" load-source="docdb">SK</country><country mxw-id="DS660703938" load-source="docdb">SM</country><country mxw-id="DS660625375" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><abstract mxw-id="PA139072421" ref-ucid="WO-2014130338-A1" lang="EN" load-source="patent-office"><p num="0000">The present disclosure describes apparatuses and techniques for patching boot code of read-only memory (ROM). In some aspects, execution of boot code from a ROM is initiated to start a boot process of a device. Execution of the boot code from the ROM is then interrupted to enable execution of other boot code, such as corrected boot code or additional boot code, from another memory. Once the other boot code is executed, execution of the boot code from the ROM is resumed to continue booting the computing device. By so doing, the corrected boot code or additional boot code can be executed during the boot process effective to patch the boot code stored in the ROM.</p></abstract><abstract mxw-id="PA139540070" ref-ucid="WO-2014130338-A1" lang="EN" source="national office" load-source="docdb"><p>The present disclosure describes apparatuses and techniques for patching boot code of read-only memory (ROM). In some aspects, execution of boot code from a ROM is initiated to start a boot process of a device. Execution of the boot code from the ROM is then interrupted to enable execution of other boot code, such as corrected boot code or additional boot code, from another memory. Once the other boot code is executed, execution of the boot code from the ROM is resumed to continue booting the computing device. By so doing, the corrected boot code or additional boot code can be executed during the boot process effective to patch the boot code stored in the ROM.</p></abstract><abstract mxw-id="PA139072422" ref-ucid="WO-2014130338-A1" lang="FR" load-source="patent-office"><p num="0000">La présente invention concerne des appareils et des techniques permettant de retoucher le code de démarrage d'une mémoire morte (ROM). Sous certains aspects, l'exécution d'un code de démarrage à partir d'une ROM est amorcée pour lancer le processus de démarrage d'un dispositif. L'exécution du code de démarrage à partir de la ROM est alors interrompue pour permettre l'exécution d'un autre code de démarrage, tel qu'un code de démarrage corrigé ou un code de démarrage supplémentaire, à partir d'une autre mémoire. Une fois que l'autre code de démarrage est exécuté, l'exécution du code de démarrage à partir de la ROM est reprise pour continuer à amorcer le dispositif informatique. Ce faisant, on peut exécuter le code de démarrage corrigé ou le code de démarrage supplémentaire pendant le processus de démarrage qui a pour effet de retoucher le code de démarrage stocké dans la ROM.</p></abstract><abstract mxw-id="PA139540071" ref-ucid="WO-2014130338-A1" lang="FR" source="national office" load-source="docdb"><p>La présente invention concerne des appareils et des techniques permettant de retoucher le code de démarrage d'une mémoire morte (ROM). Sous certains aspects, l'exécution d'un code de démarrage à partir d'une ROM est amorcée pour lancer le processus de démarrage d'un dispositif. L'exécution du code de démarrage à partir de la ROM est alors interrompue pour permettre l'exécution d'un autre code de démarrage, tel qu'un code de démarrage corrigé ou un code de démarrage supplémentaire, à partir d'une autre mémoire. Une fois que l'autre code de démarrage est exécuté, l'exécution du code de démarrage à partir de la ROM est reprise pour continuer à amorcer le dispositif informatique. Ce faisant, on peut exécuter le code de démarrage corrigé ou le code de démarrage supplémentaire pendant le processus de démarrage qui a pour effet de retoucher le code de démarrage stocké dans la ROM.</p></abstract><description mxw-id="PDES78476547" ref-ucid="WO-2014130338-A1" lang="EN" load-source="patent-office"><!-- EPO <DP n="3"/>--><p id="p0001" num="0001"> PATCHING BOOT CODE OF READ-ONLY MEMORY </p><p id="p0002" num="0002"> RELATED APPLICATIONS </p><p id="p0003" num="0003">[0001] This present disclosure claims priority to U.S. Provisional Patent Application Serial No. 61/768,097 filed February 22<sup>nd</sup>, 2013 the disclosure of which is incorporated by reference herein in its entirety. </p><p id="p0004" num="0004">BACKGROUND </p><p id="p0005" num="0005"> [0002] The background description provided herein is for the purpose of generally presenting the context of the disclosure. Work of the presently named inventors, to the extent it is described in this background section, as well as aspects of the description that may not otherwise qualify as prior art at the time of filing, are neither expressly nor impliedly admitted as prior art against the present disclosure. </p><p id="p0006" num="0006">[0003] Computing and electronic devices often execute boot code on power-up to configure resources or components of the device. Once the resources and components are configured, an operating system is loaded by the boot code and executed. Control of the device is then passed to the executing operating system, which implements functionalities or applications of the device. </p><p id="p0007" num="0007"> [0004] To prevent the execution of unauthorized software on the device, the boot code can verify an authenticity of the operating system and software layers above the boot code. Because the boot code is the lowest level of code executed at power-on, the boot code is often hard-coded into hardware of the device to ensure authenticity of 
<!-- EPO <DP n="4"/>-->
 the boot code. While hard-coding the boot code prevents malignant modification of the boot code, the hard-coding also prevents modification of the boot code to correct errors. Thus, to correct an error in the boot code, the hardware of the device often requires re-design and re-fabrication, which consumes considerable time, money, and resources. </p><p id="p0008" num="0008">SUMMARY </p><p id="p0009" num="0009"> [0005] The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features and advantages will be apparent from the description and drawings. As such, this Summary should not be considered to describe essential features nor used to limit the scope of the claimed subject matter. </p><p id="p0010" num="0010"> [0006] A method is described for initiating, from a read-only memory (ROM), execution of first boot code to start a boot process of a computing device. The method then interrupts the execution of the first boot code to enable execution of second boot code from another memory. After the second boot code is executed, the execution of the first boot code is resumed to continue the boot process of the computing device. </p><p id="p0011" num="0011"> [0007] Another method is described for initiating execution of boot code from a ROM, the execution of the boot code being advanced via a program counter. Responsive to the program counter reaching a predetermined address in the boot code, execution of the boot code is interrupted. The method then executes alternate boot 
<!-- EPO <DP n="5"/>-->
 code from a one-time -programmable (OTP) memory instead of some of the boot code in the ROM. Responsive to execution of the alternate boot code, the program counter is returned to an address in the boot code effective to resume execution of the boot code from the ROM. </p><p id="p0012" num="0012"> [0008] A System-on-Chip (SoC) is described that includes a processor, ROM, OTP memory, and an interrupt manager that is configured to interrupt the processor's execution of boot code from the ROM in response to a program counter of the processor encountering a predetermined address in the boot code. The interrupt manager is further configured to cause the processor to execute additional boot code from the OTP memory and then return the program counter to an address in the boot code effective cause the processor to resume execution of the boot code from the ROM. </p><p id="p0013" num="0013"> [0009] The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features and advantages will be apparent from the description and drawings. </p><p id="p0014" num="0014">BRIEF DESCRIPTION OF THE DRAWINGS </p><p id="p0015" num="0015">[0010] In the figures, the left-most digit of a reference number identifies the figure in which the reference number first appears. The use of the same reference numbers in different instances in the description and the figures indicate like elements. </p><p id="p0016" num="0016"> Fig. 1 illustrates an operating environment having computing devices in accordance with one or more aspects. 
<!-- EPO <DP n="6"/>-->
 Fig. 2 illustrates an example boot architecture of a computing device in accordance with one or more aspects. </p><p id="p0017" num="0017"> Fig. 3 illustrates a method for interrupting execution of boot code from a read-only memory. </p><p id="p0018" num="0018"> Fig. 4 illustrates a method for executing alternate boot code from a onetime-programmable memory. </p><p id="p0019" num="0019"> Fig. 5 illustrates examples of boot code and a boot code patch in accordance with one or more aspects. </p><p id="p0020" num="0020"> Fig. 6 illustrates a method for burning boot code into fuses of a one-time- programmable memory. </p><p id="p0021" num="0021"> Fig. 7 illustrates a System-on-Chip (SoC) environment for implementing aspects of the techniques described herein. </p><p id="p0022" num="0022">DETAILED DESCRIPTION </p><p id="p0023" num="0023">[0011] Conventional techniques for patching boot code of read-only memory (ROM) typically require re-fabrication of ROM hardware in which the boot code is written (e.g., burned). This re-fabrication of the ROM hardware often includes another round of pre-silicon verification, silicon tape-out or masking, ROM porting, manufacture of ROM hardware, and post-silicon verification. As such, the re- fabrication of ROM hardware to patch boot code consumes a considerable amount of time, money, and resources. 
<!-- EPO <DP n="7"/>-->
 [0012] This disclosure describes apparatuses and techniques for patching boot code in ROM, which enable other boot code (e.g., alternate or additional boot code) to be executed from another memory during a boot process. In some aspects, the other memory is one-time -programmable (OTP) memory, into which the other boot code is burned after fabrication of hardware that includes the ROM. When the boot code is embodied in a System-on-Chip (SoC), the SoC may provide a lockout mechanism for the other code (e.g., patching code). For example, if no patching is determined to be necessary after verification of the boot code (e.g., BootROM) prior to shipping a product in which the boot code is embodied, the SoC may provide a capability to disable the feature to ensure security of the boot code through the life of the product. Similarly, if patching of the boot code is necessary, the SoC may provide another capability for locking out remaining blocks of the OTP memory once patched but prior to shipment of the hardware to ensure security of the other boot code. </p><p id="p0024" num="0024">[0013] The following discussion describes an operating environment, techniques that may be employed in the operating environment, and a System-on-Chip (SoC) in which components of the operating environment can be embodied. In the discussion below, reference is made to the operating environment by way of example only. </p><p id="p0025" num="0025">[0014] Operating Environment </p><p id="p0026" num="0026"> Fig. 1 illustrates an example of an operating environment 100 having computing devices 102, each of which are capable of communicating, accessing, presenting, or processing various data. Computing devices 102 include smart-phone 104, tablet computer 106, network-attached storage drive 108 (NAS drive 108), digital 
<!-- EPO <DP n="8"/>-->
 camera 110, and internet-protocol enabled television 112 (IP TV 112). Although not shown, other configurations of computing devices 102 are also contemplated such as a desktop computer, server, mobile-internet device (MID), fax machine, printer, digital camcorder, netbook, ultra-book, gaming console, home automation terminal, mobile hotspot, networked media player, and the like. </p><p id="p0027" num="0027"> [0015] Generally, computing devices 102 have operational states ranging from an "off state to an "on" state. These operational states may include a fully off state (mechanical off), hibernation state, sleep state, suspend state, idle state, active state, and the like. When transitioning from a lower operational state to a higher operational state (e.g., from an off state to an active state), computing device 102 is booted. Booting computing device 102 includes executing low-level code (e.g., boot code or binary) that configures components or resources of computing device 102 for access by an operating system or higher-level applications. </p><p id="p0028" num="0028"> [0016] Each computing device 102 includes processor core 114 (e.g. an application processor core) and computer-readable storage media 116 (CRM 116). Although shown as a single core, processor core 114 may be one of any suitable number and/or type of processing cores, which may be configured in any suitable manner (e.g., a heterogeneous multi-core application processor). In some cases, processor core 114 is implemented as a core of a microcontroller, embedded controller, or digital-signal processor. </p><p id="p0029" num="0029"> [0017] CRM 116 includes volatile memory 118 and non-volatile memory 120, which may include any suitable type, combination, or number of internal and/or 
<!-- EPO <DP n="9"/>-->
 external memory devices. Each memory of CRM 116 may be implemented as an on- chip memory area of hardware or an off-chip memory device that communicates data with processor core 114 via a data interface or bus. In this particular example, volatile memory 118 includes static random access memory 122 (SRAM 122) and synchronous dynamic random-access memory 124 (DRAM 124). Alternately or additionally, volatile memory 118 may include other suitable types of memory, such as random-access memory (RAM), asynchronous dynamic RAM, double-data-rate RAM (DDR), and the like. </p><p id="p0030" num="0030"> [0018] Non-volatile memory 120 includes serial-peripheral interface (SPI) Flash 126, NAND Flash 128, read-only memory 130, and one-time -programmable (OTP) memory 132. Other non-volatile memories contemplated include non-volatile RAM (NVRAM), electronically-erasable programmable ROM, embedded multimedia card (eMMC) devices, NOR Flash, single-level cell (SLC) Flash, multi-level cell (MLC) Flash, and the like. In this particular example, ROM 130 and OTP memory 132 are implemented as on-chip memory areas, which are manufactured into various metallic and semiconductor layers of a chip. </p><p id="p0031" num="0031"> [0019] Non-volatile memory 120 stores data of computing device 102 persistently when powered-down or suspended. Boot code of computing device 102 is stored in one or more non-volatile memory components, such as SPI Flash 126, NAND Flash 128, and ROM 130. For example, lowest-level or secure boot code is written or burned into ROM 130 during manufacturing of the chip that includes ROM 130. By so doing, the boot code in ROM 130, also referred to as boot-ROM, cannot be 
<!-- EPO <DP n="10"/>-->
 modified after the chip is manufactured. The non-modifiable nature of ROM 130 ensures an authenticity and security of the boot code stored in ROM 130. Higher- level boot code of computing device 102 is implemented as boot loaders that are stored in SPI Flash 126 and NAND Flash 128, respectively. Because the contents of SPI Flash 126 and NAND Flash 128 are modifiable or user accessible, the higher- level boot code stored in these devices is not secure. </p><p id="p0032" num="0032"> [0020] In some aspects, boot code is written to OTP memory 132, which is capable of being written to one time. OTP memory 132 includes blocks of fuses, each of which represents a settable binary value. More specifically, OTP memory 132 is manufactured with all of the fuses set to a virgin or default state, such as blocks of all ones or all zeroes. To write data into OTP memory 132, appropriate fuses are burned from their default state to a non-default state to indicate a desired binary value. Accordingly, once a fuse of OTP memory 132 is burned to the non-default state, the fuse is no longer useful to write other data to OTP memory 132. Alternately or additionally, contents of OTP memory 132 may be permanently locked by burning fuses of unused fuse blocks and error-correcting code bits associated with the unused fuse blocks. </p><p id="p0033" num="0033"> [0021] Operating systems, applications, or user data (not shown) of computing device 102 may be stored by, or executed from, volatile memory 118, non-volatile memory 120, or any other suitable type of CRM 116. Alternately or additionally, operating systems and/or applications of computing device 102 may be embodied as firmware or other processor-executable instructions, binaries, or code. Operating 
<!-- EPO <DP n="11"/>-->
 systems and applications of device 102 are executable by processor core 114 to provide a user interface, various functionalities, and/or services of computing device 102. </p><p id="p0034" num="0034"> [0022] CRM 116 also includes interrupt manager 134, which in this particular example, is embodied as processor-executable instructions that are executable by processor core 114 to implement various functionalities. Alternately or additionally, interrupt manager 134 may be implemented, in part or whole, via firmware or hardware (not shown) or any suitable combination thereof. In some cases, interrupt manager 134 is hard-coded into boot code of ROM 130 during the fabrication (e.g., manufacturing) of ROM 130 or a chip in which ROM 130 resides. Interrupt manager 134 may interrupt execution of boot code from ROM 130 to enable boot code to be executed from other memories. The implementation and use of interrupt manager 134 varies and is described below. </p><p id="p0035" num="0035"> [0023] Computing device 102 may also include I/O ports 136, display 138, or network interface(s) 140. I/O ports 136 allow computing device 102 to interact with other devices or users. I/O ports 136 may include any combination of internal or external ports, such as USB ports, audio ports, Serial ATA (SATA) ports, PCI-express based ports or card-slots, secure digital input/output (SDIO) slots, and/or other legacy ports. Various peripherals may be operatively coupled with I/O ports 136, such as human-input devices (HIDs), external computer-readable storage media, or other peripherals. 
<!-- EPO <DP n="12"/>-->
 [0024] Display 138 may present a user interface or rendered graphics associated with an operating system or application of computing device 102. Display 138 may include a touch-input sensor (not shown), such as a touch screen or touch- sensitive overlay. Network interface(s) 140 provides connectivity to one or more networks and other devices connected therewith. Data communicated over network interfaces 140 may be packetized or framed depending on a communication protocol or standard by which computing device 102 is communicating. Network interfaces 140 may include wired interfaces, such as Ethernet or fiber optic interfaces for communication over a local network, intranet, or the Internet. Network interfaces 140 may also include wireless interfaces that facilitate communication over wireless networks, such as wireless LANs, cellular networks, or wireless personal-area-networks (e.g., Bluetooth™). </p><p id="p0036" num="0036"> [0025] Fig. 2 illustrates an example boot architecture of a computing device in accordance with one or more aspects at 200. Execution of boot code during a boot process occurs in hardware 202 and software 204 of a computing device. Hardware 202 includes ROM 130, into which a binary of boot code (boot-ROM 206) is burned during manufacture of ROM 130. Boot-ROM 206 is executed to initiate a boot process of the computing device. Because boot-ROM 206 is burned to ROM 130 and not modifiable, execution of boot-rom 206 can implement a trusted boot process in which boot-ROM 206 functions as a "root of trust". More specifically, once boot- ROM 206 is written to ROM 130, the read-only nature of ROM 130 ensures an authenticity and security of boot-ROM 206. 
<!-- EPO <DP n="13"/>-->
 [0026] Hardware 202 also includes OTP memory 132 that is configured as blocks of fuses that are capable of storing binary values. In this particular example, OTP memory 132 stores boot-ROM patch 208, which includes binary code that is executed during the boot sequence of the computing device. In some cases, boot-ROM patch 208 includes alternate boot code that is executing instead of a portion of boot-ROM 206, such as when the portion of boot-ROM 206 includes an error or bug. In other cases, boot-ROM patch 208 includes additional boot code that is executed in conjunction with boot-ROM 206. In such cases, the execution of the additional boot code may implement additional or functionalities of the computing device during the boot sequence. The implementation and use of code written to OTP memory varies and is described below. </p><p id="p0037" num="0037"> [0027] During the boot sequence, the execution of boot-ROM 206 loads a higher- level boot loader into software 204, which in turn loads another higher-level boot loader, and the boot sequence continues until an operating system is loaded. In this particular example, execution of boot-ROM 206 loads level 2 boot loader 210 from SPI Flash 126. Before transferring control of resources to level 2 boot loader 210, boot-ROM 206 validates an authenticity of code of the boot loader by verifying a cryptographic signature or hash. By so doing, boot-ROM 206 ensures that the next level boot loader is secure (e.g., not tampered with) and a chain of trust is established from the "root of trust" to a next step of the boot sequence. </p><p id="p0038" num="0038"> [0028] Once control of resources is passed from boot-ROM 206 to level 2 boot loader 210, execution of the boot loader further configures resources of the computing 
<!-- EPO <DP n="14"/>-->
 device and loads level 3 boot loader 212 from NAND Flash 128. Here, to continue the chain of trust, level 2 boot loader 210 validates an authenticity of 3 boot loader 212 before control of the resources is transferred to 3 boot loader 212. As shown in Fig. 2, the boot sequence continues until level N boot loader 214 is loaded, validated, and executed as the boot sequence progresses through any number of intermediate boot loaders. To implement a trusted boot process, an authenticity of each level of boot code or boot loader is validated by a previous boot loader. </p><p id="p0039" num="0039">[0029] To conclude the boot sequence, execution of level N boot loader 214 loads operating system 216 from non-volatile 120 and validates an authenticity of the operating system by verifying a cryptographic signature or hash value associated with operating system 216. By so doing, a trusted boot process is implemented to ensure that the software executing on the computing device is authentic and authorized. The "root of trust" of the trusted boot process is boot-ROM 206, which is guaranteed to be secure due to the inability to alter ROM 130 once the memory is manufactured. </p><p id="p0040" num="0040">[0030] Techniques of Patching Boot Code of Read-Only Memory </p><p id="p0041" num="0041">The following discussion describes techniques of patching boot code of read-only memory. These techniques can be implemented using the previously described environment or entities, such as interrupt manager 134 of Fig. 1 embodied on a computing device 102. These techniques include methods illustrated in Figs. 3, 4, and 6, each of which is shown as a set of operations performed by one or more entities. These methods are not necessarily limited to the orders shown for performing the operations. Further, these methods may be used in conjunction with 
<!-- EPO <DP n="15"/>-->
 one another, in whole or in part, whether performed by the same entity, separate entities, or any combination thereof. In portions of the following discussion, reference will be made to operating environment 100 of Fig. 1 and entities of Figs. 2 and 5 by way of example. Such reference is not to be taken as limited to operating environment 100 but rather as illustrative of one of a variety of examples. </p><p id="p0042" num="0042">[0031] Fig. 3 depicts a method 300 for interrupting execution of boot code from a read-only memory, including operations performed by interrupt manager 134 of Fig. 1. </p><p id="p0043" num="0043"> [0032] At 302, execution of first boot code from a read-only memory (ROM) is initiated. Initiating execution of the first boot code starts a boot process of a computing device. In some cases, the first boot code is a secure boot-ROM that is burned into hardware during manufacture of the ROM. Initiating the execution of the first boot code can be responsive to a power-on event of the computing device. For example, when a smart phone or tablet computer is powered on, a microcontroller or hardware logic circuit can initiate execution of a boot-ROM binary. </p><p id="p0044" num="0044">[0033] At 304, execution of the first boot code is interrupted to enable execution of second boot code from another memory. The execution of the first boot code is interrupted at a predetermined point effective to halt execution of the first boot code. The predetermined point may be an address or instruction in the first boot code that triggers an interrupt, break, jump, and the like. When the first boot code is not executing, second boot code can be executed from another memory of the computing device. In some cases, the second boot code is executed instead of a portion of the 
<!-- EPO <DP n="16"/>-->
 first boot code, such as a portion that contains a bug or error. In other cases, execution of the second boot code provides an additional function or feature during the boot process of the device. </p><p id="p0045" num="0045"> [0034] At 306, the execution of the first boot code from the ROM is resumed after execution of the second boot code. Resuming execution of the first boot code from ROM continues the boot process of the device. In some cases, the execution of the first boot code is resumed at a predetermined return point, such as a return address. Continued execution of the first boot code may load a high-level boot loader or an operating system of the device. In some cases, authenticity of the higher-level boot loader or operating system is verified before control of device resources is passed from the first boot code. This can be effective to implement a trusted boot process in which each level or layer of the boot process is validating before control of the device is transferred from a lower-level boot loader. By executing root level boot code from ROM and OTP memory, security of the lowest-level boot code is ensured due to the non-modifiable nature of these memories. </p><p id="p0046" num="0046"> [0035] Fig. 4 depicts a method 400 for executing alternate boot code from a onetime-programmable memory, including operations performed by interrupt manager 134 of Fig. 1. </p><p id="p0047" num="0047"> [0036] At 402, execution of boot code from a read-only memory (ROM) is initiated. The boot code stored in the ROM may include a boot-ROM binary that is executed to boot a computing device. In some cases, the boot-ROM is burned into physical conductor or semi-conductor layers of the ROM and is not modifiable. In 
<!-- EPO <DP n="17"/>-->
 such cases, the boot-ROM is a secure boot-ROM and can function as a "root of trust" for a trusted boot process. Execution of the boot code is advanced by a program counter that increments through addresses of the boot to cause execution of instructions associated with each address. </p><p id="p0048" num="0048"> [0037] As an example, consider a user powering-on smart phone 104 of Fig. 1. Assume here that smart phone 104 is booting to an "on" state from an "off state in which components and resources of smart phone 104 were powered down. To boot to the "on" state, boot-ROM 206 begins to execute in response to the user powering-on smart phone 104. As shown in Fig. 5, boot- ROM 206 includes addresses 502 and binary 504, which is converted from binary to machine code instructions (instructions 506) when executed. Processor core 114 of smart phone 104 executes a line of binary 504, or a corresponding instruction 506, as program counter 508 progresses through addresses 502. </p><p id="p0049" num="0049"> [0038] At 404, the execution of the boot code from the ROM is interrupted. This can be responsive to a program counter reaching a predetermined address in the boot code. The predetermined address may be stored in a different memory, such as a onetime-programmable memory to ensure the predetermined address cannot be modified. In some cases, an interrupt service routine (e.g., hardware -based interrupt logic) is configured to fire an interrupt when the program counter reaches the predetermined address in the boot code. In such cases, the fired interrupt may be effective to cause an interrupt handler to execute other code. The predetermined address may indicate a line of boot code that includes an error or bug, the execution of which is to be 
<!-- EPO <DP n="18"/>-->
 prevented. Alternately or additionally, the predetermined address may be a first address of a section of boot code that includes an error or bug. </p><p id="p0050" num="0050"> [0039] In the context of the present example, assume that boot-ROM section 510 includes an error that, responsive to execution, prevents smart phone 104 from powering on. Accordingly, address 512 (0x5E0123FC) is selected to initiate an interrupt process to prevent the execution of the "BNE" instruction. The address selected to fire the interrupt is written into boot-ROM patch 208 as interrupt address 514. When program counter 508 reaches interrupt address 514, interrupt manager 134 fires an interrupt effective to prevent processor core 114 from executing the "BNE" instruction. </p><p id="p0051" num="0051"> [0040] At 406, alternate boot code is executed from a one-time programmable (OTP) memory. This alternate boot code is executed instead of a portion of the boot code stored in the ROM. In some cases, the execution of the alternate boot code is responsive to an interrupt fired during execution of the boot code from ROM. In such cases, the interrupt can be cleared by an interrupt handler configured to execute the alternate boot code. This interrupt handler may be implemented or configured during earlier execution of the boot code. </p><p id="p0052" num="0052"> [0041] Continuing the ongoing example, interrupt handler 516 clears the interrupt fired by interrupt manager 134. While the execution of boot-ROM 206 is paused, interrupt handler 516 executes patch binary 518 of boot-ROM patch 208, which is stored in OTP memory 132. Here, patch binary 518 is executed instead of boot-ROM section 510 and the execution of the erroneous code in boot-ROM section 510 is 
<!-- EPO <DP n="19"/>-->
 prevented. By so doing, the code of boot-ROM section 510 can be patched without altering or modifying the contents of ROM 130. Additionally, because patch binary 518 is burned into OTP memory 132, the "root of trust" of the boot code is maintained because contents of the OTP memory cannot be modified once burned. </p><p id="p0053" num="0053">[0042] At 408, the program counter is returned to an address in the boot code effective to resume execution of the boot code from the ROM. The return address in the boot code can be configured such that one or more instructions of the boot code are skipped. Optionally, method 400 may return to operation 404 to interrupt execution of the boot code from the ROM. For example, in some cases, multiple sections of boot code may be patched. As such, iterations of operations 404 through 408 of method 400 may be performed any suitable number of times to execute additional binaries to patch the boot code stored in ROM. </p><p id="p0054" num="0054"> [0043] Concluding the ongoing example, assume that address 520 (0x5E01241C), which follows boot-ROM section 510, is burned into boot-ROM patch 208 as return address 522. Here, interrupt handler 516 sets program counter 508 to return address 522 after execution of patch binary 518. This is effective to cause processor core 114 to skip boot-ROM section 510 and resume execution of boot-ROM 206 at address 520. Once execution of boot-ROM 206 loads a boot loader of smart phone 104, the boot- ROM 206 verifies the boot loader as authentic and passes control to the boot loader to continue booting smart phone 104. </p><p id="p0055" num="0055"> [0044] Fig. 6 depicts a method 600 for burning boot code into fuses of a one-time- programmable memory. 
<!-- EPO <DP n="20"/>-->
 [0045] At 602, boot code is burned into fuses of a one-time programmable (OTP) memory. The boot code may be alternate boot code or additional boot code that supplements other boot code stored in a read-only memory (ROM), such as a boot- ROM binary. By way of example, consider a trusted boot-ROM binary that includes multiple sections of code, one of which contains an error. A patch binary designed to execute in place of the erroneous section of boot-ROM is burned into the fuses of an OTP memory. As such, execution of the boot code burned into the fuses during a boot sequence can be effective to patch the error (or bug) in the boot-ROM. </p><p id="p0056" num="0056">[0046] At 604, a first address for an interrupt service is burned into the fuses of the OTP. Inclusion of this first address in the OTP memory can be effective to cause the interrupt service to fire an interrupt when a program counter encounters the first address. Alternately or additionally, the first address is effective to cause execution of boot code from the OTP memory during a boot sequence. In the context of the example above, an address located ahead of the error in the boot-ROM is burned into the fuses of the OTP memory. By selecting an address that is ahead of the error, execution of the boot-ROM is interrupted by the interrupt service before the error is encountered. Additionally, when a program counter reaches this address, an interrupt handler can be caused to execute the patch binary instead of the section of boot-ROM that includes the error. </p><p id="p0057" num="0057"> [0047] At 606, a second address for an interrupt service is burned into the fuses of the OTP. Inclusion of this second address in the OTP memory can be effective to cause the interrupt service to set the program counter to the second address after an 
<!-- EPO <DP n="21"/>-->
 interrupt is serviced. In some cases, the second address is located within boot code executed from the ROM, such as boot-ROM. By setting the program counter to an address in the boot-ROM, execution of the boot-ROM can be resumed from the address at which the program counter is set. </p><p id="p0058" num="0058"> [0048] In some cases, the second address does not immediately follow an address from which an interrupt is initiated. In such cases, this can be effective to prevent execution of a particular portion or section of boot code. Continuing the ongoing example, an address located after the error in the boot-ROM is burned into the fuses of the OTP memory. As such, binary of the boot-ROM located between the addresses burned into the fuses of the OTP memory is not executed. </p><p id="p0059" num="0059"> [0049] Optionally at 608, additional fuses of the OTP memory are burned to secure data previously burned into the OTP memory. The additional fuses are fuses of unused blocks of the OTP memory and fuses of error-correcting code bits associated with the unused blocks. By so doing, the OTP memory cannot be modified, which is effective to secure the contents of the OTP memory, such as boot code patches. Alternately or additionally, a stock-keeping unit (SKU) number associated with the OTP memory can be updated or altered to reflect the functionality provided by the boot code burned into the OTP memory. For example, a SKU number of a chip that includes an OTP memory storing a boot-ROM patch can be revised to reflect the inclusion of the boot-ROM patch within the chip. </p><p id="p0060" num="0060">[0050] System-on-Chip </p><p id="p0061" num="0061"> Fig. 7 illustrates a System-on-Chip (SoC) 700, which can implement various aspects 
<!-- EPO <DP n="22"/>-->
 of loading boot code from multiple memories. A SoC can be implemented in any suitable device, such as a video game console, IP-enabled television, smart-phone, laptop computer, personal navigation device, access point, wireless router, cellular broadband router, tablet computer, server, network-enabled printer, set-top box, printer, scanner, camera, picture frame, home appliance, thermostat, home automation device, and/or any other type of electronic device. </p><p id="p0062" num="0062"> [0051] SoC 700 can be integrated with electronic circuitry, a microprocessor, memory, input-output (I/O) logic control, communication interfaces, other hardware, firmware, and/or software needed to provide functionalities of a device, such as any of the above-listed devices. SoC 700 can also include an integrated data bus (not shown) that couples the various components of the SoC for data communication between the components. An electronic or computing device that includes SoC 700 can also be implemented with many combinations of differing components. In some cases, these differing components may be configured to implement concepts described herein over various internal or external data interfaces. </p><p id="p0063" num="0063"> [0052] In this example, SoC 700 includes various components such as an input- output (I/O) logic control 702 (e.g., to include electronic circuitry) and microprocessor 704. SoC 700 also includes memory 706, which can be any type and/or combination of RAM, SRAM, DRAM, Flash, low-latency nonvolatile memory, ROM, and/or other suitable electronic data storage. In at least some aspects, boot code of SoC 700 is stored in a portion of memory 706 that is implemented as ROM. 
<!-- EPO <DP n="23"/>-->
 [0053] SoC 700 also includes one-time -programmable memory 132 (OTP memory 132) in which additional or alternate boot code is stored. This alternate or additional boot code can be used as described herein to implement one or more aspects of patching boot code of ROM. By way of example and in the context of SoC 700, the ability to trap on a desired patch address is a feature implemented by the System-On-Chip based on one-time -programmable fuses of OTP 132. Once other boot code (e.g., patch code) is executed in response to encountering the desired patch address, execution of boot code from ROM is resumed to continue booting a computing device in which SoC 700 is embodied. </p><p id="p0064" num="0064"> [0054] Alternately or additionally, SoC 700 may comprise data interfaces (not shown) for accessing additional or external off-chip memory, such as external SRAM, DRAM, or Flash memory. Although not shown, the external memory (or memory 706) may include multiple non-volatile memory devices storing multiple respective boot loaders and/or portions of boot code, as described with reference to Fig. 1. SoC 700 can also include various firmware and/or software, such as operating system(s) 708, which can be computer-executable instructions maintained by memory 706 and executed by microprocessor 704. SoC 700 may also include other various communication interfaces and components embodied as hardware, firmware, software, or any suitable combination thereof. </p><p id="p0065" num="0065"> [0055] SoC 700 also includes interrupt manager 134, which may be embodied as disparate or combined components, logic, routines, or services. Examples of these various components, functions, and/or entities, and their corresponding functionality, 
<!-- EPO <DP n="24"/>-->
 are described with reference to the respective components of the environment 100 and various configurations as illustrated by Figs. 2 and 5. Interrupt manager 134, either independently or in combination with other entities (e.g., an interrupt service routine), can be implemented as computer-executable instructions maintained by memory 706 and executed by microprocessor 704 to implement various embodiments and/or features described herein. Interrupt manager 134 may also be provided integral with other entities of the SoC, such as hardware interrupt logic associated with microprocessor 704 or another suitable software, firmware, or hardware component within SoC 700. Alternatively or additionally, interrupt manager 134 and the other components can be implemented as hardware, firmware, fixed logic circuitry, or any combination thereof that is implemented in connection with the I/O logic control 702 and/or other signal processing and control circuits of SoC 700. </p><p id="p0066" num="0066">[0056] Although the subject matter has been described in language specific to structural features and/or methodological operations, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or operations described above, including orders in which they are performed. 
</p></description><claims mxw-id="PCLM70076791" ref-ucid="WO-2014130338-A1" lang="EN" load-source="patent-office"><claim-statement><!-- EPO <DP n="25"/>-->CLAIMS  What is claimed is: </claim-statement><claim id="clm-0001" num="1"><claim-text>1. A method comprising: </claim-text><claim-text> initiating, from a read-only memory (ROM), execution of a first boot code to start a boot process of a computing device; </claim-text><claim-text> interrupting, during the boot process of the computing device, the execution of the first boot code to enable execution of a second boot code from another memory; and </claim-text><claim-text> resuming, after the second boot code is executed, the execution of the first boot code to continue the boot process of the computing device. </claim-text></claim><claim id="clm-0002" num="2"><claim-text>2. The method as recited in claim 1, wherein the other memory is one-time- programmable memory to which the second boot code is burned. </claim-text></claim><claim id="clm-0003" num="3"><claim-text>3. The method as recited in claim 1 further comprising executing, responsive to the interruption of the execution of the first boot code, the second boot code from the other memory. 
<!-- EPO <DP n="26"/>-->
</claim-text></claim><claim id="clm-0004" num="4"><claim-text>4. The method as recited in claim 1 , wherein interrupting the execution of the first boot code is responsive to a hardware -based interrupt firing during execution of the first boot code. </claim-text></claim><claim id="clm-0005" num="5"><claim-text>5. The method as recited in claim 4 further comprising, responsive to the hardware -based interrupt firing, clearing the fired hardware -based interrupt, causing execution of the second boot code, and returning to a predefined point of execution of the first boot code. </claim-text></claim><claim id="clm-0006" num="6"><claim-text>6. The method as recited in claim 5, wherein the predefined point to which execution of the first boot code is returned is different from a point at which execution of the first boot code is interrupted. </claim-text></claim><claim id="clm-0007" num="7"><claim-text>7. The method as recited in claim 1 , wherein the first boot code is written into the ROM during manufacture of a device or chip in which the ROM is embodied. 
<!-- EPO <DP n="27"/>-->
</claim-text></claim><claim id="clm-0008" num="8"><claim-text>8. A method comprising: </claim-text><claim-text> initiating execution of a first boot code from a read-only memory (ROM), the execution of the first boot code advanced via a program counter; </claim-text><claim-text> interrupting, responsive to the program counter reaching a predetermined address in the first boot code, the execution of the first boot code; </claim-text><claim-text> executing, instead of at least some of the first boot code, a second boot code from a one-time -programmable (OTP) memory; and </claim-text><claim-text> returning, responsive to completion of executing the second boot code, the program counter to an address in the first boot code effective to resume execution of the first boot code from the ROM. </claim-text></claim><claim id="clm-0009" num="9"><claim-text>9. The method as recited in claim 8, wherein the predetermined address at which execution of the first boot code is interrupted or the address to which the program counter is returned is stored in the OTP memory. </claim-text></claim><claim id="clm-0010" num="10"><claim-text>10. The method as recited in claim 8, wherein execution of the first boot code and the second boot code is effective to load a boot loader and the method further comprises, prior to transferring control to the boot loader, verifying a cryptographic signature or cryptographic hash of the boot loader to ensure authenticity of the boot loader. 
<!-- EPO <DP n="28"/>-->
</claim-text></claim><claim id="clm-0011" num="11"><claim-text>11. The method as recited in claim 8, wherein interrupting the execution of the first boot code includes firing an interrupt and the method further comprises, prior to executing the second boot code, clearing the fired interrupt. </claim-text></claim><claim id="clm-0012" num="12"><claim-text>12. The method as recited in claim 8, wherein the at least some of the first boot code includes a coding error, and the address to which the program counter is returned is located subsequent to the coding error in the first boot code such that the coding error is not executed. </claim-text></claim><claim id="clm-0013" num="13"><claim-text>13. The method as recited in claim 8, wherein the first boot code is burned into the ROM and the second boot code is burned into the OTP memory such that execution of the first boot code and the second boot code implements at least part of a trusted boot process. 
<!-- EPO <DP n="29"/>-->
</claim-text></claim><claim id="clm-0014" num="14"><claim-text>14. A System-on-Chip comprising: </claim-text><claim-text> a processor configured to execute, via a program counter, code to boot a device in which the System-on-Chip is embodied; </claim-text><claim-text> a read-only memory (ROM) storing a first boot code for the device; </claim-text><claim-text> a one-time -programmable (OTP) memory storing a second boot code; and an interrupt manager configured to: </claim-text><claim-text> interrupt execution of the first boot code from the ROM in response to the program counter encountering a predetermined address in the first boot code; </claim-text><claim-text> cause the processor to execute the second boot code from the OTP memory; and </claim-text><claim-text> return, after the second boot code is executed, the program counter to an address in the first boot code effective to resume execution of the first boot code from the ROM. </claim-text></claim><claim id="clm-0015" num="15"><claim-text>15. The System-on-Chip of claim 14, wherein the OTP memory includes one or more blocks of fuses to store data and the second boot code is burned into one or more blocks of the fuses. </claim-text></claim><claim id="clm-0016" num="16"><claim-text>16. The System-on-Chip of claim 15, wherein unused blocks of the fuses and error-correction code bits associated with the unused blocks of the fuses are burned such that contents of the OTP memory cannot be modified. 
<!-- EPO <DP n="30"/>-->
</claim-text></claim><claim id="clm-0017" num="17"><claim-text>17. The System-on-Chip of claim 14, wherein the System-on-Chip includes an address link register that is configured to store the address to which the program counter is returned after the second boot code is executed. </claim-text></claim><claim id="clm-0018" num="18"><claim-text>18. The System-on-Chip of claim 17, wherein the interrupt manager is further configured to set the address link register to an address that is immediately subsequent to the predetermined address at which execution of the first boot code is interrupted. </claim-text></claim><claim id="clm-0019" num="19"><claim-text>19. The System-on-Chip of claim 17, wherein the interrupt manager is further configured to set the address link register to an address that is not immediately subsequent to the predetermined address effective to cause the processor to not execute a portion of the first boot code stored in the ROM. </claim-text></claim><claim id="clm-0020" num="20"><claim-text>20. The System-on-Chip of claim 14, wherein the device in which the System-on- Chip is embodied comprises one of a computing device, electronic device, or communication device. 
</claim-text></claim></claims><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
