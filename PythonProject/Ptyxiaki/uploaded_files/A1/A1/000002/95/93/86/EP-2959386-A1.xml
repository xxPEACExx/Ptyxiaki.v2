<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2959386-A1" country="EP" doc-number="2959386" kind="A1" date="20151230" family-id="50272574" file-reference-id="286467" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="160452583" ucid="EP-2959386-A1"><document-id><country>EP</country><doc-number>2959386</doc-number><kind>A1</kind><date>20151230</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-14709575-A" is-representative="NO"><document-id mxw-id="PAPP193868134" load-source="patent-office" format="original"><country>EP</country><doc-number>14709575.6</doc-number><date>20140224</date><lang>EN</lang></document-id><document-id mxw-id="PAPP193868135" load-source="docdb" format="epo"><country>EP</country><doc-number>14709575</doc-number><kind>A</kind><date>20140224</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC162033448" ucid="EP-2014053497-W" linkage-type="W" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>2014053497</doc-number><kind>W</kind><date>20140224</date></document-id></priority-claim><priority-claim mxw-id="PPC162030603" ucid="US-201313775305-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201313775305</doc-number><kind>A</kind><date>20130225</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1988520236" load-source="docdb">G06F   9/54        20060101AFI20140912BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1984020261" load-source="docdb" scheme="CPC">G06F  12/0284      20130101 LI20160109BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1984023633" load-source="docdb" scheme="CPC">G06F   3/0656      20130101 FI20160109BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1984698893" load-source="docdb" scheme="CPC">G06F   3/0683      20130101 LI20160107BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1984699609" load-source="docdb" scheme="CPC">G06F   3/0613      20130101 LI20160107BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1984705332" load-source="docdb" scheme="CPC">G06F   9/546       20130101 LI20160107BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987771540" load-source="docdb" scheme="CPC">G06F   9/544       20130101 LI20150626BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT165549215" lang="DE" load-source="patent-office">WARTEZEITFREIER ALGORITHMUS FÜR KOMMUNIKATION ZWISCHEN KERNEN, PROZESSEN ODER TASKS</invention-title><invention-title mxw-id="PT165549216" lang="EN" load-source="patent-office">WAIT-FREE ALGORITHM FOR INTER-CORE, INTER-PROCESS, OR INTER-TASK COMMUNICATION</invention-title><invention-title mxw-id="PT165549217" lang="FR" load-source="patent-office">ALGORITHME EXEMPT D'ATTENTE POUR UNE COMMUNICATION INTER-NOYAU, INTER-PROCESSUS, OU INTER-TÂCHE</invention-title></technical-data><parties><applicants><applicant mxw-id="PPAR1103328380" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>BARCO NV</last-name><address><country>BE</country></address></addressbook></applicant><applicant mxw-id="PPAR1103315648" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>BARCO NV</last-name></addressbook></applicant><applicant mxw-id="PPAR1101649900" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Barco NV</last-name><iid>100083550</iid><address><street>President Kennedypark 35</street><city>8500 Kortrijk</city><country>BE</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR1103339321" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>MORTIER PETER</last-name><address><country>NL</country></address></addressbook></inventor><inventor mxw-id="PPAR1103312036" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>MORTIER, Peter</last-name></addressbook></inventor><inventor mxw-id="PPAR1101651929" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>MORTIER, Peter</last-name><address><street>Bartolomeus Diazstraat 20</street><city>NL-4562 AP Hulst</city><country>NL</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR1101652798" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>IPLodge</last-name><iid>101392367</iid><address><street>Technologielaan 9</street><city>3001 Heverlee</city><country>BE</country></address></addressbook></agent></agents></parties><international-convention-data><pct-or-regional-filing-data ucid="EP-2014053497-W"><document-id><country>EP</country><doc-number>2014053497</doc-number><kind>W</kind><date>20140224</date><lang>EN</lang></document-id></pct-or-regional-filing-data><pct-or-regional-publishing-data ucid="WO-2014128288-A1"><document-id><country>WO</country><doc-number>2014128288</doc-number><kind>A1</kind><date>20140828</date><lang>EN</lang></document-id></pct-or-regional-publishing-data><designated-states><ep-contracting-states><country mxw-id="DS660788991" load-source="docdb">AL</country><country mxw-id="DS660703815" load-source="docdb">AT</country><country mxw-id="DS660788993" load-source="docdb">BE</country><country mxw-id="DS660626274" load-source="docdb">BG</country><country mxw-id="DS660726065" load-source="docdb">CH</country><country mxw-id="DS660625204" load-source="docdb">CY</country><country mxw-id="DS660703816" load-source="docdb">CZ</country><country mxw-id="DS660788994" load-source="docdb">DE</country><country mxw-id="DS660625205" load-source="docdb">DK</country><country mxw-id="DS660625206" load-source="docdb">EE</country><country mxw-id="DS660704054" load-source="docdb">ES</country><country mxw-id="DS660626291" load-source="docdb">FI</country><country mxw-id="DS660625460" load-source="docdb">FR</country><country mxw-id="DS660788995" load-source="docdb">GB</country><country mxw-id="DS660625219" load-source="docdb">GR</country><country mxw-id="DS660788996" load-source="docdb">HR</country><country mxw-id="DS660703817" load-source="docdb">HU</country><country mxw-id="DS660726066" load-source="docdb">IE</country><country mxw-id="DS660625220" load-source="docdb">IS</country><country mxw-id="DS660625461" load-source="docdb">IT</country><country mxw-id="DS660625221" load-source="docdb">LI</country><country mxw-id="DS660626292" load-source="docdb">LT</country><country mxw-id="DS660710282" load-source="docdb">LU</country><country mxw-id="DS660626293" load-source="docdb">LV</country><country mxw-id="DS660626294" load-source="docdb">MC</country><country mxw-id="DS660710287" load-source="docdb">MK</country><country mxw-id="DS660710288" load-source="docdb">MT</country><country mxw-id="DS660703818" load-source="docdb">NL</country><country mxw-id="DS660704059" load-source="docdb">NO</country><country mxw-id="DS660726071" load-source="docdb">PL</country><country mxw-id="DS660626300" load-source="docdb">PT</country><country mxw-id="DS660703827" load-source="docdb">RO</country><country mxw-id="DS660626301" load-source="docdb">RS</country><country mxw-id="DS660726072" load-source="docdb">SE</country><country mxw-id="DS660625462" load-source="docdb">SI</country><country mxw-id="DS660704060" load-source="docdb">SK</country><country mxw-id="DS660726073" load-source="docdb">SM</country><country mxw-id="DS660710289" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data><office-specific-data><eptags><ep-no-a-document-published>*</ep-no-a-document-published></eptags></office-specific-data></bibliographic-data><abstract mxw-id="PA139079805" ref-ucid="WO-2014128288-A1" lang="EN" load-source="patent-office"><p num="0000">A method and system are presented for providing deterministic inter-core, inter-process, and inter-thread communication between a reader and a writer. The reader and writer communicate by passing data through a shared memory using double buffering of double buffers. The shared memory includes a first double buffer and a second double buffer. Both double buffers include a first low level buffer and a second low level buffer. Using double buffering of the double buffers, both the reader and the writer may simultaneously access the shared memory.</p></abstract><abstract mxw-id="PA139546360" ref-ucid="WO-2014128288-A1" lang="EN" source="national office" load-source="docdb"><p>A method and system are presented for providing deterministic inter-core, inter-process, and inter-thread communication between a reader and a writer. The reader and writer communicate by passing data through a shared memory using double buffering of double buffers. The shared memory includes a first double buffer and a second double buffer. Both double buffers include a first low level buffer and a second low level buffer. Using double buffering of the double buffers, both the reader and the writer may simultaneously access the shared memory.</p></abstract><abstract mxw-id="PA139079806" ref-ucid="WO-2014128288-A1" lang="FR" load-source="patent-office"><p num="0000">L'invention concerne un procédé et un système pour réaliser une communication inter-noyau, inter-processus, et inter-fil d'exécution déterministe entre un dispositif de lecture et un dispositif d'écriture. Le dispositif de lecture et le dispositif d'écriture communiquent en faisant passer des données par l'intermédiaire d'une mémoire partagée en utilisant une mise en mémoire tampon double de mémoires tampons doubles. La mémoire partagée comprend une première mémoire tampon double et une seconde mémoire tampon double. Les deux mémoires tampons doubles comprennent une première mémoire tampon de niveau bas et une seconde mémoire tampon de niveau bas. En utilisant une mise en mémoire tampon double des mémoires tampons doubles, le dispositif de lecture et le dispositif d'écriture peuvent tous deux accéder simultanément à la mémoire partagée.</p></abstract><abstract mxw-id="PA139546361" ref-ucid="WO-2014128288-A1" lang="FR" source="national office" load-source="docdb"><p>L'invention concerne un procédé et un système pour réaliser une communication inter-noyau, inter-processus, et inter-fil d'exécution déterministe entre un dispositif de lecture et un dispositif d'écriture. Le dispositif de lecture et le dispositif d'écriture communiquent en faisant passer des données par l'intermédiaire d'une mémoire partagée en utilisant une mise en mémoire tampon double de mémoires tampons doubles. La mémoire partagée comprend une première mémoire tampon double et une seconde mémoire tampon double. Les deux mémoires tampons doubles comprennent une première mémoire tampon de niveau bas et une seconde mémoire tampon de niveau bas. En utilisant une mise en mémoire tampon double des mémoires tampons doubles, le dispositif de lecture et le dispositif d'écriture peuvent tous deux accéder simultanément à la mémoire partagée.</p></abstract><description mxw-id="PDES78478056" ref-ucid="WO-2014128288-A1" lang="EN" load-source="patent-office"><!-- EPO <DP n="3"/>--><p id="p0001" num="0001"> WAIT-FREE ALGORITHM FOR INTER-CORE, INTER-PROCESS, OR INTERTASK COMMUNICATION </p><p id="p0002" num="0002">TECHNICAL FIELD </p><p id="p0003" num="0003"> The present invention relates generally to multi-core computer systems, and particularly to methods for communicating and sharing data between cores, processes, or threads. </p><p id="p0004" num="0004">BACKGROUND </p><p id="p0005" num="0005"> The need for more powerful processing platforms in the avionics industry and the availability of multi-core devices has resulted in the development of avionics processing platforms utilizing multi-core devices. However, before multi-core devices can be utilized in avionics processing </p><p id="p0006" num="0006">platforms, testing should be performed to ensure that the operation of each multi-core device complies with required regulations. For example, it may be a requirement that a display is updated every 50 ms. Before a multi-core device can be utilized, it should be shown to comply with this requirement. </p><p id="p0007" num="0007"> In order to ensure that a multi-core device complies with required regulations, multi-core devices should be able to pass data between cores, processes and threads in a wait-free manner. There should also be no interference between applications running on the multi-core device. That is, each application should be partitioned in memory and time space, such that memory and timing are not affected by the execution of other </p><p id="p0008" num="0008">applications. </p><p id="p0009" num="0009"> Current deterministic solutions for multi-core communication can be divided into blocking and non-blocking algorithms. Blocking algorithms are non-ideal, as threads/cores compete for shared resources and, due to mutual exclusion, can have their execution postponed indefinitely. </p><p id="p0010" num="0010">Current, conventional non-blocking algorithms predominately use atomic read-modify-write primitives that should be provided by the underlying </p><p id="p0011" num="0011">hardware components. Additionally, non-blocking algorithms may require a writer to wait for a reader to complete reading data from a shared </p><p id="p0012" num="0012">resource before the writer is permitted to write data to the shared 
<!-- EPO <DP n="4"/>-->
 resource. That is, current non-blocking algorithms may not allow a reader to simultaneously read data from a shared resource as a writer writes data to the shared resource. </p><p id="p0013" num="0013">SUMMARY </p><p id="p0014" num="0014"> A system and method is proposed for providing deterministic inter-core, inter-process, and inter-thread communication between a reader and a writer by passing data through shared memory using double buffering of double buffers. A system and method according to the invention enables one or more </p><p id="p0015" num="0015">advantages to be obtained, including allowing, in a deterministic manner, a reader to simultaneously read data from a shared resource as a writer writes data to the shared resource. </p><p id="p0016" num="0016"> According to one aspect of the disclosure, a method for providing deterministic inter-core, inter-process, and inter-thread communication between a reader and a writer by passing data through shared memory using double buffering of double buffers includes the reader or writer selecting one of a first double buffer or a second double buffer as a selected double buffer. The writer writes data to the selected double buffer, each double buffer is stored in the shared memory, and each double buffer includes a first low level buffer and a second low level buffer. The method additionally includes the reader reading data. Reading data includes the reader determining if new data has been written to the selected double buffer. New data corresponds to data that has not been read by the reader. If new data has been written to the selected double buffer, the reader selects the non-selected double buffer as the selected double buffer such that the writer writes data to the newly selected double buffer. If new data has been written to the selected double buffer the reader also determines if new data has been written to the previously selected double buffer in the time since the previous check to determine if new data had been written to the previously selected double buffer. If new data has been written to the selected double buffer, the reader accesses and outputs the last data written to the previously selected double buffer. If new data has not been written to the selected double 
<!-- EPO <DP n="5"/>-->
 buffer, the reader determines if old data or new data was written to the non- selected double buffer. Old data corresponds to data that the reader has previously read. If neither old data nor new data was written to the non-selected double buffer, no data is output by the reader. If old data or new data was written to the non-selected double buffer, the reader accesses and outputs the last data written to the non-selected double buffer. </p><p id="p0017" num="0017"> Alternatively or additionally, the writer writing data to the selected double buffer may include the writer storing data in the low level buffer of the selected double buffer that is most convenient. </p><p id="p0018" num="0018"> Alternatively or additionally, the reader may read data at the same time as the writer writes data to the selected double buffer. </p><p id="p0019" num="0019"> Alternatively or additionally, the reader may output a state. For example, the reader may output a new data state when new data has been written to the selected double buffer. The reader may output the new data state when new data has not been written to the selected double buffer and new data has been written to the non-selected double buffer. The reader may output an old data state when new data has not been written to both the selected double buffer and the non-selected double buffer and the non-selected double buffer contains old data. The reader may output a no data state when new data has not been written to both the selected double buffer and the non-selected double buffer and the non-selected double buffer does not contain old data. </p><p id="p0020" num="0020"> Alternatively or additionally, the reader or writer selecting one of the first double buffer or the second double buffer as the selected double buffer may include the reader setting a transmit index in the shared memory to identify the first double buffer or the second double buffer. The double buffer identified by the transmit index may correspond to the selected double buffer and the double buffer not identified by the transmit index may correspond to an non-selected double buffer. </p><p id="p0021" num="0021"> Alternatively or additionally, the reader or writer may initialize both double buffers to an initial state prior to the reader reading data. 
<!-- EPO <DP n="6"/>-->
 Alternatively or additionally, initializing both double buffers to an initial state may include the reader or writer setting a shared index in the shared memory to an initial value for the first double buffer and the second double buffer. The shared index may identify one of the first low level buffer, the second low level buffer, or the initial value for each double buffer. </p><p id="p0022" num="0022"> Alternatively or additionally, the reader determining if new data has been written to the selected double buffer may include the reader reading the transmit index to identify the selected double buffer and the reader reading the shared index for the selected double buffer. New data may have been written to the selected double buffer if the shared index for the selected double buffer does not correspond to the initial value. </p><p id="p0023" num="0023"> Alternatively or additionally, the reader determining if new data has been written to the selected double buffer may include the reader reading the transmit index to identify the selected double buffer, the reader reading the shared index for the selected double buffer, and the reader reading a read index for the selected double buffer. The read index for a given double buffer may indicate the low level buffer identified by the shared index for the given double buffer from which the reader last accessed data. New data may have been written to the selected double buffer if the shared index for the selected double buffer does not correspond to the read index for the selected double buffer and the shared index for the selected double buffer does not correspond to the initial value. </p><p id="p0024" num="0024"> Alternatively or additionally, if new data has been written to the selected double buffer, the reader may initialize the non-selected double buffer before the reader selects the non-selected double buffer as the selected double buffer. </p><p id="p0025" num="0025"> Alternatively or additionally, the reader initializing the non-selected double buffer may include the reader setting the shared index for the non-selected double buffer to the initial value. </p><p id="p0026" num="0026"> Alternatively or additionally, the reader selecting the non-selected double buffer as the selected double buffer may include the reader updating the transmit index to identify the non-selected double buffer such that the non-selected 
<!-- EPO <DP n="7"/>-->
 double buffer is now the selected double buffer and the selected double buffer is now the non-selected double buffer. </p><p id="p0027" num="0027"> The reader determining if new data has been written to the previously selected double buffer in the time since the previous check may include the reader reading the shared index for the previously selected double buffer and the reader setting a read index for the previously selected double buffer in the shared memory to identify the low level buffer identified by the shared index for the non-selected double buffer. </p><p id="p0028" num="0028"> Alternatively or additionally, the reader accessing and outputting the last data written to the previously selected double buffer may include the reader accessing the data stored in the low level buffer identified by the shared index of the previously selected double buffer and the reader outputting the data. </p><p id="p0029" num="0029"> Alternatively or additionally, determining if old data or new data was written to the non-selected double buffer may include the reader reading the shared index for the non-selected double buffer. The non-selected double buffer may not contain old data or new data if the shared index for the non-selected double buffer corresponds to the initial value. </p><p id="p0030" num="0030"> Alternatively or additionally, determining if old data or new data was written to the non-selected double buffer may include, if the shared index for the non-selected double buffer does not correspond to the initial value, the reader comparing the shared index for the non-selected double buffer and the read index for the non-selected double buffer. The non-selected double buffer may contain old data if the shared index for the non-selected double buffer and the read index for the non-selected double buffer correspond to the same low level buffer. </p><p id="p0031" num="0031"> Alternatively or additionally, if the shared index for the non-selected double buffer and the read index for the non-selected double buffer do not correspond to the same low level buffer, new data may have been written to the non-selected double buffer and the reader setting the read index for the non- selected double buffer may identify the low level buffer identified by the shared index for the non-selected double buffer. 
<!-- EPO <DP n="8"/>-->
 Alternatively or additionally, the reader accessing and outputting the last data written to the non-selected double buffer may include the reader accessing the data stored in the low level buffer identified by the shared index of the non- selected double buffer and the reader outputting the data. </p><p id="p0032" num="0032"> Alternatively or additionally, the writer writing data to the selected double buffer may include the writer reading the shared index for the selected double buffer, the writer storing data in a next low level buffer for the selected double buffer, and the writer setting the shared index for the selected double buffer to correspond to the next low level buffer. The next low level buffer may </p><p id="p0033" num="0033">corresponds to the low level buffer for the selected double buffer not indicated by the shared index for the selected double buffer if the shared index corresponds to the first low level buffer or the second low level buffer. The next low level buffer may correspond to the first low level buffer for the selected double buffer if the shared index for the selected double buffer corresponds to the initial value. </p><p id="p0034" num="0034"> Alternatively or additionally, the writer setting the shared index for the selected double buffer to correspond to the next low level buffer may include reading a value of the transmit index (Tx) and determining a corrected transmit index. The transmit index value may be an integer between zero and three. A value of the corrected transmit index may be equal to Tx mod 2. The corrected transmit index having a value of zero may correspond to the selected double buffer being the first double buffer. The corrected transmit index having a value of one may correspond to the selected double buffer being the second double buffer. The writer setting the shared index for the selected double buffer to correspond to the next low level buffer may additionally include reading a value of the shared index (Sx) and determining a corrected shared index. The shared index value may be an integer between zero and four. A value of the corrected shared index may be equal to ((Sx-1 ) mod 2)+1 . The corrected shared index having a value of zero may correspond to the initial value. The corrected shared index having a value of one may correspond to the first low level buffer. The corrected shared index having a value of two may correspond to the second low level buffer. The writer setting the shared index for the selected double buffer to 
<!-- EPO <DP n="9"/>-->
 correspond to the next low level buffer may also include determining a value of the next low level buffer and setting the value of the shared index equal to the value of the next low level buffer. The value of the next low level buffer may equal (Sx mod 2)+1 if the transmit index equal zero or one. The value of the next low level buffer may equal (Sx mod 2)+3 if the transmit index equal two or three. </p><p id="p0035" num="0035"> Alternatively or additionally, a computational device may include a multicore processor and a shared memory. The multicore processor may carry out the method for providing deterministic inter-core, inter-process, and inter- thread communication between a reader and a writer by passing data through shared memory using double buffering of double buffers. </p><p id="p0036" num="0036"> Alternatively or additionally, a non-transitory computer-readable storage medium may store logical instructions thereon that when executed by a processor perform the steps of the method for providing deterministic inter-core, inter-process, and inter-thread communication between a reader and a writer by passing data through shared memory using double buffering of double buffers. </p><p id="p0037" num="0037"> The foregoing and other features of the invention are hereinafter fully described and particularly pointed out in the claims, the following description and annexed drawings setting forth in detail certain illustrative embodiments of the invention, these embodiments being indicative, however, of but a few of the various ways in which the principles of the invention may be employed. </p><p id="p0038" num="0038"> Features that are described and/or illustrated with respect to one embodiment may be used in the same way or in a similar way in one or more other embodiments and/or in combination with or instead of the features of the other embodiments. </p><p id="p0039" num="0039">BRIEF DESCRIPTION OF THE DRAWINGS</p><p id="p0040" num="0040">FIG. 1 is a block diagram illustrating an exemplary multi-core </p><p id="p0041" num="0041">computational device. 
<!-- EPO <DP n="10"/>-->
 FIG. 2 is a block diagram illustrating a method for providing deterministic inter-core, inter-process, and inter-thread communication between a reader and a writer; </p><p id="p0042" num="0042"> FIGs. 3a-3c are block diagrams illustrating steps for reading data by the reader; </p><p id="p0043" num="0043"> FIG. 4 is a block diagram illustrating steps for writing data by the writer;</p><p id="p0044" num="0044">FIG. 5 is a block diagram of another embodiment of the method for providing deterministic inter-core, inter-process, and inter-thread communication between a reader and a writer; </p><p id="p0045" num="0045"> FIGs. 6a-6c are block diagrams illustrating steps for reading data by the reader; </p><p id="p0046" num="0046"> FIG. 7 is a block diagram illustrating steps for writing data by the writer; FIGs. 8a-8b are block diagrams illustrating steps for reading data by the reader; and </p><p id="p0047" num="0047"> FIG. 9 is a block diagram illustrating steps for writing data by the writer. </p><p id="p0048" num="0048">DETAILED DESCRIPTION </p><p id="p0049" num="0049"> The present invention provides a system and method for providing deterministic inter-core, inter-process, and inter-thread communication between a reader and a writer. The reader and writer communicate by passing data through a shared memory using double buffering of double buffers. The shared memory includes a first double buffer and a second double buffer. Both double buffers include a first low level buffer and a second low level buffer. Using double buffering of the double buffers, both the reader and the writer may simultaneously access (i.e., read and/or write data to) the shared memory. </p><p id="p0050" num="0050"> Turning initially to FIG. 1 , an exemplary multi-core computational device 10 is shown. The multi-core computational device 10 includes a multi-core processor 12 and a non-transitory computer-readable storage medium 18. The multi-core processor 12 includes a first core 14 having a reader 15 and a second core 16 having a writer 17. The reader 15 and writer 17 may have read-write access to a shared memory 20 included in the storage medium 18. The shared 
<!-- EPO <DP n="11"/>-->
 memory 20 includes a read index 22, a transmit index 24, a shared index 26, a first double buffer 28, and a second double buffer 30. The first double buffer 28 has a first low level buffer 32 and a second low level buffer 34. The second double buffer 30 has a first low level buffer 36 and a second low level buffer 38. </p><p id="p0051" num="0051"> As will be understood by one of ordinary skill in the art, the processor 12 may have various implementations. For example, the processor 12 may include a central processing unit (CPU) or any other suitable multi-core device, such as a programmable circuit, integrated circuit, memory and I/O circuits, an </p><p id="p0052" num="0052">application specific integrated circuit, microcontroller, complex programmable logic device, other programmable circuits, or the like. The processor 12 may also include a non-transitory computer readable memory, such as a CPU cache, computational random access memory (RAM), RAM, or any other suitable memory. Instructions for performing the method described below may be stored in the non-transitory computer readable memory and executed by the processor. </p><p id="p0053" num="0053"> The reader 15 and writer 17 may communicate by passing data through the shared memory 20. Data may be passed through the shared memory 20 by the writer 17 storing (i.e., writing) data in and the reader 15 accessing (i.e., reading) the data stored in the first double buffer 28 and/or the second double buffer 30. That is, the writer 17 writes data to the first low level buffer 32 of the first double buffer 28, the second low level buffer 34 of the first double buffer 28, the first low level buffer 36 of the second double buffer 30, and/or the second low level buffer 38 of the second double buffer 30. When the reader 15 reads data form the shared memory 20, the reader 15 may read the last data written by the writer 17. For example, the writer 17 may write data three times prior to the reader 15 reading data. When the reader 15 reads data, the reader 15 will only read the last data written by the writer 17 (i.e., the reader 15 will not read the data written in the previous two write operations performed by the writer 17). </p><p id="p0054" num="0054"> In order to determine which double buffer 28, 30 to write data to, the writer 17 reads the transmit index 24 to determine a selected double buffer. That is, the selected double buffer may identify either the first double buffers 28 or the second double buffer 30. In order to determine which low level buffer 32, 34, 36, 
<!-- EPO <DP n="12"/>-->
 38 of the selected double buffer to write data, the writer 17 reads the shared index 26. That is, the shared index 26 may identify the first low level buffer 32, 36 or the second low level buffer 34, 38 of the selected double buffer. The shared index 26 may identify, for a given double buffer 32, 34, the low level buffer to which data was last written. Similarly, the reader 15 also reads the transmit index 24 to determine the selected double buffer for reading data and the shared index 26 to determine which low level buffer 32, 34, 36, 38 of the selected double buffer to read data from. </p><p id="p0055" num="0055"> Accordingly, the reader 15 may have read-write access to the read index 22 and the transmit index 24. The reader 15 may have read only access to the first double buffer 32 and the second double buffer 34. The reader 15 may also have read-write access or read only access to the shared index 26. The writer 17 may have read-write access to the shared index 26, the first double buffer 32, and the second double buffer 34. The writer 17 may have read only access to the transmit index 24. </p><p id="p0056" num="0056"> The read and write operations should be atomic, i.e. performed without interrupt. That is, as implemented, the processor 12 and the shared memory 20 should be configured such that access to the transmit index 24 and the shared index 26 occurs atomically. </p><p id="p0057" num="0057"> As will be understood by one of ordinary skill in the art, the storage medium 18 may include a non-transitory computer readable medium, such as random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), or any other suitable medium. Instructions for performing the method described below may be stored in the non-transitory computer readable medium and executed by the processor. </p><p id="p0058" num="0058"> With reference to FIG. 2, a block diagram depicting a method for providing deterministic inter-core, inter-process, and inter-thread communication between a reader 15 and a writer 17 is shown. In process block 50 a double buffer is selected for storing data. That is, the reader 15 or writer 17, e.g., may select either the first double buffer 28 or the second double buffer 30 as the selected 
<!-- EPO <DP n="13"/>-->
 double buffer. In process block 52, both the first double buffer 28 and the second double buffer 30 are initialized. The reader 15, prior to reading data, may perform initialization of the double buffers 28, 30. </p><p id="p0059" num="0059"> Following process block 52, decision blocks 54 and 58 may occur simultaneously. That is, the reader 15 may read data at the same time as the writer 17 writes data. In decision block 54, a check is performed to determine if data is to be written. If data is to be written, then, in process block 56, the writer 17 writes data. For example, the writer 17 may store data in the low level buffer of the selected double buffer that is most convenient. In decision block 58, a check is performed to determine if there data is to be read. If data is to be read, then, in process block 60, the reader 15 reads data. </p><p id="p0060" num="0060"> Turning to FIG. 3a, reading data by the reader 15 is further described. In decision block 62, a check is performed to determine if new data has been written to the selected double buffer. New data is data that has not previously been read by the reader 15. In block 64, if new data has been written to the selected double buffer, the reader 15 may, e.g., initialize the non-selected double buffer. Initializing a double buffer 28, 30, e.g., is further described in process block 103 of FIG. 5. Next, in process block 66, the reader 15, e.g., selects the non-selected double buffer as the selected double buffer, such that the writer 17 will now write data to the newly selected double buffer. </p><p id="p0061" num="0061"> In process block 68, the reader 15 determines if new data has been written to the previously selected double buffer in the time since the previous check (i.e., process block 62). In process block 70, the reader 15 reads and outputs the last data written to the previously selected double buffer. In process block 72, the reader 15 optionally outputs a status of new data (i.e., when new data has been written to the selected double buffer). </p><p id="p0062" num="0062"> The following example is provided to demonstrate the operation of FIG. 3a. In this example, the reader 15 has received an instruction to read the last data written to the shared memory 20. Assume, at the time block 62 is performed, the selected double buffer is the first double buffer 28 and the writer 17 has previously written data to the first low level buffer 32 of the selected 
<!-- EPO <DP n="14"/>-->
 double buffer, but data has not been written to the second low level buffer 34. Following decision block 62, because data has been written to the selected double buffer, process block 64 is performed. In process block 64, the non- selected double buffer (i.e., the second double buffer 30) is initialized. In process block 66, the second double buffer 30 (i.e., the non-selected double buffer) is selected as the selected double buffer. Now, following process block 66, if the writer 17 writes new data to the shared memory 20, the writer 17 will write data to the newly selected double buffer, not the double buffer from which the reader 15 is reading data (i.e., the previously selected double buffer). </p><p id="p0063" num="0063"> Continuing the example, in process block 68, the reader 15 determines if new data has been written to the previously selected double buffer (i.e., the first double buffer 28) since process block 62. As stated above, at the time process block 62 was performed, data had been written to the first low level buffer 32 of the first double buffer 28, but no data had been written to the second low level buffer 34. However, during operation of blocks 62 and 64, in this example, the writer 17 wrote new data to the second low level buffer 34 of the first double buffer 32 (i.e., the selected double buffer at the time). If process block 68 is not performed (i.e., the reader 15 does not check if new data has been written to the previously selected double buffer during operation of steps 64 and 66), then the reader 15 may incorrectly read old data (in this example the data stored in the first low level buffer 32) and miss the new data that was written to the shared memory 20 during operation of blocks 62 and 64 (in this example the data stored in the second low level buffer 34). The reading of old data as opposed to the new data may make the method non-deterministic and cause errors. </p><p id="p0064" num="0064"> Returning to FIGS. 3a and 3b, if new data has not been written to the selected double buffer, then decision block 80 of FIG. 3b is performed. In decision block 80, the reader 15 determines if old data or new data was written to the non-selected double buffer. Old data corresponds to data that the reader 15 has previously read. If neither old data nor new data was written to the non- selected double buffer, then, in process block 82, no data is output by the reader 15. Following process block 82 (i.e., when new data has not been written to both 
<!-- EPO <DP n="15"/>-->
 the selected double buffer and the non-selected double buffer does not contain old data), in process block 84, a status no data may optionally be output. </p><p id="p0065" num="0065"> In process block 86, if old data or new data was written to the non- selected double buffer, the reader 15 accesses and outputs the last data written to the non-selected double buffer. Accessing and outputting the last data written to the non-selected double buffer in process block 86 is further described in FIG. 3c. </p><p id="p0066" num="0066"> With reference to FIG. 3c, decision block 87 determines if new data been written to the shared memory 20 since data was last read from the non-selected double buffer. If new data has been written, then, in process block 88, the reader 15 reads and outputs the new data. In process block 90 (i.e., when new data has not been written to the selected double buffer and new data has been written to the non-selected double buffer), the reader 15 optionally outputs the status new data. If new data has not been written, then, in process block 92, the reader 15 outputs the old data that was last written to the non-selected double buffer. In process block 94 (i.e., when new data has not been written to both the selected double buffer and the non-selected double buffer and the non-selected double buffer contains old data), the reader 15 may optional output the status old data. </p><p id="p0067" num="0067"> Turning to FIG. 4, the writer 17 writing data in process block 56 of FIG. 2 is further described. In decision block 95, the writer 17 determines if data has been written to the selected double buffer. If data has not been written to the selected double buffer, then, in process block 96 the writer 17 writes data to either of the low level buffers of the selected double buffer. For example, the writer 17 may write data to the low level buffer of the selected double buffer that is most convenient. The most convenient low level buffer may comprise the first low level buffer, the second low level buffer, the last low level buffer to which data was written, the low level buffer that data was not written to last, the low level buffer with the shortest access time, or any other suitable criteria for selecting the most convenient low level buffer. If data has been written to the selected double buffer, then, in process block 98, the writer 17 writes data to the 
<!-- EPO <DP n="16"/>-->
 low level buffer of the selected double buffer that does not contain data or that contains the oldest data. </p><p id="p0068" num="0068"> With reference to FIG. 5, a block diagram depicting an alternative embodiment of the method for providing deterministic inter-core, inter-process, and inter-thread communication between the reader 15 and the writer 17 is shown. In process block 102, the reader 15 sets the transmit index 24 to identify either the first double buffer 28 or the second double buffer 30. The double buffer 28, 30 identified by the transmit index 24 corresponds to the selected double buffer. The double buffer not identified by the transmit index corresponds to an non-selected double buffer. For example, if the transmit index 24 contains the value zero, the first double buffer 28 may be the selected double buffer and the second double buffer 30 may be the non-selected double buffer. </p><p id="p0069" num="0069">Alternatively, if the transmit index 24 contains the value one, the second double buffer 30 may be the selected double buffer and the first double buffer 28 may be the non-selected double buffer. </p><p id="p0070" num="0070"> In process block 103, the reader 15 or writer 17 sets the shared index 26 to an initial value for the first double buffer 28 and the second double buffer 30. The shared index 26 may identify, for each double buffer, one of the first low level buffer 32, 36, the second low level buffer 34, 38, or the initial value. For example, the shared index 26 may take the form of a two element array, the first element of the array may correspond to the first double buffer 28 and the second element of the array may correspond to the second double buffer 30 (i.e., the shared index 26 may take the form [first double buffer 28, second double buffer 30]). In this example, upon initialization, the shared index 26 may correspond to [0,0]. If, e.g., the shared index 26 corresponds to [2,1 ], then the shared index 26 identifies the second low level buffer 34 for the first double buffer 28 and the first low level buffer 36 for the second double buffer 30. That is, for the shared index 26, a value of one may correspond to the first low level buffer 32, 36 and a value of two may correspond to the second low level buffer 34, 38. </p><p id="p0071" num="0071"> As described above and in further detail in FIG. 7, the shared index 26 may identify the low level buffer of the selected double buffer to which data was 
<!-- EPO <DP n="17"/>-->
 last written. Both the reader 15 and the writer 17 use the shared index 26 to determine which low level buffer of the selected double buffer to respectively read and write data. As the writer 17 writes data to the selected double buffer, the writer 17 may update the shared index 26 to identify the low level buffer of the selected double buffer to which data was written. Thus, if the shared index 26 has a value of zero (i.e., the initial value), then the writer 17 has not written data to the selected double buffer, because, if the writer 17 had written data to the selected double buffer, the shared index 26 would have been updated to identify the low level buffer of the selected double buffer to which data was written. </p><p id="p0072" num="0072"> Returning to FIG. 5, following process block 103, decision blocks 104 and 108 may occur simultaneously. That is, the reader 15 may read data at the same time as the writer 17 writes data. In decision block 104, a check is performed to determine if data is to be written. If data is to be written, then, in process block 106, the writer 17 writes data. For example, the writer 17 may store data in the low level buffer of the selected double buffer that is most convenient. In decision block 108, a check is performed to determine if there data is to be read. If data is to be read, then, in process block 1 10, the reader 15 reads data. </p><p id="p0073" num="0073"> Turning to FIGS. 6a-6c, reading data by the reader 15 is further described. In process block 130, the reader 15 reads the transmit index 24 to identify the selected double buffer. Next, in process block 132, the reader 15 reads the shared index 26 for the selected double buffer. In decision block 134, new data has been written to the selected double buffer if the shared index 26 for the selected double buffer does not correspond to the initial value. If the shared index 26 for the selected double buffer does not correspond to the initial value, the method progresses to process block 140 of FIG. 6b. </p><p id="p0074" num="0074"> With reference to FIG. 6b, in process block 140, the reader 15 initializes the non-selected double buffer, i.e., the reader 15 may set the shared index 26 for the non-selected double buffer to the initial value. In process block 142, the reader 15 updates the transmit index 24 to identify the non-selected double 
<!-- EPO <DP n="18"/>-->
 buffer such that the non-selected double buffer is now the selected double buffer and the selected double buffer is now the non-selected double buffer (i.e., the previously selected double buffer). Thus, the writer 17 will now write data to the newly selected double buffer. </p><p id="p0075" num="0075"> In process block 144, the reader 15 determines if new data has been written to the previously selected double buffer in the time since decision block 132. In process block 144, the reader 15 again reads the shared index 26 for the previously selected double buffer (identifying the low level buffer of the previously selected double buffer to which data was last written). Thus, without step 144, if the writer 17 had written data to the previously selected double buffer during operation of steps 140 and 142, the reader 15 would have incorrectly read the old data stored in the low level buffer identified by the shared index 26 in step 132. However, by again reading the shared index 26 in step 144, the reader 15 will correctly read the last data written by the writer 17 to the </p><p id="p0076" num="0076">previously selected double buffer. </p><p id="p0077" num="0077"> In process block 146, the reader 15 sets the read index 22 for the previously selected double buffer in the shared memory 20 to identify the low level buffer identified by the shared index 26 for the previously selected double buffer. The read index 22, for a given double buffer, indicates the low level buffer identified by the shared index 26 for the given double buffer from which the reader 15 last accessed data. For example, the read index 22 may take the form of a two element array, the first element of the array corresponding to the first double buffer 28 and the second element of the array corresponding to the second double buffer 30 (i.e., the read index 22 may take the form [first double buffer 28, second double buffer 30]). In this example, assuming the reader 15 has not yet read data from the shared memory 20, the read index 22 </p><p id="p0078" num="0078">corresponds to [0,0]. If the reader 15 reads from the second low level buffer 34 of the first double buffer 28, the read index 22 may be updated to correspond to [2,0], indicating, for the first double buffer 28, the reader 15 last read data from the second low level buffer 34. 
<!-- EPO <DP n="19"/>-->
 In the combination of process blocks 148 and 150, the reader 15 accesses and outputs the last data written to the previously selected double buffer. In process block 148, the reader 15 accesses (i.e., reads) the data stored in the low level buffer identified by the shared index 26 of the previously selected double buffer. In process block 150, the reader 15 outputs the data. In process block 152, the reader 15 optionally outputs the status new data. </p><p id="p0079" num="0079"> Turning to FIGs. 6a and 6c, in decision block 134 of FIG. 6a, if the shared index 26 for the selected double buffer corresponds to the initial value, the method progresses to process block 160 of FIG. 6c. In the combination of blocks 160 and 162, the reader 15 determines if old data or new data was written to the non-selected double buffer. In process block 160, the reader 15 reads the shared index 26 for the non-selected double buffer. In decision block 162, the reader 15 determines if the shared index of the non-selected double buffer corresponds to the initial value. The non-selected double buffer does not contain old data or new data if the shared index for the non-selected double buffer corresponds to the initial value. </p><p id="p0080" num="0080"> In decision block 162, if the shared index 26 of the non-selected double buffer corresponds to the initial value, then, in process block 164, the reader 15 outputs no data. In process block 166, the reader 15 optionally outputs the status no data. </p><p id="p0081" num="0081"> Alternatively, in decision block 162, if the shared index 26 of the non- selected double buffer does not correspond to the initial value (indicating data has been written to the non-selected double buffer), the reader 15 determines if old data or new data was written to the non-selected double buffer. Determining if old data or new data was written to the non-selected double buffer includes, in decision block 168, the reader 15 comparing the shared index 26 for the non- selected double buffer and the read index 22 for the non-selected double buffer. The non-selected double buffer contains old data if the shared index 26 for the non-selected double buffer and the read index 22 for the non-selected double buffer correspond to the same low level buffer. That is, because the read index 22 indicates the low level buffer from which the reader 15 last read data and the 
<!-- EPO <DP n="20"/>-->
 shared index 26 indicates the low level buffer from which the writer 17 last wrote data, if the low level buffer that the writer 17 last wrote data to (i.e., the shared index 26) is the same as the low level buffer that the reader 15 last read data from (i.e., the read index 22), then new data has not been written to the non- selected double buffer. Alternatively, if the shared index 26 for the non-selected double buffer and the read index 22 for the non-selected double buffer do not correspond to the same low level buffer, then new data was written to the non- selected double buffer. </p><p id="p0082" num="0082"> In process block 170, if the shared index 26 for the non-selected double buffer and the read index 22 for the non-selected double buffer correspond to the same low level buffer, the reader 15 accesses (i.e., reads) the data stored in the low level buffer identified by the shared index 26 of the non-selected double buffer. In process block 172, the reader 15 outputs the data. In process block 174, the reader 15 optionally outputs the status old data. </p><p id="p0083" num="0083"> In process block 176, if the shared index 26 for the non-selected double buffer and the read index 22 for the non-selected double buffer do not </p><p id="p0084" num="0084">correspond to the same low level buffer, the reader 15 sets the read index 22 for the non-selected double buffer to identify the low level buffer identified by the shared index 26 for the non-selected double buffer. In process block 178, the reader 15 accesses (i.e., reads) the data stored in the low level buffer identified by the shared index 26 of the non-selected double buffer. In process block 180, the reader 15 outputs the data. In process block 182, the reader 15 optionally outputs the status new data. </p><p id="p0085" num="0085"> Turning to FIG. 7, the writer 17 writing data, e.g., to the selected double buffer in process block 106 of FIG. 5 is further described. In process block 190, the writer 17 reads the transmit index 24 to determine the selected double buffer. In process block 192, the writer 17 reads the shared index 26 for the selected double buffer. As described previously, the shared index 26 identifies the low level buffer to which data was last written. In process block 194, the writer 17 determines a next low level buffer for the selected double buffer. The next low level buffer identifies a low level buffer for the selected double buffer to which the 
<!-- EPO <DP n="21"/>-->
 writer 17 will write new data. If the shared index 26 corresponds to the first low level buffer or the second low level buffer, the next low level buffer may correspond to the low level buffer for the selected double buffer not indicated by the shared index 26 for the selected double buffer. If the shared index 26 for the selected double buffer corresponds to the initial value, the next low level buffer may correspond to the first low level buffer for the selected double buffer. In process block 196, the writer 17 stores (i.e., writes) data in the next low level buffer for the selected double buffer. In process block 198, the writer 17 sets the shared index 26 for the selected double buffer to correspond to the next low level buffer. </p><p id="p0086" num="0086"> The following example is provided to demonstrate the operation of FIG. 7. In this example, assume the selected double buffer is the first double buffer 28 and that the writer 17 has written data to the first low level buffer 32 since the reader 15 last read data. Thus, in this example, the transmit index 24 identifies the first double buffer 28 as the selected double buffer and the shared index 26 identifies the first low level buffer 32 of the first double buffer 28. Assuming the writer 17 receives another write instruction, in process blocks 190 and 192, the writer 17 reads the transmit index 24 and shared index 26. Prior to writing data, in process block 194, the writer 17 determines the next low level buffer to which data will be written. In this example, because data was last written to the first low level buffer 32 of the first double buffer 28, the next low level buffer is determined to be the second low level buffer 32 of the first double buffer 28. After writing the data to the next low level buffer in process block 196, the writer 17 sets the shared index 26 for the first double buffer 28 (i.e., the selected double buffer) to correspond to the second low level buffer 32 (i.e., the next low level buffer). </p><p id="p0087" num="0087"> In this example, if further write instructions are received, the writer 17 may alternate writing data between the first low level buffer 32 and the second low level buffer 34 of the selected double buffer (i.e., the first double buffer 28) until the reader 15 begins a read operation. 
<!-- EPO <DP n="22"/>-->
 Turning to FIGs. 6a, 8a, and 8b, in an alternative embodiment, in decision block 134 (FIG. 6a), if the shared index 26 for the selected double buffer does not correspond to the initial value, the method may progress to process block 200 (FIG. 8a). In this embodiment, the reader 15 may have only read access to the shared index 26. Thus, as opposed to the processes described in FIGs. 6b and 6c, following decision block 134, the reader 15 does not set the shared index 26 for either double buffer 28, 30 to the initial value. This may prevent a conflict caused by the reader 15 and writer 17 attempting to write to the shared index 26 at the same time. </p><p id="p0088" num="0088"> In process block 200, the reader 15 reads the shared index 26 for the selected double buffer. In decision block 202, a check is performed to determine if the shared index 26 for the selected double buffer corresponds to the read index 22 for the selected double buffer. If the shared index 26 for the selected double buffer does not correspond to the read index 22 for the selected double buffer, new data has been written to the selected double buffer. If new data has been written to the selected double buffer, the method progresses to process block 204. </p><p id="p0089" num="0089"> In process block 204, the reader 15 updates the transmit index 24 to identify the non-selected double buffer such that the non-selected double buffer is now the selected double buffer and the selected double buffer is now the non- selected double buffer (i.e., the previously selected double buffer). </p><p id="p0090" num="0090"> In process block 206, the reader 15 determines if new data has been written to the previously selected double buffer in the time since decision block 200. In process block 206, the reader 15 again reads the shared index 26 for the previously selected double buffer (identifying the low level buffer of the </p><p id="p0091" num="0091">previously selected double buffer to which data was last written). Thus, without step 206, if the writer 17 had written data to the previously selected double buffer during operation of steps 202 and 204, the reader 15 would have incorrectly read the old data stored in the low level buffer identified by the shared index 26 in step 200. However, by again reading the shared index 26 in step 206, the 
<!-- EPO <DP n="23"/>-->
 reader 15 will correctly read the last data written by the writer 17 to the </p><p id="p0092" num="0092">previously selected double buffer. </p><p id="p0093" num="0093"> In process block 208, the reader 15 sets the read index 22 for the previously selected double buffer in the shared memory 20 to identify the low level buffer identified by the shared index 26 for the previously selected double buffer. As described previously, the read index 22, for a given double buffer, indicates the low level buffer identified by the shared index 26 for the given double buffer from which the reader 15 last accessed data. </p><p id="p0094" num="0094"> In the combination of process blocks 210 and 212, the reader 15 accesses and outputs the last data written to the previously selected double buffer. In process block 210, the reader 15 accesses (i.e., reads) the data stored in the low level buffer identified by the shared index 26 of the previously selected double buffer. In process block 212, the reader 15 outputs the data. In process block 214, the reader 15 optionally outputs the status new data. </p><p id="p0095" num="0095"> Returning to decision block 202, if the shared index 26 for the selected double buffer corresponds to the read index 22 for the selected double buffer, new data has not been written to the selected double buffer. If new data has not been written to the selected double buffer, the method progresses to process block 216 to determine if old data or new data was written to the non-selected double buffer. </p><p id="p0096" num="0096"> Determining if old data or new data was written to the non-selected double buffer includes, in process block 216, the reader 15 reading the shared index 26 for the non-selected double buffer. In decision block 230 (FIG. 8b), the reader 15 compares the shared index 26 for the non-selected double buffer and the read index 22 for the non-selected double buffer. The non-selected double buffer contains old data if the shared index 26 for the non-selected double buffer and the read index 22 for the non-selected double buffer correspond to the same low level buffer. That is, because the read index 22 indicates the low level buffer from which the reader 15 last read data and the shared index 26 indicates the low level buffer from which the writer 17 last wrote data, if the low level buffer that the writer 17 last wrote data to (i.e., the shared index 26) is the same as the 
<!-- EPO <DP n="24"/>-->
 low level buffer that the reader 15 last read data from (i.e., the read index 22), then new data has not been written to the non-selected double buffer. </p><p id="p0097" num="0097">Alternatively, if the shared index 26 for the non-selected double buffer and the read index 22 for the non-selected double buffer do not correspond to the same low level buffer, then new data was written to the non-selected double buffer. </p><p id="p0098" num="0098"> In process block 232, if the shared index 26 for the non-selected double buffer and the read index 22 for the non-selected double buffer correspond to the same low level buffer, the reader 15 accesses (i.e., reads) the data stored in the low level buffer identified by the shared index 26 of the non-selected double buffer. In process block 234, the reader 15 outputs the data. In process block 236, the reader 15 optionally outputs the status old data. </p><p id="p0099" num="0099"> In process block 240, if the shared index 26 for the non-selected double buffer and the read index 22 for the non-selected double buffer do not correspond to the same low level buffer, the reader 15 sets the read index 22 for the non-selected double buffer to identify the low level buffer identified by the shared index 26 for the non-selected double buffer. In process block 242, the reader 15 accesses (i.e., reads) the data stored in the low level buffer identified by the shared index 26 of the non-selected double buffer. In process block 244, the reader 15 outputs the data. In process block 246, the reader 15 optionally outputs the status new data. </p><p id="p0100" num="0100"> Turning to FIG. 9, the writer 17 writing data to the selected double buffer in process block 106 of FIG. 5 is further described. In process block 260, the writer 17 reads the transmit index 24. The value of the transmit index 24 ( Tx) may be an integer between zero and three. In process block 262, to determine the selected double buffer, the writer 17 determines a corrected transmit index 14. The value of the corrected transmit index may be equal to Tx mod 2. The corrected transmit index having a value of zero may correspond to the selected double buffer being the first double buffer 28 and the corrected transmit index 24 having a value of one may correspond to the selected double buffer being the second double buffer 30. 
<!-- EPO <DP n="25"/>-->
 The modulus operator (i.e., mod), e.g., may operate according to the modulus operator in the ADA95 language or the C language. The sign of the output of the modulus operator may be machine-dependent for negative operands. For example, the modulus operator may operate as described in Kernighan Brian, W., and M. Ritchie Dennis, "The C programming language," Second Edition, AT&amp;T Bell laboratories, New Jersey, Prentice Hall (1988), the entire contents of which are incorporated by reference herein. </p><p id="p0101" num="0101"> In process block 264, the writer 17 reads the shared index 26 for the selected double buffer. The value of the shared index 26 (Sx) may be an integer between zero and four. In process block 266, the writer 17 determines a corrected shared index to determine the low level buffer of the selected buffer to which data was last written. The value of the corrected shared index may be equal to ((Sx- 1) mod 2)+ 1. The corrected shared index having a value of zero may correspond to the initial value, the corrected shared index having a value of one may correspond to the first low level buffer, and the corrected shared index having a value of two may correspond to the second low level buffer. </p><p id="p0102" num="0102"> In process block 268, the writer 17 determines a next low level buffer for the selected double buffer. The next low level buffer may be determined such that, if the transmit index 24 equals zero or one, the value of the next low level buffer equals (Sx mod 2)+ 1. If the transmit index 24 equals two or three, the value of the next low level buffer may equal (Sx mod 2)+3. In process block 270, the writer 17 stores (i.e., writes) data in the next low level buffer for the selected double buffer. In process block 272, the writer 17 sets the value of the shared index 26 equal to the value of the next low level buffer. </p><p id="p0103" num="0103"> Although the invention has been shown and described with respect to a certain illustrated embodiment or embodiments, equivalent alterations and modifications will occur to others skilled in the art upon reading and </p><p id="p0104" num="0104">understanding the specification and the annexed drawings. In particular regard to the various functions performed by the above described integers </p><p id="p0105" num="0105">(components, assemblies, devices, compositions, etc.), the terms (including a reference to a "means") used to describe such integers are intended to 
<!-- EPO <DP n="26"/>-->
 correspond, unless otherwise indicated, to any integer which performs the specified function (i.e., that is functionally equivalent), even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated embodiment or embodiments of the invention. 
</p></description><claims mxw-id="PCLM70078340" ref-ucid="WO-2014128288-A1" lang="EN" load-source="patent-office"><claim id="clm-0001" num="0001"><!-- EPO <DP n="27"/>--><claim-text/><claim-text>A method for providing deterministic inter-core, inter-process, and inter-thread communication between a reader and a writer by passing data through shared memory using double buffering of double buffers, the method comprising: </claim-text><claim-text>the reader or writer selecting one of a first double buffer or a second double buffer as a selected double buffer, wherein the writer writes data to the selected double buffer, each double buffer is stored in the shared memory, and each double buffer comprises a first low level buffer and a second low level buffer; </claim-text><claim-text>the reader reading data, wherein reading data comprises: </claim-text><claim-text>the reader determining if new data has been written to the selected double buffer, wherein new data corresponds to data that has not been read by the reader; </claim-text><claim-text>if new data has been written to the selected double buffer: </claim-text><claim-text>the reader selecting the non-selected double buffer as the selected double buffer such that the writer writes data to the newly selected double buffer; </claim-text><claim-text>the reader determining if new data has been written to the previously selected double buffer in the time since the previous check to determine if new data had been written to the previously selected double buffer; </claim-text><claim-text>the reader accessing and outputting the last data written to the previously selected double buffer; </claim-text><claim-text>if new data has not been written to the selected double buffer: the reader determining if old data or new data was written to the non- selected double buffer, wherein old data corresponds to data that the reader has previously read; </claim-text><claim-text>if neither old data nor new data was written to the non- selected double buffer, no data is output by the reader; </claim-text><claim-text>and if old data or new data was written to the non-selected double 
<!-- EPO <DP n="28"/>-->
 buffer, the reader accessing and outputting the last data written to the non- selected double buffer. </claim-text><claim-text>The m ethod of claim 1 , wherein the writer writ ing data to the selected double buffer com prises the writer storing data in the low level buffer of the selected double buffer that is m ost conven ient . </claim-text><claim-text>The m ethod of claim 1 or 2 , wherein the reader reads data at the sam e tim e as the writer writes data to the selected double buffer. </claim-text><claim-text>The m ethod according to any one of claim s 1 to 3 , fu rther com prising the reader outputting a state, wherein : </claim-text><claim-text>the reader outputs a new data state when new data has been written to the selected double buffer; </claim-text><claim-text>the reader outputs the new data state when new data has not been written to the selected double buffer and new data has been written to the non- selected double buffer; </claim-text><claim-text>the reader outputs an old data state when new data has not been written to both the selected double buffer and the non- selected double buffer and the non- selected double buffer contains old data; </claim-text><claim-text>and the reader outputs a no data state when new data has not been written to both the selected double buffer and the non- selected double buffer and the non- selected double buffer does not contain old data. The m ethod to anyone of claim s 1 to 4 , wherein the reader or writer selecting one of the first double buffer or the second double buffer as the selected double buffer com prises: </claim-text><claim-text>the reader setting a transm it index in the shared m em ory to identify the first double buffer or the second double buffer, wherein the double buffer ident ified by the transm it index corresponds to the selected double buffer and the double buffer not identified by the transm it index corresponds to an non- selected double buffer. 
<!-- EPO <DP n="29"/>-->
</claim-text><claim-text>6. The method to anyone of claims 1 to 5, further comprising the reader or writer initializing both double buffers to an initial state prior to the reader reading data. </claim-text><claim-text>The method of claim 6, wherein initializing both double buffers to an initial state comprises: </claim-text><claim-text> the reader or writer setting a shared index in the shared memory to an initial value for the first double buffer and the second double buffer, wherein the shared index identifies one of the first low level buffer, the second low level buffer, or the initial value for each double buffer. </claim-text><claim-text>The method according to anyone of claims 1 to 7, wherein the reader determining if new data has been written to the selected double buffer comprises: </claim-text><claim-text> the reader reading the transmit index to identify the selected double buffer; the reader reading the shared index for the selected double buffer; </claim-text><claim-text> and wherein new data has been written to the selected double buffer if the shared index for the selected double buffer does not correspond to the initial value. </claim-text><claim-text>The method according to anyone of claims 1 to 8, wherein the reader determining if new data has been written to the selected double buffer comprises: </claim-text><claim-text> the reader reading the transmit index to identify the selected double buffer; </claim-text><claim-text> the reader reading the shared index for the selected double buffer; the reader reading a read index for the selected double buffer, wherein the read index for a given double buffer indicates the low level buffer identified by the shared index for the given double buffer from which the reader last accessed data; </claim-text><claim-text> and wherein new data has been written to the selected double buffer if the shared index for the selected double buffer does not correspond to 
<!-- EPO <DP n="30"/>-->
 the read index for the selected double buffer and the shared index for the selected double buffer does not correspond to the initial value. </claim-text><claim-text>10. The method according to anyone of claims 1 to 9, further comprising, if new data has been written to the selected double buffer, the reader initializing the non-selected double buffer before the reader selecting the non-selected double buffer as the selected double buffer. </claim-text><claim-text>11. The method according to anyone of claims 1 to 10, wherein the reader initializing the non- selected double buffer comprises: </claim-text><claim-text> the reader setting the shared index for the non-selected double buffer to the initial value. </claim-text><claim-text>12. The method according to anyone of claims 1 to 11 , wherein the reader selecting the non-selected double buffer as the selected double buffer comprises: </claim-text><claim-text> the reader updating the transmit index to identify the non-selected double buffer such that the non-selected double buffer is now the selected double buffer and the selected double buffer is now the non- selected double buffer. </claim-text><claim-text>13. The method according to anyone of claims 1 to 12, wherein the reader determining if new data has been written to the previously selected double buffer in the time since the previous check comprises: </claim-text><claim-text> the reader reading the shared index for the previously selected double buffer; </claim-text><claim-text> and the reader setting a read index for the previously selected double buffer in the shared memory to identify the low level buffer identified by the shared index for the non-selected double buffer. </claim-text><claim-text>14. The method according to anyone of claims 1 to 13, wherein the reader accessing and outputting the last data written to the previously selected double buffer comprises: 
<!-- EPO <DP n="31"/>-->
 the reader accessing the data stored in the low level buffer identified by the shared index of the previously selected double buffer; </claim-text><claim-text> and the reader outputting the data. </claim-text><claim-text>15. The method according to anyone of claims 1 to 10, wherein determining if old data or new data was written to the non-selected double buffer comprises: </claim-text><claim-text> the reader reading the shared index for the non-selected double buffer; </claim-text><claim-text> and wherein the non-selected double buffer does not contain old data or new data if the shared index for the non-selected double buffer corresponds to the initial value. </claim-text><claim-text>16. The method according to anyone of claims 1 to 15, wherein determining if old data or new data was written to the non-selected double buffer further comprises: </claim-text><claim-text> if the shared index for the non-selected double buffer does not correspond to the initial value: </claim-text><claim-text> the reader comparing the shared index for the non-selected double buffer and the read index for the non-selected double buffer; </claim-text><claim-text> and wherein the non-selected double buffer contains old data if the shared index for the non-selected double buffer and the read index for the non-selected double buffer correspond to the same low level buffer. </claim-text><claim-text>17. The method according to anyone of claims 1 to 16, wherein determining if old data or new data was written to the non-selected double buffer further comprises: </claim-text><claim-text> wherein, if the shared index for the non-selected double buffer and the read index for the non-selected double buffer do not correspond to the same low level buffer: </claim-text><claim-text> new data was written to the non-selected double buffer; </claim-text><claim-text> and the reader setting the read index for the non-selected double 
<!-- EPO <DP n="32"/>-->
 buffer to ident ify the low level buffer ident ified by the shared index for the non- selected double buffer. </claim-text><claim-text>The m ethod of according to anyone of claim s 1 to 1 7 , wherein the reader accessing and outputting the last data written to the non- selected double buffer com prises: </claim-text><claim-text>the reader accessing the data stored in the low level buffer identif ied by the shared index of the non- selected double buffer; </claim-text><claim-text>and the reader outputting the data. </claim-text><claim-text>The m ethod according to anyone of claim s 1 to 1 8, the writer writ ing data to the selected double buffer com prises: </claim-text><claim-text>the writer reading the shared index for the selected double buffer; the writer storing data in a next low level buffer for the selected double buffer, wherein ( 1 ) the next low level buffer corresponds to the low level buffer for the selected double buffer not indicated by the shared index for the selected double buffer if the shared index corresponds to the first low level buffer or the second low level buffer and ( 2) the next low level buffer corresponds to the first low level buffer for the selected double buffer if the shared index for the selected double buffer corresponds to the in itial value; and the writer setting the shared index for the selected double buffer to correspond to the next low level buffer. </claim-text><claim-text>The m ethod according to anyone of claim s 1 to 1 9 , wherein the writer setting the shared index for the selected double buffer to correspond to the next low level buffer com prises: </claim-text><claim-text>reading a value of the transm it index (Tx) , wherein the transm it index value is an integer between zero and th ree; </claim-text><claim-text>determ in ing a corrected transm it index , wherein a value of the corrected transm it index is equal to Tx mod 2 , the corrected transm it index having a value of zero corresponds to the selected double buffer 
<!-- EPO <DP n="33"/>-->
 being the first double buffer, and the corrected transmit index having a value of one corresponds to the selected double buffer being the second double buffer; </claim-text><claim-text> reading a value of the shared index (Sx), wherein the shared index value is an integer between zero and four; </claim-text><claim-text> determining a corrected shared index, wherein a value of the corrected shared index is equal to ((Sx - 1) mod 2) + 1 , the corrected shared index having a value of zero corresponds to the initial value, the corrected shared index having a value of one corresponds to the first low level buffer, and the corrected shared index having a value of two corresponds to the second low level buffer; </claim-text><claim-text> determining a value of the next low level buffer, wherein the value of the next low level buffer equals (Sx mod 2) + 1 if the transmit index equal zero or one and the value of the next low level buffer equals (Sx mod 2) + 3 if the transmit index equal two or three; </claim-text><claim-text> and setting the value of the shared index equal to the value of the next low level buffer. </claim-text><claim-text>21. A computational device comprising a multicore processor and a shared memory, the multicore processor carrying out a method of anyone of claims 1 to 20. </claim-text><claim-text>A non-transitory computer-readable storage medium storing logical instructions thereon that when executed by a processor perform the steps of anyone of the methods of claim 1 to 20. 
</claim-text></claim></claims><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
