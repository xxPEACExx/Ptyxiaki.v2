<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2960787-A1" country="EP" doc-number="2960787" kind="A1" date="20151230" family-id="51062692" file-reference-id="318329" date-produced="20180824" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="160451490" ucid="EP-2960787-A1"><document-id><country>EP</country><doc-number>2960787</doc-number><kind>A1</kind><date>20151230</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-14174845-A" is-representative="YES"><document-id mxw-id="PAPP193865948" load-source="patent-office" format="original"><country>EP</country><doc-number>14174845.9</doc-number><date>20140627</date><lang>EN</lang></document-id><document-id mxw-id="PAPP193865949" load-source="docdb" format="epo"><country>EP</country><doc-number>14174845</doc-number><kind>A</kind><date>20140627</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC162031475" ucid="EP-14174845-A" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>14174845</doc-number><kind>A</kind><date>20140627</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1965249464" load-source="docdb">G06F   1/32        20060101AFI20160223BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-1965253392" load-source="docdb">G06F   9/50        20060101ALI20160223BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1687166231" load-source="docdb" scheme="CPC">Y02D  50/20        20180101 LA20180219BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1687166232" load-source="docdb" scheme="CPC">Y02D  10/22        20180101 LA20180219BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1687166233" load-source="docdb" scheme="CPC">Y02D  10/171       20180101 LA20180219BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1687166234" load-source="docdb" scheme="CPC">Y02D  10/172       20180101 LA20180219BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1687166235" load-source="docdb" scheme="CPC">Y02D  10/126       20180101 LA20180219BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1687166236" load-source="docdb" scheme="CPC">Y02D  10/24        20180101 LA20180219BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1732707381" load-source="docdb" scheme="CPC">G06F   9/5094      20130101 LI20171115BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1732707382" load-source="docdb" scheme="CPC">G06F   1/3296      20130101 LI20171115BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1732707383" load-source="docdb" scheme="CPC">G06F   1/324       20130101 LI20171115BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1732707384" load-source="docdb" scheme="CPC">G06F   1/3228      20130101 LI20171115BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1732707386" load-source="docdb" scheme="CPC">G06F   1/3287      20130101 LI20171115BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1984702530" load-source="docdb" scheme="CPC">G06F   1/329       20130101 LI20151231BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1984703374" load-source="docdb" scheme="CPC">G06F   1/3206      20130101 FI20151231BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT165545936" lang="DE" load-source="patent-office">Verfahren zur Ausführung eines Jobs in einem Computersystem, Ressourcenmanager und Rechnersystem mit großer Leistung</invention-title><invention-title mxw-id="PT165545937" lang="EN" load-source="patent-office">A method of executing an application on a computer system, a resource manager and a high performance computer system</invention-title><invention-title mxw-id="PT165545938" lang="FR" load-source="patent-office">Procédé d'exécution d'une application dans un système informatique, gestionnaire de ressources et système informatique haute performance</invention-title><citations><patent-citations><patcit mxw-id="PCIT335962083" load-source="docdb" ucid="US-20090100437-A1"><document-id format="epo"><country>US</country><doc-number>20090100437</doc-number><kind>A1</kind><date>20090416</date></document-id><sources><source name="APP" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT335962084" load-source="docdb" ucid="US-20120216205-A1"><document-id format="epo"><country>US</country><doc-number>20120216205</doc-number><kind>A1</kind><date>20120823</date></document-id><sources><source name="APP" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT335962085" load-source="docdb" ucid="US-20140089699-A1"><document-id format="epo"><country>US</country><doc-number>20140089699</doc-number><kind>A1</kind><date>20140327</date></document-id><sources><source name="SEA" category="Y" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT335962086" load-source="docdb" ucid="US-8706798-B1"><document-id format="epo"><country>US</country><doc-number>8706798</doc-number><kind>B1</kind><date>20140422</date></document-id><sources><source name="SEA" category="Y" created-by-npl="N"/></sources></patcit></patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR1103313961" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>FUJITSU LTD</last-name><address><country>JP</country></address></addressbook></applicant><applicant mxw-id="PPAR1103305936" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>FUJITSU LIMITED</last-name></addressbook></applicant><applicant mxw-id="PPAR1101652490" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>FUJITSU LIMITED</last-name><iid>100126510</iid><address><street>1-1, Kamikodanaka 4-chome, Nakahara-ku</street><city>Kawasaki-shi, Kanagawa 211-8588</city><country>JP</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR1103325431" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>VAN DEN BERGHE SVEN</last-name><address><country>GB</country></address></addressbook></inventor><inventor mxw-id="PPAR1103340217" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>VAN DEN BERGHE, SVEN</last-name></addressbook></inventor><inventor mxw-id="PPAR1101643400" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>VAN DEN BERGHE, SVEN</last-name><address><street>12 Woodland Close</street><city>Marlow Bucks, SL7 3LE</city><country>GB</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR1101640875" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Stebbing, Timothy Charles</last-name><suffix>et al</suffix><iid>100028668</iid><address><street>Haseltine Lake LLP Lincoln House, 5th Floor 300 High Holborn</street><city>London WC1V 7JH</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS660783567" load-source="docdb">AL</country><country mxw-id="DS660688113" load-source="docdb">AT</country><country mxw-id="DS660783569" load-source="docdb">BE</country><country mxw-id="DS660610710" load-source="docdb">BG</country><country mxw-id="DS660611239" load-source="docdb">CH</country><country mxw-id="DS660685868" load-source="docdb">CY</country><country mxw-id="DS660688114" load-source="docdb">CZ</country><country mxw-id="DS660606664" load-source="docdb">DE</country><country mxw-id="DS660783570" load-source="docdb">DK</country><country mxw-id="DS660685869" load-source="docdb">EE</country><country mxw-id="DS660685345" load-source="docdb">ES</country><country mxw-id="DS660610711" load-source="docdb">FI</country><country mxw-id="DS660610712" load-source="docdb">FR</country><country mxw-id="DS660783571" load-source="docdb">GB</country><country mxw-id="DS660783572" load-source="docdb">GR</country><country mxw-id="DS660783573" load-source="docdb">HR</country><country mxw-id="DS660688143" load-source="docdb">HU</country><country mxw-id="DS660611240" load-source="docdb">IE</country><country mxw-id="DS660783574" load-source="docdb">IS</country><country mxw-id="DS660610713" load-source="docdb">IT</country><country mxw-id="DS660685870" load-source="docdb">LI</country><country mxw-id="DS660606665" load-source="docdb">LT</country><country mxw-id="DS660688144" load-source="docdb">LU</country><country mxw-id="DS660606666" load-source="docdb">LV</country><country mxw-id="DS660606667" load-source="docdb">MC</country><country mxw-id="DS660690985" load-source="docdb">MK</country><country mxw-id="DS660690986" load-source="docdb">MT</country><country mxw-id="DS660610714" load-source="docdb">NL</country><country mxw-id="DS660685346" load-source="docdb">NO</country><country mxw-id="DS660610735" load-source="docdb">PL</country><country mxw-id="DS660685351" load-source="docdb">PT</country><country mxw-id="DS660610736" load-source="docdb">RO</country><country mxw-id="DS660690999" load-source="docdb">RS</country><country mxw-id="DS660610737" load-source="docdb">SE</country><country mxw-id="DS660691000" load-source="docdb">SI</country><country mxw-id="DS660611241" load-source="docdb">SK</country><country mxw-id="DS660611242" load-source="docdb">SM</country><country mxw-id="DS660606669" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA166479860" lang="EN" load-source="patent-office"><p id="pa01" num="0001">In a HPC system, a Resource Manager (100) deliberately introduces heterogeneities to the execution speeds of some, but not all, of the nodes (102) allocated to an application (101) during the application's execution. These heterogeneities may cause changes to the amount of time spent waiting on these coordination points: computation intensive applications will be most affected by these changes, IO bound applications less so. By monitoring wait time reports received from a Communications library (103), the Resource Manager (100) can discriminate between these two types of application and suitable power states can be applied to the nodes (102) allocated to the application. More particularly, if the application (101) is IO bound then all the nodes (102) can be switched to a lower-power state to save energy. This can be applied at any point during application execution so that the hardware configuration can be adjusted to keep optimal efficiency as the application passes through phases with different energy use and performance characteristics.
<img id="iaf01" file="imgaf001.tif" wi="105" he="83" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA166759672" lang="EN" source="EPO" load-source="docdb"><p>In a HPC system, a Resource Manager (100) deliberately introduces heterogeneities to the execution speeds of some, but not all, of the nodes (102) allocated to an application (101) during the application's execution. These heterogeneities may cause changes to the amount of time spent waiting on these coordination points: computation intensive applications will be most affected by these changes, IO bound applications less so. By monitoring wait time reports received from a Communications library (103), the Resource Manager (100) can discriminate between these two types of application and suitable power states can be applied to the nodes (102) allocated to the application. More particularly, if the application (101) is IO bound then all the nodes (102) can be switched to a lower-power state to save energy. This can be applied at any point during application execution so that the hardware configuration can be adjusted to keep optimal efficiency as the application passes through phases with different energy use and performance characteristics.</p></abstract><description mxw-id="PDES98404561" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><u>Field of the Invention</u></heading><p id="p0001" num="0001">The present application relates to energy-aware resource management in a computer system, such as a high-performance computer system (HPC system).</p><heading id="h0002"><u>Background of the Invention</u></heading><p id="p0002" num="0002">The invention addresses energy consumption in computer systems, for example the amount of energy consumed by programs running on large-scale computer clusters, particularly high performance computing (HPC) systems. HPC clusters consist of a large number of quasi-independent computers (nodes) that are coupled together and may be used to execute one large, monolithic application. Applications (or other jobs) are split into a number of communicating tasks; and these tasks are allocated to nodes by a Resource Manager.</p><p id="p0003" num="0003">The Resource Manager is responsible for the efficient running of the HPC system, making sure that resources, including nodes, (and any other resources) deliver a service to requirements. The over-riding service requirement is generally to complete the application as fast as possible but, since the nodes may be high-end computers and use a lot of energy, a secondary requirement, whose importance is rising, is to use as little energy as possible. The compute nodes have a variety of mechanisms that can be used to reduce the energy but these usually come at the cost of computational performance.</p><p id="p0004" num="0004">Increases in the capability of the microprocessors that form the core of the servers result in increased energy use. However, modern microprocessor designs also have the ability to reduce power consumption when the highest performance is not required. This is achieved through a variety of techniques, such as voltage and frequency scaling or turning off unused sections of a microprocessor. This capability is made available through the operating system to the Resource<!-- EPO <DP n="2"> --> Managers so that they can reduce the power consumption of their cluster, but use of this capability must be balanced against the need to maintain performance of the applications executing on the cluster.</p><p id="p0005" num="0005">The overall performance of an application depends on a number of factors. Computational performance is important in many HPC applications, and these are said to be "compute-bound" or CPU-bound. Some applications are dominated by other factors, such as reading and writing data to memory or communicating data between nodes: these are said to be IO (input-output) bound. The performance of compute-bound applications is adversely affected by placing nodes into energy-saving states, but IO bound applications can have their nodes placed into energy saving states with minimal impact on performance. A Resource Manager has no a <i>priori</i> way of knowing if an application under its control is compute-bound or 10-bound and so cannot place any application into energy-saving mode whilst guaranteeing no reduction in performance. Applications may also pass through various phases during their execution and these phases can have different characteristics, one phase might be compute bound, but the following IO bound.</p><p id="p0006" num="0006">Many Resource Managers expose the ability to set the energy saving mode of a job to the user of the HPC cluster. This capability is not however always well used since the users may not be motivated to save energy (unless, for example, they are being charged for energy used in addition to other resources used). Also, users will not want to reduce the execution performance of their applications (i.e. they want to minimise the time to solution). Therefore, it is desirable for Resource Managers to automatically apply energy saving modes where it can be guaranteed that performance will not be affected.</p><p id="p0007" num="0007">The state of the art in such "energy-aware" Resource Managers is represented by US patent applications <patcit id="pcit0001" dnum="US20120216205A"><text>US 20120216205</text></patcit> and <patcit id="pcit0002" dnum="US20090100437A"><text>US 20090100437</text></patcit>. These describe a Resource Manager with a database of the performance characteristics of previously submitted jobs and a computational model of the effect of placing a cluster into energy saving mode on a job with the given performance characteristics. If the Resource Manager can identify a job as the same as one previously submitted, it<!-- EPO <DP n="3"> --> uses the recorded characteristics to compute the best energy configuration that does not impact performance.</p><p id="p0008" num="0008">The problem that these patent applications do not address is that there is no guarantee that a resubmitted job will have the same performance characteristics as the previous submission. Resource Managers cannot know from outside an application what the optimal settings are for energy efficiency. Even though the same application may have been submitted previously, there could have been changes not visible to the Resource Manager that affect the energy use characteristics. These changes include modifications to the code, selection of a different solution algorithm, a different mapping of load to compute nodes, a change to the problem size or a change to enabled options. All of these changes can affect the energy use characteristics of an application and the interaction between configurations and computational performance, so past experience with an application is not a reliable guide to the execution of the current application with the current initialisation files.</p><p id="p0009" num="0009">Therefore, it is desirable to provide energy-aware execution which does not rely on previously submitted jobs.</p><heading id="h0003"><u>Summary of the Invention</u></heading><p id="p0010" num="0010">According to one aspect of the invention there is provided a method of executing an application on a computer system by a plurality of nodes, the application comprising at least one iteration phase and the nodes having a plurality of power states, the method comprising:
<ol><li>a) starting execution of the application with the nodes in a default power state;</li><li>b) monitoring wait times of nodes to determine that execution has reached an iteration phase, and determining an average wait time of the nodes;</li><li>c) for a subset of the nodes, changing the power state;</li><li>d) continuing to monitor wait times and comparing with the wait times determined in the default power state to decide whether the iteration phase is input-output bound or not; and<!-- EPO <DP n="4"> --></li><li>e) if the iteration phase is input-output bound, changing the power state of all the nodes to reduce energy consumption and continuing execution.</li></ol></p><p id="p0011" num="0011">Such a method is most conveniently performed by a means of a Resource Manager as defined below. Such a Resource Manager can monitor progress of the application in each of the nodes by receiving notifications from a communications library, for example, which is accessed by the nodes during execution.</p><p id="p0012" num="0012">Step a) may involve starting execution in a homogeneous execution state. However, some systems are inherently heterogeneous.</p><p id="p0013" num="0013">Steps c) and d) are preferably repeated for each of a plurality of power states, each repetition using a possibly different subset of the nodes.</p><p id="p0014" num="0014">Here, the plurality of power states comprise at least a highest and lowest power state of the nodes; more generally the plurality of power states will comprise each of a plurality of possible power states of the nodes, as defined for example by setting various values of clock frequency, power supply voltage etc. for each node.</p><p id="p0015" num="0015">In any method as defined above, preferably, the size of the subset is determined by observing the effect, on average wait times of nodes, of changing the power state of different numbers of said nodes.</p><p id="p0016" num="0016">Preferably, the wait times are wait times at global barriers of the application. Such "global waits" can be detected, for example, by a communications library which is referred to during execution of the application.</p><p id="p0017" num="0017">In any method as defined above, preferably, step e) comprises changing the power state of the nodes to a power state which produces no detectable change in wait times.</p><p id="p0018" num="0018">In one form of the invention, step e) comprises continuing execution of the application to the end using the changed power state. Alternatively, steps b) to e) are repeated for at least one further iteration phase of execution of the application.<!-- EPO <DP n="5"> --></p><p id="p0019" num="0019">According to a second aspect of the present invention, there is provided a Resource Manager managing nodes of a computer system to execute an application comprising at least one iteration phase, the nodes having a plurality of power states, the Resource Manager comprising:
<ul><li>a scheduling module for allocating respective portions of the application to the nodes;</li><li>a power setting module arranged for setting power states of each of the plurality of nodes;</li><li>a wait time monitoring module for monitoring wait times of nodes and calculate an average wait time; and</li><li>an application type determining module for deciding, based on the average wait time; whether the application is input-output, IO, bound or not; wherein</li><li>the power setting module is arranged to start execution of the application with the nodes in a default power state;</li><li>the wait time monitoring module is arranged to monitor wait times of nodes to determine that execution has reached an iteration phase, and to calculate an average wait time of the nodes;</li><li>the power setting module is responsive to a determination that execution has reached an iteration phase, to change the power state of a subset of the nodes;</li><li>the wait time monitoring module is arranged to continue to monitor wait times and calculate an average wait time in the changed power state;</li><li>the application type determining module is arranged to decide whether the application is IO bound or not by comparing the average wait time in the changed power state with the average wait time determined in the default power state; and</li><li>the power setting module is responsive to a decision that the application is IO bound, to change the power state of all the nodes to reduce energy consumption.</li></ul></p><p id="p0020" num="0020">Preferably the application is executed with the assistance of a communications library and the wait time monitoring module monitors the wait times of nodes by receiving notifications from the communications library.<!-- EPO <DP n="6"> --></p><p id="p0021" num="0021">A further aspect of the present invention provides a high-performance computer system comprising nodes or servers coupled together by an interconnect to form a cluster and a Resource Manager as described above.</p><p id="p0022" num="0022">A still further aspect relates to software for providing the above mentioned Resource Manager. Such software may be stored on one or more non-transitive computer-readable recording media.</p><p id="p0023" num="0023">Large-scale computer systems, such as modern high performance computer (HPC) systems, use large amounts of energy. There is a strong desire to reduce this for cost and social responsibility reasons. The component nodes of HPC clusters have the ability to reduce their energy consumption, but at the cost of reduced performance for some, but not all, types of application. A HPC cluster Resource Manager can save energy while maintaining performance if it can identify those applications that will not lose performance when executed in energy-saving mode.</p><p id="p0024" num="0024">This invention allows the discovery of the most efficient configuration of the hardware for a particular application, one that achieves unchanged performance with the lowest power consumption, whilst the application is executing.</p><p id="p0025" num="0025">Embodiments aim to allow the execution of computer jobs on HPC clusters in an energy saving mode without affecting performance. To do this requires identification of the characteristics of a job submitted to the cluster. The characteristics of HPC jobs are very variable from submission to submission and often vary during the execution of one job. Using prior knowledge of submitted jobs is thus unreliable; the characteristics of every job must be determined individually on submission and ideally during execution.</p><p id="p0026" num="0026">A principle adopted in embodiments is to acquire this information by applying tests to an executing application. The tests should be non-invasive, not changing the execution results and with small impact on the run-time of the application. They should be sensitive, execute quickly and reliably. Tests with these characteristics can be<!-- EPO <DP n="7"> --> applied repeatedly during execution so that the energy use can be fine tuned as the performance characteristics evolve during execution.</p><p id="p0027" num="0027">To this end, embodiments of the present invention deliberately introduce heterogeneities to the execution speeds of some, but not all, of the nodes allocated to an application during the application's execution. As HPC applications require coordination between the nodes, for example to pass data or to globally synchronise computations, these heterogeneities may cause changes to the amount of time spent waiting on these coordination points. Computation intensive applications will be most affected by these changes, IO bound applications less so. This means that the invention can discriminate between these two types of application and so allow the best energy configurations to be set.</p><p id="p0028" num="0028">Having determined whether the application is CPU-bound or IO bound, suitable power states can be applied to the nodes allocated to the application. This can be applied at any point during application execution, so that the hardware configuration can be adjusted to keep optimal efficiency as the application passes through phases with different energy use and performance characteristics.</p><p id="p0029" num="0029">In this specification, the terms "node", "server", "processor", "microprocessor" and "CPU" are used interchangeably unless the context demands otherwise, as are "program", "application" and "job". The terms "run" and "execution" are equivalent. Likewise, the terms "(HPC) system", "cluster" and "server collection" are equivalent.</p><heading id="h0004"><u>Brief Description of the Drawings</u></heading><p id="p0030" num="0030">Reference is made, by way of example only, to the accompanying drawings in which:
<ul><li><figref idrefs="f0001">Figure 1</figref> shows an execution timeline of an application apportioned among a plurality of nodes;</li><li><figref idrefs="f0001">Figure 2</figref> shows an execution timeline of an application with homogenous nodes;</li><li><figref idrefs="f0002">Figure 3</figref> shows an execution timeline of an application with heterogeneous nodes;</li><li><figref idrefs="f0002">Figure 4</figref> shows the effect of applying a perturbation to one of the nodes in <figref idrefs="f0002">Figure 3</figref>;</li><li><figref idrefs="f0003">Figure 5</figref> shows the effect on the execution timeline of slowing all nodes equally;<!-- EPO <DP n="8"> --></li><li><figref idrefs="f0003">Figure 6</figref> is a graph showing a simulation of the effect of introducing heterogeneities to an application;</li><li><figref idrefs="f0004">Figure 7</figref> is a schematic block diagram of a high-performance computing system embodying the present invention;</li><li><figref idrefs="f0004">Figure 8</figref> is a schematic block diagram of functional modules of a Resource Manager;</li><li><figref idrefs="f0005">Figure 9</figref> is a flowchart of steps performed in a method embodying the present invention; and</li><li><figref idrefs="f0006">Figure 10</figref> is a flowchart of steps performed in a modified method embodying the present invention.</li></ul></p><heading id="h0005"><u>Detailed Description</u></heading><p id="p0031" num="0031">As indicated above, embodiments address the problem of reducing the amount of energy consumed by programs running on large-scale computer systems, particularly high performance computing (HPC) systems, in which tasks are allocated to nodes by a Resource Manager.</p><p id="p0032" num="0032">The role of the Resource Manager is to allocate the tasks amongst the nodes so that an appropriate quality of service measure is reached e.g. a group of tasks is completed in the shortest time, or a particular task finishes by a certain time. Resource managers use sophisticated algorithms and heuristics that rely on knowledge of the availability of resources in the HPC system. Resources can include processor time, server memory, network bandwidth or the availability of a software licence. Resource Managers also ensure that the cluster is used as efficiently as possible, and one of the measures of efficiency, particularly for large HPC clusters, is the amount of energy that they use.</p><p id="p0033" num="0033">If Resource Managers can reliably detect the characteristics of the application execution, then more energy saving can be achieved by actively managing power consumption states. This principle will now be explained in more detail with respect to <figref idrefs="f0001 f0002 f0003">Figures 1 to 6</figref> of the drawings.</p><p id="p0034" num="0034">The high-level architecture of HPC systems is a collection of quasi-independent nodes coupled by a communications network. Applications running on HPC systems are<!-- EPO <DP n="9"> --> distributed over the nodes and each portion of the application is decoupled as much as possible from the other portions, although some communication between the nodes is always necessary. Communication leads to the nodes having to coordinate their execution as they wait for the arrival of messages from other nodes. The degree of coordination varies with application and algorithm type, but there are usually many times during an application's execution where nodes will wait on the completion of computations on other nodes. A number of these waits for coordination require global communications (i.e. across all nodes allocated to the application) and so any delays to the execution by one node will cause the whole application to wait for the slowest node to catch up.</p><p id="p0035" num="0035"><figref idrefs="f0001">Figure 1</figref> shows execution phases of a simple program executing on four nodes, with time represented by the length along the horizontal bars. The program has four phases: execute, wait, execute and wait. The wait dependencies are shown as arrows between the nodes. The first wait phase models a local coordination barrier since the nodes only communicate in pairs that is, A with B and C with D. The second wait models a global coordination barrier; every node waits on all the other nodes before completion. This is labelled "Global Wait" in the Figure to indicate that all nodes (in general) must wait here.</p><p id="p0036" num="0036"><figref idrefs="f0001">Figure 2</figref> shows the execution timeline for the program of <figref idrefs="f0001">Figure 1</figref> when the nodes are homogeneous with identical execution times (for example, due to having identical computational ability and comparable portions of the application assigned to them). Since all nodes arrive at the wait phase at the same time, no time is spent waiting and execution of the next phase can commence immediately.</p><p id="p0037" num="0037"><figref idrefs="f0002">Figure 3</figref> shows the execution timeline for heterogeneous nodes, for which the execution time is different for different nodes. Since some nodes now execute faster than other nodes there are periods of waiting (shaded in the Figure), except for the slowest node (B) which becomes the critical path. Node A waits after the first execution phase for its only partner Node B. Similarly Node C waits on Node D. The global wait after the second execute phase causes all the nodes to wait for B to complete.<!-- EPO <DP n="10"> --></p><p id="p0038" num="0038"><figref idrefs="f0002">Figure 4</figref> shows the timeline for the same program with a change to the execution speed on Node C, such as would be introduced by reducing the clock frequency of a CPU bound program. This slowing down of Node C (referred to below as a "perturbation" of Node C, thus creating a "heterogeneity" between Node C and the other nodes) reduces the power consumption by Node C. On the other hand, the execution phases take longer, changing the distribution of wait phases in Node C and D (there is no change to Nodes A and B, as Node B is still the slowest node). The time spent in the global wait phase also changes. However, there is no change to the overall execution time even with the slowing down of one node.</p><p id="p0039" num="0039">Contrast the change to <figref idrefs="f0002">Figure 4</figref> with <figref idrefs="f0003">Figure 5</figref>, which illustrates the effect of slowing all nodes by the same amount. The total time has changed, but the distribution of times spent in each phase on each node is, in proportion, the same. Clearly, the situation in <figref idrefs="f0002">Figure 4</figref> is preferable: less energy consumption with no impact on execution time.</p><p id="p0040" num="0040">Waiting nodes are idle resources and reduce overall computational performance, and so are usually reduced as much as possible. However, they still occur for a number of reasons. Some of these reasons persist throughout an application's execution; these inherent reasons include an imbalance in the load placed on the nodes and differing performance of heterogeneous or impaired nodes. There are also transient reasons ("jitter"), such as interference from other processes, which will have a short-term effect on performance. This means that nodes will always experience some amount of time waiting at barriers for other nodes.</p><p id="p0041" num="0041">By perturbing individual nodes as in the example of <figref idrefs="f0002">Figure 4</figref>, heterogeneities can be created among the nodes. Where the HPC system consists of nodes in the form of independent computers, it is straightforward to change the settings of nodes individually - for example the computer's clock speed could be reduced. Introducing heterogeneities to the node execution time can have a significant impact on the execution time of an application as is shown in <figref idrefs="f0003">Figure 6</figref>.<!-- EPO <DP n="11"> --></p><p id="p0042" num="0042">In <figref idrefs="f0003">Figure 6</figref>, the x-axis represents the proportion of nodes whose computation rate (execution speed) is changed. A proportion of 0.1 corresponds to 10% of the nodes, 0.2 to 20% and so on. Thus, the extreme left-hand end of the graph represents the case of complete homogeneity with all nodes having the same execution speed. The extreme right-hand end of the graph likewise represents homogeneity (100% of the nodes being changed in the same way). At these points, there is a small but finite average global wait time of the nodes as shown on the y-axis.</p><p id="p0043" num="0043">In this simulation, a proportion of the nodes is perturbed to run 10% slower than the other nodes with a random background jitter (that is, an uncertainty in the amount of perturbation applied) of 5%. As can be seen from the Figure, when all nodes execute at the same rate - at either end of the x-axis of <figref idrefs="f0003">Figure 6</figref> - the average wait time at a global barrier is small but similar. If there is a small amount of heterogeneity (a few nodes run slower than the majority), then the average global wait time increases significantly. It will be observed that the largest effect is seen with only a few % of nodes being perturbed. This is a general result which does not depend on a specific HPC system.</p><p id="p0044" num="0044">It should be noted that the nature of the perturbation applied to the nodes is not important, so long as it reduces the execution speed of the nodes concerned. Possible mechanisms include reduction of the clock frequency of the node, reduction of the operating voltage of the node; partial shutdown of computational functions of the node; and sharing resources of the node with another application (since normally, the application can be assumed to have exclusive access to the node). Preferably, the perturbation should not affect the I/O performance of the node.</p><p id="p0045" num="0045">In view of the effect observed above, embodiments of the present invention are based on the following considerations:
<ol><li>(i) Applications are distributed over a large number of nodes which can be controlled (at least with respect to power settings) individually.<!-- EPO <DP n="12"> --></li><li>(ii) The nodes execute their respective portions of the application independently but all non-trivial applications require communication between nodes and so have points where progress is dependent on partner nodes reaching a mutual coordination point (a barrier).</li><li>(iii) Applications typically consist of a number of initialisation and iteration phases, each initialisation phase being followed by an iteration phase. The initialisation phases may be relatively short: perhaps less than 5% of the total execution time.</li><li>(iv) The rate of progress through a computation can vary from node to node, due for example, to imbalances in the load on a node, interference from other code executing on the node and differing node capabilities. This results in some nodes waiting for other nodes waiting at barriers.</li><li>(v) The average time spent in waiting at a global barrier is significantly affected by heterogeneity in execution rate of a small number of nodes.</li><li>(vi) Energy saving features on the node hardware affect the rate of progress through a computation if the application is CPU bound. This effect is significantly less for IO bound code.</li></ol></p><p id="p0046" num="0046">These factors mean that it is possible to discriminate between CPU bound and IO bound applications by changing the energy saving feature settings on a small number of nodes, and monitoring average wait times at global barriers. If they change significantly from an unperturbed (homogeneous) system, then the application is CPU bound, if they do not change, then the application is IO bound.</p><p id="p0047" num="0047">Once this discrimination is made, IO bound applications can have the executing nodes placed into reduced power consumption modes, resulting in energy savings with no reduction in performance. For the remainder of execution of the current job, therefore (perhaps 80% of the total run time), the application can be executed with the optimal settings applied to all the nodes. This allows significant energy savings without having to refer to a history of previously-submitted jobs as in the prior art.<!-- EPO <DP n="13"> --></p><p id="p0048" num="0048">Bringing these observations together, the proposed process can be outlined as follows:
<ol><li>(a) Upon initial execution of a job, the Resource Manager schedules and allocates resources to the job as normal.</li><li>(b) The job is run using the default energy configuration until it reaches a stable execution point, i.e. it has finished initialisation and is into an iteration part. The application is monitored and the average wait time at a global barrier is determined (the average is taken over the nodes allocated to the application and, possibly over several instances of reaching the barrier).</li><li>(c) The Resource Manager modifies the energy configuration of some of the nodes allocated to the application to new values, for example one that trades performance for energy saving. Modifying the energy configuration can be achieved by any one or more of reducing the node's clock speed, operating voltage, activated computational functions, or exclusivity to the application, as mentioned above. Below, this energy configuration is also referred to as a "power state".</li><li>(d) The Resource Manager observes the effect of these changes on the execution characteristics of the job; particularly monitoring changes to wait times at the global barriers used in Step (b).</li><li>(e) After a short period of monitoring, the Resource Manager analyses the data and determines from these the type of application (CPU or IO bound). This short period could be quantified, for example, as a few percent of the expected overall execution time. The expected overall execution time is usually provided by the user (so that the Resource Manager knows how long resources have to be allocated to the job). Alternatively, it would be possible to wait for a suitable proportion (such as one-quarter or one-half) of the time spent in the initialisation phase.<!-- EPO <DP n="14"> --></li><li>(f) Knowing the application's characteristics, the Resource Manager then sets the best configuration for the job, and uses it for the remainder of the job execution. That is, the application is found to be IO-bound then the Resource Manager applies a reduced energy configuration to all the nodes executing the application. By contrast, if the application is determined to be CPU-bound then the Resource Manager restores all nodes to a default configuration (normally the highest-power setting for each node).</li></ol></p><p id="p0049" num="0049">Thus, the present invention does not aim to detect the optimum power state for each node individually, but rather aims to find a global setting which reduces energy use with little or no impact on execution time.</p><p id="p0050" num="0050"><figref idrefs="f0004">Figure 7</figref> is a schematic of a HPC system for implementing the invention, consisting of components 100, 102, 103 as explained below for executing an application 101. The Resource Manager 100 controls the HPC system, allocating applications to nodes and applying settings (such as clock speed, operating voltage etc. as discussed above) to the hardware. Applying power settings may be done with co-operation of a local operating system (not shown) of each of the nodes.</p><p id="p0051" num="0051">For the purposes of this discussion, it is assumed that a single application 101 is allocated to run on a number of nodes 102. The application needs to communicate data between the nodes, and to do this it uses a communication library 103. Communications libraries implement a standardised interface, such as MPI, and are supplied as a standard component of the support software for all HPC systems. They interface between the application code and the communications hardware to provide optimal performance.</p><p id="p0052" num="0052">Some of the interactions between these components are highlighted in the lines drawn between them. The Resource Manager allocates nodes to the execution of the application (104, 105). The executing application calls routines in the Communications Library to communicate data and to coordinate waits at barriers (106). The Resource Manager also applies settings to the nodes to control energy use and performance (107). To monitor the wait times as outlined earlier, the Resource Manager needs to know whether nodes are in an execute phase or a wait phase. For this purpose, a new<!-- EPO <DP n="15"> --> interaction (108) is introduced to communicate information from the Application to the Resource Manager via the Communications Library. This interaction is described below.</p><p id="p0053" num="0053">Functional modules of the Resource Manager 100 are shown schematically in <figref idrefs="f0004">Figure 8</figref>. In addition to a scheduler 100a for allocating portions of the application execution (job) to each node, there is a power setting module 100b capable of issuing commands to individual nodes to change their energy configurations. As indicated in the Figure, the modules 100a and 100b are connected to the nodes 102 to supply commands thereto. A wait time monitor 100c is connected to the communications library 103 to receive wait time reports as indicated at 108 in <figref idrefs="f0004">Figure 7</figref>, and calculating average wait times. Since barrier waits are produced by calls to specific functions in the library, this is a convenient way to detect when nodes are waiting. An application type determining module 100d decides, based on comparing average wait times of nodes with or without perturbations as discussed above, whether the application (at least in the present phase) is IO-bound or not.</p><p id="p0054" num="0054"><figref idrefs="f0005">Figure 9</figref> shows the flow of execution from a job being allocated to a set of nodes, through determination of the characteristics and setting of the best configuration for the remainder of the execution.</p><p id="p0055" num="0055">At 200 a job is allocated to a set of nodes on the computer, and these nodes are set to default configuration. Here, "default configuration" means a configuration which would be adopted in the absence of energy-saving measures such as those of the present invention. In the case of identical nodes executing similar portions of the application, this would correspond to the homogeneous execution case of <figref idrefs="f0001">Figure 2</figref>. However, as will be appreciated, the HPC system may comprise heterogeneous nodes, and/or the application portions assigned to respective nodes may differ in the amount of computational effort involved.</p><p id="p0056" num="0056">The Resource Manager receives reports from the job (via the communications library, 103) about the wait times of each node at the global barriers (201).<!-- EPO <DP n="16"> --></p><p id="p0057" num="0057">At some point (202, "Yes") these wait times will stabilise, i.e. there is a repeating pattern of waits with similar durations. This indicates that the job has reached the main section (in other words, an iteration phase) of execution.</p><p id="p0058" num="0058">The Resource Manager then introduces heterogeneities (203) to the execution rate of a subset of the nodes allocated to the job. Here, the "subset" means a smaller number of nodes than the set to which the job was allocated. The number of nodes in the subset is determined along the lines depicted in <figref idrefs="f0003">Figure 6</figref>: that is, a proportion of nodes provoking the strongest response. As indicated by <figref idrefs="f0003">Figure 6</figref> this might be 1 or 2% of the nodes, for example. The heterogeneities are introduced randomly (in other words, the subset is a random subset of the full set of nodes).</p><p id="p0059" num="0059">The Resource Manager continues monitoring the wait times (204) and compares the new average time to the average times determined for homogeneous execution (from 201). This comparison allows discrimination between CPU bound and IO bound execution (205). As described below, there may be a number of possible power consumption states to test; each one can be tested in turn (206). Once all possible configurations have been examined, the optimal setting (power state) is applied to all the nodes (207) and the job executed to completion. That is, the settings determined by introducing homogeneities to individual nodes are applied equally to the whole set of nodes executing the application.</p><p id="p0060" num="0060">There are usually a number of different power consumption states for the nodes, each reducing the power consumption but having lower performance. It can generally be assumed that if there are N power states called S<sub>1</sub>, S<sub>2</sub>, S<sub>3</sub>, ..., S<sub>N</sub>, then their power consumption P is ordered: <maths id="math0001" num=""><math display="block"><msub><mi mathvariant="normal">P</mi><mn mathvariant="normal">1</mn></msub><mo>&gt;</mo><msub><mi mathvariant="normal">P</mi><mn mathvariant="normal">2</mn></msub><mo>&gt;</mo><msub><mi mathvariant="normal">P</mi><mn mathvariant="normal">3</mn></msub><mo>&gt;</mo><mo>…</mo><mo>&gt;</mo><msub><mi mathvariant="normal">P</mi><mi mathvariant="normal">N</mi></msub></math><img id="ib0001" file="imgb0001.tif" wi="45" he="9" img-content="math" img-format="tif"/></maths><br/>
and the rate of execution R is ordered: <maths id="math0002" num=""><math display="block"><msub><mi mathvariant="normal">R</mi><mn mathvariant="normal">1</mn></msub><mo>&gt;</mo><msub><mi mathvariant="normal">R</mi><mn mathvariant="normal">2</mn></msub><mo>&gt;</mo><msub><mi mathvariant="normal">R</mi><mn mathvariant="normal">3</mn></msub><mo>&gt;</mo><mo>…</mo><mo>&gt;</mo><msub><mi mathvariant="normal">R</mi><mi mathvariant="normal">N</mi></msub><mn>.</mn></math><img id="ib0002" file="imgb0002.tif" wi="47" he="10" img-content="math" img-format="tif"/></maths><!-- EPO <DP n="17"> --></p><p id="p0061" num="0061">All the nodes are initially (at 200) set to S<sub>1</sub>, the highest-power (and thus highest-performance) setting. The first introduction of heterogeneity, at 203, sets the power states of some of the nodes (the "subset" referred to above) to S<sub>N</sub>. Setting these nodes immediately to S<sub>N</sub> (rather than to some intermediate power level) is the quickest way to reveal an IO bound application.</p><p id="p0062" num="0062">If an IO bound application is detected at 205 (no change to wait times), then 206 passes through the no branch to 207 where S<sub>N</sub> is applied to all the nodes and execution completed (208). If, however, a CPU bound application is suspected (change to wait times), the nodes in state S<sub>N</sub> are set to S<sub>N-1</sub> (for example) at 203 and the monitor, discriminate loop - steps 203 to 206 - executed again, using a different subset of randomly-selected nodes. Incidentally, in this step it would be possible to set the power state using a binary search, so that the next step tested is half way between the lowest value that shows no difference from S<sub>1</sub>, and the highest tested so far.</p><p id="p0063" num="0063">The monitor, discriminate loop continues until no change to wait time is detected. If all states S<sub>1</sub>,S<sub>2</sub>,S<sub>3</sub>,...,S<sub>N</sub> have been tested without any IO bound having been detected, then the homogeneous state is all nodes at S<sub>1</sub> (corresponding to no energy-saving and no change to the default configuration), otherwise it is the value of S which produced no detectable change to the global wait times.</p><p id="p0064" num="0064">In the above process, it is possible to use only a subset of the states; for example, rather than examine all the values of S, just S<sub>1</sub> and S<sub>N</sub> can be used. This approach may lead to some jobs being executed at higher power consumption, but with quicker selection of the final homogeneous state.</p><p id="p0065" num="0065"><figref idrefs="f0003">Figure 6</figref> shows that only a very small proportion of nodes should have a perturbed execution rate: between 1% and 5%, so the size of the subset considered above should be small. The proportion of nodes to be perturbed will be independent of any specific HPC system, so a general value can be chosen. Preferably, the size of the subset should be the same at each test (repetition of the monitor, discriminate loop) so as to discriminate an IO bound application from a response that is too small. However,<!-- EPO <DP n="18"> --> where an IO bound application is suspected, it may help to increase the size of the subset to confirm that the subset size is large enough.</p><p id="p0066" num="0066">Although it was described above to apply the method of the invention early on in execution of the application and to apply the determined setting for the remainder of the execution, it is possible to apply the method again at any point during application execution, so that the hardware configuration can be adjusted to keep optimal efficiency as the application passes through phases with different energy use and performance characteristics.</p><p id="p0067" num="0067">That is, an HPC application often passes through several different phases in its computation, where each phase may have different memory and CPU use characteristics and as the application passes through these phases the optimal power use configuration may change.</p><p id="p0068" num="0068"><figref idrefs="f0006">Figure 10</figref> shows, as a modified method embodying the present invention, how the flow of <figref idrefs="f0005">Figure 9</figref> can be extended to monitor execution and adjust power consumption configurations to adapt to changes in program phase. Steps 300 to 306 correspond to <figref idrefs="f0005">Figure 9</figref>'s steps 200 to 206, respectively. Once an optimal configuration has been found and the job's nodes homogenized to this (step 307), execution proceeds in step 308, but the Resource Manager monitors the wait times (309) for a change of phase (310). If one is detected, then the testing loop is re-entered at 303 and a new configuration determined.</p><p id="p0069" num="0069">Various modifications are possible within the scope of the invention.</p><p id="p0070" num="0070">In the above description, it was assumed that the Resource Manager modifies the energy configuration of some of the nodes in order to reduce their performance. However, this is not the only possible arrangement. It would be possible (if allowed by the node hardware) to temporarily boost the performance of individual nodes so as to expend more energy in the nodes in a critical path (those nodes with a large computational load and for which the other nodes have to wait). This would reduce the total energy expended by reducing the overall time spent to execute the application. In<!-- EPO <DP n="19"> --> the method of <figref idrefs="f0005">Figures 9</figref> and <figref idrefs="f0006">10</figref>, this would necessitate starting the nodes in a power state below the highest possible state S1.</p><p id="p0071" num="0071">Although the Resource Manager 100 is shown in <figref idrefs="f0004">Figure 7</figref> as a single functional unit distinct from the nodes 102, it would be possible for the Resource Manager to be distributed among a plurality of functional units, and/or implemented on one or more of the nodes.</p><p id="p0072" num="0072">In the discussion above, N power consumption states were assumed; however, the present invention can be applied with as few as two possible power states of each node.</p><p id="p0073" num="0073">The method steps referred to herein may be carried out in a different order from the order of definition and still produce favourable results.</p><p id="p0074" num="0074">The Resource Manager may be implemented in software, hardware, middleware, as an application specific integrated circuit (ASIC) or in any other form.</p><heading id="h0006"><u>Industrial Applicability</u></heading><p id="p0075" num="0075">This invention allows the discovery of the most efficient configuration of the hardware for a particular application, one that achieves unchanged performance with the lowest power consumption, whilst the application is executing, thereby reducing energy consumption in high-performance computing without necessarily prolonging execution time.</p></description><claims mxw-id="PCLM90459501" lang="EN" load-source="patent-office"><!-- EPO <DP n="20"> --><claim id="c-en-0001" num="0001"><claim-text>A method of executing an application on a computer system by a plurality of nodes, the application comprising at least one iteration phase and the nodes having a plurality of power states, the method comprising:
<claim-text>a) starting execution of the application with the nodes in a default power state;</claim-text>
<claim-text>b) monitoring wait times of nodes to determine that execution has reached an iteration phase, and determining an average wait time of the nodes;</claim-text>
<claim-text>c) for a subset of the nodes, changing the power state;</claim-text>
<claim-text>d) continuing to monitor wait times and comparing with the wait times determined in the default power state to decide whether the iteration phase is input-output bound or not; and</claim-text>
<claim-text>e) if the iteration phase is input-output bound, changing the power state of all the nodes to reduce energy consumption and continuing execution.</claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The method according to claim 1 wherein steps c) and d) are repeated for each of a plurality of power states, each repetition using a possibly different subset of the nodes.</claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The method according to claim 2 wherein the plurality of power states comprise at least a highest and lowest power state of the nodes.</claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The method according to claim 2 wherein the plurality of power states are each of a plurality of possible power states of the nodes.</claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The method according to any preceding claim wherein the size of the subset is determined by observing the effect, on average wait times of nodes, of changing the power state of different numbers of said nodes.</claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The method according to any preceding claim wherein the wait times are wait times at global barriers of the application.<!-- EPO <DP n="21"> --></claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>The method according to any preceding claim wherein step e) comprises changing the power state of the nodes to a power state which produces no detectable change in wait times.</claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>The method according to any preceding claim wherein step e) comprises continuing execution of the application to the end using the changed power state.</claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>The method according to any of claims 1 to 7 further comprising repeating steps b) to e) for at least one further iteration phase of execution of the application.</claim-text></claim><claim id="c-en-0010" num="0010"><claim-text>A Resource Manager (100) managing nodes of a computer system to execute an application comprising at least one iteration phase, the nodes having a plurality of power states, the Resource Manager comprising:
<claim-text>a scheduling module (100a) for allocating respective portions of the application to the nodes;</claim-text>
<claim-text>a power setting module (100b) arranged for setting power states of each of the plurality of nodes;</claim-text>
<claim-text>a wait time monitoring module (100c) for monitoring wait times of nodes (102) and calculate an average wait time; and</claim-text>
<claim-text>an application type determining module (100d) for deciding, based on the average wait time; whether the application is IO bound or not; wherein</claim-text>
<claim-text>the power setting module (100b) is arranged to start execution of the application with the nodes in a default power state;</claim-text>
<claim-text>the wait time monitoring module (100c) is arranged to monitor wait times of nodes to determine that execution has reached an iteration phase, and to calculate an average wait time of the nodes;</claim-text>
<claim-text>the power setting module (100b) is responsive to a determination that execution has reached an iteration phase, to change the power state of a subset of the nodes;</claim-text>
<claim-text>the wait time monitoring module (100c) is arranged to continue to monitor wait times and calculate an average wait time in the changed power state;</claim-text>
<claim-text>the application type determining module (100d) is arranged to decide whether the application is IO bound or not by comparing the average wait time in the changed power state with the average wait time determined in the default power state; and<!-- EPO <DP n="22"> --></claim-text>
<claim-text>the power setting module (100b) is responsive to a decision that the application is IO bound, to change the power state of all the nodes to reduce energy consumption.</claim-text></claim-text></claim><claim id="c-en-0011" num="0011"><claim-text>The Resource Manager according to claim 10, wherein the application is executed with the assistance of a communications library (103) and the wait time monitoring module (100c) monitors the wait times of nodes (102) by receiving notifications from the communications library (103).</claim-text></claim><claim id="c-en-0012" num="0012"><claim-text>A high performance computing system comprising:
<claim-text>a plurality of interconnected nodes (102); and</claim-text>
<claim-text>the Resource Manager according to claim 10 or 11.</claim-text></claim-text></claim><claim id="c-en-0013" num="0013"><claim-text>Software which, when executed by a processor of a computer, provides the Resource Manager according to claim 10 or 11.</claim-text></claim></claims><amended-claims mxw-id="PCLM90459500" lang="EN" load-source="patent-office" amended-claim-type="EPC"><heading id="h0007">Amended claims in accordance with Rule 137(2) EPC.</heading><claim id="ac-en-0001" num="0001"><claim-text>A method of executing a single application on a computer system by a plurality of nodes, the application comprising at least one iteration phase as a main section of execution of the application and the nodes having a plurality of power states, the method comprising:
<claim-text>a) starting execution of the application with the nodes in a default power state;</claim-text>
<claim-text>b) monitoring wait times of nodes which are waiting on completion of computations in other nodes, to determine that execution has reached an iteration phase, and determining an average wait time of the nodes;</claim-text>
<claim-text>c) for a subset of the nodes, changing the power state;</claim-text>
<claim-text>d) after changing the power state for the subset of nodes, continuing to monitor wait times and comparing with the wait times determined in the default power state to decide whether the iteration phase is input-output bound or not; and</claim-text>
<claim-text>e) if the iteration phase is input-output bound, changing the power state of all the nodes to reduce energy consumption and continuing execution.</claim-text></claim-text></claim><claim id="ac-en-0002" num="0002"><claim-text>The method according to claim 1 wherein steps c) and d) are repeated for each of a plurality of power states, each repetition using a possibly different subset of the nodes.</claim-text></claim><claim id="ac-en-0003" num="0003"><claim-text>The method according to claim 2 wherein the plurality of power states comprise at least a highest and lowest power state of the nodes.</claim-text></claim><claim id="ac-en-0004" num="0004"><claim-text>The method according to claim 2 wherein the plurality of power states are each of a plurality of possible power states of the nodes.</claim-text></claim><claim id="ac-en-0005" num="0005"><claim-text>The method according to any preceding claim wherein the size of the subset is determined by observing the effect, on average wait times of nodes, of changing the power state of different numbers of said nodes.</claim-text></claim><claim id="ac-en-0006" num="0006"><claim-text>The method according to any preceding claim wherein the wait times are wait times at global barriers of the application.</claim-text></claim><claim id="ac-en-0007" num="0007"><claim-text>The method according to any preceding claim wherein step e) comprises changing the power state of the nodes to a power state which produces no detectable change in wait times.</claim-text></claim><claim id="ac-en-0008" num="0008"><claim-text>The method according to any preceding claim wherein step e) comprises continuing execution of the application to the end using the changed power state.</claim-text></claim><claim id="ac-en-0009" num="0009"><claim-text>The method according to any of claims 1 to 7 further comprising repeating steps b) to e) for at least one further iteration phase of execution of the application.</claim-text></claim><claim id="ac-en-0010" num="0010"><claim-text>A Resource Manager (100) managing nodes of a computer system to execute a single application comprising at least one iteration phase as a main section of execution of the application, the nodes having a plurality of power states, the Resource Manager comprising:
<claim-text>a scheduling module (100a) for allocating respective portions of the application to the nodes;</claim-text>
<claim-text>a power setting module (100b) arranged for setting power states of each of the plurality of nodes;</claim-text>
<claim-text>a wait time monitoring module (100c) for monitoring wait times of nodes (102) which are waiting on completion of computations in other nodes, and calculate an average wait time; and</claim-text>
<claim-text>an application type determining module (100d) for deciding, based on the average wait time; whether the application is IO bound or not; wherein</claim-text>
<claim-text>the power setting module (100b) is arranged to start execution of the application with the nodes in a default power state;</claim-text>
<claim-text>the wait time monitoring module (100c) is arranged to monitor wait times of nodes to determine that execution has reached an iteration phase, and to calculate an average wait time of the nodes;</claim-text>
<claim-text>the power setting module (100b) is responsive to a determination that execution has reached an iteration phase, to change the power state of a subset of the nodes;</claim-text>
<claim-text>the wait time monitoring module (100c) is arranged, after the power setting module (100b) has changed the power state for the subset of nodes, to continue to monitor wait times and calculate an average wait time in the changed power state;</claim-text>
<claim-text>the application type determining module (100d) is arranged to decide whether the application is IO bound or not by comparing the average wait time in the changed power state with the average wait time determined in the default power state; and</claim-text>
<claim-text>the power setting module (100b) is responsive to a decision that the application is IO bound, to change the power state of all the nodes to reduce energy consumption.</claim-text></claim-text></claim><claim id="ac-en-0011" num="0011"><claim-text>The Resource Manager according to claim 10, wherein the application is executed with the assistance of a communications library (103) and the wait time monitoring module (100c) monitors the wait times of nodes (102) by receiving notifications from the communications library (103).</claim-text></claim><claim id="ac-en-0012" num="0012"><claim-text>A high performance computing system comprising:
<claim-text>a plurality of interconnected nodes (102); and</claim-text>
<claim-text>the Resource Manager according to claim 10 or 11.</claim-text></claim-text></claim><claim id="ac-en-0013" num="0013"><claim-text>Software which, when executed by a processor of a computer, provides the Resource Manager according to claim 10 or 11.</claim-text></claim></amended-claims><drawings mxw-id="PDW20422224" load-source="patent-office"><!-- EPO <DP n="23"> --><figure id="f0001" num="1,2"><img id="if0001" file="imgf0001.tif" wi="165" he="194" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="24"> --><figure id="f0002" num="3,4"><img id="if0002" file="imgf0002.tif" wi="145" he="224" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="25"> --><figure id="f0003" num="5,6"><img id="if0003" file="imgf0003.tif" wi="162" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="26"> --><figure id="f0004" num="7,8"><img id="if0004" file="imgf0004.tif" wi="165" he="216" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="27"> --><figure id="f0005" num="9"><img id="if0005" file="imgf0005.tif" wi="165" he="216" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="28"> --><figure id="f0006" num="10"><img id="if0006" file="imgf0006.tif" wi="165" he="216" img-content="drawing" img-format="tif"/></figure></drawings><search-report-data><doc-page id="srep0001" file="srep0001.tif" wi="159" he="233" type="tif"/><doc-page id="srep0002" file="srep0002.tif" wi="159" he="233" type="tif"/></search-report-data><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
