<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2960798-A1" country="EP" doc-number="2960798" kind="A1" date="20151230" family-id="51033004" file-reference-id="318329" date-produced="20180824" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="160451479" ucid="EP-2960798-A1"><document-id><country>EP</country><doc-number>2960798</doc-number><kind>A1</kind><date>20151230</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-14174765-A" is-representative="YES"><document-id mxw-id="PAPP193865926" load-source="docdb" format="epo"><country>EP</country><doc-number>14174765</doc-number><kind>A</kind><date>20140627</date><lang>EN</lang></document-id><document-id mxw-id="PAPP193865927" load-source="patent-office" format="original"><country>EP</country><doc-number>14174765.9</doc-number><date>20140627</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC162032656" ucid="EP-14174765-A" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>14174765</doc-number><kind>A</kind><date>20140627</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1988524820" load-source="docdb">G06F  11/36        20060101AFI20141215BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1987772585" load-source="docdb" scheme="CPC">G06F  11/3664      20130101 LI20141209BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987786463" load-source="docdb" scheme="CPC">G06F  11/3636      20130101 FI20141209BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT165545903" lang="DE" load-source="patent-office">Automatische Speicherleckdetektion</invention-title><invention-title mxw-id="PT165545904" lang="EN" load-source="patent-office">Automatic memory leak detection</invention-title><invention-title mxw-id="PT165545905" lang="FR" load-source="patent-office">Détection de fuite de mémoire automatique</invention-title><citations><patent-citations><patcit mxw-id="PCIT335962078" load-source="docdb" ucid="US-20130054925-A1"><document-id format="epo"><country>US</country><doc-number>20130054925</doc-number><kind>A1</kind><date>20130228</date></document-id><sources><source name="SEA" category="I" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT335962077" load-source="docdb" ucid="WO-1993003435-A1"><document-id format="epo"><country>WO</country><doc-number>1993003435</doc-number><kind>A1</kind><date>19930218</date></document-id><sources><source name="SEA" category="A" created-by-npl="N"/></sources></patcit></patent-citations><non-patent-citations><nplcit><text>HASTINGS R ET AL: "PURIFY: FAST DETECTION OF MEMORY LEAKS AND ACCESS ERRORS", PROCEEDINGS OF THE WINTER USENIX CONFERENCE, XX, XX, 20 January 1992 (1992-01-20), pages 125 - 136, XP000619456</text><sources><source mxw-id="PNPL59204937" load-source="docdb" name="SEA" category="A"/></sources></nplcit><nplcit><text>None</text><sources><source mxw-id="PNPL57937302" load-source="docdb" name="APP"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR1103325400" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>SAP SE</last-name><address><country>DE</country></address></addressbook></applicant><applicant mxw-id="PPAR1103316836" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>SAP SE</last-name></addressbook></applicant><applicant mxw-id="PPAR1101640994" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>SAP SE</last-name><iid>101471558</iid><address><street>Dietmar-Hopp-Allee 16</street><city>69190 Walldorf</city><country>DE</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR1103311422" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>LIU YINGQIAO</last-name><address><country>DE</country></address></addressbook></inventor><inventor mxw-id="PPAR1103342657" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>Liu, Yingqiao</last-name></addressbook></inventor><inventor mxw-id="PPAR1101640793" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Liu, Yingqiao</last-name><address><street>c/o SAP AG Dietmar-Hopp-Allee 16</street><city>69190 Walldorf</city><country>DE</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR1101648320" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Richardt Patentanwälte</last-name><iid>101226098</iid><address><street>Wilhelmstraße 7</street><city>65185 Wiesbaden</city><country>DE</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS660783513" load-source="docdb">AL</country><country mxw-id="DS660687966" load-source="docdb">AT</country><country mxw-id="DS660606607" load-source="docdb">BE</country><country mxw-id="DS660611106" load-source="docdb">BG</country><country mxw-id="DS660610611" load-source="docdb">CH</country><country mxw-id="DS660606608" load-source="docdb">CY</country><country mxw-id="DS660687971" load-source="docdb">CZ</country><country mxw-id="DS660783515" load-source="docdb">DE</country><country mxw-id="DS660606609" load-source="docdb">DK</country><country mxw-id="DS660606610" load-source="docdb">EE</country><country mxw-id="DS660690785" load-source="docdb">ES</country><country mxw-id="DS660611111" load-source="docdb">FI</country><country mxw-id="DS660610612" load-source="docdb">FR</country><country mxw-id="DS660783516" load-source="docdb">GB</country><country mxw-id="DS660606611" load-source="docdb">GR</country><country mxw-id="DS660783517" load-source="docdb">HR</country><country mxw-id="DS660687972" load-source="docdb">HU</country><country mxw-id="DS660610613" load-source="docdb">IE</country><country mxw-id="DS660606612" load-source="docdb">IS</country><country mxw-id="DS660611112" load-source="docdb">IT</country><country mxw-id="DS660606613" load-source="docdb">LI</country><country mxw-id="DS660611113" load-source="docdb">LT</country><country mxw-id="DS660685648" load-source="docdb">LU</country><country mxw-id="DS660611114" load-source="docdb">LV</country><country mxw-id="DS660611119" load-source="docdb">MC</country><country mxw-id="DS660685649" load-source="docdb">MK</country><country mxw-id="DS660685650" load-source="docdb">MT</country><country mxw-id="DS660690786" load-source="docdb">NL</country><country mxw-id="DS660685239" load-source="docdb">NO</country><country mxw-id="DS660690791" load-source="docdb">PL</country><country mxw-id="DS660611120" load-source="docdb">PT</country><country mxw-id="DS660687973" load-source="docdb">RO</country><country mxw-id="DS660611121" load-source="docdb">RS</country><country mxw-id="DS660690792" load-source="docdb">SE</country><country mxw-id="DS660610614" load-source="docdb">SI</country><country mxw-id="DS660685240" load-source="docdb">SK</country><country mxw-id="DS660685241" load-source="docdb">SM</country><country mxw-id="DS660685659" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA166479849" lang="EN" load-source="patent-office"><p id="pa01" num="0001">starting executing an executable code by the computer processor; repetitively executing at least a portion of the executable code, the least a portion of the executable code comprising dynamic memory allocation requests and dynamic memory deallocation requests, wherein a repetition number of the repetitive executions is an integer value greater than one; in response to execution of each of the dynamic memory allocation requests of the at least a portion of the executable code generating a record, each of the records comprising a unique memory identification of a unique portion of the main memory dynamically allocated upon the execution of the each of the dynamic memory allocation request and a unique code identification of a fragment of the executable code and/or of a fragment of a source code corresponding to the fragment of the executable code, wherein execution of the fragment of the executable code causes the execution of the each of the dynamic memory allocation requests, wherein the executable code is generated from the source code, wherein each of the unique memory identifications comprises a memory size of the respective unique portion of the main memory, wherein each of the unique memory identifications further comprises a memory address of the respective unique portion of the main memory; in response to execution of each of the dynamic memory deallocation requests of the at least a portion of the executable code deleting one of the records if the one of the records comprises the unique memory identification as specified in the each of the dynamic memory deallocation requests..
<img id="iaf01" file="imgaf001.tif" wi="78" he="122" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA166759661" lang="EN" source="EPO" load-source="docdb"><p>starting executing an executable code by the computer processor; repetitively executing at least a portion of the executable code, the least a portion of the executable code comprising dynamic memory allocation requests and dynamic memory deallocation requests, wherein a repetition number of the repetitive executions is an integer value greater than one; in response to execution of each of the dynamic memory allocation requests of the at least a portion of the executable code generating a record, each of the records comprising a unique memory identification of a unique portion of the main memory dynamically allocated upon the execution of the each of the dynamic memory allocation request and a unique code identification of a fragment of the executable code and/or of a fragment of a source code corresponding to the fragment of the executable code, wherein execution of the fragment of the executable code causes the execution of the each of the dynamic memory allocation requests, wherein the executable code is generated from the source code, wherein each of the unique memory identifications comprises a memory size of the respective unique portion of the main memory, wherein each of the unique memory identifications further comprises a memory address of the respective unique portion of the main memory; in response to execution of each of the dynamic memory deallocation requests of the at least a portion of the executable code deleting one of the records if the one of the records comprises the unique memory identification as specified in the each of the dynamic memory deallocation requests..</p></abstract><description mxw-id="PDES98404550" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><b>Field of the invention</b></heading><heading id="h0002"><b>Technical field</b></heading><p id="p0001" num="0001">Apparatuses and methods consistent with the exemplary embodiments relate to an electronic apparatus and method controlling the same, and more particularly to detecting a memory leak when executing an executable code.<!-- EPO <DP n="2"> --></p><heading id="h0003"><b>Background</b></heading><p id="p0002" num="0002">Executable codes being executed on computer systems often comprise dynamic memory allocation requests and dynamic memory deallocation requests. It is a common practice to prepare the executable code in a way that portions of the dynamic memory requested/allocated by executing of the dynamic memory allocation requests of said executable code are freed by executing of the respective dynamic memory allocation requests of said executable code. If the executable code fails to release the allocated dynamic memory before its execution is completed then it causes a memory leak, i.e. one or more portions of the dynamic memory remain allocated for the executable code after completion of the execution of the executable code. A special garbage collection software or service may free said not released dynamic memory after the completion of the execution of said executable code and thus compensate for said failures occurred during execution of said executable code. In the simplest case the user may simply reboot the computer in order to free all not deallocated portions of the dynamic memory. All these solutions may be at least partially effective, when the executable code is operated for a short time (i.e. no 24/7 continuous round-the-clock operation is required) and the ever increasing volume of the dynamic memory allocated for the execution of said executable code does not compromise operation of other executable codes executed on the same computer system and/or performance of the computer system itself. An ultimate solution would be to prepare an executable code upfront which is free of the aforementioned failures. This solution might be implemented when the executable code and/or source code used for generation of the executable code are relatively small, so that a software engineer is capable of finding all mistakes in at least one of said codes just by checking at least one of said codes and/or by executing the executable code in a debug mode. If the executable code is big, which is typically the case for modern industrial/commercial software, then there is a need for an automated system for memory leak detection.</p><heading id="h0004"><b>Summary</b></heading><p id="p0003" num="0003">A main memory is, as understood here, a memory directly accessible to the central processing unit (CPU) of a computer system. The CPU continuously reads instructions stored in the main memory and executes them as required. Any data actively<!-- EPO <DP n="3"> --> operated on is also stored in the main memory. The main memory may be implemented using dynamic random access memory (DRAM).</p><p id="p0004" num="0004">Dynamic allocation/deallocation of portions of the main memory is, as understood here, reserving portions of main memory moment to moment, as needed, without having to reserve a fixed amount ahead of time. Each of the reserved portions is unique and does not overlap any other of the reserved portions. Executable codes may perform dynamic memory allocation for their own use during their execution, i.e. a portion of the main memory may be dynamically allocated for the execution of the executable code upon a dynamic memory allocation request of the executable code and said portion may be deallocated/released upon a respective dynamic memory deallocation request of said executable code.</p><p id="p0005" num="0005">A computer-implemented technology for detecting memory leaks in a dynamically memory allocated portions of a main memory of a computer system during execution of an executable code on the computer system is described herein. The executable code comprises dynamic memory allocation requests and dynamic memory deallocation requests. As it will be clearly seen from the description hereon this technology can not only detect memory leaks during execution of an executable code, but identify fragments of the executable code which have caused the memory leaks. Of particular significance of this computer-implemented technology is a functionality that enables mapping of the identified fragments of the executable code to the corresponding source code. Using this mapping developers can correct the source code and generate a new executable code which cases less memory leaks. The problem of memory leak detection in the source code is of particular importance for programming languages like C/C++, which have dynamic memory allocation and dynamic memory deallocation functionalities.</p><p id="p0006" num="0006">It is an objective of embodiments of the invention to provide for an computer system configured to detect memory leaks caused by execution of an executable code on the computer system, to identify fragments of the executable code, which execution has caused the memory leaks, a computer-implemented method to perform the same, and a computer readable medium having stored thereon a computer executable code for execution by a computer processor controlling the computer system, wherein execution of the instructions of the executable code cause the computer processor to execute said computer-implemented method. Advantageous embodiments are described in the dependent claims.<!-- EPO <DP n="4"> --></p><p id="p0007" num="0007">According to one embodiment, the present invention relates to a computer-implemented method for detecting a memory leak in dynamically allocated portions of a main memory of a computer system. The computer system comprises the main memory and a computer processor. The computer-implemented method comprises the following: starting executing an executable code by the computer processor; repetitively executing at least a portion of the executable code, the least a portion of the executable code comprising dynamic memory allocation requests and dynamic memory deallocation requests, wherein a repetition number of the repetitive executions is an integer value greater than one; in response to execution of each of the dynamic memory allocation requests of the at least a portion of the executable code generating a record, each of the records comprising a unique memory identification of a unique portion of the main memory dynamically allocated upon the execution of the each of the dynamic memory allocation requests and a unique code identification of a fragment of the executable code and/or of a fragment of a source code corresponding to the fragment of the executable code, wherein the executable code is generated from the source code, wherein execution of the fragment of the executable code causes the execution of the each of the dynamic memory allocation requests, wherein each of the unique memory identifications comprises a memory size of the respective unique portion of the main memory , wherein each of the unique memory identifications further comprises a memory address of the respective unique portion of the main memory; in response to execution of each of the dynamic memory deallocation requests of the at least a portion of the executable code deleting one of the records if the one of the records comprises the unique memory identification as specified in the each of the dynamic memory deallocation requests; after completion of the repetitive executing, counting numbers of the records in each of groups of the records, wherein each of the groups consists of the records having the identical unique code identifications and the identical memory sizes; selecting the groups having the numbers of the records being equal either to the repetition number or to the repetition number multiplied by any integer number greater than one; and identifying the fragment of the executable code having unique code identification stored in the record of one of the selected groups as a fragment of the executable code which execution causes the memory leak and/or identifying the fragment of the source code having unique code identification stored in the record of the one of the selected groups as a fragment of the source code having the respective<!-- EPO <DP n="5"> --> fragment of the executable code which execution causes the memory leak. The primary advantage of this computer-implemented method is a functionality enabling detecting memory leaks caused by execution of at least the portion of the executable code which comprises at least one dynamic memory allocation request, which does not cause the memory leaks, and at least one dynamic memory allocation request, which causes the memory leak. If the executable code is prepared in a correct way, repetitive execution of any portion of it does not cause respective repetitive erroneous dynamic memory allocation requests, which allocate portions of memory and do not release said portions of memory when they are no longer needed.</p><p id="p0008" num="0008">Another embodiment of the present invention relates to a computer system comprising a main memory and a computer processor. The computer processor is configured perform the following: starting executing an executable code by the computer processor; repetitively executing at least a portion of the executable code, the least a portion of the executable code comprising dynamic memory allocation requests and dynamic memory deallocation requests, wherein a repetition number of the repetitive executions is an integer value greater than one; in response to execution of each of the dynamic memory allocation requests of the at least a portion of the executable code generating a record, each of the records comprising a unique memory identification of a unique portion of the main memory dynamically allocated upon the execution of the each of the dynamic memory allocation requests and a unique code identification of a fragment of the executable code and/or of a fragment of a source code corresponding to the fragment of the executable code, wherein the executable code is generated from the source code, wherein execution of the fragment of the executable code causes the execution of the each of the dynamic memory allocation requests, wherein each of the unique memory identifications comprises a memory size of the respective unique portion of the main memory, wherein each of the unique memory identifications further comprises a memory address of the respective unique portion of the main memory; in response to execution of each of the dynamic memory deallocation requests of the at least a portion of the executable code deleting one of the records if the one of the records comprises the unique memory identification as specified in the each of the dynamic memory deallocation requests; after completion of the repetitive executing, counting numbers of the records in each of groups of the records, wherein each of the groups consists of the<!-- EPO <DP n="6"> --> records having the identical unique code identifications and the identical memory sizes; selecting the groups having the numbers of the records being equal either to the repetition number or to the repetition number multiplied by any integer number greater than one; and identifying the fragment of the executable code having unique code identification stored in the record of one of the selected groups as a fragment of the executable code which execution causes the memory leak and/or identifying the fragment of the source code having unique code identification stored in the record of the one of the selected groups as a fragment of the source code having the respective fragment of the executable code which execution causes the memory leak. Another embodiment of the present invention refers to a computer readable medium having stored thereon a computer executable code for execution by a computer processor controlling a computer system comprising a main memory, wherein execution of the instructions of the executable code causes the computer processor to execute the following computer-implemented method: starting executing an executable code by the computer processor; repetitively executing at least a portion of the executable code, the least a portion of the executable code comprising dynamic memory allocation requests and dynamic memory deallocation requests, wherein a repetition number of the repetitive executions is an integer value greater than one; in response to execution of each of the dynamic memory allocation requests of the at least a portion of the executable code generating a record, each of the records comprising a unique memory identification of a unique portion of the main memory dynamically allocated upon the execution of the each of the dynamic memory allocation requests and a unique code identification of a fragment of the executable code and/or of a fragment of a source code corresponding to the fragment of the executable code, wherein the executable code is generated from the source code, wherein execution of the fragment of the executable code causes the execution of the each of the dynamic memory allocation requests, wherein each of the unique memory identifications comprises a memory size of the respective unique portion of the main memory , wherein each of the unique memory identifications further comprises a memory address of the respective unique portion of the main memory; in response to execution of each of the dynamic memory deallocation requests of the at least a portion of the executable code deleting one of the records if the one of the records comprises the unique memory identification as specified in the each of the dynamic memory deallocation requests; after completion of the repetitive executing,<!-- EPO <DP n="7"> --> counting numbers of the records in each of groups of the records, wherein each of the groups consists of the records having the identical unique code identifications and the identical memory sizes; selecting the groups having the numbers of the records being equal either to the repetition number or to the repetition number multiplied by any integer number greater than one; and identifying the fragment of the executable code having unique code identification stored in the record of one of the selected groups as a fragment of the executable code which execution causes the memory leak and/or identifying the fragment of the source code having unique code identification stored in the record of the one of the selected groups as a fragment of the source code having the respective fragment of the executable code which execution causes the memory leak. According to another embodiment the source code comprises call commands, each of the call commands has a unique respective executable call command of the executable code, each of the dynamic memory allocation requests has a respective unique dynamic memory allocation command of the source code, execution of each of the executable call commands causes execution of a fragment of the executable code specified in the each of the executable call commands, wherein the execution of each of the executable call commands causes interruption of a sequentially ordered execution of the executable code and after execution of the respective portion of the executable code the sequentially ordered execution of the executable code is resumed, each of some of the fragments of the executable code specified in their respective call requests comprises one or more of the dynamic memory allocation requests, each of some the fragments of the executable code specified in their respective call requests comprises at least one of the call requests, wherein each of the call commands has a respective unique line identification in the source code, wherein each of the dynamic memory allocation commands has a respective unique line identification in the source code, wherein each of the unique code identifications comprises the unique line identification of the dynamic memory allocation command having the respective dynamic memory allocation request which execution has caused the generation of the record comprising the each of the unique code identifications, wherein each of the unique code identifications further comprises all unique line identifications of the call commands having their respective executable call commands which have caused execution of their respective portions of the executable code being partially executed during execution<!-- EPO <DP n="8"> --> of the respective dynamic memory allocation request which execution has caused the generation of the record comprising the each of the unique code identifications. This embodiment discloses a mapping mechanism for detecting portions of the source code, which corresponding fragments of the executable code when executed cause memory leaks. The source code comprises as usual a main code module (e.g. main.cpp in C/C++) and number of the secondary code modules (e.g. subroutines, functions, etc). A fragment of executable code corresponding to the main code module may cause execution of one or more other fragments of the executable code corresponding of the respective fragments of one or more secondary code modules. For instance, the primary code module may comprise a call of a function or a subroutine in one of the secondary code modules. Further, a subroutine of one of the secondary code modules may comprise fragments of the source code, which call execution of the same or another subroutine. Tracing of entire chain of fragments of the source code having corresponding of the executable code, which execution has caused the memory leak is very important for a developer/programmer. A particular implementation depends on a programming language environment. For instance, when C/C++ programming language is used, calling of each function or subroutine comprises "call stack" procedure. Registering of parameters of "call stack" procedures, such as dynamic memory allocation parameters, a name of the function/subroutine which was called, a name of the respective function/subroutine which has generated the respective call, etc. may provide sufficient information for tracing of entire chain mentioned above. Further details regarding implementation of this tracing are described in the next following embodiments.</p><p id="p0009" num="0009">According to another embodiment the source code is split in code modules, wherein each of the code modules has a unique name identification, wherein each of the call commands has a respective unique line number in the respective code module comprising the each of the call commands, wherein the unique line identification of each of the call commands comprises the respective unique line number of the each of the call commands and the unique name identification of the respective code module comprising the each of the call commands, wherein each of the dynamic memory allocation commands has a respective unique line number in the respective code module comprising the each of the dynamic memory allocation commands, wherein the unique line identification of each of the dynamic memory allocation commands comprises the respective unique line number of the each of the dynamic<!-- EPO <DP n="9"> --> memory allocation commands and the unique name identification of the respective code module comprising the each of the dynamic memory allocation commands. According to another embodiment, the generating of the records and the deleting of the records is executed only during the repetitive execution.</p><p id="p0010" num="0010">According to another embodiment, the executing of the executable code is executed in a software environment configured in a multilayered software architecture comprising an application software layer, a leak detection software layer, and an operating system software layer, the executing of the executable code is performed in the application software layer, the leak detection software layer is allocated in between the application software layer and the operating system software layer, the leak detection software layer is configured to perform the generating of the respective record upon execution of each of the dynamic memory allocation request and to perform the deleting the record to be deleted upon execution of the respective dynamic memory deallocation request.</p><p id="p0011" num="0011">The functioning of the leak detection software layer may be based on hooking techniques, which are used to alter or augment the behavior of an operating system, of applications, or of other software components by intercepting function calls or messages or events passed between software components and/or software layers. According to another embodiment the repetitive executing of the at least of the portion of the executable code is performed in a software driven test mode by a test software operating in the application software layer.<!-- EPO <DP n="10"> --></p><heading id="h0005"><b>Figures</b></heading><p id="p0012" num="0012"><ul><li><figref idrefs="f0001">Fig. 1</figref> is a block diagram of a computer system.</li><li><figref idrefs="f0001">Fig. 2</figref> is an example source code.</li><li><figref idrefs="f0002">Fig. 3</figref> is a diagram of a software environment configured in multilayered software architecture.</li><li><figref idrefs="f0003">Fig. 4</figref> is a graph of overall volume of allocated memory versus time.</li><li><figref idrefs="f0003">Fig. 5</figref> is a graph of overall volume of allocated memory versus time.</li><li><figref idrefs="f0003">Fig. 6</figref> is a stacked histogram of a breakdown of a memory allocation versus time.</li><li><figref idrefs="f0004">Fig. 7</figref> is a flow chart of a method for detecting a memory leak.</li><li><figref idrefs="f0005">Fig. 8</figref> is a set of tables illustrating execution of an executable code corresponding to the example source code.</li></ul><!-- EPO <DP n="11"> --></p><heading id="h0006"><b>Detailed description</b></heading><p id="p0013" num="0013">In the following description, reference is made to the accompanying drawings that form a part hereof, and in which is shown by way of illustration specific embodiments which may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention, and it is to be understood that other embodiments may be utilized and that structural, electrical, and optical changes may be made without departing from the scope of the present invention. The following description of example embodiments is, therefore, not to be taken in a limited sense, and the scope of the present invention is defined by the appended claims.</p><p id="p0014" num="0014"><figref idrefs="f0001">Fig. 1</figref> illustrates a block diagram of an example computer system 105, which may be used for a computer-implemented method of a detecting a memory leak. The computer system 105 comprises a main memory 101, a hard disk drive 102, a computer processor 100, one or more input devices 103, and one or more output devices 104. The computer processor is communicatively coupled with devices mentioned above. The communicative coupling may be performed via one or more data busses. The computer processor is configured to perform a computer-implemented method for detecting a memory leak in dynamically allocated portions of the main memory 101. Input and output devices are configured to support user interface functions, such as displaying to a user information generated by the computer system and receiving various information form the user, such a commands, text, etc. The main memory is used for storing at least a portion of the executable code comprising dynamic memory allocation requests and dynamic memory deallocation requests. The computer processor is further configured to allocate unique portions of the main memory upon execution of each of the dynamic memory allocation requests and of the dynamic memory deallocation requests. Hard disk may be configured to store the executable code and a source code used for generation of said executable code.</p><p id="p0015" num="0015">The source code may be split in source code modules. An example source depicted on the <figref idrefs="f0001">Fig. 2</figref> has two code modules 302 and 303. Each source code module has a unique respective identification name 301. Some or all of each lines of the source code module have a respective unique line identification in the source code. Some or all of each of the lines of the source code has a unique respective line number 301 in the respective source code comprising the each of the lines. The unique line<!-- EPO <DP n="12"> --> identification of the line of the source code may comprise the unique name identification of the source code module comprising said line and the unique line number of said line in said source code module. For instance the unique line identification of a line "if(!ptr1)" in the example source code comprises the name of the source module "Subroutine.cpp" and the line number "90." Each dynamic memory allocation request of the executable code has a respective dynamic memory allocation command in the source code. Each dynamic memory deallocation request of the executable code has a respective dynamic memory deallocation command in the source code. Each of some or all of the code modules may comprise subroutines, functions, etc. Some or all of the each code modules comprise one or more call commands. Some or all of the each code modules comprise one or more of the dynamic memory allocation commands. Some or all of the each code modules comprise one or more of the dynamic memory deallocation commands. Each of the call commands in the source code has a respective executable code command in the executable code. Execution of each of the executable call commands causes execution of a fragment of the executable code specified in the each of the executable call commands, wherein the execution of each of the executable call commands causes interruption of a sequentially ordered execution of the executable code and after execution of the respective portion of the executable code the sequentially ordered execution of the executable code is resumed. The fragment of the executable code specified in the executable call command may correspond to a function or subroutine in the source code, wherein the respective call command of the source code may be allocated within another subroutine or another function. The sequentially ordered execution of executable code and subsequent resuming of the sequential execution of the executable code is as usual performed by executing CallStack operations which generate stack data structures needed for the resuming the sequential execution of the executable code form the point where its sequential execution was interrupted. Further CallStack operations store information in the stack data structures regarding all fragments of the executable code specified in their respective executable call commands which execution is started but not is completed yet. For instance these fragments of the executable code may be active subroutines and functions of the executable code, which execution is started and not yet completed yet. This kind of stack data structures is also known as an execution stack, control stack, run-time stack, or machine stack.<!-- EPO <DP n="13"> --></p><p id="p0016" num="0016">Branching of execution of the executable code is quite complex, because each of some or all of the fragments of the executable code specified in their respective call requests comprises one or more of the dynamic memory allocation requests, and each of some or all the fragments of the executable code specified in their respective call requests comprises at least one of the call requests. Thus providing to a code developer or a programmer complete information regarding all active subroutines, functions, etc. of the executable code which were active when the dynamic memory allocation request causing the memory leak was executed is very important. This may be done by evaluating the stack data structures and as a result thereof by identifying all executable call functions and portions of the executable code specified in them which execution was partially completed when the dynamic memory allocation request causing the memory leak was executed. This information can be easily mapped to the respective lines of the source code. For instance when the aforementioned approach is applied to the example code depicted on the <figref idrefs="f0001">Fig. 2</figref> the developer will get the following information: line 300 in subroutine.cpp and line 50 in main.cpp. The details regarding identifying the dynamic memory allocation request of an executable code corresponding to the dynamic memory allocation command "ptr3= allocatememory(400)" as the command of the executable code which execution causes the memory leak will be described in the text further on. <figref idrefs="f0001">Fig. 2</figref> illustrates a software environment configured in a multilayered software architecture comprising at least an application software layer, a leak detection software layer, and an operating system software layer. If the primary and secondary code modules are written in C/C++ language the operating system software layer may be a C Run Time Library. The executing of the executable code is performed in the application software layer. The leak detection software layer is allocated in between the application software layer and the operating system software layer, the leak detection software layer is configured to perform the generating of the respective record upon execution of each of the dynamic memory allocation request and to perform the deleting the record to be deleted upon execution of the respective dynamic memory deallocation request. Each of the records comprise a unique memory identification of a unique portion of the main memory dynamically allocated upon the execution of the each of the dynamic memory allocation request and a unique code identification of a fragment of the executable code which causes the execution of the each of the dynamic memory allocation request and/or of a fragment of a source<!-- EPO <DP n="14"> --> code corresponding to the fragment of the executable code. The unique code identification of the fragment of the source code may be implemented as described above. Each of the unique memory identifications may comprise a memory size of the respective unique portion of the dynamic memory and a memory address of the respective unique portion of the main memory. The memory size may be specified in bytes or number of words in the memory. The memory address may be a first address of the respective unique portion of the main memory. The memory address may be further a virtual address in the memory.</p><p id="p0017" num="0017">Application software layer coordinates execution of one or more executable codes. It forwards (macro) commands/requests generated by the one or more executable codes to the operating system software layer via optional infrastructure software layer and manages data traffic needed for execution of the one or more executable codes. A test software may operate in the application layer. The test software manages execution of the executable code and detection of memory leaks generated during execution of the executable code. For instance the test software may cause a repetitive execution of at least a portion of the executable code in the software driven test mode. The repetitive execution may be performed by a repetitive calling of the same function of the executable code by the test software (e.g. performing the same transaction, the same update/modification of data processed by the executable code, etc.). Alternatively or in addition to this the test software may cause repetitive execution of entire executable code or one or more preselected portions of the executable code. The test software may further activate/deactivate the leak detection software layer when necessary. For instance, the leak detection software layer may be activated only when the repetitive execution of at least a portion of the executable code is performed. A test schedule/scenario of searching for of the portions of the executable code causing the memory leaks performed by the test software may be specified by user.</p><p id="p0018" num="0018">The multilayered software architecture may comprise further an infrastructure software layer allocated in-between the application software layer and the leak detection software layer. The infrastructure layer performs logging networking, and other services which are required for supporting the application software layer. It may convert macro commands/requests received from the application layer into commands/requests executable by the operating system software layer.<!-- EPO <DP n="15"> --></p><p id="p0019" num="0019">Functioning of the leak detection software layer may be based on hooking techniques, which are used to alter or augment the behavior of an operating system, of applications, of executable codes, or of other software components by intercepting function calls or messages or events passed between software components and/or software layers.</p><p id="p0020" num="0020">The operating system software layer provides functioning of the computer system during execution of the one or more executable codes and test software and execution of the one or more executable codes, the test software, and other software components operating on the computer system.</p><p id="p0021" num="0021">Functioning of the software environment depicted on the <figref idrefs="f0002">Fig. 3</figref> may be illustrated on the following example. At first the executable code initiates generation of a new business object (BO). The application software layer sends a respective request for creating of the new BO (1. New BO) to the infrastructure software layer. Afterwards the infrastructure software layer generates a request for string memory addressed to the operating system software layer (1.1 require string memory). In accordance with the functionalities of leak detection software described above the leak detection software layer sends a request for raw memory allocation (1.1.1. require raw allocation) and generates a record (1.1.2. generate record). The content of this generated record and all other records further generated in the description of this example is described above. The request of raw memory is an allocation of a unique portion of the memory 101 of the computer system 105 for the BO. After the generating of said record the infrastructure software layer sends another request for allocating of Data Access Gate (DAG) memory within the previously allocated raw memory (1.2. DAG memory). When the DAG memory is allocated the leak detection software layer generates another recoded related to the DAG memory allocation (1.2.1. generate record). Afterwards the infrastructure layer sends information regarding generated BO (3. BO allocated). The information comprises memory addresses and memory volumes of the allocated portions of the memory.</p><p id="p0022" num="0022">Additional raw memory may be required during life time of the generated BO. In this case the application layer sends a request for allocation of additional raw memory addressed directly to the operating system software layer (3. require raw memory) upon receiving if the respective request from the executable code. In accordance with the functionalities of the leak detection software layer the leak detection tool forwards this request to the operating system software layer (3.1.1. require raw<!-- EPO <DP n="16"> --> memory), generates the respective record related to the allocation of the additional raw memory (3.1.2. generate record), and sends a confirmation to the application software layer (5. raw memory allocated).</p><p id="p0023" num="0023">When the executable code comprises the command to delete the generated BO and this command is executed, the application software generates a request to delete the generated BO addressed to the infrastructure software layer (6. delete BO). In response to this request the infrastructure layer generates corresponding request to free the string memory (6.1) and to free the DAG memory (6.2.). When the leak detection software layer receives the requests 6.1 and 6.2 is sends request to free the raw memory allocated in the step 1.1.1. and deletes the respective records in step 6.2.1. "delete record", wherein the respective records are generated in the steps 1.1.2 and 1.2.1. When the BO is deleted the previously allocated additional raw memory is deleted. When the application layer receives a respective request to delete the BO, it sends a request to free the allocated raw memory directly addressed to the operating system software layer (7. Free raw memory), wherein the allocated memory to be freed is allocated in the previous step 3.1.1. In accordance with the functionalities of the leak detection software layer the leak detection tool forwards this request to the operating system software layer (7.1.1. free raw memory) and deletes the respective record (7.1.2. delete record), which was generated in the step 3.1.2.</p><p id="p0024" num="0024"><figref idrefs="f0003">Figs. 4-6</figref> illustrate issues related to identification of the memory leaks in greater detail. <figref idrefs="f0003">Fig. 4</figref> illustrates an overall volume of allocated memory for execution of a first executable code which execution causes memory leaks. The execution of the first executable code starts at time t0 and ends at time t12. <figref idrefs="f0003">Fig. 4</figref> illustrates an overall volume of allocated memory for execution of second executable code which execution does not cause memory leaks. The execution of the second executable starts at time t0 and ends at time t12. As it can be clearly seen from the <figref idrefs="f0003">Figs. 4 and 5</figref> the time evolution of these graphs does not provide sufficient information for differentiating between the first and the second executable code and drawing a conclusion that the execution of the first executable code causes the memory leaks. The volume of allocated memory equals to zero when execution of the first and the second executable codes is ended, despite the fact that the execution of the first executable code does cause the memory leaks, i.e. not all allocated memory is freed by respective portions of the first executable code. The release of the not released memory which<!-- EPO <DP n="17"> --> was allocated for the execution of the first executable code may be performed automatically by dedicated functions of the operating system, special memory garbage collection software, etc. when the execution of the first executable code is finished. Memory allocation for execution of the executable codes serves many purposes. The execution of the executable code may require a one-time scratchpad, allocated once and never de-allocated for the duration of the program execution. The execution of the executable code may further require a creation of an in-memory structure, like a binary tree, that is used throughout the program. Execution of the operations of the executable code like the lazy load, cache and singleton may require allocation of the memory that is not released until the execution of the executable code is completed. This portion of allocated memory is marked as "cache&amp;singleton" on <figref idrefs="f0003">Fig. 6</figref> illustrating a stacked histogram of a breakdown of a memory allocation versus time during execution of the first executable code. At it clearly seen from the <figref idrefs="f0003">Fig. 6</figref> this portion of allocated memory remains constant when the time value is equal to t4, t6, t8, and t10.</p><p id="p0025" num="0025">The portion of the allocated memory called "common" on the stacked diagram (<figref idrefs="f0003">Fig. 6</figref>) illustrates another example of the allocated memory that is required for the execution of the first executable code, which is released when the execution of the executable code is completed. This portion of allocated memory may serve a purpose of processing of a recurring event or service that the first executable code performs during its execution.</p><p id="p0026" num="0026">The portion of allocated memory called "leak" on the stack diagram (<figref idrefs="f0003">Fig. 6</figref>) corresponds to the memory leaks caused by execution of the first executable code. This portion of memory would have been released at t4, t6, t8, t10 if the execution of first executable code did not cause the memory leaks. In the other words, if the first executable code would have been free of errors causing the memory leaks the portion of the allocated memory called "leak" would not be present in the stack diagram (<figref idrefs="f0003">Fig. 5</figref>). Thus there is a need for an effective procedure enabling differentiation between allocations of memory corresponding to the memory leaks and other allocations of memory.</p><p id="p0027" num="0027"><figref idrefs="f0004">Fig. 7</figref> illustrates a flow diagram of a method for automated memory leak detection during execution of the executable code. The executable code may be executed on the computer system 105 which is described above.<!-- EPO <DP n="18"> --></p><p id="p0028" num="0028">Merely for explanatory purposes the execution of the method depicted on the <figref idrefs="f0004">Fig. 7</figref> is illustrated on an example of detecting the memory leaks caused by execution of an executable code which is generated using the example source code depicted on the <figref idrefs="f0001">Fig. 2</figref>. The example code comprises to source code modules "main.cpp" and subroutine.cpp".</p><p id="p0029" num="0029">The method begins with a process block 200, wherein executing the executable code by a computer processor is started. Afterwards a repetitive execution of at least a portion of the executable code is started in a process block 201. The least the portion of the executable code comprises dynamic memory allocation requests and dynamic memory deallocation requests. A repetition number of the repetitive executions is an integer value greater than one. The repetitive execution may be operated by the test software described above.</p><p id="p0030" num="0030">The at least the portion of the executable code may be the executable code corresponding to the example source code mentioned above.</p><p id="p0031" num="0031">A process block 202 is executed at least once during the repetitive execution. In the process block 202 a record upon execution of each of the dynamic memory allocation request is executed. Each of the records comprises a unique memory identification of a unique portion of the main memory dynamically allocated upon the execution of the each of the dynamic memory allocation request and a unique code identification of a fragment of the executable code which causes the execution of the each of the dynamic memory allocation request and/or of a fragment of a source code corresponding to the fragment of the executable code, wherein the executable code is generated from the source code. Each of the unique memory identifications may comprise a memory size of the respective unique portion of the main memory. Each of the unique memory identifications may further comprise a memory address of the respective unique portion of the main memory. Details of contents of the records are described above.</p><p id="p0032" num="0032">A process block 203 is executed at least once during the repetitive execution. In the process block 203 the record upon execution of the dynamic memory deallocation is deleted if the record to be deleted comprises the unique memory identification as specified in said dynamic memory deallocation request.</p><p id="p0033" num="0033">A decision process block 204 causes the repetitive execution of the at least the portion of the executable code, wherein the number the repetitive executions of the at least the portion of the executable code equals to the integer number greater than<!-- EPO <DP n="19"> --> one. It is necessary to mention that in order to prevent corruption of the results (i.e. a set of records generated by execution of the process blocks 202 and 203) no other software tools are allowed to change memory allocations generated by the at least the portion of the executable code during its repetitive execution.</p><p id="p0034" num="0034">Turning back to the example source code the execution of the process blocks 201-203 and the decision process block 204 during triple execution the executable code corresponding to the example source code results in the following, wherein no changes in allocation of memory which was allocated as a result of the execution of the executable code is performed between the consecutive executions of the executable code. The first execution of the executable code results in generation of Table 1 depicted on the <figref idrefs="f0005">Fig. 8</figref>. Execution of the fragment of the executable code corresponding to a line 50 in the main.cpp causes execution of the fragment of the executable code corresponding to the subroutine.cpp. Since a pointer ptr1 is not generated yet, execution of the fragment of the executable code corresponding to lines 90 and 100 in the subroutine.cpp causes allocation of 200 bytes in the memory. This procedure is registered in a record 1 of the Table 1. This record comprises the request number equal to 1, an allocated memory size of 200 bytes, an address of the allocated memory 0x0000000000378ec, a unique name identification of the subroutine module "subroutine.cpp" and a unique line number identification 100 of a dynamic memory allocation command "ptr1=allocatememory(200)", a unique name identification of the main.cpp module "main.cpp" and a unique line number identification 50 of a call command "int ret =addOrder()", which calls the subroutine "subroutine.cpp". As it is mentioned above the lines of the source code of the first record may be identified by monitoring execution of their respective callstack operations of the executable code.</p><p id="p0035" num="0035">The execution of a fragment of the executable code corresponding to line 110 will not cause execution of a fragment of the executable code corresponding to line 120 because a pointer ptr2 is not generated yet.</p><p id="p0036" num="0036">Execution of the fragments of the executable code corresponding to the lines 200 and 300 causes generation of records 2 and 3 in a similar way as generation of the record 1.</p><p id="p0037" num="0037">Subsequent execution of the executable code corresponding to example source code times results in generation of Table 2 depicted on the <figref idrefs="f0005">Fig. 8</figref>. Execution of the fragment of the executable code corresponding to the line 90 prevents further allocation<!-- EPO <DP n="20"> --> of unique portions of memory of 200 bytes. Therefore the record 1 is not multiplied in the table 2. The record 2 is deleted during the second execution and afterwards the record with the identical content except the memory address is generated during the second execution. The same occurs during the third execution and as a result thereof the record 6 is generated. Since the execution of the fragment of the executable code corresponding to line 300 causes memory leaks the table 2 comprises 3 respective records 3, 5, and 7.</p><p id="p0038" num="0038">When the repetitive execution is completed, the decision process block 204 causes stop of the generation and the deletion of the records and execution of a process block 205. This may be performed by deactivating of the operation of the leak detection memory layer. It is needed for prevention of corruption of the generated records. The corruption may be caused by further execution of the executable code. Alternatively the generation and deletion of the records may be further continued after the execution of the decision process block 204, i.e. there is no need to stop the deleting and generating of the records when the repetitive execution is completed if the records generated during the repetitive execution are saved as a separate partition.</p><p id="p0039" num="0039">In the process block 205 the records generated during the repetitive execution are split in groups, wherein each of the groups consists of the records having the identical unique code identifications and the identical memory sizes.</p><p id="p0040" num="0040">A process block 206 is executed after the process block 205. In the process block 206 count numbers of the records in each of the groups of the records is calculated. Turning back to the aforementioned example source code the execution of the process blocks 205 and 206 results in generation of the table 3 depicted on the <figref idrefs="f0005">Fig. 8</figref>. The first group corresponds to the record 1 in the Table 2 and has the count number equal to 1, because no other record other than record 1 has the same the same unique code identification and the same memory size as specified in the record 1. The second group corresponds to the record 6 in the Table 2 and has the count number equal to 1, because no other record other than record 6 has the same unique code identification and the same memory size as specified in the record 6. The third group corresponds to the records 3, 4, and 7 in the Table 2 and has the count number equal to 3, because the records 3, 4, and 7 have the identical unique code identification and the identical memory size.<!-- EPO <DP n="21"> --></p><p id="p0041" num="0041">In a process block 207 the groups having respective count numbers equal either to the repetition number or to the repetition number multiplied by any integer number greater than one are selected. The criterion wherein the repetition number is multiplied by any integer number greater than is needed because the repetitive execution of the fragment of the executable code causing the memory leak may be multiplied by internal repetitive execution within the at least the portion of the executable code. Turning back to the aforementioned example the execution of the process block 207 results in selection of the third group in the third table depicted on the <figref idrefs="f0005">Fig. 8</figref>, because a count number of this group equals to the repetition number.</p><p id="p0042" num="0042">In a process block 208 the fragment of the executable code having unique code identification stored in the record of one of the selected groups is identified as a fragment of the executable code which execution causes the memory leak and/or the fragment of the source code having unique code identification stored in the record of the one of the selected groups is identified as a fragment of the source code having the respective fragment of the executable code which execution causes the memory leak.</p><p id="p0043" num="0043">Turning back to the aforementioned example the execution of the process block 208 results in identification of the line 50 in the main.cpp and the line 300 in the subroutine.cpp, which corresponding fragments of the executable code cause the memory leak when executed.</p></description><claims mxw-id="PCLM90459488" lang="EN" load-source="patent-office"><!-- EPO <DP n="22"> --><claim id="c-en-0001" num="0001"><claim-text>A computer-implemented method for detecting a memory leak in dynamically allocated portions of a main memory (101) of a computer system (105), the computer system comprising the main memory and a computer processor (100), the computer-implemented method comprising:
<claim-text>starting executing an executable code by the computer processor (200);</claim-text>
<claim-text>repetitively executing at least a portion of the executable code (201, 204), the least a portion of the executable code comprising dynamic memory allocation requests and dynamic memory deallocation requests, wherein a repetition number of the repetitive executions is an integer value greater than one;</claim-text>
<claim-text>in response to execution of each of the dynamic memory allocation requests of the at least a portion of the executable code generating a record (202), each of the records comprising a unique memory identification of a unique portion of the main memory dynamically allocated upon the execution of the each of the dynamic memory allocation requests and a unique code identification of a fragment of the executable code and/or of a fragment of a source code corresponding to the fragment of the executable code, wherein execution of the fragment of the executable code causes the execution of the each of the dynamic memory allocation requests, wherein the executable code is generated from the source code, wherein each of the unique memory identifications comprises a memory size of the respective unique portion of the main memory , wherein each of the unique memory identifications further comprises a memory address of the respective unique portion of the main memory ;</claim-text>
<claim-text>in response to execution of each of the dynamic memory deallocation requests of the at least a portion of the executable code deleting one of the records if the one of the records comprises the unique memory identification as specified in the each of the dynamic memory deallocation requests (203);</claim-text>
<claim-text>after completion of the repetitive executing (204), counting numbers of the records in each of groups of the records, wherein each of the groups consists<!-- EPO <DP n="23"> --> of the records having the identical unique code identifications and the identical memory sizes (205, 206);</claim-text>
<claim-text>selecting the groups having the numbers of the records being equal either to the repetition number or to the repetition number multiplied by any integer number greater than one (207); and</claim-text>
<claim-text>identifying the fragment of the executable code having unique code identification stored in the record of one of the selected groups as a fragment of the executable code which execution causes the memory leak and/or identifying the fragment of the source code having the unique code identification stored in the record of the one of the selected groups as a fragment of the source code having the respective fragment of the executable code which execution causes the memory leak (208).</claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The computer-implemented method of claim 1, wherein the source code comprises call commands, each of the call commands has a unique respective executable call command of the executable code, each of the dynamic memory allocation requests has a respective unique dynamic memory allocation command of the source code, execution of each of the executable call commands causes execution of a fragment of the executable code specified in the each of the executable call commands, wherein the execution of each of the executable call commands causes interruption of a sequentially ordered execution of the executable code and after execution of the respective portion of the executable code the sequentially ordered execution of the executable code is resumed, each of some of the fragments of the executable code specified in their respective call requests comprises one or more of the dynamic memory allocation requests, each of some the fragments of the executable code specified in their respective call requests comprises at least one of the call requests, wherein each of the call commands has a respective unique line identification in the source code, wherein each of the dynamic memory allocation commands has a respective unique line identification in the source code, wherein each of the unique code identifications comprises the unique line identification of the dynamic memory allocation command<!-- EPO <DP n="24"> --> having the respective dynamic memory allocation request which execution has caused the generation of the record comprising the each of the unique code identifications, wherein each of the unique code identifications further comprises all unique line identifications of the call commands having their respective executable call commands which have caused execution of their respective portions of the executable code being partially executed during execution of the respective dynamic memory allocation request which execution has caused the generation of the record comprising the each of the unique code identifications.</claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The computer-implemented method of claim 2, wherein the source code is split in code modules (302, 303), wherein each of the code modules has a unique name identification (300), wherein each of the call commands has a respective unique line number (301) in the respective code module comprising the each of the call commands, wherein the unique line identification of each of the call commands comprises the respective unique line number of the each of the call commands and the unique name identification of the respective code module comprising the each of the call commands, wherein each of the dynamic memory allocation commands has a respective unique line number in the respective code module comprising the each of the dynamic memory allocation commands, wherein the unique line identification of each of the dynamic memory allocation commands comprises the respective unique line number (301) of the each of the dynamic memory allocation commands and the unique name identification of the respective code module comprising the each of the dynamic memory allocation commands.</claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The computer-implemented method of any one of the preceding claims, wherein the generating of the records and the deleting of the records is executed only during the repetitive execution.</claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The computer-implemented method of any one of the preceding claims, wherein the executing of the executable code is executed in a software environment configured in a multilayered software architecture comprising an application software layer, a leak detection software layer, and an operating<!-- EPO <DP n="25"> --> system software layer, the executing of the executable code is performed in the application software layer, the leak detection software layer is allocated in between the application software layer and the operating system software layer, the leak detection software layer is configured to perform the generating of the respective record upon execution of each of the dynamic memory allocation request and to perform the deleting the record to be deleted upon execution of the respective dynamic memory deallocation request.</claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The computer-implemented method of claim 5, wherein the repetitive executing of the at least of the portion of the executable code is performed in a software driven test mode by a test software operating in the application software layer.</claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>A computer system (105) comprising a main memory (101) and a computer processor (100), wherein the computer processor is configured to perform the following:
<claim-text>starting executing an executable code (200);</claim-text>
<claim-text>repetitively executing at least a portion of the executable code (201, 204), the least a portion of the executable code comprising dynamic memory allocation requests and dynamic memory deallocation requests, wherein a repetition number of the repetitive executions is an integer value greater than one;</claim-text>
<claim-text>in response to execution of each of the dynamic memory allocation requests of the at least a portion of the executable code generating a record (202), each of the records comprising a unique memory identification of a unique portion of the main memory dynamically allocated upon the execution of the each of the dynamic memory allocation requests and a unique code identification of a fragment of the executable code and/or of a fragment of a source code corresponding to the fragment of the executable code, wherein execution of the fragment of the executable code causes the execution of the each of the dynamic memory allocation requests, wherein the executable code is generated from the source code, wherein each of the unique memory identifications<!-- EPO <DP n="26"> --> comprises a memory size of the respective unique portion of the main memory, wherein each of the unique memory identifications further comprises a memory address of the respective unique portion of the main memory;</claim-text>
<claim-text>in response to execution of each of the dynamic memory deallocation requests of the at least a portion of the executable code deleting one of the records if the one of the records comprises the unique memory identification as specified in the each of the dynamic memory deallocation requests (203);</claim-text>
<claim-text>after completion of the repetitive executing (204), counting numbers of the records in each of groups of the records, wherein each of the groups consists of the records having the identical unique code identifications and the identical memory sizes (205, 206);</claim-text>
<claim-text>selecting the groups having the numbers of the records being equal either to the repetition number or to the repetition number multiplied by any integer number greater than one (207); and</claim-text>
<claim-text>identifying the fragment of the executable code having unique code identification stored in the record of one of the selected groups as a fragment of the executable code which execution causes the memory leak and/or identifying the fragment of the source code having the unique code identification stored in the record of the one of the selected groups as a fragment of the source code having the respective fragment of the executable code which execution causes the memory leak (208).</claim-text></claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>The computer system of claim 7, wherein the source code comprises call commands, each of the call commands has a unique respective executable call command of the executable code, each of the dynamic memory allocation requests has a respective unique dynamic memory allocation command of the source code, execution of each of the executable call commands causes execution of a fragment of the executable code specified in the each of the executable call commands, wherein the execution of each of the executable call commands causes interruption of a sequentially ordered execution<!-- EPO <DP n="27"> --> of the executable code and after execution of the respective portion of the executable code the sequentially ordered execution of the executable code is resumed, each of some of the fragments of the executable code specified in their respective call requests comprises one or more of the dynamic memory allocation requests, each of some the fragments of the executable code specified in their respective call requests comprises at least one of the call requests, wherein each of the call commands has a respective unique line identification in the source code, wherein each of the dynamic memory allocation commands has a respective unique line identification in the source code, wherein each of the unique code identifications comprises the unique line identification of the dynamic memory allocation command having the respective dynamic memory allocation request which execution has caused the generation of the record comprising the each of the unique code identifications, wherein each of the unique code identifications further comprises all unique line identifications of the call commands having their respective executable call commands which have caused execution of their respective portions of the executable code being partially executed during execution of the respective dynamic memory allocation request which execution has caused the generation of the record comprising the each of the unique code identifications.</claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>The computer system of claim 8, wherein the source code is split in code modules (302, 303), wherein each of the code modules has a unique name identification (300), wherein each of the call commands has a respective unique line number (301) in the respective code module comprising the each of the call commands, wherein the unique line identification of each of the call commands comprises the respective unique line number of the each of the call commands and the unique name identification of the respective code module comprising the each of the call commands, wherein each of the dynamic memory allocation commands has a respective unique line number in the respective code module comprising the each of the dynamic memory allocation commands, wherein the unique line identification of each of the dynamic memory allocation commands comprises the respective unique line number (301) of the each of the dynamic memory allocation commands and<!-- EPO <DP n="28"> --> the unique name identification of the respective code module comprising the each of the dynamic memory allocation commands.</claim-text></claim><claim id="c-en-0010" num="0010"><claim-text>The computer system of one of the claims 7-9, the generating of the records and the deleting of the records is executed only during the repetitive execution..</claim-text></claim><claim id="c-en-0011" num="0011"><claim-text>The computer system of one of the claims 7-10, wherein the executing of the executable code is executed in a software environment on the computer system, the software environment is configured in a multilayered software architecture comprising an application software layer, a leak detection software layer, and an operating system software layer, the executing of the executable code is performed in the application software layer, the leak detection software layer is allocated in between the application software layer and the operating system software layer, the leak detection software layer is configured to perform the generating of the respective record upon execution of each of the dynamic memory allocation request and to perform the deleting the record to be deleted upon execution of the respective dynamic memory deallocation request.</claim-text></claim><claim id="c-en-0012" num="0012"><claim-text>The computer system of claim 11, wherein the repetitive executing of the at least of the portion of the executable code is performed in a software driven test mode by a test software operating in the application software layer.</claim-text></claim><claim id="c-en-0013" num="0013"><claim-text>A computer readable medium having stored thereon a computer executable code for execution by a computer processor (100) controlling a computer system (105) comprising a main memory (101), wherein execution of the instructions of the executable code causes the computer processor to execute a computer-implemented method of claims 1-6 on the computer system.</claim-text></claim></claims><amended-claims mxw-id="PCLM90459487" lang="EN" load-source="patent-office" amended-claim-type="EPC"><heading id="h0007">Amended claims in accordance with Rule 137(2) EPC.</heading><claim id="ac-en-0001" num="0001"><claim-text>A computer-implemented method for detecting a memory leak in dynamically allocated portions of a main memory (101) of a computer system (105), the computer system comprising the main memory and a computer processor (100), the computer-implemented method comprising:
<claim-text>starting executing an executable code by the computer processor (200);</claim-text>
<claim-text>repetitively executing at least a portion of the executable code (201, 204), the least a portion of the executable code comprising dynamic memory allocation requests and dynamic memory deallocation requests, wherein a repetition number of the repetitive executions is an integer value greater than one;</claim-text>
<claim-text>in response to execution of each of the dynamic memory allocation requests of the at least a portion of the executable code generating a record (202), each of the records comprising a unique memory identification of a unique portion of the main memory dynamically allocated upon the execution of the each of the dynamic memory allocation requests and a unique code identification of a fragment of the executable code and/or of a fragment of a source code (303) corresponding to the fragment of the executable code, wherein execution of the fragment of the executable code causes the execution of the each of the dynamic memory allocation requests, wherein the executable code is generated from the source code, wherein each of the unique memory identifications comprises a memory size of the respective unique portion of the main memory, wherein each of the unique memory identifications further comprises a memory address of the respective unique portion of the main memory;</claim-text>
<claim-text>in response to execution of each of the dynamic memory deallocation requests of the at least a portion of the executable code deleting one of the records if the one of the records comprises the unique memory identification as specified in the each of the dynamic memory deallocation requests (203);</claim-text>
<claim-text>after completion of the repetitive executing (204), counting numbers of the records in each of groups of the records, wherein each of the groups consists of the records having the identical unique code identifications and the identical memory sizes (205, 206);</claim-text>
<claim-text>selecting the groups having the numbers of the records being equal either to the repetition number or to the repetition number multiplied by any integer number greater than one (207); and</claim-text>
<claim-text>identifying the fragment of the executable code having unique code identification stored in the record of one of the selected groups as a fragment of the executable code which execution causes the memory leak and/or identifying the fragment of the source code having the unique code identification stored in the record of the one of the selected groups as a fragment of the source code having the respective fragment of the executable code which execution causes the memory leak (208).</claim-text></claim-text></claim><claim id="ac-en-0002" num="0002"><claim-text>The computer-implemented method of claim 1, wherein the source code comprises call commands, each of the call commands has a unique respective executable call command of the executable code, each of the dynamic memory allocation requests has a respective unique dynamic memory allocation command of the source code, execution of each of the executable call commands causes execution of a fragment of the executable code specified in the each of the executable call commands, wherein the execution of each of the executable call commands causes interruption of a sequentially ordered execution of the executable code and after execution of the respective portion of the executable code the sequentially ordered execution of the executable code is resumed, each of some of the fragments of the executable code specified in their respective call requests comprises one or more of the dynamic memory allocation requests, each of some the fragments of the executable code specified in their respective call requests comprises at least one of the call requests, wherein each of the call commands has a respective unique line identification in the source code, wherein each of the dynamic memory allocation commands has a respective unique line identification in the source code, wherein each of the unique code identifications comprises the unique line identification of the dynamic memory allocation command having the respective dynamic memory allocation request which execution has caused the generation of the record comprising the each of the unique code identifications, wherein each of the unique code identifications further comprises all unique line identifications of the call commands having their respective executable call commands which have caused execution of their respective portions of the executable code being partially executed during execution of the respective dynamic memory allocation request which execution has caused the generation of the record comprising the each of the unique code identifications.</claim-text></claim><claim id="ac-en-0003" num="0003"><claim-text>The computer-implemented method of claim 2, wherein the source code is split in code modules (302, 303), wherein each of the code modules (302, 303) has a unique name identification (300), wherein each of the call commands has a respective unique line number (301) in the respective code module (302, 303) comprising the each of the call commands, wherein the unique line identification of each of the call commands comprises the respective unique line number (301) of the each of the call commands and the unique name identification of the respective code module (302, 303) comprising the each of the call commands, wherein each of the dynamic memory allocation commands has a respective unique line number in the respective code module comprising the each of the dynamic memory allocation commands, wherein the unique line identification of each of the dynamic memory allocation commands comprises the respective unique line number (301) of the each of the dynamic memory allocation commands and the unique name identification (300) of the respective code module (302, 303) comprising the each of the dynamic memory allocation commands.</claim-text></claim><claim id="ac-en-0004" num="0004"><claim-text>The computer-implemented method of any one of the preceding claims, wherein the generating of the records and the deleting of the records is executed only during the repetitive execution.</claim-text></claim><claim id="ac-en-0005" num="0005"><claim-text>The computer-implemented method of any one of the preceding claims,<br/>
wherein the executing of the executable code is executed in a software environment configured in a multilayered software architecture comprising an application software layer, a leak detection software layer, and an operating system software layer, the executing of the executable code is performed in the application software layer, the leak detection software layer is allocated in between the application software layer and the operating system software layer, the leak detection software layer is configured to perform the generating of the respective record upon execution of each of the dynamic memory allocation request and to perform the deleting the record to be deleted upon execution of the respective dynamic memory deallocation request.</claim-text></claim><claim id="ac-en-0006" num="0006"><claim-text>The computer-implemented method of claim 5, wherein the repetitive executing of the at least of the portion of the executable code is performed in a software driven test mode by a test software operating in the application software layer.</claim-text></claim><claim id="ac-en-0007" num="0007"><claim-text>A computer system (105) comprising a main memory (101) and a computer processor (100), wherein the computer processor is configured to perform the following:
<claim-text>starting executing an executable code (200);</claim-text>
<claim-text>repetitively executing at least a portion of the executable code (201, 204), the least a portion of the executable code comprising dynamic memory allocation requests and dynamic memory deallocation requests, wherein a repetition number of the repetitive executions is an integer value greater than one;</claim-text>
<claim-text>in response to execution of each of the dynamic memory allocation requests of the at least a portion of the executable code generating a record (202), each of the records comprising a unique memory identification of a unique portion of the main memory dynamically allocated upon the execution of the each of the dynamic memory allocation requests and a unique code identification of a fragment of the executable code and/or of a fragment of a source code (303) corresponding to the fragment of the executable code, wherein execution of the fragment of the executable code causes the execution of the each of the dynamic memory allocation requests, wherein the executable code is generated from the source code, wherein each of the unique memory identifications comprises a memory size of the respective unique portion of the main memory, wherein each of the unique memory identifications further comprises a memory address of the respective unique portion of the main memory;</claim-text>
<claim-text>in response to execution of each of the dynamic memory deallocation requests of the at least a portion of the executable code deleting one of the records if the one of the records comprises the unique memory identification as specified in the each of the dynamic memory deallocation requests (203);</claim-text>
<claim-text>after completion of the repetitive executing (204), counting numbers of the records in each of groups of the records, wherein each of the groups consists of the records having the identical unique code identifications and the identical memory sizes (205, 206);</claim-text>
<claim-text>selecting the groups having the numbers of the records being equal either to the repetition number or to the repetition number multiplied by any integer number greater than one (207); and</claim-text>
<claim-text>identifying the fragment of the executable code having unique code identification stored in the record of one of the selected groups as a fragment of the executable code which execution causes the memory leak and/or identifying the fragment of the source code having the unique code identification stored in the record of the one of the selected groups as a fragment of the source code having the respective fragment of the executable code which execution causes the memory leak (208).</claim-text></claim-text></claim><claim id="ac-en-0008" num="0008"><claim-text>The computer system of claim 7, wherein the source code comprises call commands, each of the call commands has a unique respective executable call command of the executable code, each of the dynamic memory allocation requests has a respective unique dynamic memory allocation command of the source code, execution of each of the executable call commands causes execution of a fragment of the executable code specified in the each of the executable call commands, wherein the execution of each of the executable call commands causes interruption of a sequentially ordered execution of the executable code and after execution of the respective portion of the executable code the sequentially ordered execution of the executable code is resumed, each of some of the fragments of the executable code specified in their respective call requests comprises one or more of the dynamic memory allocation requests, each of some the fragments of the executable code specified in their respective call requests comprises at least one of the call requests, wherein each of the call commands has a respective unique line identification in the source code, wherein each of the dynamic memory allocation commands has a respective unique line identification in the source code, wherein each of the unique code identifications comprises the unique line identification of the dynamic memory allocation command having the respective dynamic memory allocation request which execution has caused the generation of the record comprising the each of the unique code identifications, wherein each of the unique code identifications further comprises all unique line identifications of the call commands having their respective executable call commands which have caused execution of their respective portions of the executable code being partially executed during execution of the respective dynamic memory allocation request which execution has caused the generation of the record comprising the each of the unique code identifications.</claim-text></claim><claim id="ac-en-0009" num="0009"><claim-text>The computer system of claim 8, wherein the source code is split in code modules (302, 303), wherein each of the code modules (302, 303) has a unique name identification (300), wherein each of the call commands has a respective unique line number (301) in the respective code module (302, 303) comprising the each of the call commands, wherein the unique line identification of each of the call commands comprises the respective unique line number (301) of the each of the call commands and the unique name identification of the respective code module (302, 303) comprising the each of the call commands, wherein each of the dynamic memory allocation commands has a respective unique line number in the respective code module comprising the each of the dynamic memory allocation commands, wherein the unique line identification of each of the dynamic memory allocation commands comprises the respective unique line number (301) of the each of the dynamic memory allocation commands and the unique name identification (300) of the respective code module (302, 303) comprising the each of the dynamic memory allocation commands.</claim-text></claim><claim id="ac-en-0010" num="0010"><claim-text>The computer system of one of the claims 7-9, the generating of the records and the deleting of the records is executed only during the repetitive execution..</claim-text></claim><claim id="ac-en-0011" num="0011"><claim-text>The computer system of one of the claims 7-10, wherein the executing of the executable code is executed in a software environment on the computer system, the software environment is configured in a multilayered software architecture comprising an application software layer, a leak detection software layer, and an operating system software layer, the executing of the executable code is performed in the application software layer, the leak detection software layer is allocated in between the application software layer and the operating system software layer, the leak detection software layer is configured to perform the generating of the respective record upon execution of each of the dynamic memory allocation request and to perform the deleting the record to be deleted upon execution of the respective dynamic memory deallocation request.</claim-text></claim><claim id="ac-en-0012" num="0012"><claim-text>The computer system of claim 11, wherein the repetitive executing of the at least of the portion of the executable code is performed in a software driven test mode by a test software operating in the application software layer.</claim-text></claim><claim id="ac-en-0013" num="0013"><claim-text>A computer readable medium having stored thereon a computer executable code for execution by a computer processor (100) controlling a computer system (105) comprising a main memory (101), wherein execution of the instructions of the executable code causes the computer processor to execute a computer-implemented method of claims 1-6 on the computer system.</claim-text></claim></amended-claims><drawings mxw-id="PDW20422213" load-source="patent-office"><!-- EPO <DP n="29"> --><figure id="f0001" num="1,2"><img id="if0001" file="imgf0001.tif" wi="151" he="184" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="30"> --><figure id="f0002" num="3"><img id="if0002" file="imgf0002.tif" wi="163" he="181" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="31"> --><figure id="f0003" num="4,5,6"><img id="if0003" file="imgf0003.tif" wi="135" he="213" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="32"> --><figure id="f0004" num="7"><img id="if0004" file="imgf0004.tif" wi="144" he="213" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="33"> --><figure id="f0005" num="8"><img id="if0005" file="imgf0005.tif" wi="165" he="188" img-content="drawing" img-format="tif"/></figure></drawings><search-report-data><doc-page id="srep0001" file="srep0001.tif" wi="159" he="233" type="tif"/><doc-page id="srep0002" file="srep0002.tif" wi="159" he="233" type="tif"/></search-report-data><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
