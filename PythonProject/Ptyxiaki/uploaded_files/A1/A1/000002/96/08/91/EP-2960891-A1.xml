<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2960891-A1" country="EP" doc-number="2960891" kind="A1" date="20151230" family-id="53434250" file-reference-id="317925" date-produced="20180824" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="160451440" ucid="EP-2960891-A1"><document-id><country>EP</country><doc-number>2960891</doc-number><kind>A1</kind><date>20151230</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-15172249-A" is-representative="YES"><document-id mxw-id="PAPP193865848" load-source="patent-office" format="original"><country>EP</country><doc-number>15172249.3</doc-number><date>20150616</date><lang>EN</lang></document-id><document-id mxw-id="PAPP193865849" load-source="docdb" format="epo"><country>EP</country><doc-number>15172249</doc-number><kind>A</kind><date>20150616</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC162029101" ucid="US-2014313402-W" linkage-type="A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>2014313402</doc-number><kind>W</kind><date>20140624</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1988519959" load-source="docdb">G09C   1/00        20060101AFI20151110BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1946264703" load-source="docdb" scheme="CPC">H04L   9/3226      20130101 LI20160425BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987771063" load-source="docdb" scheme="CPC">G09C   1/00        20130101 FI20151102BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987797647" load-source="docdb" scheme="CPC">H04L2209/16        20130101 LA20151102BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987800576" load-source="docdb" scheme="CPC">H04L2209/603       20130101 LA20151102BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT165545786" lang="DE" load-source="patent-office">VERFAHREN ZUR EINFÜHRUNG DER ABHÄNGIGKEIT EINER WHITE-BOX-IMPLEMENTATION AUF EINEN SATZ VON STRINGS</invention-title><invention-title mxw-id="PT165545787" lang="EN" load-source="patent-office">METHOD FOR INTRODUCING DEPENDENCE OF WHITE-BOX IMPLEMENTATIONON A SET OF STRINGS</invention-title><invention-title mxw-id="PT165545788" lang="FR" load-source="patent-office">PROCÉDÉ PERMETTANT D'INTRODUIRE LA DÉPENDANCE D'IMPLÉMENTATION D'UNE BOÎTE BLANCHE SUR UN ENSEMBLE DE CHAÎNES</invention-title><citations><patent-citations><patcit mxw-id="PCIT356617717" load-source="docdb" ucid="US-20070014394-A1"><document-id format="epo"><country>US</country><doc-number>20070014394</doc-number><kind>A1</kind><date>20070118</date></document-id><sources><source name="APP" created-by-npl="N"/><source name="SEA" category="YD" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT371137737" load-source="docdb" ucid="US-20120163582-A1"><document-id format="epo"><country>US</country><doc-number>20120163582</doc-number><kind>A1</kind><date>20120628</date></document-id><sources><source name="SEA" category="XYI" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT377492061" load-source="docdb" ucid="US-201414263429-A" dnum-type="application"><document-id format="epo"><country>US</country><doc-number>201414263429</doc-number><kind>A</kind><date>20140428</date></document-id><sources><source name="APP" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT371137738" load-source="docdb" ucid="US-8479016-B2"><document-id format="epo"><country>US</country><doc-number>8479016</doc-number><kind>B2</kind><date>20130702</date></document-id><sources><source name="APP" created-by-npl="N"/><source name="SEA" category="XDYI" created-by-npl="N"/></sources></patcit></patent-citations><non-patent-citations><nplcit><text>STANLEY CHOW; PHIL EISEN; HAROLD JOHNSON; PAUL C. VAN OORSCHOT: "A White-Box DES Implementation for DRM Applications", DIGITAL RIGHTS MANAGEMENT: ACM CCS-9 WORKSHOP, DRM 2002, 18 November 2002 (2002-11-18)</text><sources><source mxw-id="PNPL57906865" load-source="docdb" name="APP"/></sources></nplcit><nplcit><text>STANLEY CHOW; PHILIP EISEN; HAROLD JOHNSON; PAUL C. VAN OORSCHOT: "White-Box Cryptography and an AES Implementation", SELECTED AREAS IN CRYPTOGRAPHY: 9TH ANNUAL INTERNATIONAL WORKSHOP, SAC 2002, 15 August 2002 (2002-08-15)</text><sources><source mxw-id="PNPL57906866" load-source="docdb" name="APP"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR1103311725" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>NXP BV</last-name><address><country>NL</country></address></addressbook></applicant><applicant mxw-id="PPAR1103338033" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>NXP B.V.</last-name></addressbook></applicant><applicant mxw-id="PPAR1101649739" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>NXP B.V.</last-name><iid>101007059</iid><address><street>High Tech Campus 60</street><city>5656 AE Eindhoven</city><country>NL</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR1103304183" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>MICHIELS WILHELMUS PETRUS ADRIANUS JOHANNUS</last-name><address><country>NL</country></address></addressbook></inventor><inventor mxw-id="PPAR1103331995" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>MICHIELS, WILHELMUS PETRUS ADRIANUS JOHANNUS</last-name></addressbook></inventor><inventor mxw-id="PPAR1101642551" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>MICHIELS, WILHELMUS PETRUS ADRIANUS JOHANNUS</last-name><address><street>Hich Tech Campus 46-255</street><city>5656AG EINDHOVEN</city><country>NL</country></address></addressbook></inventor><inventor mxw-id="PPAR1103343748" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>HOOGERBRUGGE JAN</last-name><address><country>NL</country></address></addressbook></inventor><inventor mxw-id="PPAR1103308353" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>HOOGERBRUGGE, JAN</last-name></addressbook></inventor><inventor mxw-id="PPAR1101647645" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>HOOGERBRUGGE, JAN</last-name><address><street>High Tech Campus 46</street><city>5656AG EINDHOVEN</city><country>NL</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR1101644474" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Krott, Michel</last-name><iid>101402860</iid><address><street>NXP B.V. Intellectual Property &amp; Licensing High Tech Campus 60</street><city>5656 AG Eindhoven</city><country>NL</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS660783321" load-source="docdb">AL</country><country mxw-id="DS660610060" load-source="docdb">AT</country><country mxw-id="DS660783323" load-source="docdb">BE</country><country mxw-id="DS660687222" load-source="docdb">BG</country><country mxw-id="DS660684867" load-source="docdb">CH</country><country mxw-id="DS660610189" load-source="docdb">CY</country><country mxw-id="DS660610061" load-source="docdb">CZ</country><country mxw-id="DS660606419" load-source="docdb">DE</country><country mxw-id="DS660783324" load-source="docdb">DK</country><country mxw-id="DS660610190" load-source="docdb">EE</country><country mxw-id="DS660684770" load-source="docdb">ES</country><country mxw-id="DS660687231" load-source="docdb">FI</country><country mxw-id="DS660687232" load-source="docdb">FR</country><country mxw-id="DS660783325" load-source="docdb">GB</country><country mxw-id="DS660783326" load-source="docdb">GR</country><country mxw-id="DS660783327" load-source="docdb">HR</country><country mxw-id="DS660610199" load-source="docdb">HU</country><country mxw-id="DS660684868" load-source="docdb">IE</country><country mxw-id="DS660783328" load-source="docdb">IS</country><country mxw-id="DS660687233" load-source="docdb">IT</country><country mxw-id="DS660610200" load-source="docdb">LI</country><country mxw-id="DS660606420" load-source="docdb">LT</country><country mxw-id="DS660610062" load-source="docdb">LU</country><country mxw-id="DS660606421" load-source="docdb">LV</country><country mxw-id="DS660606422" load-source="docdb">MC</country><country mxw-id="DS660689773" load-source="docdb">MK</country><country mxw-id="DS660689774" load-source="docdb">MT</country><country mxw-id="DS660687234" load-source="docdb">NL</country><country mxw-id="DS660684775" load-source="docdb">NO</country><country mxw-id="DS660687239" load-source="docdb">PL</country><country mxw-id="DS660684776" load-source="docdb">PT</country><country mxw-id="DS660687240" load-source="docdb">RO</country><country mxw-id="DS660684777" load-source="docdb">RS</country><country mxw-id="DS660687241" load-source="docdb">SE</country><country mxw-id="DS660689783" load-source="docdb">SI</country><country mxw-id="DS660684869" load-source="docdb">SK</country><country mxw-id="DS660684870" load-source="docdb">SM</country><country mxw-id="DS660606424" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA166479810" lang="EN" load-source="patent-office"><p id="pa01" num="0001">A method of performing a cryptographic operation using a cryptographic implementation in a cryptographic system, including: receiving, by the cryptographic system, an identifying string value; receiving, by the cryptographic system, an input message; performing, by the cryptographic system, a keyed cryptographic operation mapping the input message into an output message wherein the output message is the correct result when the indentifying string value is one of a set of binding string values, wherein the set includes a plurality ofbinding string values.
<img id="iaf01" file="imgaf001.tif" wi="93" he="97" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA166759622" lang="EN" source="EPO" load-source="docdb"><p>A method of performing a cryptographic operation using a cryptographic implementation in a cryptographic system, including: receiving, by the cryptographic system, an identifying string value; receiving, by the cryptographic system, an input message; performing, by the cryptographic system, a keyed cryptographic operation mapping the input message into an output message wherein the output message is the correct result when the indentifying string value is one of a set of binding string values, wherein the set includes a plurality ofbinding string values.</p></abstract><description mxw-id="PDES98404511" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><b>RELATED APPLICATION</b></heading><p id="p0001" num="0001">This patent application is related to <patcit id="pcit0001" dnum="US263429A"><text>U.S. Patent Application No. 14/263,429</text></patcit>, entitled "METHOD FOR INCLUDING AN IMPLICIT INTEGRITY OR AUTHENTICITY CHECK INTO A WHITE-BOX IMPLEMENTATION" to Michiels et al. (hereinafter "related application").</p><heading id="h0002"><b>TECHNICAL FIELD</b></heading><p id="p0002" num="0002">Various exemplary embodiments disclosed herein relate generally to a method for introducing dependence of a white-box implementation on a set of strings.</p><heading id="h0003"><b>BACKGROUND</b></heading><p id="p0003" num="0003">The Internet provides users with convenient and ubiquitous access to digital content. Because the Internet is a powerful distribution channel, many user devices strive to directly access the Internet. The user devices may include a personal computer, laptop computer, set-top box, internet enabled media player, mobile telephone, smart phone, tablet, mobile hotspot, or any other device that is capable of accessing the Internet. The use of the Internet as a distribution medium for copyrighted content creates the compelling challenge to secure the interests of the content provider. Increasingly, user devices operate using a processor loaded with suitable software to render (playback) digital content, such as audio and/or video. Control of the playback software is one way to enforce the interests of the content owner including the terms and conditions under which the content may be used. Previously many user devices were closed systems. Today more and more platforms are partially open. Some users may be assumed to have complete control over and access to the hardware and software that provides access to the content and a large amount of time and resources to attack and bypass any content protection mechanisms. As a consequence, content providers must deliver content to legitimate users across a hostile network to a community where not all users or user devices can be trusted.</p><p id="p0004" num="0004">Secure software applications may be called upon to carry out various functions such as, for example, cryptographic functions used to protect and authenticate digital content.<!-- EPO <DP n="2"> --> In order to counter attacks, these algorithms have to be obfuscated (hidden) in order to prevent reverse engineering and modification of the algorithm or prohibit obtaining the user-specific secure information. Accordingly, the functions of the secure software application may be carried out by various functions as defined by the instruction set of the processor implementing the secure software. For example, one way to obscure these functions is by the use of lookup tables.</p><p id="p0005" num="0005">The widespread use of digital rights management (DRM) and other secure software has given rise to the need for secure, tamper-resistant software that seeks to complicate tampering with the software. Various techniques for increasing the tamper resistance of software applications exist. Most of these techniques are based on hiding the embedded knowledge of the application by adding a veil of randomness and complexity in both the control and the data path of the software application. The idea behind this is that it becomes more difficult to extract information merely by code inspection. It is therefore more difficult to find the code that, for example, handles access and permission control of the secure application, and consequently to change it.</p><p id="p0006" num="0006">As used herein, white-box cryptography includes a secure software application that performs cryptographic functions in an environment where an attacker has complete control of the system running the white-box cryptography software. Thus, the attacker can modify inputs and outputs, track the operations of the software, sample and monitor memory used by the software at any time, and even modify the software. Accordingly, the secure functions need to be carried out in a manner that prevents the disclosure of secret information used in the secure functionality. White-box cryptography functions may be implemented in various ways. Such methods include: obscuring the software code; using complex mathematical functions that obscure the use of the secret information; using look-up tables; using finite state machines; or any other methods that carry out cryptographic functions but hide the secret information needed for those secure functions. A white-box implementation may also contain components that include anti-debugging and tamper-proofing properties.</p><p id="p0007" num="0007">There are several reasons for preferring a software implementation of a cryptographic algorithm to a hardware implementation. This may, for instance, be the case because a software solution is renewable if the keys leak out, because it is has lower cost, or<!-- EPO <DP n="3"> --> because the application-developer has no influence on the hardware where the white-box system is implemented.</p><heading id="h0004"><b>SUMMARY</b></heading><p id="p0008" num="0008">A brief summary of various exemplary embodiments is presented below. Some simplifications and omissions may be made in the following summary, which is intended to highlight and introduce some aspects of the various exemplary embodiments, but not to limit the scope of the invention. Detailed descriptions of an exemplary embodiment adequate to allow those of ordinary skill in the art to make and use the inventive concepts will follow in later sections.</p><p id="p0009" num="0009">Various exemplary embodiments relate to a non-transitory machine-readable storage medium encoded with instructions for execution by a cryptographic implementation in a cryptographic system for performing a cryptographic operation, the non-transitory machine-readable storage medium including: instructions for receiving, by the cryptographic system, an identifying string value; instructions for receiving, by the cryptographic system, an input message; instructions for performing, by the cryptographic system, a keyed cryptographic operation mapping the input message into an output message wherein the output message is the correct result when the indentifying string value is one of a set of binding string values, wherein the set includes a plurality of binding string values.</p><p id="p0010" num="0010">Various embodiments are described wherein there are input messages for which the output message is an incorrect result when the indentifying string is not in the set of binding string values.</p><p id="p0011" num="0011">Various embodiments are described wherein the indentifying string value is based upon an identification of the cryptographic implementation.</p><p id="p0012" num="0012">Various embodiments are described wherein the indentifying string value is based upon a hash of a portion of code in the cryptographic system.</p><p id="p0013" num="0013">Various embodiments are described wherein the indentifying string value is based upon an identification of the cryptographic system.</p><p id="p0014" num="0014">Various embodiments are described wherein the indentifying string value is based upon a user password.<!-- EPO <DP n="4"> --></p><p id="p0015" num="0015">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and the non-transitory machine-readable storage medium further includes: instructions for encoding an output of the first function based upon the indentifying string value; and instructions for performing the second function on the encoded output of the first function wherein the second function includes decoding the encoded output of the first function using the set of binding string values.</p><p id="p0016" num="0016">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and the non-transitory machine-readable storage medium further includes: instructions for encoding an output of the first function using the set of binding string values; and instructions for performing the second function on the encoded output of the first function wherein the second function includes decoding the encoded output of the first function based upon the indentifying string value.</p><p id="p0017" num="0017">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and the non-transitory machine-readable storage medium further includes: instructions for perturbing an output of the first function using the indentifying string value; and instructions for performing the second function on the perturbed output of the first function wherein the second function includes compensating for the perturbation of the output of the first function using the set of binding string values.</p><p id="p0018" num="0018">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and the non-transitory machine-readable storage medium further includes: instructions for introducing a perturbation in the calculation of the first function based upon the identifying string value; instructions for compensating for the perturbation in the calculation of the first function during calculation of the second function based upon the set of binding string values.</p><p id="p0019" num="0019">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and the non-transitory machine-readable storage medium further includes: instructions for introducing a<!-- EPO <DP n="5"> --> perturbation in the calculation of the first function based upon the set of binding string values; instructions for compensating for the perturbation in the calculation of the first function during calculation of the second function based upon the identifying string value.</p><p id="p0020" num="0020">Various embodiments are described wherein the cryptographic system includes a network of finite state machines.</p><p id="p0021" num="0021">Various embodiments are described wherein the cryptographic system includes a network of lookup tables.</p><p id="p0022" num="0022">Various embodiments are described wherein the cryptographic operation is one of advanced encryption system (AES) or data encryption standard (DES).</p><p id="p0023" num="0023">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and the non-transitory machine-readable storage medium further includes: instructions for modifying the first function based upon the indentifying string value.</p><p id="p0024" num="0024">Various embodiments are described wherein the first function is a plurality of instructions, and modifying the first function based upon the identifying string value includes producing a modifying string value based upon the identifying string value and wherein a portion of the plurality of instructions is implemented using the modifying string value.</p><p id="p0025" num="0025">Further, various exemplary embodiments relate to a method of producing a cryptographic implementation of a cryptographic operation mapping an input message to an output message in a cryptographic system that binds the cryptographic implementation to a binding string value, including: receiving information specifying a set of binding string values; modifying a cryptographic implementation to receive an indentifying string value; modifying the cryptographic implementation based upon the received information specifying the set of binding string values so that: when a received indentifying string value is one of the set of binding string values, the cryptographic implementation outputs a correct output message.</p><p id="p0026" num="0026">Various embodiments are described wherein when a received indentifying string value is not one of the set of binding string values, the cryptographic implementation outputs an incorrect output message.<!-- EPO <DP n="6"> --></p><p id="p0027" num="0027">Various embodiments are described wherein the indentifying string value is based upon an identification of the cryptographic implementation.</p><p id="p0028" num="0028">Various embodiments are described wherein the indentifying string value is based upon a hash of a portion of the cryptographic implementation.</p><p id="p0029" num="0029">Various embodiments are described wherein the indentifying string value is based upon an identification of the cryptographic system.</p><p id="p0030" num="0030">Various embodiments are described wherein the indentifying string value is based upon a user password.</p><p id="p0031" num="0031">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and modifying the cryptographic implementation so that: the output of one of the first function is encoded based upon the indentifying string value; and a second function is performed on the encoded output of the first function wherein the second function includes decoding the encoded output of the first function using the set of binding string values.</p><p id="p0032" num="0032">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and modifying the cryptographic implementation so that: the output of one of the first function is encoded based upon the set of binding string values; and a second function is performed on the encoded output of the first function wherein the second function includes decoding the encoded output of the first function based upon the indentifying string value.</p><p id="p0033" num="0033">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and modifying the cryptographic implementation so that: the output of one of the first function is perturbed using the indentifying string value; and a second function is performed on the encoded output of the first function wherein the second function includes compensating for the perturbation of the output of the first function using the set of binding string values.</p><p id="p0034" num="0034">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and modifying the cryptographic implementation so that: a perturbation is introduced in the calculation of the first function based upon the identifying string value; and the perturbation in the calculation<!-- EPO <DP n="7"> --> of the first function is compensated for during calculation of the second function based upon the set of binding string values.</p><p id="p0035" num="0035">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and modifying the cryptographic implementation so that: a perturbation is introduced in the calculation of the first function based upon the set of binding string values; the perturbation in the calculation of the first function is compensated for during calculation of the second function based upon the identifying string value.</p><p id="p0036" num="0036">Various embodiments are described wherein the cryptographic system includes a network of finite state machines.</p><p id="p0037" num="0037">Various embodiments are described wherein the cryptographic system includes a network of lookup tables.</p><p id="p0038" num="0038">Various embodiments are described wherein the cryptographic operation is one of advanced encryption system (AES) or data encryption standard (DES).</p><p id="p0039" num="0039">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function, and modifying the cryptographic implementation so that: the first function is based upon the indentifying string value.</p><p id="p0040" num="0040">Various embodiments are described wherein the first function is a plurality of instructions, and modifying the cryptographic implementation so that the first function is based upon the identifying string value includes producing a modifying string value based upon the identifying string value and wherein a portion of the plurality of instructions is implemented using the modifying string value.</p><p id="p0041" num="0041">Further, various exemplary embodiments relate to a method of performing a cryptographic operation using a cryptographic implementation in a cryptographic system, including: receiving, by the cryptographic system, an identifying string value; receiving, by the cryptographic system, an input message; performing, by the cryptographic system, a keyed cryptographic operation mapping the input message into an output message wherein the output message is the correct result when the indentifying string value is one of a set of binding string values, wherein the set includes a plurality of binding string values.<!-- EPO <DP n="8"> --></p><p id="p0042" num="0042">Various embodiments are described wherein there are input messages for which the output message is an incorrect result when the indentifying string is not in the set of binding string values.</p><p id="p0043" num="0043">Various embodiments are described wherein the indentifying string value is based upon an identification of the cryptographic implementation.</p><p id="p0044" num="0044">Various embodiments are described wherein the indentifying string value is based upon a hash of a portion of code in the cryptographic system.</p><p id="p0045" num="0045">Various embodiments are described wherein the indentifying string value is based upon an identification of the cryptographic system.</p><p id="p0046" num="0046">Various embodiments are described wherein the indentifying string value is based upon a user password.</p><p id="p0047" num="0047">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and the method further includes: encoding an output of the first function based upon the indentifying string value; and performing the second function on the encoded output of the first function wherein the second function includes decoding the encoded output of the first function using the set of binding string values.</p><p id="p0048" num="0048">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and the method further includes: encoding an output of the first function using the set of binding string values; and performing the second function on the encoded output of the first function wherein the second function includes decoding the encoded output of the first function based upon the indentifying string value.</p><p id="p0049" num="0049">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and a second function, and the method further includes: perturbing an output of the first function using the indentifying string value; and performing the second function on the perturbed output of the first function wherein the second function includes compensating for the perturbation of the output of the first function using the set of binding string values.<!-- EPO <DP n="9"> --></p><p id="p0050" num="0050">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and the method further includes: introducing a perturbation in the calculation of the first function based upon the identifying string value; compensating for the perturbation in the calculation of the first function during calculation of the second function based upon the set of binding string values.</p><p id="p0051" num="0051">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and the method further includes: introducing a perturbation in the calculation of the first function based upon the set of binding string values; compensating for the perturbation in the calculation of the first function during calculation of the second function based upon the identifying string value.</p><p id="p0052" num="0052">Various embodiments are described wherein the cryptographic system includes a network of finite state machines.</p><p id="p0053" num="0053">Various embodiments are described wherein the cryptographic system includes a network of lookup tables.</p><p id="p0054" num="0054">Various embodiments are described wherein the cryptographic operation is one of advanced encryption system (AES) or data encryption standard (DES).</p><p id="p0055" num="0055">Various embodiments are described wherein the cryptographic implementation includes a plurality of functions including a first function, and the method further includes: modifying the first function based upon the indentifying string value.</p><p id="p0056" num="0056">Various embodiments are described wherein the first function is a plurality of instructions, and modifying the first function based upon the identifying string value includes producing a modifying string value based upon the identifying string value and wherein a portion of the plurality of instructions is implemented using the modifying string value.</p><heading id="h0005"><b>BRIEF DESCRIPTION OF THE DRAWINGS</b></heading><p id="p0057" num="0057">In order to better understand various exemplary embodiments, reference is made to the accompanying drawings, wherein:
<ul><li><figref idrefs="f0001">FIG. 1</figref> illustrates the main steps of a round of AES;<!-- EPO <DP n="10"> --></li><li><figref idrefs="f0001">FIG. 2</figref> illustrates a white-box AES implementation with encodings on the input of the rounds;</li><li><figref idrefs="f0002">FIG. 3</figref> illustrates the computation of one output nibble by means of a network of look-up tables;</li><li><figref idrefs="f0002">FIG. 4</figref> illustrates a portion of the network table of <figref idrefs="f0002">FIG. 3</figref> obfuscated by encoding the inputs and outputs; and</li><li><figref idrefs="f0003">FIG. 5</figref> illustrates a first embodiment of binding a white-box implementation;</li><li><figref idrefs="f0003">FIG. 6</figref> illustrates the application of obfuscation to the white-box implementation of <figref idrefs="f0003">FIG. 5</figref>;</li><li><figref idrefs="f0004">FIG. 7</figref> illustrates a second embodiment of binding a white-box implementation; and</li><li><figref idrefs="f0004">FIG. 8</figref> is a flow chart illustrating a method of binding a white-box implementation to a set of binding strings.</li></ul></p><p id="p0058" num="0058">To facilitate understanding, identical reference numerals have been used to designate elements having substantially the same or similar structure and/or substantially the same or similar function.</p><heading id="h0006"><b>DETAILED DESCRIPTION</b></heading><p id="p0059" num="0059">The description and drawings illustrate the principles of the invention. It will thus be appreciated that those skilled in the art will be able to devise various arrangements that, although not explicitly described or shown herein, embody the principles of the invention and are included within its scope. Furthermore, all examples recited herein are principally intended expressly to be for pedagogical purposes to aid the reader in understanding the principles of the invention and the concepts contributed by the inventor(s) to furthering the art, and are to be construed as being without limitation to such specifically recited examples and conditions. Additionally, the term, "or," as used herein, refers to a non-exclusive or (<i>i.e.,</i> and/or), unless otherwise indicated (<i>e.g.,</i> "or else" or "or in the alternative"). Also, the various embodiments described herein are not necessarily mutually exclusive, as some embodiments can be combined with one or more other embodiments to form new embodiments.</p><p id="p0060" num="0060">Code lifting is a problem that may arise with a software implementation of cryptographic algorithm. This problem may be overcome by binding the white-box<!-- EPO <DP n="11"> --> implementation to an arbitrary given string s, <i>i.e.,</i> the white-box implementation only works properly if the string <i>s</i> is available. Binding the white-box implementation to a string s, may be used to implement node locking, software tamper resistance, user binding, and traitor tracing. The problem of code lifting may arise because a software implementation of a cryptographic algorithm may be copied and used on unauthorized nodes or by unauthorized users. Accordingly, a white-box implementation, although it may effectively hide a cryptographic key, may still be distributed as a whole. This white-box implementation may be as valuable as the key itself. If, for instance, the white-box implementation implements a decryption algorithm, then by not having the key, the receiver may not be able to encrypt, but the white-box implementation is sufficient to decrypt. This means that an adversary illegitimately distributes the white-box implementation as a whole instead of the underlying hidden cryptographic key, which typically is of high value that should not be distributed in an uncontrolled way. Typically, the key is only present implicitly. In other embodiments, the key may include dynamic keys that, for example, take implicit key information and change it with some sort of dynamic information to change the key used in the cryptographic function.</p><p id="p0061" num="0061">As mentioned above the use of an arbitrary given string <i>s</i> may be used to overcome these problems. A solution for using an arbitrary given string <i>s</i> is described in <patcit id="pcit0002" dnum="US8479016B"><text>U.S. Patent No. 8,479,016 to Michiels</text></patcit> ("Michiels"). The string <i>s</i> may be some binary string that may be derived from the device on which the white-box implementation should be running and that cannot be derived on other devices. For instance, <i>s</i> may be defined as a unique identifier of the device. In Michiels a white-box implementation is derived containing <i>s</i>, and this white-box implementation is placed on the device where the string <i>s</i> is omitted where the string is part of a lookup table or operational code used in the white-box implementation. As a result, the device can only execute the white-box implementation once it can derive the omitted string <i>s</i> and then uses the value of <i>s</i> when the table entry is requested that was omitted or to provide the correct instruction in the operational code, <i>i.e.,</i> the white-box implementation can only be executed on the legitimate device.</p><p id="p0062" num="0062">In the related application, embodiments are described that implement an alternative approach for binding a white-box implementation to an arbitrary string <i>s</i> other than including it in the definition of a lookup table. Instead the string <i>s</i> is a parameter of a function<!-- EPO <DP n="12"> --> of the white-box implementation, <i>i.e.,</i> the string <i>s</i> is not used for the specification of the function (<i>e.g.,</i> a lookup table or operational code) as in Michiels, but rather as a parameter of the function.</p><p id="p0063" num="0063">In the related application, a method for binding a white-box implementation to an arbitrary string <i>s</i> is described. This description is included below. Then the embodiments of Michiels and the related application will be extended to allow binding of the white-box implementation to a plurality of strings.</p><p id="p0064" num="0064">Any strings <i>s</i> that represent the integrity or authenticity of the system that the white-box implementation runs on may be used. If, for instance, <i>s</i> is the hash of some code fragment, then it hardens the software against tampering. Also, the string <i>s</i> may be used for node locking where <i>s</i> is the unique identification of a node or hardware in the white-box system. Another use-case for the string <i>s</i> is traitor tracing. If the string is the name of the legitimate owner of a white-box implementation, and if this white-box implementation is encountered on an illegitimate device or on the Internet, then the white-box implementation may be traced back to the source of the leakage. Further, <i>s</i> may be used to identify users by being associated with a user password or hash of a user password.</p><p id="p0065" num="0065">Both the related application and Michiels describe a method of making the correct functioning of a white-box implementation dependent on an arbitrary given string s. This may be used to solve the above problem of code lifting in the following way. Let the string <i>s</i> be some binary string that may be derived from the device on which the white-box implementation should be running and that cannot be derived on other devices. For instance, <i>s</i> may be defined as a unique identifier of the device. Next, the approach of the related application or Michiels is used to make the white-box implementation dependent on <i>s</i>. Then the obtained white-box implementation may be installed on a device, where string <i>s</i> is omitted. Then, the device may only execute the white-box implementation once the device can derive the omitted string <i>s</i>, <i>i.e.,</i> the white-box implementation may only be executed on the legitimate device. Analogously, the white-box implementation may be bound to a person by letting the string <i>s</i> be a password or a (digitized) fingerprint.</p><p id="p0066" num="0066">A property of both approaches is that once the white-box implementation is derived, there is no longer a choice in the string <i>s</i> that needs to be provided to the<!-- EPO <DP n="13"> --> implementation in order for it to work properly: that is, it works properly for all messages if and only if string <i>s</i> is present. This is, for instance, sufficient if a white-box implementation is to be bound to a single device. Suppose, however, that a user is to be provided with a white-box implementation that they can run on multiple devices: for instance, their mobile phone and their tablet. Then for both approaches the user must be provided with two white-box implementations: one for the mobile phone and one for the tablet. Another example where the option to choose between multiple strings in order to get a properly functioning white-box implementation is the following. Suppose that a white-box implementation is bound to a user via a string <i>s</i> representing a password. Then forgetting the password makes the white-box implementation useless. When the white-box implementation is used to decrypt valuable data, this then means that the valuable data cannot be read anymore. A solution may include (besides the password string s) that the white-box implementation also works properly for a password that is, for instance, only known by a helpdesk. In that case, the helpdesk may help to restore the valuable data. The embodiments of the invention described below make a white-box implementation dependent on a set of strings in the sense that the implementation works properly for any string in the set (instead of all strings in the set).</p><p id="p0067" num="0067">In order to demonstrate embodiments of the invention, an example white-box implementation of AES will now be described. White-box cryptography is the discipline of implementing a cryptographic algorithm in software such that it is difficult for an attacker to find the key. Hereby, the strongest conceivable (but for software most realistic) attack model is assumed in which the adversary is assumed to have full control over and full access to the white-box implementation.</p><p id="p0068" num="0068">A table-based approach to a white-box implementation of the Advanced Encryption Standard (AES) and the Data Encryption Standard (DES) were proposed in the following papers: "<nplcit id="ncit0001" npl-type="s"><text>White-Box Cryptography and an AES Implementation", by Stanley Chow, Philip Eisen, Harold Johnson, and Paul C. Van Oorschot, in Selected Areas in Cryptography: 9th Annual International Workshop, SAC 2002, St. John's, Newfoundland, Canada, Aug. 15-16, 2002</text></nplcit>, referred to hereinafter as "Chow 1"; and "<nplcit id="ncit0002" npl-type="s"><text>A White-Box DES Implementation for DRM Applications", by Stanley Chow, Phil Eisen, Harold Johnson, and Paul C. van Oorschot, in Digital Rights Management: ACM CCS-9 Workshop, DRM 2002, Washington,<!-- EPO <DP n="14"> --> D.C., USA, Nov. 18, 2002</text></nplcit>, referred to hereinafter as "Chow 2". Chow 1 and Chow 2 disclose methods of using a table-based approach to hide the cryptographic key by a combination of encoding its tables with random bijections, and extending the cryptographic boundary by pushing it out further into the containing application.</p><p id="p0069" num="0069">As noted, for many cryptographic operations it is desired to have a white-box implementation. The invention may be applied, for example, to symmetric and asymmetric cryptographic operations. Also, the invention may be applied to block ciphers, stream ciphers, message authentication schemes, signature schemes, <i>etc.</i> Note that the invention may also be applied to hash functions. The latter is especially useful if the hash function is used as a building block which processes secret information, <i>e.g.,</i> a secret key, secret data, <i>etc.</i> For example, the invention may be applied to a hash function used in a keyed-Hash Message Authentication Code (HMAC or KHMAC). Well known block ciphers include: Advanced Encryption Standard (AES), Secure And Fast Encryption Routine, (SAFER, and variants SAFER+ and SAFER++), Blowfish, Data Encryption Standard (DES), <i>etc.</i> A well known stream cipher is RC4. Moreover any block cipher can be used as stream cipher using an appropriate mode of operation, <i>e.g.,</i> Cipher feedback (CFB), Counter mode (CTR), <i>etc.</i></p><p id="p0070" num="0070">The white-box implementation may be implemented using a plurality of basic blocks. The plurality of basic blocks is interconnected, in the sense that some of the blocks build on the outputs of one or more of the previous blocks. A basic block may also be implemented in software running on a general purpose computer chip, <i>e.g.</i> a microprocessor. For example, a basic block may use a plurality of computer instructions, including arithmetical instructions, which together implement the functionality of the basic block. A widely used implementation for the basic block is a look-up table. For example, Chow 1 and Chow 2 take this approach to implement the AES and DES block ciphers. A look-up table implementation includes a list which lists for possible input values, an output value. The input value may be explicit in the lookup table. In that situation the look-up table implementation could map a particular input to a particular output by searching in the list of input values for the particular input. When the particular input is found the particular output is then also found. For example, the particular output may be stored alongside the particular input. Preferably, the input values are not stored explicitly, but only implicitly. For example, if the possible<!-- EPO <DP n="15"> --> inputs are a consecutive range, <i>e.g.</i> of numbers or bit-strings, the look-up table may be restricted to storing a list of the output values. A particular input number may, <i>e.g.,</i> be mapped to the particular output which is stored at a location indicated by the number. Further, finite state machines or code obfuscation may be used to implement the white-box implementation.</p><p id="p0071" num="0071">For example, a look up table for a function may be created by computing the output value of the function for its possible inputs and storing the outputs in a list. If the function depends on multiple inputs the outputs may be computed and stored for all possible combinations of the multiple inputs. Look-up tables are especially suited to implement non-linear functions, which map inputs to output in irregular ways. A white-box implementation can be further obfuscated, as is explained below, by applying to one or more of its look-up tables a fixed obfuscating input encoding and a fixed output encodings. The results of applying a fixed obfuscating input encoding and output encodings is then fully pre-evaluated. Using this technique, a look-up table would be replaced by an obfuscated look-up table which has the same dimensions, that it takes the same number input bits and produces the same number of output bits. The input encoding and output encoding used in such obfuscation are not explicit in the final white-box implementation.</p><p id="p0072" num="0072">The network of basic blocks are arranged to compute an output message when they are presented with an input message. Typically, the input message is operated upon by a number of basic input blocks. A number of further basic blocks may take input from one or more of the basic input blocks and/or from the input. Yet further basic blocks can take input in any combination of the input message, the output of basic input blocks and the output of the further basic blocks. Finally some set of basic exit blocks, <i>i.e.,</i> at least one, produce as output all or part of the output-message. In this manner a network of basic blocks emerges which collectively computes the mapping from the input message to output message.</p><p id="p0073" num="0073">The key used may be a cryptographic key and may contain sufficient entropy to withstand an anticipated brute force attack. It is noted that in a white-box implementation, the key is typically not explicitly present in the implementation. This would risk the key being found by inspection of the implementation. Typically, the key is only present implicitly. Various ways are known to hide a key in a cryptographic system. Typically, at least the method of partial evaluation is used, wherein a basic block which needs key input is evaluated<!-- EPO <DP n="16"> --> in-so-far that it does not depend on the input-message. For example, a basic operation wherein an input-value, a masking value, which does not depend on the input-message, <i>e.g</i>. a value from an S-box, and a key-value need to be XORed can be partially evaluated by XORing the key value and the masking value together beforehand. In this way the operation still depends on the key-value although the key-value is not explicitly present in the implementation. Instead, only the XOR between the key-value and masking-value is present in the implementation. Note that, more complicated ways and/or further ways of hiding the keys are compatible with this invention.</p><p id="p0074" num="0074">Below exemplary embodiments are described using the AES (Advanced Encryption Standard) block cipher, because AES has become a widely used standard for block ciphers. AES is a block cipher with a block size of 128 bits or 16 bytes. The plaintext is divided in blocks of 16 bytes which form the initial state of the encryption algorithm, and the final state of the encryption algorithm is the cipher text. At any given point in the encryption algorithm these 16 bytes are the state of the encryption algorithm. To conceptually explain AES, the bytes of the state are organized as a matrix of 4x4 bytes. AES includes a number of rounds, which depends on the key size. Each round is includes similar processing steps operating on bytes, rows, or columns of the state matrix, each round using a different round key in these processing steps. In the discussion using AES as an example, it is noted that AES defines a round in a specific manner. In the embodiments below, a round is any grouping of steps that includes at least one non-linear mapping function, such as an S-box in AES. Accordingly, a round as described below includes one non-linear mapping function and any combination of other steps of the cryptographic function.</p><p id="p0075" num="0075"><figref idrefs="f0001">FIG. 1</figref> illustrates some main processing steps of a round of AES. The processing steps include:
<ul><li>AddRoundKey 110 - each byte of the state is XORed with a byte of the round key;</li><li>SubBytes 120 - a byte-to-byte permutation using a lookup table;</li><li>ShiftRows 140-each row of the state is rotated a fixed number of bytes; and<br/>
MixColumns 150 - each column is processed using a modulo multiplication in GF(2<sup>8</sup>).</li></ul><!-- EPO <DP n="17"> --></p><p id="p0076" num="0076">The steps SubBytes 120, ShiftRows 130, and MixColumns 150 are independent of the particular key used. The key is applied in the step AddRoundKey 110. Except for the step ShiftRows 140, the processing steps can be performed on each column of the 4x4 state matrix without knowledge of the other columns. Therefore, they can be regarded as 32-bit operations as each column consists of four 8-bit values. Dashed line 150 indicates that the process is repeated until the required number of rounds has been performed.</p><p id="p0077" num="0077">Each of these steps or a combination of steps may be represented by a lookup table or by a network of lookup tables. If the AddRoundKey 110 step is implemented by XORing with the round key, then the key is visible to the attacker in the white-box attack context. The AddRoundKey 110 step can also be embedded in lookup tables, which makes it less obvious to find out the key. In fact, it is possible to replace a full round of AES by a network of lookup tables. For example, the SubBytes 120, ShiftRows 130, and MixColumns 150 steps may be implemented using table lookups. Below a possible white-box implementation of AES in sufficient detail is discussed to describe the embodiments of the invention below, but further detailed descriptions of such an implementation are found in Chow 1. Also, other variations in the lookup table implementation may be used which are within the scope of the invention.</p><p id="p0078" num="0078">Both the table-based white-box implementations and the finite state machine implementations have the property that all intermediate values in the implementation are encoded (as compared to a standard implementation). Examples of white-box implementations using finite state machines are disclosed in <patcit id="pcit0003" dnum="US20070014394A"><text>U.S. Patent Publication 2007/0014394</text></patcit> entitled "Data Processing Method" and a presentation at the Re-trust Sixth Quarterly Meeting entitled "Synchrosoft MCFACT™ Secure Data Processing Technology" by Wulf Harder and Atis Straujums dated March 11, 2008, which each are hereby incorporated by reference for all purposes as if fully set forth herein. <figref idrefs="f0001">FIG. 2</figref> illustrates a white-box AES implementation with encodings on the input of the rounds, <i>i.e.,</i> on the input of the S-boxes. As shown, each of the 16 input bytes are encoded by f<sub>i</sub> and each of the output bytes are encoded by g<sub>i</sub>.</p><p id="p0079" num="0079">In order to describe embodiments of the invention, a basic description of a table-based white-box AES implementation will be described. For a more detailed description<!-- EPO <DP n="18"> --> of a method for implementing a table-based white-box AES see Chow 1. Chow 1 illustrates a specific implementation that breaks up certain functions using tables of specified sizes. It is well understood that various other divisions of the tables may be made resulting in different functions for the look-up tables and different sizes. Further, while the embodiments of the invention described below use a table-based white-box implementation of AES, other ciphers and cryptographic functions may be implemented according to the embodiments described. Also, other types of white-box implementations may be used instead of the table-base implementation, for example, a finite-state implementation.</p><p id="p0080" num="0080">The description of the table-based white-box AES is split into two steps. In the first step, a round of AES is described as a network of lookup tables. In the second step, the tables are obfuscated by encoding their input and output.</p><heading id="h0007">Step 1: Implementing AES as a network of lookup tables.</heading><p id="p0081" num="0081">AES operates on data blocks of 16 bytes. These are typically described as a 4x4 byte matrix, called the state including bytes x<sub>1,1</sub>, x<sub>1,2</sub>, x<sub>1,3</sub>, ... x<sub>4,4</sub>. A round of AES as described above with respect to <figref idrefs="f0001">FIG. 1</figref> include the following operations: AddRoundKey 110, SubBytes 120, ShiftRows 130, and MixColumns 140. The first two operations, AddRoundKey and SubBytes can be merged into a single T-box operation. That is, we can define a byte-to-byte function T<sub>i,j</sub> for input byte <i>x<sub>i,j</sub></i> as T<sub>¡,j</sub>(x<sub>¡,j</sub>) = S(x<sub>i,j</sub>⊕k<sub>i,j</sub>) where <i>k<sub>i,j</sub></i> is a single byte of a 16 byte round key based upon the AES key. Let y<sub>i,j</sub> be the output of T<sub>i,j</sub>. The ShiftRows operations is just an index-renumbering of the output bytes y<sub>i,j</sub>. For ease of presentation, this operation is omitted in this description, but may be incorporated into the look-up table implementing T<sub>i,j</sub> or implemented as a separate manipulation of the state matrix. In the MixColumns step, an output byte <i>z<sub>i,j</sub></i> of the round is computed from the 4 output bytes <i>y<sub>1,j</sub>, y<sub>2,j</sub>, y<sub>3,j</sub>,</i> and <i>y<sub>4,j</sub></i> via the algebraic expression z<sub>l,j</sub> = MC<sub>l,1</sub> · y<sub>1,j</sub> ⊕ MC<sub>l,2</sub> · y<sub>2,j</sub> ⊕ MC<sub>l,3</sub> · Y<sub>3,j</sub> ⊕ MC<sub>l,4</sub> · y<sub>4,j</sub> in GF(2<sup>8</sup>) for some constants MC<sub>l,r</sub>.</p><p id="p0082" num="0082">Now define a lookup table for each byte-to-byte function <i>Q<sub>i,j,l</sub></i>(<i>x<sub>i,j</sub></i>) = <i>MC<sub>l,i</sub></i> · <i>T<sub>i,j</sub></i>(<i>x<sub>i,j</sub></i>) with <i>i, j, l</i> = 1,2, ...,16. Then any output byte <i>z<sub>l,j</sub></i> may be computed by XORing the results of these lookup tables, <i>i.e., z<sub>l,j</sub> = Q</i><sub>1<i>,j,i</i></sub>(<i>x<sub>l,j</sub></i>) ⊕ <i>Q</i><sub>2<i>,j,l</i></sub>(<i>x</i><sub>2<i>,j</i></sub>) ⊕ <i>Q</i><sub>3<i>,j,i</i></sub>(<i>x</i><sub>3<i>,j</i></sub>) ⊕ <i>Q</i><sub>4<i>,j,l</i></sub>(<i>x</i><sub>4<i>,j</i></sub>). Note that the index <i>i, j</i>, <i>l</i> of Q-box can be interpreted as "the contribution of input<!-- EPO <DP n="19"> --> byte <i>i, j</i> of a round to output byte <i>l, j</i> of the round". The XOR may be implemented to operate on each of two nibbles (<i>i.e.,</i> 4-bit values) as a lookup table to reduce the size of the XOR tables. Accordingly, the Q-box may be implemented to produce output nibbles so that the size of the tables is reduced. Therefore, the computation of each output byte <i>z<sub>l,j</sub></i> of an AES-round has been described as a network of lookup tables. The network of lookup tables to compute a single output nibble of byte <i>z</i><sub>2,3</sub> is shown in <figref idrefs="f0002">FIG. 3</figref>.</p><p id="p0083" num="0083"><figref idrefs="f0002">FIG. 3</figref> illustrates the computation of one output nibble by means of a network of look-up tables. The superscript index (1) in the Q-boxes indicates that the tables only provide the first nibble of the output of the Q-box. A set of input bytes x<sub>1,3</sub>, x<sub>2,3</sub>, x<sub>3,3</sub>, and x<sub>4,3</sub> in the input state 310 are input into the Q-boxes 320, 322, 324, 326. The outputs of lookup tables 320 and 322 are fed into the XOR 330, and the outputs of lookup tables 324 and 326 are fed into the XOR 332. The outputs of XORs 330 and 332 are fed into XOR 334. The output of XOR 334 is the first nibble of the output z<sub>2,3</sub> of output state 340. The second nibble of the output z<sub>2,3</sub> of output state 340 may be calculated in the same way using additional Q-boxes along with a similar XOR network. Further, additional sets of tables may be implemented to completely convert the input state 310 into the output state 340 by receiving a column of bytes from the input state and converting them into the output of the corresponding column of the output state.</p><heading id="h0008">Step 2: Obfuscating the tables and the intermediate values</heading><p id="p0084" num="0084">In the implementation depicted in <figref idrefs="f0002">FIG. 3</figref>, the key may easily be extracted from the Q-boxes. Just applying the inverse MixColumns multiplication and the inverse S-box to the output reveals the plain AddRoundKey operation. To prevent this, the input and outputs of all lookup tables are encoded with arbitrary bijective functions. This is described in Chow 1. This means that a lookup table is merged with an encoding function that encodes the output and with a decoding function that decodes the input. The encodings are chosen such that the output encoding of one table matches the input encoding assumed in the next tables. A portion of the implementation of <figref idrefs="f0002">FIG. 3</figref> is depicted in <figref idrefs="f0002">FIG. 4</figref> for the first round. In this example, the input to the round is not encoded in order to be compliant with AES, but the output of the round is encoded. The output encoding is handled in the next round. That is, unlike the first round, the second round (and the later rounds) assumes that the input is encoded.<!-- EPO <DP n="20"> --> Alternatively, the first round may receive an encoded input. This input encoding must then be applied elsewhere in the software program containing the white-box implementation. Similarly, the last round may or may not include an output encoding depending on whether the output is to be AES compliant. Note that in the white-box implementation obtained, both the lookup tables and the intermediate values are obfuscated.</p><p id="p0085" num="0085">The description of the table lookup based white-box implementation described above was for the encryption operation of AES. It is noted that the above description is easily adapted for the decryption operation by using the inverse of the SubBytes, ShiftRows, and MixColumns operations (invSubytes, invShiftRows, and invMixColumns). Accordingly, it is assumed that the description above can be used for either the encryption or decryption operation of AES as needed in the embodiments below.</p><p id="p0086" num="0086">The related application describes the following embodiments. Let <i>s</i> be the parameter of a function (<i>e.g.,</i> a lookup table) within the white-box implementation. That is, <i>s</i> is not used for the specification of the function, but as parameter of the function. In one embodiment, the internal encodings of intermediate values in the white-box implementation may be chosen in dependence of <i>s</i>. In another embodiment a dependence on <i>s</i> may be introduced in a computed value in the white-box implementation, which dependence is annihilated further on in the computation so that the correct computed result may be obtained.</p><p id="p0087" num="0087">The method of introducing the dependence on an arbitrary string <i>s</i> may work by parameterizing a white-box implementation with <i>s</i>. In a table-based white-box implementation, each lookup table has as input either the output (or part of the output) of another lookup table and/or the input (or part of the input) of the implementation (<i>e.g</i>., the plaintext to be encrypted). Accordingly, lookup tables or functions are introduced that have string <i>s</i> as their input.</p><p id="p0088" num="0088">As an example, a single string <i>s</i> including 4 bits may be bound to the white-box implementation. The string <i>s</i> may be called a binding string value. This embodiment may easily be extended to larger bit strings by applying the described method k times resulting in the binding of strings of 4<i>k</i> bits.<!-- EPO <DP n="21"> --></p><p id="p0089" num="0089"><figref idrefs="f0003">FIG. 5</figref> illustrates a first embodiment of binding a white-box implementation. <figref idrefs="f0003">FIG. 5</figref> is similar to <figref idrefs="f0002">FIG. 3</figref>, but includes an extension to include binding the string <i>s</i> to the white-box implementation. A dependence on an arbitrary 4-bit string <i>s</i> may be implemented as follows. Let <i>h</i><sub>0</sub>,...,<i>h</i><sub>15</sub> be 2<sup>4</sup> bijective encoding functions, and let <i>T</i> be a 8-to-4-bit lookup table 550 defined by <i>T</i>(<i>v,σ</i>) <i>= h<sub>σ</sub></i>(<i>v)</i> where <i>v</i> is an output nibble from the Q-box 520 and the nibble σ is an identifying string value. As can be seen in <figref idrefs="f0003">FIG. 5</figref>, the lookup table <i>T</i> 550 receives the input v from Q-box 520 <i>Q</i><sup>(1)</sup><sub>1,3,2</sub>, and the output of T 550 is input into the succeeding XOR-table 530. The XOR-table 530 may compensate for effect of <i>T</i> 550 on v when <i>σ</i>=<i>s</i>. This may be accomplished by decoding the input to the XOR 530 using the function h<sub>s</sub><sup>-1</sup>. When <i>σ</i>=<i>s</i> this results in the correct value of v being input to the XOR 530. Otherwise, the value input to the XOR 530 is incorrect and results in an incorrect output of the white-box implementation. It is noted that the earlier the lookup table T is implemented in the white-box implementation, the greater change it will have to the output when <i>σ</i>≠<i>s</i>.</p><p id="p0090" num="0090"><figref idrefs="f0003">FIG. 6</figref> illustrates the application of obfuscation to the white-box implementation of <figref idrefs="f0003">FIG. 5</figref>. Each of the Q-boxes 620, 622, 624, 626 correspond to the Q-boxes in <figref idrefs="f0003">FIG. 5</figref> but include input decodings g<sub>i</sub> and output encodings f<sub>i</sub> as shown. Further, the lookup table 650 corresponds to the lookup table 550 in <figref idrefs="f0003">FIG. 5</figref> but includes input decoding f<sub>1</sub><sup>-1</sup> and output encoding f<sub>8</sub>. Finally, the lookup XOR-tables 630, 632, 634 correspond to the XOR-tables 530, 532, 534 in <figref idrefs="f0003">FIG. 5</figref> but include input decodings f<sub>i</sub><sup>-1</sup> and output encodings f<sub>i</sub>.</p><p id="p0091" num="0091">Now a description of extending the embodiment of <figref idrefs="f0003">FIG. 5</figref> to include multiple binding strings will now be provided. Let <i>W</i> ⊆ 2<sup>4</sup> be set of 4-bit strings, and <i>let s E W.</i> Then the embodiment of <figref idrefs="f0003">FIG.5</figref> may be extended so that if <i>s</i> ∉ <i>W</i> the white-box implementation produces an incorrect result. Define <i>h</i><sub>0</sub>,...,<i>h</i><sub>15</sub> such that if <i>i</i> ∈ <i>W</i> then <i>h<sub>i</sub></i>(<i>v</i>)= <i>h<sub>s</sub></i>(<i>v</i>) for all nibbles v, and if <i>i</i> ∉ <i>W</i> then there exists at least one nibble <i>v</i> with <i>h<sub>i</sub></i>(<i>v</i>)≠ <i>h<sub>s</sub></i>(<i>v</i>). This will result<!-- EPO <DP n="22"> --> in the correct functioning of the white-box implementation dependent on the availability of <i>any</i> strings from a set <i>W.</i></p><p id="p0092" num="0092">This functionality may be implemented by modifying the white-box implementation described in <figref idrefs="f0003">FIG. 5</figref> as follows. The table T 550 may be modified so that for any identifying string value <i>σ</i> that is in <i>W, h<sub>σ</sub></i> is defined such that <i>h<sub>σ</sub></i>(<i>v</i>)= <i>h<sub>s</sub></i>(<i>v</i>) for all nibbles v, On the other hand, if the identifying string value <i>σ</i> is not in <i>W</i>, there exists at least one nibble <i>v</i> with <i>h<sub>i</sub></i>(<i>v</i>)≠ <i>h<sub>s</sub></i>(<i>v</i>). This will lead to the white-box implementation functioning incorrectly when the value of σ is not in <i>W</i>.</p><p id="p0093" num="0093"><figref idrefs="f0004">FIG. 7</figref> illustrates a second embodiment of binding a white-box implementation as described in the related application. In this embodiment, an output of a first function in the white-box implementation may be perturbed based upon <i>σ</i> or s. Then in an output of a second function, the perturbation may be compensated using <i>s</i> or <i>σ</i> respectively. Let <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>,<i>v</i><sub>3</sub>,<i>v</i><sub>4</sub> be the 4 nibbles computed by the 4 Q-tables 720, 722, 724, 726. To the value <i>v</i><sub>1</sub> computed after lookup table <i>Q</i><sup>(1)</sup><sub>1,3,2</sub> 720 a value <i>h</i>(<i>σ, v</i><sub>1</sub>) is added via a lookup table <i>T</i><sub>1</sub> 750, where <i>h</i> is an arbitrary function with an 8-bit input and a 4-bit output. Hence, <i>T</i><sub>1</sub>(<i>σ</i>,<i>v<sub>1</sub></i>) = <i>v</i><sub>1</sub> ⊕ <i>h</i>(<i>σ, v</i><sub>1</sub>). The idea is now how to compensate for the addition of <i>h</i>(<i>σ, v</i><sub>1</sub>) when <i>σ</i> = <i>s</i>. This may be accomplished as follows. After adding <i>T</i><sub>1</sub> 750, the network computes the value <i>v</i><sub>1</sub> ⊕ <i>v</i><sub>2</sub> ⊕ <i>v<sub>3</sub></i> ⊕ <i>v</i><sub>4</sub> ⊕ <i>h</i>(<i>σ, v</i><sub>1</sub>), while <i>v</i><sub>1</sub> ⊕ <i>v</i><sub>2</sub> ⊕ <i>v</i><sub>3</sub> ⊕ <i>v</i><sub>4</sub> should be computed. To compensate for this, a lookup table <i>T</i><sub>2</sub> 752 and a XOR lookup table 736 may be added, where <i>T</i><sub>2</sub> computes the value <i>h(s, v</i><sub>1</sub>) and the XOR table adds <i>h(s, v</i><sub>1</sub>) to <i>v</i><sub>1</sub> ⊕ <i>v</i><sub>2</sub> ⊕ <i>v</i><sub>3</sub> ⊕ <i>v</i><sub>4</sub> ⊕ <i>h</i>(<i>σ, v</i><sub>1</sub>). This gives an implementation in which it is guaranteed that the proper value is calculated if and only if the implementation receives the parameter <i>σ</i>=<i>s</i>. Again, the lookup tables in <figref idrefs="f0004">FIG. 7</figref> may be obfuscated as described above to obtain a final white-box implementation.</p><p id="p0094" num="0094">Now a description of extending the embodiment of <figref idrefs="f0004">FIG. 7</figref> to include multiple binding strings will now be provided. Suppose that the white-box implementation is to work correctly for any string <i>σ</i> ∈ <i>W</i> with <i>W</i> containing multiple 4-bit strings. In the above embodiment <i>h</i> is defined as an arbitrary function from 8 to 4 bits. Now define <i>h</i> as an arbitrary function with the property that <i>h</i>(<i>v, σ</i>) <i>= h</i>(<i>v, s</i>) for all <i>σ</i> ∈ <i>Wand h</i>(<i>v,σ</i>) ≠ <i>h</i>(<i>v, s</i>) otherwise. This results in the property that the white-box implementation works properly for the entire message space if and only if <i>σ</i> ∈ <i>W.</i><!-- EPO <DP n="23"> --></p><p id="p0095" num="0095">This functionality may be implemented by modifying the white-box implementation described in <figref idrefs="f0004">FIG. 7</figref> as follows. The table T<sub>1</sub> 750 may be modified so that for any identifying string value <i>σ</i> that is in <i>W, h<sub>σ</sub></i> is defined such that <i>h</i>(<i>v, σ</i>) <i>= h</i>(<i>v, s</i>) for all nibbles v, On the other hand, if the identifying string value <i>σ</i> is not in <i>W,</i> then <i>h</i>(<i>v, σ</i>) ≠ <i>h</i>(<i>v, s</i>). This will lead to the white-box implementation functioning incorrectly when the value of <i>σ</i> is not in <i>W</i>.</p><p id="p0096" num="0096">Michiels describes a method of using a binding string <i>s</i> to specify a portion of a look up table or software codes used in the white-box implementation. Accordingly, the white-box implementation only works correctly when a string <i>σ</i> equal to the binding string <i>s</i> is present. Then the lookup table or software code will function properly. Otherwise improper output values may be obtained when the string <i>σ</i> does not equal the binding string <i>s</i>.</p><p id="p0097" num="0097">Now to extend the embodiment of Michiels to accommodate a plurality of binding strings s, let <i>W</i> ⊆ 2<sup>4</sup> be set of strings, and <i>let s</i> ∈ <i>W.</i> Then the computation of the white-box implementation is disturbed if <i>s</i> ∉ <i>W..</i> One may use techniques similar to those described above to achieve a similar result using the embodiment of Michiels.</p><p id="p0098" num="0098">A method according to the embodiments of the invention may be implemented on a computer as a computer implemented method. Executable code for a method according to the invention may be stored on a computer program medium. Examples of computer program media include memory devices, optical storage devices, integrated circuits, servers, online software, <i>etc.</i> Accordingly, a white-box system may include a computer implementing a white-box computer program. Such system, may also include other hardware elements including storage, network interface for transmission of data with external systems as well as among elements of the white-box system.</p><p id="p0099" num="0099">In an embodiment of the invention, the computer program may include computer program code adapted to perform all the steps of a method according to the invention when the computer program is run on a computer. Preferably, the computer program is embodied on a non-transitory computer readable medium.</p><p id="p0100" num="0100">Further, because white-box cryptography is often very complicated and/or obfuscated it is tedious for a human to write. It is therefore of advantage to have a method to<!-- EPO <DP n="24"> --> create the cryptographic system according to the embodiments of the invention in an automated manner.</p><p id="p0101" num="0101">A method of creating the cryptographic system according to the invention may be implemented on a computer as a computer implemented method, or in dedicated hardware, or in a combination of both. Executable code for a method according to the invention may be stored on a computer program medium. In such a method, the computer program may include computer program code adapted to perform all the steps of the method when the computer program is run on a computer. The computer program is embodied on a non-transitory computer readable medium.</p><p id="p0102" num="0102"><figref idrefs="f0004">FIG. 8</figref> is a flow chart illustrating a method of binding a white-box implementation to a binding string. First, the method begins at 805. Then, a white-box implementation of the cryptographic operation is produced or received 810. This may be produced as described above using various methods and implementations. Next, information identifying a set of strings such that <i>s ∈ W</i> may be received 815. The strings <i>s</i> may provide binding to a set of specific software instances or a specific hardware systems. Then, the white-box implementation may be modified based upon the set of strings <i>s</i> 820 so that: when an input <i>σ</i> is received that is one of the set of binding string values, the white-box implementation produces correct output for the cryptographic operation implemented by the white-box implementation; and when an input <i>σ</i> is received that is not one of the set of binding string values, the white-box implementation produces an incorrect output for the cryptographic operation implemented by the white-box implementation. The various embodiments discussed above provide different ways in which this capability may be implemented in the white-box implementation. The method may then end 825.</p><p id="p0103" num="0103">The cryptographic system described herein may be implemented on a user device such as a mobile phone, table, computer, set top box, smart TV, <i>etc.</i> A content provider, such as a television network, video stream service, financial institution, music streaming service, <i>etc.,</i> may provide software to the user device for receiving encrypted content from the content provider. That software may have the encryption key embedded therein as described above, and may also include binding strings as described above. Then the<!-- EPO <DP n="25"> --> content provider may send encrypted content to the user device, which may then decrypt using the supplied software and use the content.</p><p id="p0104" num="0104">Any combination of specific software running on a processor to implement the embodiments of the invention, constitute a specific dedicated machine.</p><p id="p0105" num="0105">As used herein, the term "non-transitory machine-readable storage medium" will be understood to exclude a transitory propagation signal but to include all forms of volatile and non-volatile memory. Further, as used herein, the term "processor" will be understood to encompass a variety of devices such as microprocessors, field-programmable gate arrays (FPGAs), application-specific integrated circuits (ASICs), and other similar processing devices. When software is implemented on the processor, the combination becomes a single specific machine.</p><p id="p0106" num="0106">It should be appreciated by those skilled in the art that any block diagrams herein represent conceptual views of illustrative circuitry embodying the principles of the invention.</p><p id="p0107" num="0107">Although the various exemplary embodiments have been described in detail with particular reference to certain exemplary aspects thereof, it should be understood that the invention is capable of other embodiments and its details are capable of modifications in various obvious respects. As is readily apparent to those skilled in the art, variations and modifications can be effected while remaining within the spirit and scope of the invention. Accordingly, the foregoing disclosure, description, and figures are for illustrative purposes only and do not in any way limit the invention, which is defined only by the claims.</p></description><claims mxw-id="PCLM90459447" lang="EN" load-source="patent-office"><!-- EPO <DP n="26"> --><claim id="c-en-0001" num="0001"><claim-text>A method of performing a cryptographic operation using a cryptographic implementation in a cryptographic system, comprising:
<claim-text>receiving, by the cryptographic system, an identifying string value;</claim-text>
<claim-text>receiving, by the cryptographic system, an input message;</claim-text>
<claim-text>performing, by the cryptographic system, a keyed cryptographic operation mapping the input message into an output message wherein the output message is the correct result when the indentifying string value is one of a set of binding string values, wherein the set includes a plurality of binding string values.</claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The method of claim 1, wherein there are input messages for which the output message is an incorrect result when the indentifying string is not in the set of binding string values.</claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The method of claim 1 or 2, wherein the identifying string value is based upon an identification of the cryptographic implementation, upon a hash of a portion of code in the cryptographic system, upon an identification of the cryptographic system or upon a user password.</claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The method of any preceding claim, wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and the method further comprises:
<claim-text>encoding an output of the first function based upon the indentifying string value; and</claim-text>
<claim-text>performing the second function on the encoded output of the first function wherein the second function includes decoding the encoded output of the first function using the set of binding string values.</claim-text><!-- EPO <DP n="27"> --></claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The method of any preceding claim, wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and the method further comprises:
<claim-text>encoding an output of the first function using the set of binding string values; and</claim-text>
<claim-text>performing the second function on the encoded output of the first function wherein the second function includes decoding the encoded output of the first function based upon the indentifying string value.</claim-text></claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The method of any preceding claim, wherein the cryptographic implementation includes a plurality of functions including a first function and a second function, and the method further comprises:
<claim-text>perturbing an output of the first function using the indentifying string value; and</claim-text>
<claim-text>performing the second function on the perturbed output of the first function wherein the second function includes compensating for the perturbation of the output of the first function using the set of binding string values.</claim-text></claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>The method of any preceding claim, wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and the method further comprises:
<claim-text>introducing a perturbation in the calculation of the first function based upon the identifying string value;</claim-text>
<claim-text>compensating for the perturbation in the calculation of the first function during calculation of the second function based upon the set of binding string values.</claim-text></claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>The method of any preceding claim, wherein the cryptographic implementation includes a plurality of functions including a first function and second function, and the method further comprises:<!-- EPO <DP n="28"> -->
<claim-text>introducing a perturbation in the calculation of the first function based upon the set of binding string values;</claim-text>
<claim-text>compensating for the perturbation in the calculation of the first function during calculation of the second function based upon the identifying string value.</claim-text></claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>The method of any preceding claim, wherein the cryptographic system includes a network of finite state machines.</claim-text></claim><claim id="c-en-0010" num="0010"><claim-text>The method of any preceding claim, wherein the cryptographic system includes a network of lookup tables.</claim-text></claim><claim id="c-en-0011" num="0011"><claim-text>The method of any preceding claim, wherein the cryptographic operation is one of advanced encryption system (AES) or data encryption standard (DES).</claim-text></claim><claim id="c-en-0012" num="0012"><claim-text>The method of any preceding claim, wherein the cryptographic implementation includes a plurality of functions including a first function, and the method further comprises: modifying the first function based upon the indentifying string value.</claim-text></claim><claim id="c-en-0013" num="0013"><claim-text>The method of claim 12, wherein the first function is a plurality of instructions, and modifying the first function based upon the identifying string value includes producing a modifying string value based upon the identifying string value and wherein a portion of the plurality of instructions is implemented using the modifying string value.</claim-text></claim><claim id="c-en-0014" num="0014"><claim-text>A non-transitory machine-readable storage medium encoded with instructions for execution by a cryptographic implementation in a cryptographic system for performing a cryptographic operation, wherein said instructions, when being executed by said cryptographic implementation, carry out a method as claimed in any preceding claim.</claim-text></claim></claims><drawings mxw-id="PDW20422174" load-source="patent-office"><!-- EPO <DP n="29"> --><figure id="f0001" num="1,2"><img id="if0001" file="imgf0001.tif" wi="105" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="30"> --><figure id="f0002" num="3,4"><img id="if0002" file="imgf0002.tif" wi="160" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="31"> --><figure id="f0003" num="5,6"><img id="if0003" file="imgf0003.tif" wi="165" he="232" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="32"> --><figure id="f0004" num="7,8"><img id="if0004" file="imgf0004.tif" wi="165" he="233" img-content="drawing" img-format="tif"/></figure></drawings><search-report-data><doc-page id="srep0001" file="srep0001.tif" wi="158" he="233" type="tif"/><doc-page id="srep0002" file="srep0002.tif" wi="158" he="233" type="tif"/></search-report-data><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
