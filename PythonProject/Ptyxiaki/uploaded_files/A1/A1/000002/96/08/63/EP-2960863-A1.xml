<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2960863-A1" country="EP" doc-number="2960863" kind="A1" date="20151230" family-id="53793940" file-reference-id="255738" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="160451818" ucid="EP-2960863-A1"><document-id><country>EP</country><doc-number>2960863</doc-number><kind>A1</kind><date>20151230</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-15174054-A" is-representative="YES"><document-id mxw-id="PAPP193866604" load-source="patent-office" format="original"><country>EP</country><doc-number>15174054.5</doc-number><date>20150626</date><lang>EN</lang></document-id><document-id mxw-id="PAPP193866605" load-source="docdb" format="epo"><country>EP</country><doc-number>15174054</doc-number><kind>A</kind><date>20150626</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC162032651" ucid="KR-20150089085-A" load-source="docdb"><document-id format="epo"><country>KR</country><doc-number>20150089085</doc-number><kind>A</kind><date>20150623</date></document-id></priority-claim><priority-claim mxw-id="PPC162028947" ucid="US-201462018221-P" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201462018221</doc-number><kind>P</kind><date>20140627</date></document-id></priority-claim><priority-claim mxw-id="PPC162033080" ucid="US-201462018228-P" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201462018228</doc-number><kind>P</kind><date>20140627</date></document-id></priority-claim><priority-claim mxw-id="PPC162034480" ucid="US-201462018254-P" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201462018254</doc-number><kind>P</kind><date>20140627</date></document-id></priority-claim><priority-claim mxw-id="PPC162036336" ucid="US-201462018274-P" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201462018274</doc-number><kind>P</kind><date>20140627</date></document-id></priority-claim><priority-claim mxw-id="PPC162034022" ucid="US-201514743700-A" load-source="docdb"><document-id format="epo"><country>US</country><doc-number>201514743700</doc-number><kind>A</kind><date>20150618</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1988525304" load-source="docdb">G06T  15/00        20110101AFI20151119BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1976511708" load-source="docdb" scheme="CPC">G06T  15/005       20130101 FI20151105BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT165546920" lang="DE" load-source="patent-office">BEWEGUNGSBASIERTES ADAPTIVES RENDERING</invention-title><invention-title mxw-id="PT165546921" lang="EN" load-source="patent-office">MOTION BASED ADAPTIVE RENDERING</invention-title><invention-title mxw-id="PT165546922" lang="FR" load-source="patent-office">RENDU ADAPTATIF EN FONCTION DU MOUVEMENT</invention-title><citations><patent-citations><patcit mxw-id="PCIT335740503" load-source="docdb" ucid="US-20050259740-A1"><document-id format="epo"><country>US</country><doc-number>20050259740</doc-number><kind>A1</kind><date>20051124</date></document-id><sources><source name="SEA" category="X" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT335745540" load-source="docdb" ucid="US-20060274075-A1"><document-id format="epo"><country>US</country><doc-number>20060274075</doc-number><kind>A1</kind><date>20061207</date></document-id><sources><source name="SEA" category="X" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT356617736" load-source="docdb" ucid="US-20150035853-A1"><document-id format="epo"><country>US</country><doc-number>20150035853</doc-number><kind>A1</kind><date>20150205</date></document-id><sources><source name="SEA" category="XP" created-by-npl="N"/></sources></patcit></patent-citations><non-patent-citations><nplcit><text>DON P. MITCHELL; ARUN N. NETRAVALI: "Reconstruction Filters in Computer Graphics", COMPUTER GRAPHICS, vol. 22, no. 4, August 1988 (1988-08-01), pages 221 - 228</text><sources><source mxw-id="PNPL62638849" load-source="docdb" name="APP"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR1103309827" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>SAMSUNG ELECTRONICS CO LTD</last-name><address><country>KR</country></address></addressbook></applicant><applicant mxw-id="PPAR1103316415" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>SAMSUNG ELECTRONICS CO., LTD</last-name></addressbook></applicant><applicant mxw-id="PPAR1101652406" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Samsung Electronics Co., Ltd</last-name><iid>101312277</iid><address><street>129, Samsung-ro Yeongtong-gu Suwon-si</street><city>Gyeonggi-Do 443-742</city><country>KR</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR1103337358" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>GOLAS ABHINAV</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103306030" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>GOLAS, Abhinav</last-name></addressbook></inventor><inventor mxw-id="PPAR1101641448" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>GOLAS, Abhinav</last-name><address><street>Apt.82 234 Escuela Avenue</street><city>Mountain View, CA California 94040</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103315450" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>CHENG CHRISTOPHER</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103332054" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>CHENG, CHRISTOPHER</last-name></addressbook></inventor><inventor mxw-id="PPAR1101646482" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>CHENG, CHRISTOPHER</last-name><address><street>1232 Loyola Drive</street><city>Santa Clara, CA California 95051</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103305548" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>BROTHERS JOHN</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103339297" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>BROTHERS, JOHN</last-name></addressbook></inventor><inventor mxw-id="PPAR1101642437" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>BROTHERS, JOHN</last-name><address><street>4225 Mountain Home Ranch Road</street><city>Calistoga, CA California 94515</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103325528" load-source="docdb" sequence="4" format="epo"><addressbook><last-name>RAMANI KARTHIK</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103310650" load-source="docdb" sequence="4" format="intermediate"><addressbook><last-name>RAMANI, KARTHIK</last-name></addressbook></inventor><inventor mxw-id="PPAR1101640027" load-source="patent-office" sequence="4" format="original"><addressbook><last-name>RAMANI, KARTHIK</last-name><address><street>372 Alric Court</street><city>San Jose, CA California 95123</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103311935" load-source="docdb" sequence="5" format="epo"><addressbook><last-name>ZHANG LIANGJUN</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103337274" load-source="docdb" sequence="5" format="intermediate"><addressbook><last-name>ZHANG, Liangjun</last-name></addressbook></inventor><inventor mxw-id="PPAR1101652325" load-source="patent-office" sequence="5" format="original"><addressbook><last-name>ZHANG, Liangjun</last-name><address><street>1373 Alderbrook Lane</street><city>San Jose, CA California 95129</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103325373" load-source="docdb" sequence="6" format="epo"><addressbook><last-name>ABRAHAM SANTOSH GEORGE</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103340751" load-source="docdb" sequence="6" format="intermediate"><addressbook><last-name>ABRAHAM, SANTOSH GEORGE</last-name></addressbook></inventor><inventor mxw-id="PPAR1101649151" load-source="patent-office" sequence="6" format="original"><addressbook><last-name>ABRAHAM, SANTOSH GEORGE</last-name><address><street>4776 Amanda Place</street><city>Pleasanton, CA California 94566</city><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103311662" load-source="docdb" sequence="7" format="epo"><addressbook><last-name>CHOW WOODY</last-name><address><country>US</country></address></addressbook></inventor><inventor mxw-id="PPAR1103322017" load-source="docdb" sequence="7" format="intermediate"><addressbook><last-name>CHOW, Woody</last-name></addressbook></inventor><inventor mxw-id="PPAR1101644498" load-source="patent-office" sequence="7" format="original"><addressbook><last-name>CHOW, Woody</last-name><address><street>933 Marilyn Drive</street><city>Mountain View, CA California 94566</city><country>US</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR1101641326" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Portch, Daniel</last-name><suffix>et al</suffix><iid>101204502</iid><address><street>Elkington and Fife LLP Prospect House 8 Pembroke Road</street><city>Sevenoaks, Kent TN13 1XR</city><country>GB</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS660693219" load-source="docdb">AL</country><country mxw-id="DS660701924" load-source="docdb">AT</country><country mxw-id="DS660693221" load-source="docdb">BE</country><country mxw-id="DS660785203" load-source="docdb">BG</country><country mxw-id="DS660611098" load-source="docdb">CH</country><country mxw-id="DS660693308" load-source="docdb">CY</country><country mxw-id="DS660701925" load-source="docdb">CZ</country><country mxw-id="DS660693222" load-source="docdb">DE</country><country mxw-id="DS660693309" load-source="docdb">DK</country><country mxw-id="DS660693310" load-source="docdb">EE</country><country mxw-id="DS660615423" load-source="docdb">ES</country><country mxw-id="DS660785204" load-source="docdb">FI</country><country mxw-id="DS660611107" load-source="docdb">FR</country><country mxw-id="DS660693227" load-source="docdb">GB</country><country mxw-id="DS660693315" load-source="docdb">GR</country><country mxw-id="DS660693228" load-source="docdb">HR</country><country mxw-id="DS660701926" load-source="docdb">HU</country><country mxw-id="DS660615048" load-source="docdb">IE</country><country mxw-id="DS660693316" load-source="docdb">IS</country><country mxw-id="DS660611108" load-source="docdb">IT</country><country mxw-id="DS660693317" load-source="docdb">LI</country><country mxw-id="DS660785205" load-source="docdb">LT</country><country mxw-id="DS660690936" load-source="docdb">LU</country><country mxw-id="DS660785206" load-source="docdb">LV</country><country mxw-id="DS660785207" load-source="docdb">MC</country><country mxw-id="DS660690937" load-source="docdb">MK</country><country mxw-id="DS660690938" load-source="docdb">MT</country><country mxw-id="DS660690943" load-source="docdb">NL</country><country mxw-id="DS660701931" load-source="docdb">NO</country><country mxw-id="DS660690944" load-source="docdb">PL</country><country mxw-id="DS660693318" load-source="docdb">PT</country><country mxw-id="DS660615424" load-source="docdb">RO</country><country mxw-id="DS660693319" load-source="docdb">RS</country><country mxw-id="DS660690945" load-source="docdb">SE</country><country mxw-id="DS660693230" load-source="docdb">SI</country><country mxw-id="DS660701932" load-source="docdb">SK</country><country mxw-id="DS660701933" load-source="docdb">SM</country><country mxw-id="DS660615049" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA166480188" lang="EN" load-source="patent-office"><p id="pa01" num="0001">An apparatus, system and method is provided to determine a motion of pixels in local regions of a scene, classify the motion into a speed category, and make decisions on how to render blocks of pixels. In one implementation the motion in a tile is classified into at least three different speed regimes. If the pixels in a tile are in a quasi-static speed regime, a determination is made whether or not to reuse a fraction of pixels from the previous frame. If the pixels are determined to be in a high speed regime, a decision is made whether or not a sampling rate may be reduced.
<img id="iaf01" file="imgaf001.tif" wi="100" he="68" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA166760000" lang="EN" source="EPO" load-source="docdb"><p>An apparatus, system and method is provided to determine a motion of pixels in local regions of a scene, classify the motion into a speed category, and make decisions on how to render blocks of pixels. In one implementation the motion in a tile is classified into at least three different speed regimes. If the pixels in a tile are in a quasi-static speed regime, a determination is made whether or not to reuse a fraction of pixels from the previous frame. If the pixels are determined to be in a high speed regime, a decision is made whether or not a sampling rate may be reduced.</p></abstract><description mxw-id="PDES98404889" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><b>FIELD OF THE INVENTION</b></heading><p id="p0001" num="0001">An embodiment of the present invention is generally related to techniques of performing graphics processing in which the number of samples rendered in a block of pixels is reduced. More particularly, an embodiment of the present invention is directed to automatically analyzing motion and other factors in individual display screen tiles (block of pixels) and making sampling decisions on a tile-by-tile basis.</p><heading id="h0002"><b>BACKGROUND OF THE INVENTION</b></heading><p id="p0002" num="0002"><figref idrefs="f0001">Figure 1</figref> illustrates major portions of a graphics pipeline 100 based on the OpenGLÂ® 3.0 standard. An illustrative set of stages includes a vertex shader operations stage 105, a primitive assembly and rasterization stage 110, a fragment pixel shader operations stage 115, a frame buffer stage 120, and a texture memory 125. The pipeline operates to receive vertex data, shade vertices, assemble and rasterize primitives, and perform shading operations on fragments/ pixels.</p><p id="p0003" num="0003">One aspect of the graphics pipeline 100 is that every region of an image is rendered at the same minimum resolution. In particular, in a conventional graphics pipeline, a sampling rate (average number of samples per pixel) is typically at least one sample for every pixel of an image.</p><p id="p0004" num="0004">One aspect of the conventional graphics pipeline is that it is wasteful and requires more pixel shading operations then desired. In particular, there is no automation in the graphics pipeline to permit strategic choices to be automatically made to reduce a sampling rate below one sample per pixel (sub-sampling/de-sampling) in local regions of an image. In the context<!-- EPO <DP n="2"> --> of mobile devices, this means that the amount of energy that is consumed is higher than desired.<!-- EPO <DP n="3"> --></p><heading id="h0003"><b>SUMMARY OF THE INVENTION</b></heading><p id="p0005" num="0005">A graphics system adaptively renders individual portions of a frame based on the motion of the underlying objects being rendered with respect to the camera's frame of reference. In one embodiment, the adaptive rendering is based at least in part on the speed of objects rendered on the screen across at least two frames. Measuring motion in screen space (via pixels) incorporates the different source of motion, including object motion and camera motion. If the speed of the underlying motion is below a quasi-static limit, a decision may be made whether or not to reuse a fraction of pixels from the previous frame. In an intermediate speed regime a full sampling rate is used. In at least one higher speed regime, a decision is made whether to select a reduced sampling rate. The decisions may be made on a tile-by-tile basis, where a tile is a contiguous set of pixels in an image, typically in a block having a square or rectangular shape.</p><p id="p0006" num="0006">One embodiment of a method includes determining, on a tile-by-tile basis, a speed of pixels of objects in a current frame relative to a previous frame. Each tile is classified into one of at least three speed categories, the at least three categories including a quasi-static speed category, a medium speed category, and a high-speed category. A sampling decision is made for each tile, based at least in part on the speed category associated with each tile. The sampling decision includes deciding whether the tile is to be sampled at a full resolution sampling rate of at least one sample per pixel in the current frame or sampled at a lower rate in the current frame. The tiles are then rendered. In one embodiment, the sampling decision is further based on whether not a tile is detected to have a strong likelihood of including an edge in color or depth. In one embodiment, for a tile classified in the quasi-static speed category the method further includes reusing pixel data from a previous frame by copying pixel data for the at least one pixel of the previous frame to the tile. In one embodiment, for a tile classified in the intermediate speed regime, every pixel is sampled at least once. In one<!-- EPO <DP n="4"> --> embodiment, for a tile classified in the at least one high speed regime a selection is made of a sampling pattern in which a number of samples is less than the number of pixels associated with the tile and interpolation is performed to determine a color at pixel locations not sampled.</p><p id="p0007" num="0007">By allowing tiles to be sampled at a lower sampling rate than at least one sample per pixel, the amount of energy used by a system to reduce the number of pixel shading operations required. This may thereby reduce the amount of energy expenditure of a mobile device through use of a graphics system according to an embodiment.</p><p id="p0008" num="0008">One embodiment of a graphics system includes a graphics processor and a graphics pipeline including an adaptive sampling generator and pixel shader. The adaptive sampling generator determines a required sample rate for each tile based at least in part on a speed of pixels of objects in each tile and selects a sample pattern based on the required sample rate. In one embodiment, the adaptive sampling generator determines a sample pattern and a sample rate for an individual tile based on a combination of the speed of objects in the individual tile and whether or not the individual tile includes an edge. In one embodiment, the graphics system includes an advection unit to perform advection, wherein for a tile having a velocity below a quasi-static speed limit, a sample pattern having a reduced sampling rate is selected and the advection unit fills in missing pixel data by reusing pixel data from a previous frame via advection. In one embodiment, the graphics system includes a reconstruction unit, wherein for a tile having a velocity above a threshold speed a reduced sampling rate is selected and missing pixel data is interpolated by the reconstruction unit.<!-- EPO <DP n="5"> --></p><heading id="h0004"><b>BRIEF DESCRIPTION OF THE DRAWINGS</b></heading><p id="p0009" num="0009"><ul><li><figref idrefs="f0001">Figure 1</figref> illustrates a conventional graphics pipeline;</li><li><figref idrefs="f0002">Figure 2</figref> illustrates a graphics pipeline in accordance with an embodiment of the present invention;</li><li><figref idrefs="f0003">Figure 3</figref> illustrates an adaptive desampling generator in accordance with an embodiment of the present invention;</li><li><figref idrefs="f0004">Figure 4</figref> illustrates an example of pixel speed considerations in performing adaptive rendering in accordance with an embodiment of the present invention;</li><li><figref idrefs="f0005">Figure 5</figref> is a flow chart illustrating rendering and reconstruction options in accordance with an embodiment of the present invention;</li><li><figref idrefs="f0006">Figure 6A</figref> illustrates an example of dithering sampling patterns to reduce visual artifacts in accordance with an embodiment of the present invention;</li><li><figref idrefs="f0007">Figure 6B</figref> illustrates a general method of performing dithering of sample patterns in accordance with an embodiment of the present invention;</li><li><figref idrefs="f0008">Figure 7A</figref> illustrates an example of advection in accordance with an embodiment of the present invention;</li><li><figref idrefs="f0009">Figure 7B</figref> illustrates a general method of performing advection in a graphics system in accordance with an embodiment of the present invention;</li><li><figref idrefs="f0010">Figure 8</figref> illustrates an example of using pre-computed weights to perform cubic spline interpolation in accordance with an embodiment of the present invention;</li><li><figref idrefs="f0011">Figure 9</figref> illustrates an example of sampling pattern related to considerations for determining pre-computed weights in accordance with an embodiment of the present invention;<!-- EPO <DP n="6"> --></li><li><figref idrefs="f0012">Figure 10</figref> illustrates an example of sampling pattern related to considerations for determining pre-computed weights in accordance with an embodiment of the present invention;</li><li><figref idrefs="f0013">Figure 11</figref> illustrates a general method of adaptive desampling in accordance with an embodiment of the present invention;</li><li><figref idrefs="f0014">Figure 12</figref> illustrates a general method of performing cubic spline interpolation in a graphics system in accordance with an embodiment of the present invention;</li><li><figref idrefs="f0015">Figure 13</figref> illustrates a general method of performing cubic spline interpolation in a graphics system in accordance with an embodiment of the present invention;</li><li><figref idrefs="f0016">Figure 14</figref> illustrates an example of differences between advection and spline reconstruction;</li><li><figref idrefs="f0017">Figures 15A and 15B</figref> illustrates an example in which different regions of a frame are adaptively rendered using different approaches based on a magnitude of per-pixel velocity.</li><li><figref idrefs="f0018">Figure 16</figref> illustrates an example of using advection for stereoscopic rendering in accordance with an embodiment of the present invention; and</li><li><figref idrefs="f0019">Figure 17</figref> illustrates adaptive rendering applied to foveated rendering in accordance with an embodiment of the present invention.</li></ul><!-- EPO <DP n="7"> --></p><heading id="h0005"><b>DETAILED DESCRIPTION</b></heading><p id="p0010" num="0010"><figref idrefs="f0002">Figure 2</figref> illustrates a graphics pipeline 200 in accordance with an embodiment of the present invention. The graphics pipeline 200 may be implemented using a graphics processing unit (GPU) including graphics hardware. The graphics pipeline 200 includes several new stages and functions to support automatically determining regions of the frame that do not require all of the pixels in individual tiles (blocks of pixels) to be sampled and rendered in order to achieve an acceptable viewing experience for a human user. As used in this application, a tile is a contiguous set of pixels in an image, typically in block having a square shape. The term frame is commonly used to describe a set of operations performed to render an image that is read by a display at a preset frequency. However, the term frame is also used to refer to the rendered image resulting from the set of operations used to render the image.</p><p id="p0011" num="0011">In one embodiment, an adaptive desampling (AD) sample generator stage 205 is provided to support adjusting a sampling pattern in local regions of an image, where the local region is a tile corresponding to a block of pixels (e.g., a 4 x 4 block of pixels, 16 x 16, or other size). Desampling is the reduction in the number of samples per tile that are sampled and rendered in the current frame. For example, desampling may include sampling and rendering on average less than one sample per pixel in a tile, and thus may also be described as sub-sampling. To maintain full image resolution, two different approaches may be used to obtain values of missing pixel data. A reconstruction and advection stage 210 supports two different options to reduce the number of pixels that need to be sampled and rendered in a tile while maintaining visual quality for a user. The reconstruction and advection stage 210 includes a reconstruction submodule 211 and an advection submodule 212. In one embodiment, a first option to reduce the number of pixels rendered in a tile is reconstruction<!-- EPO <DP n="8"> --> via higher order polynomial interpolation and filtering in a tile to generate missing pixel data for that tile. A second option to reduce the number of pixels rendered in a tile is advection, which includes identifying locations of one or more pixels in a previous frame and reusing pixels from the previous frame for a selected fraction of pixels in the tile.</p><p id="p0012" num="0012">In one embodiment, pixel data of frame "n" 215 of objects from frame n 220 is saved for possible reuse of pixel data in the next frame "n+1." Additionally, vertex coordinate data is saved for use in determining a frame-to-frame motion vector of pixels. In one embodiment, the pixel data and vertex coordinates from frame n are stored in a buffer memory for use in the next frame n+1.</p><p id="p0013" num="0013"><figref idrefs="f0003">Figure 3</figref> illustrates an AD sample stage 205 in accordance with an embodiment of the present invention. In one embodiment, desampling decisions are made in local tile regions based on velocity and edge detection (e.g., edge detection in depth/Z). A velocity buffer 310 receives the per vertex coordinates from the current fame and from the previous frame. The velocity of an individual pixel may be determined by comparing the vertex coordinates of the pixel of the current frame with the vertex coordinates of the pixel in the previous frame. In one embodiment, a forward splatting approach is used by rendering a "velocity image" with primitives from the scene, and using a per-vertex velocity as a vertex attribute. Many graphics applications render a Z-buffer as a technique to reduce the number of pixel shader instances during rendering passes. A velocity buffer/image may be rendered with a Z-buffer. During the Z-pass, where the Z/depth buffer is generated, in addition to splatting and updating the depth, the velocity is also updated at each pixel. Rendering the velocity buffer results in per-pixel velocity values in screen space, the magnitude of which corresponds to a speed. A tile, such as a 4 x 4 tile, thus has a pixel speed associated with each pixel. The tile thus has a maximum pixel speed, mean pixel speed, median pixel speed, and minimum pixel<!-- EPO <DP n="9"> --> speed. In one embodiment, the mean pixel speed is used to make desampling decisions, although more generally the maximum pixel speed or average pixel speed could also be used.</p><p id="p0014" num="0014">Visual artifacts are less perceptible to the human eye in moving objects. Thus, one factor in whether or not a sampling rate may be reduced in a tile is whether the speed is above a threshold speed.</p><p id="p0015" num="0015">However, certain types of visual artifacts tend to be more noticeable in edges in color. Strictly speaking, detecting color edges in a final image is not possible without rendering the image first. However, it is possible to detect, prior to rendering, a high likelihood of edges in color. Thus, in one embodiment, an edge detection module 305 detects the likelihood of edges in color in local blocks of pixels. That is, regions are detected in which there is a high likelihood of edges in color by assuming that there is a high likelihood of color variation across objects. In one embodiment, Z values from the rasterization of the current frame are analyzed to perform edge detection. A Laplace edge detector may be defined as stencil centered on a current pixel. Any pixel in the tile is marked as having an edge if the Laplacian of the z-buffer at the pixel is greater than a threshold value multiplied by the z-value at the pixel. This defines a one bit value per tile. More generally, any type of edge detection may be used.</p><p id="p0016" num="0016">In one embodiment, an edge mask is generated for individual tile and an edge state bit may be generated to indicate whether or not a tile includes at least one edge. In one implementation the edge mask is generated for each 4 x 4 block of pixels although more generally other tile sizes may be used. This information on velocity and the presence of an edge is used by a sample generator 315 to determine a sample pattern for a tile. In one embodiment, a full sampling resolution is utilized if an edge is detected. If no edge is detected and a tile has a speed greater than a first threshold speed a first reduced sampling rate is used. If no edge is detected and a tile has a speed above a second threshold speed a<!-- EPO <DP n="10"> --> second reduced sampling rate is used. Other additional optional factors could also be considered in making a sampling rate decision. In one embodiment, the sample pattern options include full sample resolution (at least one sample per pixel), one-half resolution (one-half of the pixels sampled in each tile), and one-quarter resolution (one in four pixels sampled in each tile). More generally, a plurality of sampling rates may be provided that are controlled by threshold parameters for each sample rate. Additionally, the sample rates selected may be optimized for the block/tile size selected. Thus, while an illustrative example includes three sample rates of 4, 8, and 16 samples for 4x4 blocks, the approach may be varied based on block size or other considerations to have a set of sampling rates each controlled by threshold parameters for each sample rate. Thus, the number of sampling rates, N, may be more than three, depending on implementation details, such as block/tile size and other factors.</p><p id="p0017" num="0017">In one embodiment, a dithering module 320 is provided to adjust the sampling pattern from a selection of sampling patterns having the same effective sampling rate. The dithering may be a repetitive sequence (e.g., sample pattern 1, sample pattern 2, sample pattern 3, sample pattern 4) or include aspects of randomization.</p><p id="p0018" num="0018">The dithering of the sampling pattern by the dithering module 320 reduces the visual perception of sampling artifacts by human users. The human eye and the human brain starts to blend images into a video sequence when the rate is faster than a biological threshold. That is, when images vary at a rate faster than a biological threshold, the human eye blends the images across time and perceives them as a continuously varying sequence, akin to a video. There is some contention about what the exact number of the biological threshold is. At frame rates of about 12 frames per second, the human eye and brain begins to see a sequence of images that is moving instead of individual images. However, somewhat higher frame rates of about 15 frames per second are required to experience the beginnings of relatively<!-- EPO <DP n="11"> --> fluid (non-jerky) movement. However, the nature of the underlying images is also an additional factor for whether or not a human observer perceives a fluid motion at a given frame rate. Thus, the human eye will tend to average out visual artifacts that are dithered at frames rates at about 12 frames per second and higher. In one embodiment, the dithering is performed such that every pixel is rendered at least fifteen frames per second, which is faster than the human eye can discern individual images. At 60 frames per second, dithering the sample pattern in a tile every four frames corresponds to rendering each pixel at least fifteen frames per second.</p><p id="p0019" num="0019"><figref idrefs="f0004">Figure 4</figref> illustrates examples of speed regimes in accordance with an embodiment of the present invention. The motion is the combination of object motion and camera motion. The speed corresponds to the magnitude of the motion vector in a tile. In this example, the speed is an indicator of the number of samples needed in a block of pixels to have an acceptable visual quality. If the motion if above a certain threshold speed K<sub>fast1</sub> for a block of pixels, it is an indication that the number of samples may be decreased (e.g., eight samples in a 4 x 4 tile) because the human eye cannot perceive the high frequencies in a moving object. If the speed is above an even higher threshold speed K<sub>fast2</sub>, it is an indicator that the number of samples in a tile may be reduced even further (e.g., four samples in a 4 x 4 tile). On the other hand, if the motion is very slow in a tile, below a speed K<sub>stat</sub> (or if there is no motion), then there may be an opportunity to reuse pixel data from the previous frame (e.g., render eight samples in a 4 x 4 tile and reuse eight color values from the previous frame via advection). The reuse of pixel data from the previous frame also requires that the graphics state does not change from the previous frame to the current frame, where the graphics state includes the shaders used, the constants provided to the shaders, and the geometry provided to the frames. There will be a speed regime where full sampling resolution is required. As an example, there may be an intermediate speed regime between K<sub>stat</sub>, and K<sub>fast1</sub> in which a full<!-- EPO <DP n="12"> --> sampling resolution is required to achieve a high visual quality. Additionally, there may be scenarios in which super-sampling is applied to individual tiles. As an illustrative example, an option may be provided to support super-sampling of a Z-edge case.</p><p id="p0020" num="0020">In one embodiment, desampling (changing the sample pattern to reduce the sampling rate below one sample per pixel) is permitted if the speed is above a first threshold speed K<sub>fast1</sub>. In one embodiment, the sampling rate is permitted to be reduced further if the speed exceeds a second threshold speed K<sub>fast2</sub>. A decision whether to perform desampling may also be dependent on other conditions, such as whether or not an edge is detected.</p><p id="p0021" num="0021">In one embodiment, motion in the camera screen space is obtained by differencing vertex position data from the current frame and the previous frame. A speed regime of a tile is classified on a tile-by-tile basis by calculating a magnitude of a motion vector based on how much a pixel of an object has moved from one frame to another. As previously discussed, in one embodiment, splatting is used in the Z-pass to determine per-pixel motion vectors. In one embodiment, speed thresholds are defined and used as inputs to make decisions on whether adaptive desampling or advection are to be used for a current frame. One speed regime is a quasi-static regime in which an object moves slowly enough that pixels of the object are unlikely to differ significantly from their previous image counterparts. If the speed is within the quasi static speed limit, a decision may be made whether advection may be used to reuse pixels from a previous frame. In one embodiment, an upper bound on a quasi-static speed, K<sub>stat</sub> is that a pixel in a given tile (tile m) in frame n remains in the same tile in frame n +1. In one embodiment, if the speed is below K<sub>stat</sub>, additional checks are performed to determine if pixels from the previous frame may be used in the current frame. This may include a check that advection produced an acceptable result in a previous frame. Additionally, a check may be performed to check that the pixel values for the tile in the current frame are consistent with a small movement over the previous frame, which may be<!-- EPO <DP n="13"> --> described as a discrepancy check. An advection discrepancy state bit may be associated with a tile to indicate that it has passed one or more discrepancy checks to confirm that the tile is suitable for advection of at least some of the pixel data.</p><p id="p0022" num="0022"><figref idrefs="f0005">Figure 5</figref> is a flowchart illustrating an example of adaptive rendering choices based on speed, edge detection, dithering, spline reconstruction and advection. Some conventional graphics pipeline features are omitted for clarity. <figref idrefs="f0005">Figure 5</figref> illustrates a specific example in which 4 x 4 tiles are used in accordance with an embodiment of the present invention. An initial pre-pass may be performed followed by a color pass to render pixel data. The scene geometry 505 of an image is provided by the application. The Z-buffer is computed 510 and edge detection is performed 515. Motion vectors are computed 520 for the scene geometry. The per-pixel motion vector is computed 525. The range of motion in a tile is computed 530. Based upon this information, a decision 535 is made whether to: 1) render 4, 8, or 16 samples in a 4 x 4 block 535 and perform interpolation or 2) to render 8 and advect 8. Dithering 540 is performed for the sampling patterns. Spline reconstruction 545 is utilized to reconstruct pixel data. If advection is used, then advection 550 is used to obtain 8 of the pixel values and the rest are obtained by rendering.</p><p id="p0023" num="0023"><figref idrefs="f0006">Figure 6A</figref> illustrates an example of sampling patterns and dithering. In this example the tile size is a 4 x 4 block of pixels. Full resolution corresponds to 16 samples. Half-resolution (8 samples) and one-quarter resolution (four samples) permits variations in the pattern of the samples. Thus, for the case of 8 samples, the arrangement of the samples can have a first sample pattern, second sample pattern, third sample pattern, etc. Having pre-defined sampling patterns supports dithering of the sample pattern for temporal color averaging. The pre-defined sampling patterns are selected to rotate the sampling so that every pixel location is rendered once every few frames. The dithering of the sample pattern can be achieved by different techniques. In one embodiment, the choice of sample pattern in an individual frame<!-- EPO <DP n="14"> --> can be selected by the dithering module 320 in a sequence by a modulo k counter. Dithering sample positions in time over multiple frames makes rendering errors harder for a human observer to see. In one embodiment, the sample patterns are selected so that each pixel is guaranteed to be rendered at least once every k frames, where (n*n)/k is the minimum number of samples per n x n tile. In another embodiment, temporal dithering is implemented using a stochastic approach to select the sample pattern.</p><p id="p0024" num="0024"><figref idrefs="f0007">Figure 6B</figref> illustrates a method of dithering in accordance with an embodiment of the present invention. Tiles in a current frame are selected 605 for sub-sampling at a reduced average sampling rate. For each tile, a sampling pattern is selected 610 to be varied over the previous frame. Rendering and reconstruction is performed 615. If additional frames are to be rendered, the process continues.</p><p id="p0025" num="0025"><figref idrefs="f0008">Figure 7A</figref> illustrates an example of advection. In a tile region, such as a 4 x 4 tile 700, advection including copying pixel data from pixel at a given location in the previous frame to the corresponding location in the current frame. For example, an individual object (e.g., a ball slowly moving across the ground) may move across the screen such that every pixel of the ball moves with a velocity. In this example there is a high level of temporal coherence between the pixels of the slowly moving ball from one frame to another. In this case, the changes are primarily motion. By determining the motion of individual pixels of the ball across frames, pixel data may be copied across frames. In this example, the motion is slow enough that pixel data can be mapped form a current pixel location to a pixel in the same tile in a previous frame. The position of a pixel in a previous frame may be computed as x(n-1) = x -mv(x), where mv(x) is the motion vector. As a result this permits pixel data to be copied from x (n-1) to x(n). That is, if the motion of the pixel is small between frames then the pixel location in the current frame may be projected back to a pixel in the previous frame and the<!-- EPO <DP n="15"> --> pixel data from the previous frame copied. Bilinear or any higher order interpolation may be used if x(n-1) has decimal components.</p><p id="p0026" num="0026">In the example of <figref idrefs="f0008">Figure 7A</figref>, advection is mixed with rendering. In one embodiment, advection is used for half of the pixels 705 in a tile and the other half of the pixels are rendered 710. Mixing advection and rendering in a single frame reduces visual artifacts associated with performing only advection. That is, it minimizes the likelihood of visual errors due to advection detectable by typical human viewers. In conjunction with temporal dithering, it ensures that errors do not accumulate over time, thus reducing the likelihood of visual errors being noticed by typical human viewers. While a 1:1 ratio of rendered pixels and advected pixels is one option, more generally other ratios could be utilized.</p><p id="p0027" num="0027">As previously discussed, in one embodiment, a maximum speed is used as condition for whether advection is permitted. In one embodiment, the criteria is that the threshold speed is low enough that local deformation of pixel positions in a small neighborhood can be classified as a rigid transformation in which the change in the positions of the pixels can be represented using one of translation and one rotation for an entire set of pixels to within a desired accuracy. For example, the maximum speed for advection can be that the magnitude of the pixel motion is below a threshold of k pixels. While it is possible that rigid transforms can occur at any speed, the likelihood decreases with increasing speed such that a speed threshold may be used as a criterion for when advection is likely to be beneficial. A discrepancy check may be performed for individual tiles to determine whether or not advection produces acceptable results. This discrepancy check can be performed in a current frame and written out as 1-bit value for each tile to let the next frame make a determination whether or not to disable advection in the neighborhood of a tile failing the discrepancy check if the check indicates that the advected results were inaccurate. That is, in this implementation advection is performed for a tile in frame n and the discrepancy check is<!-- EPO <DP n="16"> --> performed in frame n and consumed by frame n+1. Frame n+1 then uses the discrepancy check (computed in frame n) to determine whether or not to perform advection in a neighborhood about a tile in frame n+1. If the discrepancy check in frame n indicates the advection result was acceptable, advection is allowed in frame n+1. If not, the advection is turned off for a selected number of frames. The discrepancy check is a check based on whether or not there is a significant change in pixel values of a tile inconsistent with the underlying assumptions of valid advection. If the pixels of an object are slowly moving then a tile is not expected to change significantly between two frames. Thus, if the state of the tile changes significantly the discrepancy check fails. A tile state discrepancy bit (e.g., 0 or 1) may be used to indicate whether the discrepancy check passes. The degree to which changes in tile state are permitted may be determined empirically or heuristically based, for example, in the tradeoffs between the computational benefits of advection and minimizing the appearance of visual artifacts.</p><p id="p0028" num="0028">Other ways of performing discrepancy checks may be utilized. There are computational benefits to performing advection in a tile of current frame n, performing a discrepancy check, and then utilizing the discrepancy check to determine whether or not to perform advection in frame n + 1. However, it will be understood that an alternate implementation of the discrepancy check may be utilized in which the discrepancy check is performed in frame n and used to determine whether or not to utilize advection in frame n to reuse pixels from the previous frame.</p><p id="p0029" num="0029">The accuracy can be improved, if desired, using various enhancements. In one embodiment, back and forth error correction and compensation (BFECC) is used. BFECC utilized the position determined from Semi-Lagrangian advection and adds the velocity at that coordinate to obtain a new position in the current frame. If there is no error, this coordinate should be the same as the original position (x, y). Otherwise by subtracting half of<!-- EPO <DP n="17"> --> this error from (x-v<sub>x</sub>, y-v<sub>y</sub>) the second-order accurate estimate of the position is obtained, which is accurate to half a pixel, assuming that the velocity is pixel accurate.</p><p id="p0030" num="0030"><figref idrefs="f0009">Figure 7B</figref> illustrates a general method of performing advection in accordance with an embodiment of the present invention. A determination is made 1405 if the tile is suitable for advection. The suitability is based on whether the speed range is within the quasi-static range, augmented by passing any additional discrepancy checks. If the tile is suitable for advection, then a determination is made in block 1410 of corresponding pixel locations in the previous frame. A selected fraction of pixels are reused 1420 from a tile of a previous fame. The remaining pixels are rendered 1425.</p><p id="p0031" num="0031"><figref idrefs="f0010">Figure 8</figref> illustrates an example of image interpolation and reconstruction of pixel color values for the situation of desampling. In one embodiment, a weighted summation of color values is used to reconstruct unrendered pixels. For a given choice of the weight function w, a normalized set of weights can be precomputed for each configuration of pixels arising from a particular sampling pattern. For example, if 4 pixels are rendered in a 4x4 block, the remaining 12 pixels can be expressed using a weighted sum of rendered pixels within the same block, as well as its neighboring blocks. In addition, since the set of possible pixel configurations in the neighboring blocks is restricted by the set of sampling patterns, for this case, all possible weight sets can be precomputed.</p><p id="p0032" num="0032">Traditionally, a GPU utilizes bilinear interpolation. However, bilinear interpolation has various drawbacks. In one embodiment higher order polynomials having an order of at least three, such as piece-wise cubic polynomials (also known as cubic splines), are used for efficient reconstruction of sparse samples.</p><p id="p0033" num="0033">Higher order polynomials, such as cubic splines, are capable of mapping a larger frequency spectrum than bilinear interpolation and provide a greater fidelity of data reconstructed from sub-sampled blocks. Additionally, when using bilinear interpolation,<!-- EPO <DP n="18"> --> samples are preferred on both sides of a pixel, as one-sided linear extrapolation is likely to be inaccurate, as well as exceed the color spectrum range. In contrast, higher-order polynomials using a wider support (&gt;1 pixel away) are more likely to accurately approximate the functional form of rendered image data. While a variety of higher order polynomials could be used, a cubic spline has continuity characteristics that are superior to those of quadratic polynomials. Owing to the edge-detection step performed before desampling, a tile undergoing reconstruction is unlikely to have sharp discontinuities, where higher-order polynomial reconstruction may perform poorly.</p><p id="p0034" num="0034">One aspect of performing sub-sampling is that there is a sparse sample data at runtime. In an individual block region, such as a k x k pixel region, desampling may result in a subset of pixels being rendered, such as four or eight pixels from a 4 x 4 block of pixels. The missing pixel data needs to be reconstructed. A consequence of having predetermined sample patterns is that there is a finite set of possible sample locations. This permits a fixed set of local stencils to be created prior to run time, stored, and used to reconstruct pixel data using cubic splines or other higher order polynomials. Conventional approaches to evaluating higher order polynomials in hardware are computationally expensive. In contrast, in embodiments of the present invention the use of a fixed set of pre-computed stencils eliminates the computational overhead, during runtime, of performing a conventional higher order polynomial evaluation. The use of a static set of samples allows the determination of possible configurations of pixels that may need to be reconstructed, and thus the stencils that are required may be pre-computed.</p><p id="p0035" num="0035">In one embodiment, the higher order polynomial interpolation is implemented as static stencil operations using pre-computed weights. In one embodiment, a table of stencils is stored and made available for spatial reconstruction to a reconstruction submodule 211 of the reconstruction and advection stage 210. The table of stencils provides weights based on<!-- EPO <DP n="19"> --> known sample positions. In one embodiment, the table of stencils has all of the stencil weights pre-computed for each pixel location within a defined sample pattern. The pre-computed weights permit the higher order polynomial reconstruction to be performed using static stencil operations.</p><p id="p0036" num="0036">In one embodiment, a set of 5 x 5 stencils is determined for all possible pixel locations in a tile (e.g., a 4 x 4 tile) that may need to be interpolated during runtime. Each 5 x 5 stencil is computed for each pixel location and neighbor configuration. Each stencil provides a list of weight values and corresponding locations of sample points. The stencils are stored in a constant memory table available for reconstruction purposes to the reconstruction submodule 211 of reconstruction and advection stage 210. In one embodiment, at run-time, for each pixel that must be interpolated, an index is computed into this table using the pixel coordinates and sampling mask. In one implementation each stencil is addressed using: (a) the pixel's location within a tile, and (b) the sampling mask used for rendering. Thus, if dithering is employed, the stencil that is selected will depend on which sample pattern is selected for a given degree of subsampling.</p><p id="p0037" num="0037">In one embodiment, the higher order polynomial interpolation is performed using a multiplier/adder to accumulate the products of weights and sample color values. The accumulated value is then normalized by division, which in many cases can be performed by a bit shift for integer formats, or by subtraction for floating point formats. Thus, the use of stencils with pre-computed weights permits the higher order polynomial interpolation to be calculated at run time with comparatively little computational effort.</p><p id="p0038" num="0038">An example of a cubic spline functions used for reconstruction and to compute pixel color values as a weighted sum of known pixel color values is as follows:
<ul><li>In one embodiment, a formula expressing a weighted sum to determine a pixel color value is based weights w() as follows:<!-- EPO <DP n="20"> --> <maths id="math0001" num=""><math display="block"><mrow><mi>c</mi><mfenced separators=","><mi>i</mi><mo>â¢</mo><mi>j</mi></mfenced><mo>=</mo><mfrac><mrow><mstyle displaystyle="false"><mrow><mstyle displaystyle="false"><mrow><munder><mo>â</mo><mrow><mfenced open="{" close="}" separators=","><mi>a</mi><mo>â¢</mo><mi>b</mi></mfenced><mo>â</mo><mi mathvariant="italic">Filled</mi></mrow></munder></mrow></mstyle><mi>w</mi><mo>â¢</mo><mfenced separators=""><mi>i</mi><mo>-</mo><mi>a</mi><mo>,</mo><mi>j</mi><mo>-</mo><mi>b</mi></mfenced><mo>â¢</mo><mi>c</mi><mfenced separators=","><mi>a</mi><mo>â¢</mo><mi>b</mi></mfenced></mrow></mstyle></mrow><mrow><mstyle displaystyle="false"><mrow><mstyle displaystyle="false"><mrow><munder><mo>â</mo><mrow><mfenced open="{" close="}" separators=","><mi>a</mi><mo>â¢</mo><mi>b</mi></mfenced><mo>â</mo><mi mathvariant="italic">Filled</mi></mrow></munder></mrow></mstyle><mi>w</mi><mo>â¢</mo><mfenced separators=""><mi>i</mi><mo>-</mo><mi>a</mi><mo>,</mo><mi>j</mi><mo>-</mo><mi>b</mi></mfenced></mrow></mstyle></mrow></mfrac></mrow></math><img id="ib0001" file="imgb0001.tif" wi="79" he="13" img-content="math" img-format="tif"/></maths><br/>
Where c (i, j) is the color value at pixel location (i, j), w( ) is the two dimensional spline function and "Filled" is the set of pixels that were rendered. The two-dimensional spline function is the product of two one-dimensional spline functions or w(i,j) = k(i)k(j), where the one dimensional spline function k() is based on the cubic filter formula described in the paper by <nplcit id="ncit0001" npl-type="s"><text>Don P. Mitchell and Arun N. Netravali, "Reconstruction Filters in Computer Graphics," Computer Graphics, Volume 22, Number 4, August 1988, pp. 221-228</text></nplcit>: <maths id="math0002" num=""><math display="block"><mrow><mi>k</mi><mfenced><mi>x</mi></mfenced><mo>=</mo><mfrac><mn>1</mn><mn>6</mn></mfrac><mrow><mo>{</mo></mrow><mtable><mtr><mtd><mfenced separators=""><mn>12</mn><mo>-</mo><mn>9</mn><mo>â¢</mo><mi>B</mi><mo>-</mo><mn>6</mn><mo>â¢</mo><mi>c</mi></mfenced><mo>â¢</mo><msup><mfenced open="|" close="|"><mi>x</mi></mfenced><mn>3</mn></msup><mo>+</mo><mfenced separators=""><mo>-</mo><mn>18</mn><mo>+</mo><mn>12</mn><mo>â¢</mo><mi>B</mi><mo>+</mo><mn>6</mn><mo>â¢</mo><mi>C</mi></mfenced><mo>â¢</mo><msup><mfenced open="|" close="|"><mi>x</mi></mfenced><mn>2</mn></msup><mo>+</mo><mfenced separators=""><mn>6</mn><mo>-</mo><mn>2</mn><mo>â¢</mo><mi>B</mi></mfenced></mtd><mtd><mi mathvariant="italic">if</mi><mfenced open="|" close="|"><mi>x</mi></mfenced><mo>&lt;</mo><mn>1</mn></mtd></mtr><mtr><mtd><mfenced separators=""><mi>B</mi><mo>-</mo><mn>6</mn><mo>â¢</mo><mi>C</mi></mfenced><mo>â¢</mo><msup><mfenced open="|" close="|"><mi>x</mi></mfenced><mn>3</mn></msup><mo>+</mo><mfenced separators=""><mn>6</mn><mo>â¢</mo><mi>B</mi><mo>+</mo><mn>30</mn><mo>â¢</mo><mi>C</mi></mfenced><mo>â¢</mo><msup><mfenced open="|" close="|"><mi>x</mi></mfenced><mn>2</mn></msup><mo>+</mo><mfenced separators=""><mo>-</mo><mn>12</mn><mo>â¢</mo><mi>B</mi><mo>-</mo><mn>48</mn><mo>â¢</mo><mi>C</mi></mfenced><mo>â¢</mo><mfenced open="|" close="|"><mi>x</mi></mfenced><mo>+</mo><mfenced separators=""><mn>8</mn><mo>â¢</mo><mi>B</mi><mo>+</mo><mn>24</mn><mo>â¢</mo><mi>C</mi></mfenced></mtd><mtd><mi mathvariant="italic">if</mi><mrow><mspace width="1em"/></mrow><mn>1</mn><mo>â¤</mo><mfenced open="|" close="|"><mi>x</mi></mfenced><mo>â¤</mo><mn>2</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mi mathvariant="italic">otherwise</mi></mtd></mtr></mtable></mrow></math><img id="ib0002" file="imgb0002.tif" wi="165" he="23" img-content="math" img-format="tif"/></maths></li></ul></p><p id="p0039" num="0039">The distances in the Mitchell and Netravali paper are defined in a scaled pixel space: <maths id="math0003" num=""><math display="block"><mrow><mi mathvariant="normal">B</mi><mo>=</mo><mi mathvariant="normal">C</mi><mo>=</mo><msub><mrow><mmultiscripts><mrow><mo>/</mo></mrow><mprescripts/><none/><mn mathvariant="normal">1</mn></mmultiscripts></mrow><mn mathvariant="normal">3</mn></msub></mrow></math><img id="ib0003" file="imgb0003.tif" wi="24" he="8" img-content="math" img-format="tif"/></maths></p><p id="p0040" num="0040">By restricting the relative positioning of sample points, the weights and denominators can be pre-computed into stencils. Because the spline function is defined in a bounded fashion, scaling of the magnitude of x can be used to extend the functions to a desired support radius, such as a 2 pixel support radius.</p><p id="p0041" num="0041">For a tile of size n x n, it is possible to arrange a k x k square in (n/k)*(n/k) possible configurations. A sampling rate of 4*s requires s squares, leading to (n*n)/(k*k*s) sampling patterns.</p><p id="p0042" num="0042"><figref idrefs="f0011">Figure 9</figref> illustrates an example of sampling pattern in a 4 x 4 tile in which the Xs mark rendered samples and the O marks an interpolation location. A 5 x 5 stencil is used that is centered at O. Assuming any access outside this 4x4 tile is invalid, the stencil has 0 weights for any locations outside the 4x4 tile, which are removed from the stencil table. Assuming the top left pixel to be (0, 0), the table entry then reads the locations required as (0, 0), (2, 0), (0, 2), (2, 2), with appropriate weights w0, w1, w2, w3, and the normalization factor w. The<!-- EPO <DP n="21"> --> weighted summation can then be computed as 1/w (w0*c(0, 0) + w1*c(2, 0) + w2*c(0, 2) + w3*c(2, 2)) for each color component by using a multiply-and-accumulate operation. However, more generally, the reconstruction is not limited to one tile but a region of influence of a stencil may extend to neighboring 4 x 4 blocks as well.</p><p id="p0043" num="0043">Assuming a 5 x 5 stencil, there are 24 values in all to be pre-computed (the center is always 0 since the pixel itself has no color value). Of those, at most half can be rendered if 8 samples are used per 4 x 4 tile, leaving 12 values. In one embodiment, each stencil is implemented to include a 4-bit count of the number of non-zero weights, followed by 8-bit weights stored in one chunk, followed by 2 chunks of 3-bit coordinate offsets for the x and y coordinates relative to the center.</p><p id="p0044" num="0044">In one embodiment, the stencils are stored in order of the sampling patterns. In one embodiment the different sampling patterns for the same sampling rate are rotations of each other, so there are two sets of patterns. These can be stored in row major order within a 4 x 4, with an index list to point to the data for pixel (i, j). For rotations of the sampling mask, the coordinates are transformed appropriately.</p><p id="p0045" num="0045">Referring to <figref idrefs="f0012">Figure 10</figref>, consider the case of a 4x4 tile of pixels, in which 8 samples out of the possible 16 are rendered. In this example, stencils are defined for each unknown pixel given the weight function. These stencils can be retrieved at runtime from a pre-defined set of stencils. For the example case of cubic stencils with a support radius of 2 pixels, these stencils would be of size 5 x 5 if no super-sampling is performed. If it is essential to restrict accesses to a k x k tile region, the stencils can be modified appropriately to have 0 weights for such pixels which fall outside the tile. It is important to note that the number of samples does not need to be less than the number of pixels. In regions where super-sampling is desired for anti-aliasing, the number of samples may exceed the number of pixels, e.g. 32<!-- EPO <DP n="22"> --> samples for a 16 pixel 4 x 4 tile. Appropriate pre-computed stencils would be added for those cases.</p><p id="p0046" num="0046">In one embodiment, each sampling pattern is defined as combination of sparse square patterns (e.g., four samples to be rendered in a square pattern). Selecting square patterns is useful in applications in which groups of four pixels (quads) are a default unit of processing. However, more generally other arrangements of sampling positions could be used in the sampling patterns. In one embodiment, the sample patterns are squares of size 3 x 3 within a 4 x 4 tiles. Thus, adjacent vertices are 2 pixels apart along each axis.</p><p id="p0047" num="0047">In one embodiment, the same sampling pattern is used for all regions of an individual frame that are sub-sampled at a given sampling rate. In this embodiment, the same sampling pattern is used in all of the tiles sub-sampled at a given sample rate because this results in consistent spacing of sample positions within every frame, simplifying reconstruction routines.</p><p id="p0048" num="0048">In one embodiment, the sampling patterns are based on quads to exploit Single instruction multiple data (SIMD) processing units. Consistent spacing of samples provides robust interpolation and aids in achieving full pixel resolution in a final image.</p><p id="p0049" num="0049"><figref idrefs="f0013">Figure 11</figref> illustrates a general method of adaptive desampling and spline interpolation in accordance with an embodiment of the present invention. A determination is made 1005 if the speed range of the tile is within the speed range for sub-sampling and a check is made for the presence of edges. A determination 1010 is made of the sub-sampling rate and a sample pattern is chosen. The pixels of the tile are shaded 1015 based on the sampling pattern. Reconstruction is performed 1020 to interpolate missing pixel values, where spline interpolation may be performed.</p><p id="p0050" num="0050"><figref idrefs="f0014">Figure 12</figref> illustrates a method of performing cubic spline interpolation in accordance with an embodiment of the present invention. A tile is selected for sparse sampling 1105. A<!-- EPO <DP n="23"> --> sample pattern is selected 1110. Pixels are rendered 1115 for the sampled locations. Reconstruction is performed of missing pixel data via cubic spline interpolation based on pre-computed weights 1120.</p><p id="p0051" num="0051"><figref idrefs="f0015">Figure 13</figref> illustrates a method of utilizing stencils containing pre-computed weights in accordance with an embodiment of the present invention. Pre-computed weights are generated for each missing pixel location in a sample pattern 1205. A stencil containing the pre-computed weights is stored 1210. The stored stencil is accessed during runtime 1215. The accessed stencil I used to perform cubic spline interpolation 1220.</p><p id="p0052" num="0052"><figref idrefs="f0016">Figure 14</figref> illustrates an example of aspects of advection and reconstruction via cubic splines. The tile size is a 4 x 4 tile size. The pixel pattern in the previous frame is a checkerboard pattern. The rendered pixel values are denoted by an R. In the example on the left, advection is performed to reuse half of the pixel color data from the previous frame in a 4 x 4 tile. The velocity associated with the tile is very low and half of the pixels are advected by copying them from pixel values of the previous frame. Arrows are shown for four of the pixels to indicate reuse of pixel data from the same tile in the previous frame. In this case the color information is copied with no bleeding of color. In the example on the right there is a significant tile speed, corresponding to a half-pixel displacement per frame. In this example reconstruction is performed based on cubic spline interpolation. The velocity along x a 0.5 pixels leads to each rendered pixel having grey exactly halfway between black and white. The reconstructed pixels thus have the same value. That is, the color values are correct, and a full resolution render would also create the same values.</p><p id="p0053" num="0053"><figref idrefs="f0017">Figure 15A</figref> illustrates an example of a frame in which the scene has regions in which the pixel velocity differs from other regions and some regions include color edges. As an example, the scene may include a rider on a motorcycle as well as stationary objects and quasi-stationary objects, such as plants moving slowly in the wind. Thus, there are regions<!-- EPO <DP n="24"> --> that can be classified in different speed regimes. Consequently, as indicated by the boxes in <figref idrefs="f0017">Figure 15B</figref>, different regions of the scene have different pixel velocities, with some of the regions providing different opportunities for adaptive rendering. As a result, in an individual frame the system automatically analyzes individual tiles and makes a determination on a tile-by-tile basis whether to desample and perform advection, desample and perform cubic spline interpolation, or utilize a normal default sampling scheme. Individual decisions may also be made on a tile basis whether or not to perform super-sampling. As the system automatically performs this optimization, no special inputs from an application developer are required, assuming relevant parameter values are defined separately.</p><p id="p0054" num="0054">Embodiments of the present invention may be used to generate a single (non-stereoscopic) display. However, it may also be applied to stereoscopic rendering for virtual reality applications. Referring to <figref idrefs="f0018">Figure 16</figref>, consider the case where separate images are generated for each eye, corresponding to a left eye image and a right eye image. Advection may be used to improve the efficiency of the stereoscopic rendering. In one embodiment a left image is generated. A translation motion, motion<sub>trans</sub>, is defined as the translation to transform portions of the left-eye image to a right eye image. In one embodiment, the sample generator decision making is augmented to make a sampling decision for the right image to attempt to advect pixel values from the left image. In one embodiment, the sampling is Z-based and a test is performed whether a minimum Z of the left image and right image are greater than a threshold Z. If the min (Zleft, Zright)&gt;Zthresh, pixels are advected from the left frame to the right using the motion<sub>trans</sub>. Otherwise rendering is based on the motion based sampling rate. As illustrated in <figref idrefs="f0013">Figure 11</figref>, this results in the right eye image being a combination of advected pixels from the left-eye image and rendered pixels.</p><p id="p0055" num="0055"><figref idrefs="f0019">Figure 17</figref> illustrates an embodiment in which adaptive rendering is applied to foveated rendering. The structure of the human retina of the eye has a fovea portion that provides the<!-- EPO <DP n="25"> --> highest visual acuity in a healthy human eye. The greatest visual acuity of a healthy human eye is within a small cone of angles and drops off with increasing angular distance. Foveated rendering renders higher detail near where the user is looking and lowers the detail further from the focus point. <figref idrefs="f0019">Figure 17</figref> illustrates a focal point (x,y) 1725. The sampling rate is decreased with increasing radial distance from the focal point (e.g., 1/(distance from the focal point). The decrease may be performed in a stepwise fashion at specific radial distance. For example, a specific number of samples may be rendered in a circular region 1720 up to a radial distance r0 1715. A lower number of samples are rendered in the annular region 1710 from r0 to r1 1705. An even lower number of samples are rendered in the region having a radial distance greater than r1. As an illustrative example, 16 samples may be rendered in the region between (x,y) and r0, 8 samples rendered in the region between r0 and r1, and 4 samples in the region beyond r1. More generally other radially varying sampling functions may be used.</p><p id="p0056" num="0056">While the invention has been described in conjunction with specific embodiments, it will be understood that it is not intended to limit the invention to the described embodiments. On the contrary, it is intended to cover alternatives, modifications, and equivalents as may be included within the scope of the invention as defined by the appended claims. The present invention may be practiced without some or all of these specific details. In addition, well known features may not have been described in detail to avoid unnecessarily obscuring the invention. In accordance with the present invention, the components, process steps, and/or data structures may be implemented using various types of operating systems, programming languages, computing platforms, computer programs, and/or computing machines. In addition, those of ordinary skill in the art will recognize that devices, such as hardwired devices, field programmable gate arrays (FPGAs), application specific integrated circuits (ASICs), or the like, may also be used without departing from the scope of the inventive<!-- EPO <DP n="26"> --> concepts disclosed herein. The present invention may also be tangibly embodied as a set of computer instructions stored on a computer readable medium, such as a memory device.</p></description><claims mxw-id="PCLM90459839" lang="EN" load-source="patent-office"><!-- EPO <DP n="27"> --><claim id="c-en-0001" num="0001"><claim-text>A method of graphics processing, comprising:
<claim-text>adaptively rendering at least one tile of a current frame based on speed determined by comparing the current frame to a previous frame.</claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The method of claim 1 wherein the adaptively rendering at least one tile of a current frame comprises:
<claim-text>determining, on a tile-by-tile basis, a relative speed of objects as measured in screen space co-ordinates or pixels in a current frame relative to a previous frame;</claim-text>
<claim-text>classifying each tile within the frame into one of at least three speed categories, the at least three categories including a quasi-static speed category, a medium speed category, and a high-speed category;</claim-text>
<claim-text>making a sampling decision for each tile, based at least in part on the speed category associated with each tile, including whether the tile is to be sampled at a full resolution sampling rate of at least one sample per pixel in the current frame or sampled at a lower rate in the current frame; and</claim-text>
<claim-text>rendering tiles of the current frame.</claim-text></claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The method of claim 2, wherein for a tile classified in the quasi-static speed category the method further comprises reusing pixel data from a previous frame by mapping a location of at least one pixel in the current frame to a corresponding pixel in a previous frame and copying pixel data for the at least one pixel of the previous frame to the current frame.,<!-- EPO <DP n="28"> --> preferably wherein a subset of the pixels from a tile of a previous frame are copied to a tile of the current frame based on a pre-selected ratio of rendered to unrendered pixels, the method optionally further comprising performing a discrepancy check with respect to pixel color values of the previous frame as a condition for reusing pixel data from the previous frame.</claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The method of any of claims 2 or 3, wherein the speed is determined from a difference in vertex position data for rendered geometry between the current frame and a previous frame.</claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The method of any of claims 2 to 4, wherein, for a tile classified in the at least one high speed regime, making a sampling decision includes selecting a sampling pattern in which a number of rendered samples is less than the number of actual pixels associated with the tile, and optionally wherein the method further comprises performing interpolation to determine a color at pixel locations not sampled.</claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The method of any of claims 2 to 5, wherein for a tile classified in the intermediate speed regime, every pixel is sampled at least once</claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>The method of any of claims 2 to 6, further comprising detecting, on a tile-by-tile basis, whether a tile includes an edge and optionally wherein the making a sampling decision for each tile is further based on whether edges are detected within individual tiles.</claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>The method of claim 7, further comprising:
<claim-text>for a tile in the at least one high speed regime not including an edge, selecting a sampling pattern in which a number of samples is less than the number of pixels associated with the tile; and<!-- EPO <DP n="29"> --></claim-text>
<claim-text>for a tile in the at least one high speed regime including an edge, selecting a sampling pattern in which a number of samples is at least equal to one sample per pixel.</claim-text></claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>The method of any of claims 2 to 8, wherein making a sampling decision further comprises making a decision for each tile whether or not to perform super-sampling, preferably wherein the making a decision is based on whether a tile includes an edge wherein super-sampling is performed for a tile including an edge.</claim-text></claim><claim id="c-en-0010" num="0010"><claim-text>A computer program product comprising computer program code means adapted to perform all of the steps of the method of any preceding claim when said program is run on a computer.</claim-text></claim><claim id="c-en-0011" num="0011"><claim-text>A graphics system including a graphics pipeline, comprising:
<claim-text>an adaptive sampling generator configured to determine a required sample rate for each tile based at least in part on a speed of pixels of objects in each tile and selecting a sample pattern based on the required sample rate; and</claim-text>
<claim-text>a pixel shader coupled to the adaptive sampling generator;</claim-text></claim-text></claim><claim id="c-en-0012" num="0012"><claim-text>The graphics system of claim 11, wherein the adaptive sampling generator is adapted to determine a sample pattern and a sample rate for an individual tile based on a combination of the speed of objects in the individual tile and whether or not the individual tile includes an edge and optionally wherein a reduced sampling rate is selected for each tile not including an edge and having a speed above a threshold speed.</claim-text></claim><claim id="c-en-0013" num="0013"><claim-text>The graphics system of claim 12 wherein the adaptive sampling generator comprises:<!-- EPO <DP n="30"> -->
<claim-text>a velocity buffer adapted to compare per-vertex coordinates of vertices of objects in a current frame to corresponding per-vertex coordinates in a previous frame and determine a per-pixel velocity of pixels in each tile;</claim-text>
<claim-text>an edge detector adapted to detect a presence of edges in each tile; and</claim-text>
<claim-text>a sample generator adapted to determine, for each tile to be shaded, a sample pattern and sampling rate based on a speed associated with pixels in each tile and the presence of edges.</claim-text></claim-text></claim><claim id="c-en-0014" num="0014"><claim-text>The graphics system of claim 12 or 13, further comprising an advection unit, wherein for a tile having a velocity below a quasi-static speed limit, a sample pattern having a reduced sampling rate is selected and the reconstruction unit fills in missing pixel data by reusing pixel data from a previous frame via advection, optionally wherein the reconstruction unit identifies a location of a pixel in a previous frame by mapping a change in pixel coordinates.</claim-text></claim><claim id="c-en-0015" num="0015"><claim-text>The graphics system of claim 14, wherein for the tile having a velocity below the quasi-static speed limit a preselected subset of the pixels of the tile are rendered and the remainder of the pixels are reused from the previous frame based on a pre-selected ratio of rendered to unrendered pixels.</claim-text></claim></claims><drawings mxw-id="PDW20422551" load-source="patent-office"><!-- EPO <DP n="31"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="98" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="32"> --><figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="165" he="111" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="33"> --><figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="165" he="110" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="34"> --><figure id="f0004" num="4"><img id="if0004" file="imgf0004.tif" wi="165" he="72" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="35"> --><figure id="f0005" num="5"><img id="if0005" file="imgf0005.tif" wi="93" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="36"> --><figure id="f0006" num="6A"><img id="if0006" file="imgf0006.tif" wi="165" he="205" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="37"> --><figure id="f0007" num="6B"><img id="if0007" file="imgf0007.tif" wi="153" he="151" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="38"> --><figure id="f0008" num="7A"><img id="if0008" file="imgf0008.tif" wi="110" he="190" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="39"> --><figure id="f0009" num="7B"><img id="if0009" file="imgf0009.tif" wi="155" he="173" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="40"> --><figure id="f0010" num="8"><img id="if0010" file="imgf0010.tif" wi="165" he="116" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="41"> --><figure id="f0011" num="9"><img id="if0011" file="imgf0011.tif" wi="151" he="103" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="42"> --><figure id="f0012" num="10"><img id="if0012" file="imgf0012.tif" wi="151" he="93" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="43"> --><figure id="f0013" num="11"><img id="if0013" file="imgf0013.tif" wi="157" he="155" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="44"> --><figure id="f0014" num="12"><img id="if0014" file="imgf0014.tif" wi="157" he="145" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="45"> --><figure id="f0015" num="13"><img id="if0015" file="imgf0015.tif" wi="157" he="145" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="46"> --><figure id="f0016" num="14"><img id="if0016" file="imgf0016.tif" wi="163" he="215" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="47"> --><figure id="f0017" num="15A,15B"><img id="if0017" file="imgf0017.tif" wi="165" he="227" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="48"> --><figure id="f0018" num="16"><img id="if0018" file="imgf0018.tif" wi="128" he="137" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="49"> --><figure id="f0019" num="17"><img id="if0019" file="imgf0019.tif" wi="109" he="145" img-content="drawing" img-format="tif"/></figure></drawings><search-report-data><doc-page id="srep0001" file="srep0001.tif" wi="159" he="233" type="tif"/><doc-page id="srep0002" file="srep0002.tif" wi="159" he="233" type="tif"/></search-report-data><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
