<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2960849-A1" country="EP" doc-number="2960849" kind="A1" date="20151230" family-id="53502481" file-reference-id="304362" date-produced="20180826" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="160451831" ucid="EP-2960849-A1"><document-id><country>EP</country><doc-number>2960849</doc-number><kind>A1</kind><date>20151230</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-15174025-A" is-representative="YES"><document-id mxw-id="PAPP193866630" load-source="docdb" format="epo"><country>EP</country><doc-number>15174025</doc-number><kind>A</kind><date>20150626</date><lang>EN</lang></document-id><document-id mxw-id="PAPP193866631" load-source="patent-office" format="original"><country>EP</country><doc-number>15174025.5</doc-number><date>20150626</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC162030623" ucid="IL-23342214-A" load-source="docdb"><document-id format="epo"><country>IL</country><doc-number>23342214</doc-number><kind>A</kind><date>20140626</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1988525739" load-source="docdb">G06Q  30/06        20120101AFI20151102BHEP        </classification-ipcr><classification-ipcr mxw-id="PCL-1988526477" load-source="docdb">G06Q  30/02        20120101ALI20151102BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1987775158" load-source="docdb" scheme="CPC">G06Q  30/0282      20130101 LI20151029BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987793779" load-source="docdb" scheme="CPC">G06Q  30/0631      20130101 FI20151029BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT165546959" lang="DE" load-source="patent-office">VERFAHREN UND SYSTEM ZUM EMPFEHLEN EINES GEGENSTANDES AN EINEN BENUTZER</invention-title><invention-title mxw-id="PT165546960" lang="EN" load-source="patent-office">METHOD AND SYSTEM FOR RECOMMENDING AN ITEM TO A USER</invention-title><invention-title mxw-id="PT165546961" lang="FR" load-source="patent-office">PROCÉDÉ ET SYSTÈME POUR RECOMMANDER UN OBJET À UN UTILISATEUR</invention-title><citations><patent-citations><patcit mxw-id="PCIT335740922" load-source="docdb" ucid="EP-2602755-A1"><document-id format="epo"><country>EP</country><doc-number>2602755</doc-number><kind>A1</kind><date>20130612</date></document-id><sources><source name="SEA" category="I" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT335746122" load-source="docdb" ucid="US-20140081996-A1"><document-id format="epo"><country>US</country><doc-number>20140081996</doc-number><kind>A1</kind><date>20140320</date></document-id><sources><source name="SEA" category="A" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT335742881" load-source="docdb" ucid="WO-2012013996-A1"><document-id format="epo"><country>WO</country><doc-number>2012013996</doc-number><kind>A1</kind><date>20120202</date></document-id><sources><source name="SEA" category="I" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT335742955" load-source="docdb" ucid="WO-2014036020-A2"><document-id format="epo"><country>WO</country><doc-number>2014036020</doc-number><kind>A2</kind><date>20140306</date></document-id><sources><source name="SEA" category="A" created-by-npl="N"/></sources></patcit></patent-citations><non-patent-citations><nplcit><text>LI ET AL.: "Proceedings of the 21st International Joint Conference on Artificial Intelligence", July 2009, MORGAN KAUFMANN PUBLISHERS INC., article "Can Movies and Books Collaborate? Cross-domain Collaborative Filtering for Sparsity Reduction", pages: 2052 - 2057</text><sources><source mxw-id="PNPL57906958" load-source="docdb" name="APP"/></sources></nplcit><nplcit><text>MORENO ET AL.: "Proceedings of the 21st ACM international conference on Information and knowledge management", ACM, article "Transfer learning for multiple domains", pages: 425 - 434</text><sources><source mxw-id="PNPL77442034" load-source="docdb" name="APP"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR1103325383" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>DEUTSCHE TELEKOM AG</last-name><address><country>DE</country></address></addressbook></applicant><applicant mxw-id="PPAR1103315445" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>DEUTSCHE TELEKOM AG</last-name></addressbook></applicant><applicant mxw-id="PPAR1101647567" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Deutsche Telekom AG</last-name><iid>100109692</iid><address><street>Friedrich-Ebert-Allee 140</street><city>53113 Bonn</city><country>DE</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR1103339334" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>GROLMAN EDITA</last-name><address><country>IL</country></address></addressbook></inventor><inventor mxw-id="PPAR1103302731" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>Grolman, Edita</last-name></addressbook></inventor><inventor mxw-id="PPAR1101639861" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Grolman, Edita</last-name><address><street>128 Ringenblum Street</street><city>8458503 Beer Sheva</city><country>IL</country></address></addressbook></inventor><inventor mxw-id="PPAR1103325513" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>BAR ARIEL</last-name><address><country>IL</country></address></addressbook></inventor><inventor mxw-id="PPAR1103311855" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>Bar, Ariel</last-name></addressbook></inventor><inventor mxw-id="PPAR1101646949" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>Bar, Ariel</last-name><address><street>12/5 Ha'Golshim Street</street><city>7740914 Ashdod</city><country>IL</country></address></addressbook></inventor><inventor mxw-id="PPAR1103325100" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>SHAPIRA BRACHA</last-name><address><country>IL</country></address></addressbook></inventor><inventor mxw-id="PPAR1103344414" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>SHAPIRA, BRACHA</last-name></addressbook></inventor><inventor mxw-id="PPAR1101654035" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>SHAPIRA, BRACHA</last-name><address><street>35 Stroma Street</street><city>8472811 Beer Sheva</city><country>IL</country></address></addressbook></inventor><inventor mxw-id="PPAR1103317262" load-source="docdb" sequence="4" format="epo"><addressbook><last-name>ROKACH LIOR</last-name><address><country>IL</country></address></addressbook></inventor><inventor mxw-id="PPAR1103303495" load-source="docdb" sequence="4" format="intermediate"><addressbook><last-name>ROKACH, LIOR</last-name></addressbook></inventor><inventor mxw-id="PPAR1101644241" load-source="patent-office" sequence="4" format="original"><addressbook><last-name>ROKACH, LIOR</last-name><address><street>19 Sigalon Street</street><city>8496500 Omer</city><country>IL</country></address></addressbook></inventor><inventor mxw-id="PPAR1103338923" load-source="docdb" sequence="5" format="epo"><addressbook><last-name>DAYAN AVIRAM</last-name><address><country>IL</country></address></addressbook></inventor><inventor mxw-id="PPAR1103307033" load-source="docdb" sequence="5" format="intermediate"><addressbook><last-name>DAYAN, AVIRAM</last-name></addressbook></inventor><inventor mxw-id="PPAR1101641918" load-source="patent-office" sequence="5" format="original"><addressbook><last-name>DAYAN, AVIRAM</last-name><address><street>43 Ha'gefen Street</street><city>8496500 Omer</city><country>IL</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR1101639915" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Maiwald Patentanwalts GmbH</last-name><iid>100061181</iid><address><street>Elisenhof Elisenstrasse 3</street><city>80335 München</city><country>DE</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS660691428" load-source="docdb">AL</country><country mxw-id="DS660615271" load-source="docdb">AT</country><country mxw-id="DS660691430" load-source="docdb">BE</country><country mxw-id="DS660693416" load-source="docdb">BG</country><country mxw-id="DS660611357" load-source="docdb">CH</country><country mxw-id="DS660702303" load-source="docdb">CY</country><country mxw-id="DS660615272" load-source="docdb">CZ</country><country mxw-id="DS660691455" load-source="docdb">DE</country><country mxw-id="DS660702304" load-source="docdb">DK</country><country mxw-id="DS660702305" load-source="docdb">EE</country><country mxw-id="DS660785272" load-source="docdb">ES</country><country mxw-id="DS660693650" load-source="docdb">FI</country><country mxw-id="DS660693417" load-source="docdb">FR</country><country mxw-id="DS660691456" load-source="docdb">GB</country><country mxw-id="DS660702306" load-source="docdb">GR</country><country mxw-id="DS660691457" load-source="docdb">HR</country><country mxw-id="DS660615273" load-source="docdb">HU</country><country mxw-id="DS660611358" load-source="docdb">IE</country><country mxw-id="DS660702319" load-source="docdb">IS</country><country mxw-id="DS660693418" load-source="docdb">IT</country><country mxw-id="DS660702320" load-source="docdb">LI</country><country mxw-id="DS660693659" load-source="docdb">LT</country><country mxw-id="DS660615594" load-source="docdb">LU</country><country mxw-id="DS660693660" load-source="docdb">LV</country><country mxw-id="DS660693661" load-source="docdb">MC</country><country mxw-id="DS660615603" load-source="docdb">MK</country><country mxw-id="DS660615604" load-source="docdb">MT</country><country mxw-id="DS660615274" load-source="docdb">NL</country><country mxw-id="DS660785273" load-source="docdb">NO</country><country mxw-id="DS660611367" load-source="docdb">PL</country><country mxw-id="DS660693671" load-source="docdb">PT</country><country mxw-id="DS660615287" load-source="docdb">RO</country><country mxw-id="DS660693672" load-source="docdb">RS</country><country mxw-id="DS660611368" load-source="docdb">SE</country><country mxw-id="DS660693423" load-source="docdb">SI</country><country mxw-id="DS660785274" load-source="docdb">SK</country><country mxw-id="DS660611369" load-source="docdb">SM</country><country mxw-id="DS660615605" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA166480201" lang="EN" load-source="patent-office"><p id="pa01" num="0001">A computer implemented method for recommending an item to a user, according to which a plurality of users each of which with a known profile, interface with a corresponding computerized device and binary event-specific, user-item source matrices are generated, for indicating whether a given user performed a given explanatory event included in a corresponding source matrix. All users included in the source matrices are grouped to a profile-specific cluster and items included in the source matrices are grouped to an item category cluster to generate a predictive event book matrix which indicates the probability that an event unknown to have been performed by the given user will be performed for each profile-specific and item category cluster combination included in the one or more source matrices. Each user gets recommendation about an item included in the source matrices, which has a highest probability.</p></abstract><abstract mxw-id="PA166760013" lang="EN" source="EPO" load-source="docdb"><p>A computer implemented method for recommending an item to a user, according to which a plurality of users each of which with a known profile, interface with a corresponding computerized device and binary event-specific, user-item source matrices are generated, for indicating whether a given user performed a given explanatory event included in a corresponding source matrix. All users included in the source matrices are grouped to a profile-specific cluster and items included in the source matrices are grouped to an item category cluster to generate a predictive event book matrix which indicates the probability that an event unknown to have been performed by the given user will be performed for each profile-specific and item category cluster combination included in the one or more source matrices. Each user gets recommendation about an item included in the source matrices, which has a highest probability.</p></abstract><description mxw-id="PDES98404902" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><b><u>Field of the Invention</u></b></heading><p id="p0001" num="0001">The present invention relates to the field of recommender systems. More particularly, the invention relates to a transfer learning method for recommender systems by which meaningful patterns are extracted from each explanatory event record.</p><heading id="h0002"><b><u>Background of the Invention</u></b></heading><p id="p0002" num="0002">There are two main techniques for gathering feedback from a user: "explicit feedback" and "implicit feedback". With respect to explicit feedback, the recommender system requires the user to explicitly evaluate items, while no active user involvement is required with respect to implicit feedback. The feedback is derived from monitoring the activities of a user.</p><p id="p0003" num="0003">Most Recommender Systems (RS), especially those that are based on collaborative filtering (CF), rely on explicit ratings (e.g. a 1.5 rating score). Unfortunately, in many real-life commercial Recommender Systems, the rating data is scarce and biased because many users waive the rating option. Lack of available ratings may lead to a sparsity problem, negatively affecting the accuracy of neighborhood-based recommendation methods. Although existing ratings are not always available, much information about the user activities in the form of event records can be obtained. There have been several attempts in the prior art that tried to address implicit event data, either by addressing a single event type, or by addressing multiple events by mapping them to numeric or ordinal values (e.g. 3). However, transforming this data into an explicit rating is not straightforward and usually does not reflect the actual preference of the users.</p><p id="p0004" num="0004">Many studies show that the interaction with RS is used for other functions in addition to acquiring recommended items, and the role of an RS within an information system can be quite diverse. In many applications, people use RS for<!-- EPO <DP n="2"> --> discovering new items in various fields, particularly fields that are in rapid development. Due to the unfamiliarity with such items, many users tend not to rate them. By observing user behavior, implicit feedback indirectly reflects the user's opinion and preferences. In addition, in situations in which users may be more likely to rate items that they have strong opinions about, a biased set of items may be created by the ratings themselves. Beyond the obvious problem of having biased information, in this situation the RS may not allow users to be exposed to new products. Another important point is that a sufficient number of explicit ratings is usually unavailable in real life scenarios while implicit data is more within reach; this is why the majority of RS try to weight the various events until they achieve rates to use as input. Finally, it is important to note that naturally explicit feedback relies on the user's willingness to provide explicit ratings, while in implicit feedback there is no such dependence. Furthermore, explicit feedback may have a negative influence on the accuracy of RS, due to user variability and inconsistency in providing these ratings.</p><p id="p0005" num="0005">Most algorithms can interface only with systems that have rating data, and require identical rating scales for all rating matrices (sources and target). Although prediction accuracy is a very significant RS parameter, most collected data is related to binary preference or event data since many users do not cooperate by providing explicit ratings. Thus, additional methods need to be developed to support implicit data input.</p><p id="p0006" num="0006">The method of the present invention relies on multiple types of implicit data input without need for any explicit information. There are no limitations on the number of implicit events to use; furthermore, there is no limitation on the selected target event as well.</p><p id="p0007" num="0007">The basic machine learning technique that the method of the present invention is based on is transfer learning (TL). TL, which is a recently developed machine learning method intended to extract knowledge learned from one task in a domain and used for a target task in a different domain, is needed when required to rebuild statistical models following changes in the distribution of data, for<!-- EPO <DP n="3"> --> example if the data becomes outdated, or for newly-built systems that suffer from a lack of sufficient information.</p><p id="p0008" num="0008">Collecting new training data and rebuilding the model is an expensive process that cannot always be done. The common work flow in the field of Machine Learning is to first train a model based on the data that is available for a given issue - the training data, whether labeled or unlabeled. The behavior is predicted in the examined domain using the test data, according to the model that was built, and in accordance with the assumption that the training and test data are derived from the same feature space and distribution, an assumption which is not always necessarily true.</p><p id="p0009" num="0009">In contrast to traditional techniques, transfer learning allows the training and test set to have different domains, tasks and distributions. This may come in handy for newly-built CF-based systems in which the target domain is extremely sparse. Utilizing different sources of information can significantly improve accuracy of results by alleviating the data sparsity problem.</p><p id="p0010" num="0010">An example of an algorithm based on the TL method is the CBT disclosed by<nplcit id="ncit0001" npl-type="b"><text> Li et al "Can Movies and Books Collaborate? Cross-domain Collaborative Filtering for Sparsity Reduction", In Proceedings of the 21st International Joint Conference on Artificial Intelligence, July, 2009, pp. 2052-2057, Morgan Kaufmann Publishers Inc</text></nplcit>. Assuming that the domains are equally related, Li et al suggests to alleviate the sparsity problem by using user-item rating patterns found for the source domain (the dense rating matrix) and transfer them to the target domain (the sparse rating matrix).</p><p id="p0011" num="0011">In order to transfer the knowledge, a bridge is established at the cluster level of user-item rating patterns. The algorithm of Li et al is built in the following way: first, a codebook is constructed. The codebook summarizes the original rating data, i.e. it summarizes the data of the source domain. The constructed codebook indicates the rating that a user belonging to a specific user cluster will give to an item that belongs to the specific item cluster. The codebook is then constructed by<!-- EPO <DP n="4"> --> simultaneously clustering the users and the items of the source matrix. The second step of the algorithm is to model each target user and target item to one of the clusters respectively in the source domain.</p><p id="p0012" num="0012">However, if the users in the two domains behave differently, or if the domains are not significantly related, this may lead to a condition called Negative Transfer, which may result with a negative effect on the model and a decrease in the target model accuracy.</p><p id="p0013" num="0013">On the other hand, a TL method is subject to overfitting during attempts to avoid the Negative Transfer condition.</p><p id="p0014" num="0014">It is an object of the present invention to provide a transfer learning method for recommender systems that relies on multiple types of implicit data input without need for any explicit information.</p><p id="p0015" num="0015">It is an object of the present invention to provide a transfer learning method for recommender systems that avoids a negative transfer condition as well as overfitting.</p><p id="p0016" num="0016">Other objects and advantages of the invention will become apparent as the description proceeds.</p><heading id="h0003"><b><u>Summary of the Invention</u></b></heading><p id="p0017" num="0017">The present invention provides a computer implemented method for recommending an item to a user, comprising the steps of: interfacing, by a plurality of users each of which having a known profile, with a corresponding computerized device; generating one or more binary event-specific, user-item source matrices for indicating whether a given user performed a given explanatory event included in a corresponding source matrix; grouping each user included in said one or more source matrices to a profile-specific cluster and grouping each item included in said one or more source matrices to an item category cluster to generate a predictive event book matrix which indicates the<!-- EPO <DP n="5"> --> probability that an event unknown to have been performed by said given user will be performed for each profile-specific and item category cluster combination included in said one or more source matrices; and recommending to said given user an item included in said one or more source matrices which is of a highest probability.</p><p id="p0018" num="0018">The present invention is also directed to a recommender system, comprising: a plurality of computerized devices; an input device associated with each of said computerized devices, by which a user having a known profile interfaces with a corresponding computerized device; a database for storing event records as inputs, in response to an interfacing operation performed with respect to said corresponding computerized device; and a server in data communication with each of said computerized devices via a data network, for receiving said event data, wherein said server is operable to generate:
<ul><li>a target event and one or more source events;</li><li>binary event-specific, user-item source matrices for indicating whether a given user performed a given explanatory event included in a corresponding source matrix; to group each user included in said source matrices to a profile-specific cluster and to group each item included in said source matrices to an item category cluster, to generate a predictive event book matrix which indicates the probability that an event unknown to have been performed by said given user will be performed for each profile-specific and item category cluster combination included in said source matrices, and to recommend to said given user an item included in said source matrices which is of a highest probability.</li></ul></p><heading id="h0004"><b><u>Brief Description of the Drawings</u></b></heading><p id="p0019" num="0019">In the drawings:
<ul><li><figref idrefs="f0001">Fig. 1</figref> is a method for recommending an item to a user, according to one embodiment of the present invention; and</li><li><figref idrefs="f0002">Fig. 2</figref> is a schematic illustration of a system for recommending an item to a user, according to one embodiment of the invention.</li></ul><!-- EPO <DP n="6"> --></p><heading id="h0005"><b><u>Detailed Description of Preferred Embodiments</u></b></heading><p id="p0020" num="0020">In the method of the present invention, implicit events are used to learn the preferences of a user and to predict a target event, such as buying (for example, it is possible to assume that indication about "buying" is driven from a "click" and "add to playlist" records). The method does not require explicit ratings from the user, i.e., there is no need to disturb and interrupt the user experience by asking for explicit ratings.</p><p id="p0021" num="0021">The sparsity problem in collaborative filtering (CF) is able to be alleviated by extracting meaningful patterns from different source events such as an exposure to webpage event after being loaded, a scrolling webpage event, a clicking item event and a user plays item event, each of which will be referred hereinafter as "explanatory events" and projecting them towards a chosen target event. Rather than applying transfer learning (TL) for cross-domain recommendation (e.g. from books to movies), as practiced heretofore by prior art methods, the present invention utilizes TL for learning cross-events patterns in the same domain. The target event, e.g. a buying event, is usually sparser than other events and therefore can benefit from TL.</p><p id="p0022" num="0022">The sparse rating-related nature of the target event is alleviated by utilizing TL from other available events, such as click, view, and add to cart events, without assuming any overlapping of users or items between the different events. Each event type may be referred to as a "source domain" and each target event as a "target domain", in accordance with TL terminology. The resulting model can estimate the probability of a certain user <i>u</i> to perform the target event on item <i>v.</i> Consequently, an item, i.e. a service or product to be potentially consumed that is user selectable via a data network, is able to be recommended to a user by simply sorting all the items in descending order, according to their corresponding probabilities. The model can even estimate the probability for a certain user u and item <i>v</i> even if the user did not perform any explanatory related event to item <i>v</i>.<!-- EPO <DP n="7"> --></p><p id="p0023" num="0023">The Applicant has discovered that user-item patterns that are found in a certain event type can also be found in other event types. Thus it is possible to transfer learned models across event types using TL.</p><p id="p0024" num="0024">The method of the present invention can be carried out in conjunction with system 10 schematically illustrated in <figref idrefs="f0002">Fig. 2</figref>. System 10 comprises a plurality of computerized devices, such as tabletop computers 13 and mobile communication devices 14, each of which communicates with one or more data networks 18. When a user interfaces with each computerized device by means of an input device 11, such as a keypad, mouse or a touch screen, the ensuing event is registered by an event recording engine (ERE) 15 and the corresponding data is received by recommender server 20, which also communicates with a data network 18. The ERE is external and is used as an input. Server 20 processes all event data received from a plurality of users with processing module (PM) 23 to generate binary and predictive matrices, as well as a vector which defines the relatedness of an explanatory event to a target event, as will be described hereinafter. ERE 15 may reside in server 20, or alternatively an ERE may reside in each computerized device.</p><heading id="h0006"><b><u>Algorithm Overview</u></b></heading><p id="p0025" num="0025">Cross-domain codebook transfer learning concepts are applied for discovering meaningful patterns between various event record datasets. Given record sets of different event types for a specific domain, a most meaningful event type, e.g. buying, is considered as the "target event" (corresponding to the "target domain" in the cross-domain models), while the explanatory events act as the "source events" (corresponding to "source domains").</p><p id="p0026" num="0026"><figref idrefs="f0001">Fig. 1</figref> illustrates the method for building the recommendation model, as described in details in the following steps:
<ol><li>1. <b>Event Book Construction -</b> During the first step, codebooks are constructed from each source event. The codebooks capture the behavioral patterns of users for each specific event. The output of this step is a set of matrices, each<!-- EPO <DP n="8"> --> representing a codebook for a source event. The codebooks (referred to as <i>B</i>) are composed from clusters of users and items.</li><li>2. <b>Event Book Transfer</b> - An iterative transfer learning process is applied on the codebooks from step 1 to the target event. In this step, each user and each item from the target event is matched to one selected cluster of users and items, respectively, in each explanatory event codebook. The matching is actually a transfer of the knowledge to the target domain. The wrapper in step 3 repeats this step with different source events subsets and produces several candidate models.</li><li>3. <b>Event Book Wrapper</b> - The wrapper generates several models using the process described in step 2 and then selects the best observed model that will be used as the model of the target event for the recommendation process. In practice the Wrapper activates the Event Book Transfer several times, each time with a different set of candidate event books. Each activation generates a candidate model. Finally, the Wrapper selects the most accurate model from these models as the final model.</li></ol></p><p id="p0027" num="0027">The model is represented as two matrices (<i>U</i> and <i>V</i>) and a vector α. <i>U</i> maps each user in the target event to a vector of <i>N</i> cluster indices corresponding to <i>B</i> (codebook), while <i>V</i> is a symmetric map in the context of items; α is a vector specifying the global relatedness of each explanatory event to the target event. The prediction rule is based on the model that was learned by the algorithm defined in Equation 1.<maths id="math0001" num="eq. (1)"><math display="block"><mrow><mi>p</mi><mfenced separators=""><mi>u</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>d</mi><mo>,</mo><mi>i</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>d</mi></mfenced><mo>=</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mo>⁢</mo><msub><mi>α</mi><mi>n</mi></msub><mo>⁢</mo><msub><mi>B</mi><mi>n</mi></msub><mfenced open="[" close="]"><msub><mi>U</mi><mrow><mi>u</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>d</mi><mo>,</mo><mi>n</mi></mrow></msub></mfenced><mo>⁢</mo><mfenced open="[" close="]"><msub><mi>V</mi><mrow><mi>i</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>d</mi><mo>,</mo><mi>n</mi></mrow></msub></mfenced></mrow></math><img id="ib0001" file="imgb0001.tif" wi="149" he="14" img-content="math" img-format="tif"/></maths></p><p id="p0028" num="0028">Each of these components is able to be learned by the algorithms described in the following sections.</p><heading id="h0007"><b><u>Event Book Construction</u></b></heading><p id="p0029" num="0029">This algorithm is a lightweight version of a co-clustering approach for grouping similar users and items together to thereby generate a codebook for each of the source events datasets. The input of the algorithm is the events record, as each<!-- EPO <DP n="9"> --> record contains a user ID (ranging from 1 to p), an item ID (ranging from 1 to q) and a rating value which is fixed to be "1", indicating that the event is applicable in this user-item context. These records are divided into training (ST) and validation (SV) sets. The algorithm associates each user to one of K possible clusters and each item to L possible clusters (K and L are controlled parameters of the algorithm). The outputs of the algorithm are: U - the users' cluster assignment map specifying for each user his associated user-cluster index ranging from 0 to K-1; V - a symmetric vector, mapping each item to item-cluster index (0 to L-1); and B the codebook; KxL matrix specifies the probability that this event is applicable for each user-item cluster/group combination. The algorithm is set to solve the optimization problem presented in Equation 2, which aims to minimize the squared error between the actual ratings in ST and the predicted ones according to the codebook values. <maths id="math0002" num="eq. (2)"><math display="block"><mrow><msub><mi>min</mi><mrow><mi>U</mi><mo>,</mo><mi>V</mi><mo>,</mo><mi>B</mi></mrow></msub><mstyle displaystyle="false"><mrow><mstyle displaystyle="true"><mrow><munder><mo>∑</mo><mi mathvariant="italic">ST</mi></munder></mrow></mstyle><mrow><mrow><msup><mfenced separators=""><msub><mi mathvariant="italic">ST</mi><mrow><mi mathvariant="italic">uid</mi><mo>,</mo><mi mathvariant="italic">iid</mi></mrow></msub><mo>-</mo><mi>B</mi><mfenced open="[" close="]"><msub><mi>U</mi><mi mathvariant="italic">uid</mi></msub></mfenced><mo>⁢</mo><mfenced open="[" close="]"><msub><mi>V</mi><mi mathvariant="italic">iid</mi></msub></mfenced></mfenced><mn>2</mn></msup></mrow></mrow></mrow></mstyle></mrow></math><img id="ib0002" file="imgb0002.tif" wi="139" he="15" img-content="math" img-format="tif"/></maths></p><p id="p0030" num="0030">Next, we start an iterative process of co-clustering and pattern discovering (lines 6-15). Each of the iterations consists of three parts: 1) User's cluster discovery: according to the current <i>V</i> and <i>B</i> values we find the optimal cluster-index for each user (lines 8-9), minimizing the total error between the user's actual event-ratings (each fixed to be 1) and the predicted ones using the current other model variables. After discovering the new cluster assignment for all users, we update the codebook (line 11); 2) Items cluster discovery - symmetric to the previous phase (lines 11-13), but from the items' perspective. 3) Evaluation - we evaluate the accuracy of the current model measure on a validation set - <i>SV</i> (line 14), we apply this phase in order to avoid overfitting of the codebooks on <i>ST</i>. The termination condition is either: After predefined <i>T</i> iterations; or after iteration with no significant improvement to the RMSE, compared to the previous one (an improvement which is less than threshold value ε, or no improvement at all). Lastly, the algorithm returns the generated model from the iteration with minimum RMSE (line 16).</p><p id="p0031" num="0031">The following is the co-clustering, event book construction algorithm:<!-- EPO <DP n="10"> -->
<ol><li>1. For <i>iid</i>←1 .. <i>q</i> do</li><li>2. Set randomly <i>V</i><sup>(0)</sup>iid from {0, .. <i>L-1</i>}</li><li>3. For <i>uid</i>←1 <i>..p</i> do</li><li>4. Set randomly <i>U</i><sup>(0)</sup><sub>uid</sub> from {0, .. <i>K-1</i>}</li><li>5. Calculate current CodeBook - <i>B<sup>(0)</sup></i>, according to eq. 3.</li><li>6. Set <i>t</i>=1</li><li>7. While (<i>!Termination Condition</i>) do</li><li>8. For <i>uid</i>←1 ..p do <maths id="math0003" num=""><math display="block"><mrow><msub><mrow><msup><mi>U</mi><mrow><mfenced><mi>t</mi></mfenced></mrow></msup></mrow><mi mathvariant="italic">uid</mi></msub><mo>=</mo><msub><mi>argmin</mi><mrow><mi>j</mi><mo>,</mo><mi>j</mi><mo>∈</mo><mfenced open="{" close="}" separators=""><mn>0</mn><mo>…</mo><mi>K</mi><mo>-</mo><mn>1</mn></mfenced></mrow></msub><mstyle displaystyle="false"><mrow><mstyle displaystyle="true"><mrow><munder><mrow><mo>∑</mo></mrow><mrow><mi mathvariant="italic">iid</mi><mo>∈</mo><msub><mi mathvariant="italic">ST</mi><mi mathvariant="italic">uid</mi></msub></mrow></munder></mrow></mstyle><mrow><mrow><msup><mfenced separators=""><msub><mi mathvariant="italic">ST</mi><mrow><mi mathvariant="italic">uid</mi><mo>,</mo><mi mathvariant="italic">iid</mi></mrow></msub><mo>-</mo><msup><mi>B</mi><mrow><mfenced separators=""><mi>t</mi><mo>-</mo><mn>1</mn></mfenced></mrow></msup><mfenced open="[" close="]"><mi>j</mi></mfenced><mo>⁢</mo><mfenced open="[" close="]"><msubsup><mi>V</mi><mi mathvariant="italic">iid</mi><mrow><mfenced separators=""><mi>t</mi><mo>-</mo><mn>1</mn></mfenced></mrow></msubsup></mfenced></mfenced><mn>2</mn></msup></mrow></mrow></mrow></mstyle></mrow></math><img id="ib0003" file="imgb0003.tif" wi="100" he="10" img-content="math" img-format="tif"/></maths></li><li>9. Calculate current CodeBook - <i>B<sup>(t)</sup></i>, according to Eq. 3.</li><li>10. For <i>iid</i>←1 .. <i>q</i> do <maths id="math0004" num=""><math display="block"><mrow><msub><mrow><msup><mi>V</mi><mrow><mfenced><mi>t</mi></mfenced></mrow></msup></mrow><mi mathvariant="italic">iid</mi></msub><mo>=</mo><msub><mi>argmin</mi><mrow><mi>j</mi><mo>,</mo><mi>j</mi><mo>∈</mo><mfenced open="{" close="}" separators=""><mn>0</mn><mo>…</mo><mi>L</mi><mo>-</mo><mn>1</mn></mfenced></mrow></msub><mstyle displaystyle="false"><mrow><mstyle displaystyle="true"><mrow><munder><mrow><mo>∑</mo></mrow><mrow><mi mathvariant="italic">uid</mi><mo>∈</mo><msub><mi mathvariant="italic">ST</mi><mi mathvariant="italic">uid</mi></msub></mrow></munder></mrow></mstyle><mrow><mrow><msup><mfenced separators=""><msub><mi mathvariant="italic">ST</mi><mrow><mi mathvariant="italic">uid</mi><mo>,</mo><mi mathvariant="italic">iid</mi></mrow></msub><mo>-</mo><msup><mi>B</mi><mrow><mfenced separators=""><mi>t</mi><mo>-</mo><mn>1</mn></mfenced></mrow></msup><mfenced open="[" close="]"><mi>j</mi></mfenced><mo>⁢</mo><mfenced open="[" close="]"><msubsup><mi>U</mi><mi mathvariant="italic">uid</mi><mrow><mfenced separators=""><mi>t</mi><mo>-</mo><mn>1</mn></mfenced></mrow></msubsup></mfenced><mo>⁢</mo><mfenced open="[" close="]"><mi>j</mi></mfenced></mfenced><mn>2</mn></msup></mrow></mrow></mrow></mstyle></mrow></math><img id="ib0004" file="imgb0004.tif" wi="109" he="11" img-content="math" img-format="tif"/></maths></li><li>11. Update current CodeBook - <i>B<sup>(t)</sup></i> ,according to eq. 3.</li><li>12. Evaluate current model (<i>calculate RMSE</i>) on <i>SV</i> data set</li><li>13. t=t+1</li><li>14. Return <i>U</i><sup>(t)</sup>, <i>V<sup>(t)</sup></i>, <i>B</i><sup>(t)</sup> with minumum RMSE on <i>SV</i>.</li></ol></p><p id="p0032" num="0032">In lines 1-5, a random cluster index is set for each user and item in ST, and then the initial codebook is calculated. Each element Bij in the matrix is set according to Equation 3: the number of observed events in ST associated with the user-item pairs corresponding to cluster indices (i,j), divided by the total size of the pairwise-cluster (number of users that belong to cluster i multiplied by the number of items belonging to cluster j). <maths id="math0005" num="eq. (3)"><math display="block"><mrow><msub><mi>B</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mrow><mfenced open="|" close="|" separators=""><mi mathvariant="italic">ST</mi><mo>/</mo><msub><mi>U</mi><mi mathvariant="italic">uid</mi></msub><mo>=</mo><mi>i</mi><mo>∧</mo><msub><mi>V</mi><mi mathvariant="italic">iid</mi></msub><mo>=</mo><mi>j</mi></mfenced></mrow><mrow><mfenced open="|" close="|" separators=""><mi mathvariant="italic">ST</mi><mo>/</mo><msub><mi>U</mi><mi mathvariant="italic">uid</mi></msub><mo>=</mo><mi>i</mi></mfenced><mo>*</mo><mfenced open="|" close="|" separators=""><mi mathvariant="italic">ST</mi><mo>/</mo><msub><mi>V</mi><mi mathvariant="italic">iid</mi></msub><mo>=</mo><mi>j</mi></mfenced></mrow></mfrac></mrow></math><img id="ib0005" file="imgb0005.tif" wi="139" he="17" img-content="math" img-format="tif"/></maths></p><p id="p0033" num="0033">An iterative process of co-clustering and pattern discovering is then initiated in lines 6-15. Each of the iterations consists of three parts: (1) User's cluster discovery: the optimal cluster-index for each user is found according to the current V and B values (lines 8-9), minimizing the total error between the user's actual event-ratings (each fixed to be 1) and the predicted ones using the current other model variables. After discovering the new cluster assignment for all users,<!-- EPO <DP n="11"> --> the codebook is updated (line 11); (2) Items cluster discovery - symmetric to the previous phase (lines 11-13), but from the items' perspective. (3) Evaluation - the accuracy of the current model measure on a validation set - SV is evaluated (line 14), this phase being applied in order to avoid overfitting of the codebooks on ST. The termination condition is either: After predefined T iterations; or after iteration with no significant improvement to the RMSE, compared to the previous one (an improvement which is less than threshold value ε, or no improvement at all). Lastly, the algorithm returns the generated model from the iteration with minimum RMSE (line 16).</p><heading id="h0008"><b><u>Event Book Transfer</u></b></heading><p id="p0034" num="0034">This is the core learning algorithm. Based on the codebooks generated from multiple source events datasets, a model for predicting the ratings on the target event is generated. The codebooks from the different source events discover patterns regarding the probabilities that certain groups (clusters) of users will perform the given explanatory event on different groups (clusters) of items; in this algorithm this knowledge is transferred to the target event. For each user and item in the target event records, the most relevant clusters in each source/explanatory events is associated with the given codebook; in addition the algorithm determines the global relevance of each source/explanatory event to the target domain. The baseline algorithm advantageously includes a compact representation of data-structures, lacks a highly sparse indicator-based matrix W, and avoids unnecessary and costly linear-algebra matrix operations.</p><p id="p0035" num="0035">The inputs of the algorithm are the TT and TV datasets from the target event data source (training and validation datasets, respectively, with the same structures as SV and ST from the Event Book Construction section) and N source event codebooks. The outputs of the algorithm are the U and V matrices mapping for each user and item in the target event, the relevant clusters in each of the source event codebooks and a global alpha vector indicating how to aggregate the source event codebooks together. A compact representation for U and V is used, for each user/item the associated vector in U/V contains the cluster indices directly for each of the N source events. This compact representation reduces<!-- EPO <DP n="12"> --> space complexity, and enables one to predict the rating that a user (uid) will give to an item (iid) directly, without using costly matrix multiplications. The prediction rule is presented in Equation 1. The relevant matrix indices of each source event codebook are simply observed for summarizing the results according to the relevant alphas. In order to find U, V and the relevant alphas, an optimization problem intended to minimize the squared error of the model is defined, as presented in Equation 4. <maths id="math0006" num="eq. (4)"><math display="block"><mrow><msub><mi>min</mi><mrow><mi>U</mi><mo>,</mo><mi>V</mi><mo>,</mo><mi>α</mi></mrow></msub><mstyle displaystyle="false"><mrow><mstyle displaystyle="true"><mrow><munder><mrow><mo>∑</mo></mrow><mi mathvariant="italic">TT</mi></munder></mrow></mstyle><mrow><mrow><msup><mfenced separators=""><msub><mi mathvariant="italic">TT</mi><mrow><mi mathvariant="italic">uid</mi><mo>,</mo><mi mathvariant="italic">iid</mi></mrow></msub><mo>-</mo><mrow><mstyle displaystyle="false"><mrow><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mrow></mstyle><msub><mi>α</mi><mi>n</mi></msub><mrow><msub><mi>B</mi><mi>n</mi></msub><mfenced open="[" close="]"><msub><mi>U</mi><mrow><mi mathvariant="italic">uid</mi><mo>,</mo><mi>n</mi></mrow></msub></mfenced><mo>⁢</mo><mfenced open="[" close="]"><msub><mi>V</mi><mrow><mi mathvariant="italic">iid</mi><mo>,</mo><mi>n</mi></mrow></msub></mfenced></mrow></mrow></mfenced><mn>2</mn></msup></mrow></mrow></mrow></mstyle></mrow></math><img id="ib0006" file="imgb0006.tif" wi="140" he="14" img-content="math" img-format="tif"/></maths></p><p id="p0036" num="0036">The following event book transfer algorithm is used to solve this optimization problem:
<ol><li>1. For iid←1 .. <i>q</i> do</li><li>2. For n ← 0 .. <i>N-1</i> do</li><li>3. set randomly <i>V<sup>(0)</sup></i><sub>iid,n</sub> from {0, .. <i>L<sub>n-1</sub></i>}</li><li>4. For n ← 0 .. <i>N-1</i> do</li><li>5. set α<i><sup>(0)</sup></i><sub>n</sub> to <i>1</i>/<i>N</i></li><li>6. Set <i>t</i>=1</li><li>7. While (<i>!Termination Condition</i>) do</li><li>8. For <i>uid</i>←1 .<i>.</i>p do</li><li>9. Find optimal assignment <i>U</i><sub><i>uid</i>,</sub>* minimizing: <maths id="math0007" num=""><math display="block"><mrow><mstyle displaystyle="false"><mrow><mstyle displaystyle="true"><mrow><munder><mrow><mo>∑</mo></mrow><mrow><mi mathvariant="italic">iid</mi><mo>∈</mo><mi mathvariant="italic">TT</mi><mfenced><mi mathvariant="italic">uid</mi></mfenced></mrow></munder></mrow></mstyle><mrow><mrow><msup><mfenced separators=""><msub><mi mathvariant="italic">TT</mi><mrow><mi mathvariant="italic">uid</mi><mo>,</mo><mi mathvariant="italic">iid</mi></mrow></msub><mo>-</mo><mrow><mstyle displaystyle="false"><mrow><munderover><mrow><mo>∑</mo></mrow><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow></munderover></mrow></mstyle><msubsup><mi>α</mi><mi>n</mi><mrow><mfenced separators=""><mi>t</mi><mo>-</mo><mn>1</mn></mfenced></mrow></msubsup><mrow><msub><mi>B</mi><mi>n</mi></msub><mfenced open="[" close="]"><msub><mi>U</mi><mrow><mi mathvariant="italic">uid</mi><mo>,</mo><mi>n</mi></mrow></msub></mfenced><mo>⁢</mo><mfenced open="[" close="]"><msubsup><mi>V</mi><mrow><mi mathvariant="italic">iid</mi><mo>,</mo><mi>n</mi></mrow><mrow><mfenced separators=""><mi>t</mi><mo>-</mo><mn>1</mn></mfenced></mrow></msubsup></mfenced></mrow></mrow></mfenced><mn>2</mn></msup></mrow></mrow></mrow></mstyle></mrow></math><img id="ib0007" file="imgb0007.tif" wi="96" he="12" img-content="math" img-format="tif"/></maths></li><li>10. Set <i>U<sup>(t)</sup><sub>uid</sub>,*</i> according to the returned solution</li><li>11. For <i>iid</i>←1 .. <i>q</i> do</li><li>12. Find optimal assignment <i>V<sub>iid,</sub></i> * minimizing: <maths id="math0008" num=""><math display="block"><mrow><mstyle displaystyle="false"><mrow><mstyle displaystyle="true"><mrow><munder><mrow><mo>∑</mo></mrow><mrow><mi mathvariant="italic">iid</mi><mo>∈</mo><mi mathvariant="italic">TT</mi><mfenced><mi mathvariant="italic">uid</mi></mfenced></mrow></munder></mrow></mstyle><mrow><mrow><msup><mfenced separators=""><msub><mi mathvariant="italic">TT</mi><mrow><mi mathvariant="italic">uid</mi><mo>,</mo><mi mathvariant="italic">iid</mi></mrow></msub><mo>-</mo><mrow><mstyle displaystyle="false"><mrow><munderover><mrow><mo>∑</mo></mrow><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow></munderover></mrow></mstyle><msubsup><mi>α</mi><mi>n</mi><mrow><mfenced separators=""><mi>t</mi><mo>-</mo><mn>1</mn></mfenced></mrow></msubsup><mrow><msub><mi>B</mi><mi>n</mi></msub><mfenced open="[" close="]"><msubsup><mi>U</mi><mrow><mi mathvariant="italic">uid</mi><mo>,</mo><mi>n</mi></mrow><mrow><mfenced><mi>t</mi></mfenced></mrow></msubsup></mfenced><mo>⁢</mo><mfenced open="[" close="]"><msub><mi>V</mi><mrow><mi mathvariant="italic">iid</mi><mo>,</mo><mi>n</mi></mrow></msub></mfenced></mrow></mrow></mfenced><mn>2</mn></msup></mrow></mrow></mrow></mstyle></mrow></math><img id="ib0008" file="imgb0008.tif" wi="108" he="14" img-content="math" img-format="tif"/></maths></li><li>13. Set <i>V<sup>(t)</sup><sub>iid</sub>,*</i> according to the returned solution</li><li>14. Update α<i><sub>0</sub></i>, α<i><sub>1</sub></i>, ... α<i><sub>n-1</sub>.</i></li><li>15. Evaluate current model (<i>calculate RMSE</i>) on <i>TV</i></li><li>16. <i>t</i> = <i>t</i>+1.<!-- EPO <DP n="13"> --></li><li>17. Return <i>U</i><sup>(t)</sup>, <i>V</i><sup>(t)</sup><i>, B</i><sup>(t)</sup>, α<sup>(t)</sup> with minumum RMSE on <i>TV.</i></li></ol></p><p id="p0037" num="0037">At first, clusters are randomly assigned for each item in V (lines 1-3) and all alphas are initialized equally to 1/N (lines 4-5). In order to find the best model parameters the rating dataset TT is iterated several times until reaching a termination condition (lines 6-7). Each of the iterations consists of four phases: (1) Iterating all users and adjusting their cluster indices (U), minimizing the total squared error between the real ratings and the predicted ones according to the other parameters of the current model - selecting the best cluster index in each source event codebook from all possible combinations (lines 8-10). (2) Iterating all items and adjusting their cluster indices (V) in a similar way (lines 11-13). (3) Updating alphas by solving a set of N linear equations (lines 15-16) using a similar approach presented in <nplcit id="ncit0002" npl-type="b"><text>Moreno et al: "Transfer learning for multiple domains", Proceedings of the 21st ACM international conference on Information and knowledge management (pp. 425-434), ACM</text></nplcit>. (4) Evaluating the current model on the validation set TV (line 16) in order to avoid overfitting. In all parts of the algorithm, the ratings on TT/TV are scanned directly while ignoring missing values, thereby obviating the need of costly operations. The termination condition (line 7) is either: After predefined T iterations or after iteration with no significant improvement to the RMSE compared to the previous one (improvement which is less than a threshold value ε, or no improvement at all). Finally, the model with minimum RSME is returned on TV (line 17).</p><heading id="h0009"><b><u>Event Book Wrapper</u></b></heading><p id="p0038" num="0038">Commercial recommender systems may include dozens of types of explanatory events in order to support the target events. Sometimes it is not optimal to use all source domain codebooks, as some of them do not represent valid patterns in the target domain or may cause overfitting issues. An overfitting condition is liable to occur in the event-based codebook transfer, if at all. Given N different explanatory event types, there are O(N<sup>2</sup>) possible combinations to examine, to determine whether each of the events will be part of the final model. As it is not practical to examine all possible combinations, a step-forward heuristic feature selection technique may be implemented in order to find a subset of<!-- EPO <DP n="14"> --> source/explanatory event types which will generate a suboptimal solution to this problem at a linear time complexity.</p><p id="p0039" num="0039">The heuristic feature selection technique includes four phases: Firstly, the event book construction algorithm is applied on each of the N explanatory events datasets. Secondly, the event book transfer algorithm is run N times, each time with a single but different source event codebook projected to the target domain. Thirdly, all source event codebooks are ranked according to their RMSE performances on the target validation set (TV). Fourthly, a greedy algorithm which adds event codebooks according to the codebook rankings and generates a new event book transfer model with the current pool of event codebooks is initiated. Event codebooks are added until there is improvement to the RMSE on TV or after adding all available codebooks. The model with the lowest RMSE is returned as the final model. The time complexity is advantageously only O(N).</p><p id="p0040" num="0040">A byproduct of this algorithm is a ranking list of all source events generated codebooks corresponding to the target event by their accuracy performance. These values can serve as baseline estimates for assigning weights for each event type, if one wishes to linearly aggregate events to a single rating value. The ranking of explanatory events generates more objective weights, rather than the traditional manual weight assignment which may be considered subjective.</p><heading id="h0010"><b><u>Evaluation</u></b></heading><p id="p0041" num="0041">Preliminary experimental results have been carried out according to the method of the present invention for event based codebook transfer on real-life commercial datasets.</p><p id="p0042" num="0042">Proprietary datasets obtained from two popular media sites in two domains were used: Music Loads (MLDE) from http://www.musicload.de/ and Video Loads (VL) from http://www.videoload.de/. The following is a summarization of the main dataset characteristics: The MLDE and VL datasets consist of recorded and anonymous user events performed on products in the system. In each dataset the most meaningful event in the system is selected and marked as the target event<!-- EPO <DP n="15"> --> on which recommendations are generated, and in addition, two supporting events that act as source events to the target event.</p><p id="p0043" num="0043">In MLDE the target event was set as "user buys item", while the two explanatory events were set to "user plays item" and "user clicks item". In VL the target event was set to be a union of the "user plays item" and "user loans item" events, while the explanatory events were set as "user clicks item" and "user adds to recordings". In both datasets the data was extremely sparse (more than 99.98%): the MLDE (music) dataset included approximately 11M event records performed by 300K users on 1M different items, while the VL (video) dataset included approximately 4M event records of 220K users on 100K items.</p><p id="p0044" num="0044">The goal of the following experiments is to evaluate whether the method of the invention can successfully transfer knowledge from source events to the selected target event. The accuracy between models is therefore compared - the full generated event-based codebook transfer model taking into consideration all source event codebooks as described hereinabove, which are based on basic CF methods. The basic CF methods were applied by using a state of the art item-to-item CF approach for Big Data. For the similarity measure we the Cosine coefficient and Jaccard were used. In all configurations, the neighborhood size was set to be 20 - this value was detriment during the calibration process. The CF model which yielded the best result of all these options was selected to serve as the basis model for comparison. The k-NN method was chosen for evaluation.</p><p id="p0045" num="0045">All event records (target and source) where divided into training and testing datasets. The training data consisted of 80% of the ratings, selected by random splits over the users' record profiles, while the testing data consisted of the remaining 20%. Since the event book contraction and transfer algorithms rely on validation sets, the training sets were split into "real" training (ST/TT) and valuation (SV/TV) sets with an 80:20 ratio (real training 80%), in order to avoid overfitting issues.<!-- EPO <DP n="16"> --></p><p id="p0046" num="0046">The Event Book Construction was configured as follows: the size of the user and item clusters (K and L) were to 20. The stopping criteria parameters of the learning algorithm, were calibrated to be T = 10 (maximum iteration per single run) and ε = 0.0001 (minimum required improvement in the RMSE on the validation set per iteration). The stopping criteria parameters in Event Book Transfer were set to these values in a similar way.</p><p id="p0047" num="0047">The accuracy of the models was compared using RMSE precision and recall metrics on the test set. RMSE measures the deviation of the predicted rating from the real ones, while putting more emphasis on large errors. In order to measure precision and recall, top-N reconditions was first generate for each user according to the generated model, then based on the test set profile of the user measure precision - the number of hits (generated recommendations which appear in the user's test set profile) divided by N, and recall - the number of hits divided by the user profile size. Top N-recommendations were generated using random sampling of N*2 items which do not appear in the user's training profile; calculating the expected rating of each of the sampled items according to the model, and finally returning the N items with the highest prediction scores. In all experiments, N was set to 1000.</p><heading id="h0011"><b><u>Experiment 1</u></b></heading><p id="p0048" num="0048">The initial part of the experiment evaluated well-known CF models, which are suitable for binary and large-scaled datasets. The accuracy metrics (RMSE, precision and recall) of these models' baseline act as a baseline for the method of the invention. In this experiment, a state of the art item-to-item CF approach for Big Data was applied, using the Jaccard as well as the Cosine coefficient as the similarity measure. In order to choose the best model for comparison each model was run twice. In the first scenario, CF models based only on the most significant event available data were generated. In the second scenario, the input data as added to the explanatory events data was expanded in order to reduce the sparseness of the data. In both scenarios, binary rating schema were applied to indicate for each user-item pair whether there is a certain interaction between them.<!-- EPO <DP n="17"> --></p><p id="p0049" num="0049">Table 1 demonstrates the accuracy results of the different basic CF models for the MLDE (music) dataset. In the model name column, the similarity measure (JACCARD/COSINE) was indicated in brackets, while enriched datasets with the explanatory events were marked with a plus sign. For each of the accuracy metrics, the best observed result was highlighted with a bold font.</p><p id="p0050" num="0050">Table 2 demonstrates accuracy results for the VL (video) dataset, with the same notations. The resulting precision and recall absolute values are considered low since the test set includes the entire item catalog, which includes millions of items. Furthermore, as was mentioned, the dataset is extremely sparse.</p><p id="p0051" num="0051">The next part of the experiment was to construct the event codebooks for every explanatory event type in both the MLDE and VL datasets. The four different event codebooks (two for each dataset) were generated by applying the Event Book Construction algorithm. The Event Book Transfer and the Event Book Wrapper algorithms were then applied on these event codebooks with the target event dataset, to examine the projection of acquired knowledge and patterns from the event codebooks to the target event while performing transfer learning from implicit events (TIE).
<tables id="tabl0001" num="0001"><table frame="all"><title><u>TABLE 1</u></title><tgroup cols="5"><colspec colnum="1" colname="col1" colwidth="8mm"/><colspec colnum="2" colname="col2" colwidth="34mm"/><colspec colnum="3" colname="col3" colwidth="15mm"/><colspec colnum="4" colname="col4" colwidth="20mm"/><colspec colnum="5" colname="col5" colwidth="15mm"/><thead><row><entry namest="col1" nameend="col5" align="center" valign="middle"><u>Basic CF Results - MLDE Dataset</u></entry></row><row><entry valign="top"/><entry valign="top"><b>Model Name</b></entry><entry valign="top"><b>RMSE</b></entry><entry valign="top"><b>Precision</b></entry><entry valign="top"><b>Recall</b></entry></row></thead><tbody><row><entry><b>1</b></entry><entry valign="middle">MLDE (JACCARD)</entry><entry valign="middle">0.6981</entry><entry valign="middle">1.01E-04</entry><entry valign="middle">0.0116</entry></row><row><entry><b>2</b></entry><entry valign="middle">MLDE (COSINE)</entry><entry valign="middle">0.7053</entry><entry valign="middle">1.02E-04</entry><entry valign="middle">0.0118</entry></row><row><entry><b>3</b></entry><entry valign="middle">MLDE (JACCARD)+</entry><entry valign="middle"><b>0.5871</b></entry><entry valign="middle">1.38E-04</entry><entry valign="middle">0.0158</entry></row><row><entry><b>4</b></entry><entry valign="middle">MLDE (COSINE)+</entry><entry valign="middle">0.5941</entry><entry valign="middle"><b>1.39E-04</b></entry><entry valign="middle"><b>0.0160</b></entry></row></tbody></tgroup></table></tables><!-- EPO <DP n="18"> -->
<tables id="tabl0002" num="0002"><table frame="all"><title><u>TABLE 2</u></title><tgroup cols="5"><colspec colnum="1" colname="col1" colwidth="8mm"/><colspec colnum="2" colname="col2" colwidth="28mm"/><colspec colnum="3" colname="col3" colwidth="15mm"/><colspec colnum="4" colname="col4" colwidth="20mm"/><colspec colnum="5" colname="col5" colwidth="15mm"/><thead><row><entry namest="col1" nameend="col5" align="center" valign="top"><u>Basic CF Results - VL Dataset</u></entry></row><row><entry align="right" valign="top"/><entry align="center" valign="top"><b>Model Name</b></entry><entry align="center" valign="top"><b>RMSE</b></entry><entry align="center" valign="top"><b>Precision</b></entry><entry align="center" valign="top"><b>Recall</b></entry></row></thead><tbody><row><entry align="right"><b>1</b></entry><entry align="center" valign="middle">VL (JACCARD)</entry><entry align="center" valign="middle">0.6981</entry><entry align="center" valign="middle">1.35E-04</entry><entry align="center" valign="middle">0.0315</entry></row><row><entry align="right"><b>2</b></entry><entry align="center" valign="middle">VL (COSINE)</entry><entry align="center" valign="middle">0.6418</entry><entry align="center" valign="middle">1.35E-04</entry><entry align="center" valign="middle">0.0318</entry></row><row><entry align="right"><b>3</b></entry><entry align="center" valign="middle">VL+ (JACCARD)</entry><entry align="center" valign="middle">0.5807</entry><entry align="center" valign="middle"><b>1.44E-04</b></entry><entry align="center" valign="middle"><b>0.0340</b></entry></row><row><entry align="right"><b>4</b></entry><entry align="center" valign="middle">VL+ (COSINE)</entry><entry align="center" valign="middle"><b>0.5797</b></entry><entry align="center" valign="middle">1.43E-04</entry><entry align="center" valign="middle">0.0336</entry></row></tbody></tgroup></table></tables></p><p id="p0052" num="0052">Table 3 summarizes the results of the generated models on the MLDE test dataset. The baseline model results appear on the first indexed row. The TIE models appear next along with the applied codebook, see column "model name" in the table (the knowledge transfer process is marked by an arrow). The final selected model by the Event Wrapper appears last (marked with "Final" in the brackets). The best result in each metric appears in bold font.</p><p id="p0053" num="0053">In this experiment, the Event Book Wrapper generated three different TIE models: one with the "click" codebook (line 2), one with the "play" codebook (line 3) and one with both the "click" and "play" codebooks (line 4). Eventually, the last selected TIE model was according to the wrapper heuristic, with the two source<!-- EPO <DP n="19"> --> event codebooks. This model had substantially improved all accuracy matrices compared to the baseline model. The improvement level of the RMSE in the final model was 15.33%, whereas in the precision measure there was an improvement of 5.11% and in the recall measure an improvement of 5.26%. One can observe that the model with the two event codebooks was superior to the TIE models with single codebooks.
<tables id="tabl0003" num="0003"><table frame="all"><title><b><u>Table 3</u></b></title><tgroup cols="5"><colspec colnum="1" colname="col1" colwidth="8mm"/><colspec colnum="2" colname="col2" colwidth="41mm"/><colspec colnum="3" colname="col3" colwidth="15mm"/><colspec colnum="4" colname="col4" colwidth="20mm"/><colspec colnum="5" colname="col5" colwidth="15mm"/><thead><row><entry namest="col1" nameend="col5" align="center" valign="top"><u>Accuracy Results - MLDE Test Dataset</u></entry></row><row><entry valign="top"/><entry align="center" valign="top"><b>Model Name</b></entry><entry align="center" valign="top"><b>RMSE</b></entry><entry align="center" valign="top"><b>Precision</b></entry><entry align="center" valign="top"><b>Recall</b></entry></row></thead><tbody><row><entry><b>1</b></entry><entry align="center" valign="middle">Baseline CF</entry><entry align="center" valign="middle">0.5871</entry><entry align="center" valign="middle">1.39E-04</entry><entry align="center" valign="middle">0.0160</entry></row><row><entry><b>2</b></entry><entry align="center" valign="middle">TIE:</entry><entry morerows="1" rowsep="1" align="center" valign="middle">0.5061</entry><entry morerows="1" rowsep="1" align="center" valign="middle">1.41E-04</entry><entry morerows="1" rowsep="1" align="center" valign="middle">0.0163</entry></row><row><entry/><entry align="center" valign="middle">Click → Buy</entry></row><row><entry><b>3</b></entry><entry align="center" valign="middle">TIE:</entry><entry morerows="1" rowsep="1" align="center" valign="middle">0.5578</entry><entry morerows="1" rowsep="1" align="center" valign="middle">1.45E-04</entry><entry morerows="1" rowsep="1" align="center" valign="middle"><b>0.0168</b></entry></row><row><entry/><entry align="center" valign="middle">Play → Buy</entry></row><row><entry><b>4</b></entry><entry align="center" valign="middle">TIE:</entry><entry morerows="1" rowsep="1" align="center" valign="middle"><b>0.4971</b></entry><entry morerows="1" rowsep="1" align="center" valign="middle"><b>1.46E-04</b></entry><entry morerows="1" rowsep="1" align="center" valign="middle"><b>0.0168</b></entry></row><row><entry/><entry align="center" valign="middle">Click + Play →Buy (Final)</entry></row></tbody></tgroup></table></tables></p><p id="p0054" num="0054">This experiment was then repeated with target and source events in the VL dataset. Table 4 summarizes the main accuracy results, with the same notations as in Table 3. As can be seen, the best selected TIE model was one with both the "click" and "adds to recordings" event codebooks. This model has a 13.32% improvement in RMSE compared to the baseline model.<!-- EPO <DP n="20"> -->
<tables id="tabl0004" num="0004"><table frame="all"><title><b><u>Table 4</u></b></title><tgroup cols="5"><colspec colnum="1" colname="col1" colwidth="8mm"/><colspec colnum="2" colname="col2" colwidth="61mm"/><colspec colnum="3" colname="col3" colwidth="15mm"/><colspec colnum="4" colname="col4" colwidth="20mm"/><colspec colnum="5" colname="col5" colwidth="15mm"/><thead><row><entry namest="col1" nameend="col5" align="center" valign="top"><u>Accuracy Results - VL Test Dataset</u></entry></row><row><entry align="right" valign="top"/><entry align="center" valign="top"><b>Model Name</b></entry><entry align="center" valign="top"><b>RMSE</b></entry><entry align="center" valign="top"><b>Precision</b></entry><entry align="center" valign="top"><b>Recall</b></entry></row></thead><tbody><row><entry align="center"><b>1</b></entry><entry align="center" valign="middle">Baseline CF</entry><entry align="center" valign="middle">0.5797</entry><entry align="center" valign="middle"><b>1.44E-04</b></entry><entry align="center" valign="middle"><b>0.0340</b></entry></row><row><entry align="center"><b>2</b></entry><entry align="center" valign="middle">TIE:</entry><entry morerows="1" rowsep="1" align="center" valign="middle">0.5866</entry><entry morerows="1" rowsep="1" align="center" valign="middle">1.37E-04</entry><entry morerows="1" rowsep="1" align="center" valign="middle">0.0323</entry></row><row><entry align="center"/><entry align="center" valign="middle">Click→ Loan-Play</entry></row><row><entry align="center"><b>3</b></entry><entry align="center" valign="middle">TIE:</entry><entry morerows="1" rowsep="1" align="center" valign="middle">0.5164</entry><entry morerows="1" rowsep="1" align="center" valign="middle">1.36E-04</entry><entry morerows="1" rowsep="1" align="center" valign="middle">0.0320</entry></row><row><entry align="center"/><entry align="center" valign="middle">Add To Recs → Loan-Play</entry></row><row><entry align="center">4</entry><entry align="center" valign="middle">TIE:</entry><entry morerows="1" rowsep="1" align="center" valign="middle"><b>0.5025</b></entry><entry morerows="1" rowsep="1" align="center" valign="middle">1.36E-04</entry><entry morerows="1" rowsep="1" align="center" valign="middle">0.0320</entry></row><row><entry align="center"/><entry align="center" valign="middle">Click + Add To Recs →Loan-Play (Final)</entry></row></tbody></tgroup></table></tables></p><heading id="h0012"><b><u>Experiment 2</u></b></heading><p id="p0055" num="0055">In this experiment, an additional source domain was provided. Instead of adding another different explanatory event as the source domain, the target domain itself was used, such that the target event served as a source domain as well.</p><p id="p0056" num="0056">All the algorithms were configured as in the previous experiment; however, the difference was by applying the Event Book Wrapper algorithm with all three event codebooks - the two source event codebooks and the target event codebook.</p><p id="p0057" num="0057">Applying the Event Book Wrapper algorithm on the MLDE dataset resulted in the following: Firstly, the algorithm generated three single TIE models (one per each event). Secondly, based on the performances of the models in the validation<!-- EPO <DP n="21"> --> set, the ranking of the event codebooks was: Buy &gt; Click &gt; Play. Thirdly, according to the wrapper codebook selection heuristic, the next generated models were Buy + Click and Buy + Click + Play.</p><p id="p0058" num="0058">Table 5 summarizes the accuracy measures of this experiment on the MLDE test set (same notations as in Table 3).
<tables id="tabl0005" num="0005"><table frame="all"><title><b><u>Table 5</u></b></title><tgroup cols="5"><colspec colnum="1" colname="col1" colwidth="13mm"/><colspec colnum="2" colname="col2" colwidth="56mm"/><colspec colnum="3" colname="col3" colwidth="20mm"/><colspec colnum="4" colname="col4" colwidth="24mm"/><colspec colnum="5" colname="col5" colwidth="20mm"/><thead><row><entry namest="col1" nameend="col5" align="center" valign="top"><u>Accuracy Results - MLDE Test Dataset (with target event codebook)</u></entry></row><row><entry valign="top"/><entry align="center" valign="top"><b>Model Name</b></entry><entry valign="top"><b>RMSE</b></entry><entry valign="top"><b>Precision</b></entry><entry valign="top"><b>Recall</b></entry></row></thead><tbody><row><entry><b>1</b></entry><entry align="center" valign="middle">Baseline CF</entry><entry valign="middle">0.5871</entry><entry valign="middle">1.39E-04</entry><entry valign="middle">0.0160</entry></row><row><entry><b>2</b></entry><entry align="center" valign="middle">TIE:</entry><entry morerows="1" rowsep="1" valign="middle">0.4757</entry><entry morerows="1" rowsep="1" valign="middle">1.04E-04</entry><entry morerows="1" rowsep="1" valign="middle">0.0120</entry></row><row><entry/><entry align="center" valign="middle">Buy → Buy</entry></row><row><entry><b>3</b></entry><entry align="center" valign="middle">TIE: Buy + Click + Play → Buy (Final)</entry><entry valign="middle"><b>0.4724</b></entry><entry valign="middle"><b>1.57E-04</b></entry><entry valign="middle"><b>0.0182</b></entry></row></tbody></tgroup></table></tables></p><p id="p0059" num="0059">As one can see, the final model was substantially superior to the baseline model in the precision and recall metrics - improvement by 13.36% in precision and 14.29% in recall, while in terms of RMSE with a 14.29% improvement. In addition, the final model is also superior in all accuracy aspects compared to the TIE models.<!-- EPO <DP n="22"> --></p><p id="p0060" num="0060">This experiment was then repeated with target and source events in the VL dataset. The best obtained TIE model was the one with all three event codebooks ("Loan-Play", "Click" and "Add to Recs"). This model had a 11.87% improvement in RMSE while also improving the precision and recall metrics by 4.17% and 2.65%.</p><p id="p0061" num="0061">Table 6 summarizes the main accuracy results, with the same notations as in Table 4.</p><p id="p0062" num="0062">These results indicate that the method of the present invention will improve the accuracy of the baseline models. Using the target event as an explanatory event improved the results, suggesting that using existing information is as important as using the obtained information from the other events. In addition, adding more event codebooks to the model improves its accuracy.<!-- EPO <DP n="23"> -->
<tables id="tabl0006" num="0006"><table frame="all"><title><b><u>Table 6</u></b></title><tgroup cols="5"><colspec colnum="1" colname="col1" colwidth="12mm"/><colspec colnum="2" colname="col2" colwidth="78mm"/><colspec colnum="3" colname="col3" colwidth="18mm"/><colspec colnum="4" colname="col4" colwidth="23mm"/><colspec colnum="5" colname="col5" colwidth="18mm"/><thead><row><entry namest="col1" nameend="col5" align="center" valign="top"><u>Accuracy Results - VL Test Dataset (with target event codebook)</u></entry></row><row><entry valign="top"/><entry align="center" valign="top"><b>Model Name</b></entry><entry align="center" valign="top"><b>RMSE</b></entry><entry align="center" valign="top"><b>Precision</b></entry><entry align="center" valign="top"><b>Recall</b></entry></row></thead><tbody><row><entry><b>1</b></entry><entry align="center" valign="middle">Baseline CF</entry><entry align="center" valign="middle">0.5797</entry><entry align="center" valign="middle">1.44E-04</entry><entry align="center" valign="middle">0.0340</entry></row><row><entry><b>2</b></entry><entry align="center" valign="middle">TIE:</entry><entry morerows="1" rowsep="1" align="center" valign="middle">0.5325</entry><entry morerows="1" rowsep="1" align="center" valign="middle">1.36E-04</entry><entry morerows="1" rowsep="1" align="center" valign="middle">0.0320</entry></row><row><entry/><entry align="center" valign="middle">Loan-Play → Loan-Play</entry></row><row><entry><b>3</b></entry><entry align="center" valign="middle">TIE:</entry><entry morerows="1" rowsep="1" align="center" valign="middle"><b>0.5109</b></entry><entry morerows="1" rowsep="1" align="center" valign="middle"><b>1.50E-04</b></entry><entry morerows="1" rowsep="1" align="center" valign="middle"><b>0.0349</b></entry></row><row><entry/><entry align="center" valign="middle">Loan-Play + Click + Add To Recs → Loan-Play (Final)</entry></row></tbody></tgroup></table></tables></p><p id="p0063" num="0063">While some embodiments of the invention have been described by way of illustration, it will be apparent that the invention can be carried out with many modifications, variations and adaptations, and with the use of numerous equivalents or alternative solutions that are within the scope of persons skilled in the art, without exceeding the scope of the claims.</p></description><claims mxw-id="PCLM90459853" lang="EN" load-source="patent-office"><!-- EPO <DP n="24"> --><claim id="c-en-0001" num="0001"><claim-text>A computer implemented method for recommending an item to a user, comprising the steps of:
<claim-text>a) creating event-books, one for each explanatory event, using the co-clustering for grouping users and items together into sets for clusters;</claim-text>
<claim-text>b) transferring discovered patterns from said event-books to a target event;</claim-text>
<claim-text>c) for each user/item, finding the most relevant cluster in each event-book, along with a vector of weights, said vector being indicative how much each explanatory event is related to said target event;</claim-text>
<claim-text>d) creating a model for predicting, for each user/item pair, the likelihood that said item is relevant to said user in the context of the target event; and</claim-text>
<claim-text>e) based on said model, generating recommendations by selecting the items with highest values.</claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>A computer implemented method according to claim 1, comprising the steps of:
<claim-text>a) interfacing, by a plurality of users each of which having a known profile, with a corresponding computerized device;</claim-text>
<claim-text>b) generating a target event and one or more source events;</claim-text>
<claim-text>c) generating binary event-specific, user-item source matrices for indicating whether a given user performed a given explanatory event included in a corresponding source matrix;</claim-text>
<claim-text>d) grouping each user included in said source matrices to a profile-specific cluster and grouping each item included in said source matrices to an item category cluster to generate a predictive event book matrix which indicates the probability that an event unknown to have been performed by said given user will be performed for each profile-specific and item category cluster combination included in said source matrices; and</claim-text>
<claim-text>e) recommending to said given user an item included in said source matrices which is of a highest probability.</claim-text><!-- EPO <DP n="25"> --></claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The method according to claim 1, wherein the target event is defined by a binary event-specific, user-item target matrix for indicating whether a plurality of users including said given user performed an event included in said target matrix.</claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The method according to claim 3, further comprising the step of applying an iterative transfer learning process onto the generated event book matrix and transferring knowledge learned therefrom to the target matrix, to predict a relevant rating for the given user with respect to an item of the target event.</claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The method according to claim 4, wherein the step of applying an iterative transfer learning process is performed by generating a global alpha vector for defining how to aggregate event book matrices together.</claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The method according to claim 5, further comprising prior to performing the recommending step, selecting a subset of event books to obtain a best observed model from the transfer learning process, thereby eliminating event books or events which do not contribute to the prediction of the target event.</claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>A recommender system, comprising:
<claim-text>a) a plurality of computerized devices;</claim-text>
<claim-text>b) an input device associated with each of said computerized devices, by which a user having a known profile interfaces with a corresponding computerized device;</claim-text>
<claim-text>c) a database for storing event records as inputs, in response to an interfacing operation performed with respect to said corresponding computerized device; and</claim-text>
<claim-text>d) a server in data communication with each of said computerized devices via a data network, for receiving said event data, wherein said server is operable to:
<claim-text>i. generate a target event and one or more source events;<!-- EPO <DP n="26"> --></claim-text>
<claim-text>ii. generate binary event-specific, user-item source matrices for indicating whether a given user performed a given explanatory event included in a corresponding source matrix;</claim-text>
<claim-text>iii. group each user included in said source matrices to a profile-specific cluster;</claim-text>
<claim-text>iv. group each item included in said source matrices to an item category cluster;</claim-text>
<claim-text>v. generate a predictive event book matrix which indicates the probability that an event unknown to have been performed by said given user will be performed for each profile-specific and item category cluster combination included in said source matrices; and</claim-text>
<claim-text>vi. recommend to said given user an item included in said source matrices which is of a highest probability.</claim-text></claim-text></claim-text></claim></claims><drawings mxw-id="PDW20422564" load-source="patent-office"><!-- EPO <DP n="27"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="148" he="213" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="28"> --><figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="165" he="215" img-content="drawing" img-format="tif"/></figure></drawings><search-report-data><doc-page id="srep0001" file="srep0001.tif" wi="159" he="233" type="tif"/><doc-page id="srep0002" file="srep0002.tif" wi="159" he="233" type="tif"/></search-report-data><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
