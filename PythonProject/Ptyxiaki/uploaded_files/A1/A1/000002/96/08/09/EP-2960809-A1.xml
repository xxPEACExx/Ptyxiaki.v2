<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2960809-A1" country="EP" doc-number="2960809" kind="A1" date="20151230" family-id="51033005" file-reference-id="318329" date-produced="20180824" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="160451468" ucid="EP-2960809-A1"><document-id><country>EP</country><doc-number>2960809</doc-number><kind>A1</kind><date>20151230</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-14174779-A" is-representative="YES"><document-id mxw-id="PAPP193865904" load-source="docdb" format="epo"><country>EP</country><doc-number>14174779</doc-number><kind>A</kind><date>20140627</date><lang>EN</lang></document-id><document-id mxw-id="PAPP193865905" load-source="patent-office" format="original"><country>EP</country><doc-number>14174779.0</doc-number><date>20140627</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC162032616" ucid="EP-14174779-A" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>14174779</doc-number><kind>A</kind><date>20140627</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1865060875" load-source="docdb">G06F  17/30        20060101AFI20161213BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1869708802" load-source="docdb" scheme="CPC">G06F  17/30584     20130101 LI20161213BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987785980" load-source="docdb" scheme="CPC">G06F  17/30336     20130101 FI20141203BHEP        </classification-cpc><classification-cpc mxw-id="PCL-1987795141" load-source="docdb" scheme="CPC">G06F  17/30315     20130101 LI20141203BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT165545870" lang="DE" load-source="patent-office">Transparenter Zugang zu Daten mit mehreren Temperaturen</invention-title><invention-title mxw-id="PT165545871" lang="EN" load-source="patent-office">Transparent access to multi-temperature data</invention-title><invention-title mxw-id="PT165545872" lang="FR" load-source="patent-office">Accès transparent à des données multi-températures</invention-title><citations><patent-citations><patcit mxw-id="PCIT335962076" load-source="docdb" ucid="EP-2660732-A1"><document-id format="epo"><country>EP</country><doc-number>2660732</doc-number><kind>A1</kind><date>20131106</date></document-id><sources><source name="SEA" category="A" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT335962074" load-source="docdb" ucid="US-5515531-A"><document-id format="epo"><country>US</country><doc-number>5515531</doc-number><kind>A</kind><date>19960507</date></document-id><sources><source name="SEA" category="A" created-by-npl="N"/></sources></patcit><patcit mxw-id="PCIT371647023" load-source="docdb" ucid="US-5960194-A"><document-id format="epo"><country>US</country><doc-number>5960194</doc-number><kind>A</kind><date>19990928</date></document-id><sources><source name="SEA" category="XI" created-by-npl="N"/></sources></patcit></patent-citations><non-patent-citations><nplcit><text>None</text><sources><source mxw-id="PNPL62251173" load-source="docdb" name="APP"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR1103342199" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>SAP SE</last-name><address><country>DE</country></address></addressbook></applicant><applicant mxw-id="PPAR1103330443" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>SAP SE</last-name></addressbook></applicant><applicant mxw-id="PPAR1101643855" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>SAP SE</last-name><iid>101471558</iid><address><street>Dietmar-Hopp-Allee 16</street><city>69190 Walldorf</city><country>DE</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR1103333036" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>BOLIK VEIT</last-name><address><country>DE</country></address></addressbook></inventor><inventor mxw-id="PPAR1103306655" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>BOLIK, VEIT</last-name></addressbook></inventor><inventor mxw-id="PPAR1101644065" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>BOLIK, VEIT</last-name><address><street>c/o SAP AG Dietmar-Hopp-Allee 16</street><city>69190 Walldorf</city><country>DE</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR1101649612" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Richardt Patentanwälte</last-name><iid>101226098</iid><address><street>Wilhelmstraße 7</street><city>65185 Wiesbaden</city><country>DE</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS660610604" load-source="docdb">AL</country><country mxw-id="DS660690367" load-source="docdb">AT</country><country mxw-id="DS660610606" load-source="docdb">BE</country><country mxw-id="DS660606556" load-source="docdb">BG</country><country mxw-id="DS660687756" load-source="docdb">CH</country><country mxw-id="DS660610491" load-source="docdb">CY</country><country mxw-id="DS660690368" load-source="docdb">CZ</country><country mxw-id="DS660610619" load-source="docdb">DE</country><country mxw-id="DS660610492" load-source="docdb">DK</country><country mxw-id="DS660610493" load-source="docdb">EE</country><country mxw-id="DS660685478" load-source="docdb">ES</country><country mxw-id="DS660606557" load-source="docdb">FI</country><country mxw-id="DS660606558" load-source="docdb">FR</country><country mxw-id="DS660610620" load-source="docdb">GB</country><country mxw-id="DS660610494" load-source="docdb">GR</country><country mxw-id="DS660610621" load-source="docdb">HR</country><country mxw-id="DS660690369" load-source="docdb">HU</country><country mxw-id="DS660687757" load-source="docdb">IE</country><country mxw-id="DS660610503" load-source="docdb">IS</country><country mxw-id="DS660606559" load-source="docdb">IT</country><country mxw-id="DS660610504" load-source="docdb">LI</country><country mxw-id="DS660783461" load-source="docdb">LT</country><country mxw-id="DS660690370" load-source="docdb">LU</country><country mxw-id="DS660783462" load-source="docdb">LV</country><country mxw-id="DS660783463" load-source="docdb">MC</country><country mxw-id="DS660685074" load-source="docdb">MK</country><country mxw-id="DS660685083" load-source="docdb">MT</country><country mxw-id="DS660685479" load-source="docdb">NL</country><country mxw-id="DS660690375" load-source="docdb">NO</country><country mxw-id="DS660685084" load-source="docdb">PL</country><country mxw-id="DS660610505" load-source="docdb">PT</country><country mxw-id="DS660685480" load-source="docdb">RO</country><country mxw-id="DS660610506" load-source="docdb">RS</country><country mxw-id="DS660685085" load-source="docdb">SE</country><country mxw-id="DS660610511" load-source="docdb">SI</country><country mxw-id="DS660690376" load-source="docdb">SK</country><country mxw-id="DS660685086" load-source="docdb">SM</country><country mxw-id="DS660687758" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA166479838" lang="EN" load-source="patent-office"><p id="pa01" num="0001">A system, a computer-implemented method, and a computer readable medium having stored thereon a computer executable program code for providing access to a database on the system. The database comprises entries stored across partitions. The system comprises a first storage device, a second storage device, and a computing device. The first storage device comprises only one partition of the partitions. The second storage device comprises all of the other partitions except the one of the first partition. Each of the partitions has a respective partition identification for identification of that partition. Each of the entries comprises at least one data value indicative of allocation of the each of the entries in one of the partitions. Each of the entries is stored in one or more data rows of data tables stored in the database. Each of the data rows comprises a respective primary key for identification of that data row. The computing device comprises a memory storing processor-executable program code and a computer processor to execute the processor-executable program code in order to cause the computing device to perform the computer-implemented method.
<img id="iaf01" file="imgaf001.tif" wi="78" he="103" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA166759650" lang="EN" source="EPO" load-source="docdb"><p>A system, a computer-implemented method, and a computer readable medium having stored thereon a computer executable program code for providing access to a database on the system. The database comprises entries stored across partitions. The system comprises a first storage device, a second storage device, and a computing device. The first storage device comprises only one partition of the partitions. The second storage device comprises all of the other partitions except the one of the first partition. Each of the partitions has a respective partition identification for identification of that partition. Each of the entries comprises at least one data value indicative of allocation of the each of the entries in one of the partitions. Each of the entries is stored in one or more data rows of data tables stored in the database. Each of the data rows comprises a respective primary key for identification of that data row. The computing device comprises a memory storing processor-executable program code and a computer processor to execute the processor-executable program code in order to cause the computing device to perform the computer-implemented method.</p></abstract><description mxw-id="PDES98404539" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001"><b>Technical field</b></heading><p id="p0001" num="0001">This disclosure relates generally to data processing and, in particular, to transparent access of data.<!-- EPO <DP n="2"> --></p><heading id="h0002"><b>Background</b></heading><p id="p0002" num="0002">Data accessed/processed by various applications and/or services can be stored based on the age, importance, and/or any other factors related to the data in databases. For example, data that is important and/or frequently used, e.g., operation-relevant (or "hot") data can be stored in fast, expensive storage media that can be quickly accessed, whereas data that is less relevant or less-frequently accessed (or "cold" data) can be stored in a slow, less expensive storage media. The Hot data can occupy top levels of storage hierarchy so that it can be easily accessed. Data "temperature" ("hot" or "cold") can be assigned to the data based on usage, access, storage media, and/or any other factors.</p><p id="p0003" num="0003">The data can be stored redundantly at different levels of a storage hierarchy. However, it is preferable that only the hot data occupy top level(s) of storage hierarchy to save costs. After data temperature has been assigned to particular business object data and appropriate data storage location has been determined, the data can be appropriately queried/accessed. However, given the multiple temperatures of the stored data, it is difficult to determine how to optimally access the data at different storage levels, so that data queries load and/or process correct portions of "hot" and/or "cold" data.</p><p id="p0004" num="0004">Some conventional approaches to resolving this problem involve the user specifying whether cold data is to be considered or not. This is not feasible as the user typically is not aware of the temperature that has been assigned to the data and hence, is not able to identify whether cold data needs to be queried. This can lead to the end user not receiving the data the user requested (e.g., the user can be forced to re-run the query with a lower temperature delimiter), performance penalties due to unnecessarily evaluating data of higher I/O latency, and processing of a higher data volume. Another conventional approach requests application logic to derive the determination of whether hot/cold data needs to be queried and change all access coding, so that hot and/or cold data is queried explicitly. Such approach is implementation- and cost-prohibitive.</p><p id="p0005" num="0005">Thus, the conventional approaches failed to provide transparent data access that can avoid (content-wise) unnecessary data load and processing costs without placing a decision burden on end users or application developers in deciding whether data of lower temperatures should be accessed.<!-- EPO <DP n="3"> --></p><heading id="h0003"><b>Summary</b></heading><p id="p0006" num="0006">A computer-implemented technology for providing access to a database is described herein. As it will be clearly seen from the description herein this technology can reduce access time to the database by directing queries to a correct partition of the database. This process is implemented by generating a row store index of the database, wherein each data row of the database has a respective index row. As a result thereof access time to the database is reduced. Access time to the database is further reduced by storing the partitions on different storage devices having different access time. The partition containing "hot" data is stored on the first storage device having shorter access time than the second storage device, on which the rest of partitions are stored. At least a portion of the index rows is stored on the first data storage and the rest is stored on the second storage. Storing of the database across partitions and row store index across the first and the second data storage provides a unique opportunity for effective aging of data at two different time scales. For instance, moving data between partitions, when its "temperature" is changed, can be made in predetermined intervals of time because of big data volumes of data to be moved. Such operations may be performed on a weekly, monthly, annual, etc. time scale. On the other hand the most frequently used portion of index rows may be stored on the first storage and updated instantly. Since a data volume of the row sore index is much smaller than a data volume of the database, it may be stored in non-compressed way, while data compression is usually used for storing partitions of the database because of their big data volume.</p><p id="p0007" num="0007">Utilization of this scheme mentioned above can contribute to solving the following contradiction. Storing the database across partitions may be implemented according to a first set of criteria enabling optimum operation of a first group of programs, while optimum operation of a second group of programs requires storing the database across partitions according to a second set of criteria being in contradiction with the first set of the criteria. For instance programs like on-line On-Line Analytical Processing (OLAP) may prepare reports on an annual basis. Therefore it makes sense to split a data base comprising transactions in partitions on the annual basis as well. On the other hand programs like On-Line Transactional Processing (OLTP) may continue updating/monitoring at least a portion of the transactions for duration of more than one year on a daily basis. In order to avoid searching for transactions to be processed by OLTP in all partitions, a row store index can be used effectively. An<!-- EPO <DP n="4"> --> OLTP application can identify first in the row store index one or more partitions where the requested by OLTP transactions are stored and afterwards search for the requested transactions.</p><p id="p0008" num="0008">The advantage of the proposed scheme may be illustrated on another simple example. For instance optimum performance of a first group of programs operating on the database comprising transactions requires splitting of database in partitions on an annual basis, i.e. each of the transactions is stored in a respective partition associated with a year when the each of the transactions is closed. The second group of programs prepares analysis and/or modifies all transactions generated for one or more clients. This activity of the one or more clients may extend over several years, therefore having the row store index helps to start a search in the partitions comprising needed transactions instead of searching through entire database.</p><p id="p0009" num="0009">It is an objective of embodiments of the invention to provide for a system configured to provide access to a database, a computer-implemented method for providing access to a database on the system, and a computer readable medium having stored thereon a computer executable program code for providing access to a database on the system. Advantageous embodiments are described in the dependent claims. According to one embodiment, the present invention relates to a system comprising a first storage device, a second storage device, and a computing device. A database, containing entries, is stored across partitions. The first storage device comprises one partition of the partitions. The second storage device comprises the other partition(s) except the one of the first storage device. Each of the partitions has a respective partition identification for identification of that partition. Each of the entries comprises at least one data value indicative of allocation of the each of the entries in one of the partitions. Each of the entries is stored in one or more data rows of data tables stored in the database. Each of the data rows comprises a respective primary key for identification of that data row.</p><p id="p0010" num="0010">The computing device comprises: a memory storing processor-executable program code and a computer processor to execute the processor-executable program code in order to cause the computing device to: generate, for each of the primary keys, a respective index row comprising the respective primary key and the partition identification associated with said respective primary key; and execute a query by primary key on the database, wherein one of the primary keys is specified in the query by primary key.<!-- EPO <DP n="5"> --></p><p id="p0011" num="0011">The executing of the query by primary key comprises the following: identifying the partition identification associated with the specified primary key using the index rows; and executing a query by primary key on the partition having the identified partition identification using the specified primary key.</p><p id="p0012" num="0012">According to one embodiment, the execution of the processor-executable code by the computer processor further causes the computing device to modify the one or more indicative data values of the entry; and move the entry to the target partition if at least one data value indicative of allocation of the entry to be moved is modified and the at the least one modified data value indicates that the entry has to be moved to the target partition form the source partition in which it is currently stored, wherein all index rows comprising the respective primary keys of the data rows of the entry to be moved are updated after the entry to be moved is moved, wherein in each of the updated index rows the partition identification of the source partition is substituted by the partition identification of the target partition, wherein the source partition is one of the partitions and the target partition is another one of the target partitions.</p><p id="p0013" num="0013">According to one embodiment, the execution of the processor-executable code by the computer processor further causes the computing device to store at least a portion of the index rows on the first storage device, and storing all index rows, which are not stored on the first storage device, on the second storage device, wherein the index rows stored on the first storage device comply with an index allocation criterion, wherein the identifying of the partition identification associated with the specified primary key is performed using the index rows stored on the first storage device if the index rows stored on the first storage device comprise the specified primary key otherwise the identifying of the partition identification associated with the specified primary key is performed using the index rows stored on the second storage device. According to one embodiment, the present invention relates to a computer-implemented method for providing access to a database on a system. The database, comprising entries, is stored across partitions. The system comprises a first storage device, a second storage device, and a computing device. The first storage device comprises one partition of the partitions. The second storage device comprises the other partition(s) except the one of the first storage device. Each of the partitions has a respective partition identification of that partition. Each of the entries comprises at least one data value indicative of allocation of the each of the entries in<!-- EPO <DP n="6"> --> one of the partitions. Each of the entries is stored in one or more data rows of data tables stored in the database. Each of the data rows comprises a respective primary key for identification of that data row. The computing device comprises a memory storing processor-executable program code and a computer processor to execute the processor-executable program code in order to cause the computing device to perform the computer-implemented method.</p><p id="p0014" num="0014">The computer-implemented method comprises the following: generating, for each of the primary keys, a respective index row comprising the respective primary key and the partition identification associated with said respective primary key; and executing a query by primary key on the database, wherein one of the primary keys is specified in the query by primary key.</p><p id="p0015" num="0015">The executing of the query by primary key comprises the following: identifying the partition identification associated with the specified primary key using the index rows; and executing a query by primary key on the partition having the identified partition identification using the specified primary key.</p><p id="p0016" num="0016">According to one embodiment, the present invention relates to a computer readable medium having stored thereon a processor-executable program code for execution by a computer processor controlling a computing device of a system. The system comprises a first storage device, a second storage device, and the computing device. The database, comprising entries, is stored across partitions. The first storage device comprises one partition of the partitions. The second storage device comprises the other partition(s) except the one of the first storage device. Each of the partitions has a respective partition identification for identification of that partition. Each of the entries comprises at least one data value indicative of allocation of the each of the entries in one of the partitions. Each of the entries is stored in one or more data rows of data tables stored in the database. Each of the data rows comprises a respective primary key for identification of that data row. The computing device comprises a memory storing processor-executable program code and a computer processor to execute the processor-executable program code in order to cause the computing device to perform the computer-implemented method.</p><p id="p0017" num="0017">The computer-implemented method comprises the following: generating, for each of the primary keys, a respective index rows comprising the respective primary key and the partition identification associated with said respective primary key; and executing<!-- EPO <DP n="7"> --> a query by primary key on the database, wherein one of the primary keys is specified in the query by primary key.</p><p id="p0018" num="0018">The executing of the query by primary key comprises the following: identifying the partition identification associated with the specified primary key; and executing a query by primary key on the partition having the identified partition identification using the specified primary key.</p><p id="p0019" num="0019">In another embodiment the computer-implemented method further comprises storing at least a portion of the index rows on the first storage device, and storing all index rows, which are not stored on the first storage device, on the second storage device, wherein the index rows stored on the first storage device comply with an index allocation criterion, wherein the identifying of the partition identification associated with the specified primary key is performed using the index rows stored on the first storage device if the index rows stored on the first storage device comprise the specified primary key otherwise the identifying of the partition identification associated with the specified primary key is performed using the index rows stored on the second storage device.</p><p id="p0020" num="0020">In another embodiment the computer-implemented method further comprises: modifying the one or more indicative data values of the entry; and moving the entry to the target partition if at least one data value indicative of allocation of the entry to be moved is modified and the at the least one modified data value indicates that the entry has to be moved to the target partition form the source partition in which it is currently stored, wherein all index rows comprising the respective primary keys of the data rows of the entry to be moved are updated after the entry to be moved is moved, wherein in each of the updated index rows the partition identification of the source partition is substituted by the partition identification of the target partition, wherein the source partition is one of the partitions and the target partition is another one of the target partitions.</p><p id="p0021" num="0021">In another embodiment an access time of the first storage device is shorter than an access time of the second storage device.</p><p id="p0022" num="0022">In another embodiment each of some or all of the data tables are stored across partitions, wherein each of the tables being stored across partitions is split in table portions comprising the data rows stored in each of the partitions across which the each of the tables is stored, wherein the data tables are column store data tables, wherein each column of each of the data tables stored only in one of the partitions is<!-- EPO <DP n="8"> --> stored as a contiguous compressed data record in the only one of the partitions, wherein each column of each of the table portions stored in the respective partition is stored as the contiguous compressed data record in the respective partition. The moving of the entries is performed only in predetermined non-overlapping time intervals. The moving of the entry from its source partition to its target partition comprises moving each data row of the entry to be moved from the respective source table being stored in said source partition and comprising the each data row to the respective target table being stored in said target partition. The respective source table comprising the each data row and the respective target table used for inserting of the each data row are table portions of one of the data tables being stored across at least said source and said target partition and comprising the each data row. The moving of the each data row comprises the following: decompressing each of the compressed contiguous data records corresponding to the columns of the source table; decompressing each of the contiguous compressed data records corresponding to the columns of the target table; moving each of data entities of the each data row from the respective decompressed data record of the source table to the respective decompressed data record of the target table, wherein the respective decompressed data record of the source table and the respective decompressed data record of the target table correspond to one of the columns of the one of the data tables and the one of the columns comprises the each of the data entities, wherein each of the columns of the one of the data tables comprises the respective data entity of the each data row, wherein the each data entity is the primary key, or a secondary key, or the data value; after the moving of the each of the data entities compressing each of the decompressed contiguous data records corresponding to the columns of the source table; and after the moving of the each of the data entities compressing each of the decompressed contiguous data records corresponding to the columns of the target table.</p><p id="p0023" num="0023">In another embodiment the index rows are stored in index tables. The index tables are row store tables. Each of the data rows and its corresponding index row comprise the identical primary key. Each row of each of the index tables is stored as a contiguous data record. Each of the index tables has the respective data table comprising an identical set of the primary keys as the each of the index tables. The index allocation criterion is selected from a group consisting of the following index allocation criteria a)-c):<!-- EPO <DP n="9"> -->
<ol><li>a) All index rows are stored on the first storage device;</li><li>b) The index rows corresponding to the data rows stored on the first storage device are stored on the first storage device and the index rows corresponding to the data rows stored on the second storage device are stored on the second storage device, wherein each of the index tables having a portion of the index rows stored on the first storage device and another portion of the index rows stored on the second storage device is stored across the first and second storage device, wherein the moving of the each data row further comprises moving of the contiguous data record of the respective index row comprising the same primary index as the each data row from the first storage device to the second storage device if the each data row is moved from the first storage device to the second storage device, wherein the moving of the each data row further comprises moving of the contiguous data record of the respective index row comprising the same primary index as the each data row from the second storage device to the first storage device if the each data row is moved from the second storage device to the first storage device, wherein the index table comprising the respective index row is stored across the first storage device and the second storage device;</li><li>c) The index rows corresponding to the data rows stored on the first storage device are stored on the first storage device and the index rows corresponding to the data rows stored on the second storage device are stored the second storage device before the executing of any of the queries by primary key, wherein each of the index tables having a portion of the index rows stored on the first storage device and another portion of the index rows stored on the second storage device is stored across the first and second storage device, wherein the computer-implemented method further comprises: generating a counter for each of the index rows, wherein an initial counter value of each of the counters equals to zero, wherein the executing of each of the queries by primary key further comprises increasing by unity of the counter value of the respective index row comprising the primary key specified in the each of the queries by primary key; and after an overall sum of the counter values exceeds a threshold value perform the following: identifying an index row set of index rows, wherein each of the index rows of the index row set has the respective counter value higher than any of the counter values of the counters of the index rows, which do not belong to the index row set, and a data volume of the index row set is below a threshold data volume; moving each of the index rows of the index row set from the<!-- EPO <DP n="10"> --> second storage device to the first storage device if the each of the index rows of the index row set is stored on the second storage device; moving each of the index rows, which does not belong to the index row set, from the first storage device to the second storage device if the each of the index rows, which does not belong to the index row set, is stored on the first storage device; and after the identifying of the index row set stetting all of the counter values to zero.</li></ol></p><p id="p0024" num="0024">In another embodiment each of some or all of the data rows comprises one or more secondary keys. Each of the secondary keys identifies a respective data row set of the data rows. Each of the index rows of the respective primary key further comprises all secondary keys of the data row comprising the respective primary key if the data row comprising the respective primary key comprises at least one of the secondary keys. The computer-implemented method further comprises: executing a query by secondary key on the database, wherein one of the secondary keys is specified in the query by secondary key, wherein the executing of the query by secondary key comprises: identifying all of the partition identifications stored in the index rows comprising the specified secondary key; and executing a query by secondary key on all of the partitions having their partition identification identified using the specified secondary key.</p><p id="p0025" num="0025">In another embodiment the index rows are stored in index tables. The index tables are row store tables. Each of the data rows and its corresponding index row comprise the identical primary key. Each row of each of the index tables is stored as a contiguous data record. Each of the index tables has the respective data table comprising an identical set of the primary keys as the each of the index tables. The index allocation criterion is selected from a group consisting of the following index allocation criteria a)-c):
<ol><li>a) all index rows are stored on the first storage device;</li><li>b) the index rows corresponding to the data rows stored on the first storage device are stored on the first storage device and the index rows corresponding to the data rows stored on the second storage device are stored on the second storage device, wherein each of the index tables having a portion of the index rows stored on the first storage device and another portion of the index rows stored on the second storage device is stored across the first and second storage device, wherein the moving of the each data row further comprises moving of the contiguous data record of the respective index row comprising the same primary index as the each data row from<!-- EPO <DP n="11"> --> the first storage device to the second storage device if the each data row is moved from the first storage device to the second storage device, wherein the moving of the each data row further comprises moving of the contiguous data record of the respective index row comprising the same primary index as the each data row from the second storage device to the first storage device if the each data row is moved from the second storage device to the first storage device, wherein the index table comprising the respective index row is stored across the first storage device and the second storage device;</li><li>c) the index rows corresponding to the data rows stored on the first storage device are stored on the first storage device and the index rows corresponding to the data rows stored on the second storage device are stored the second storage device before the executing of any of the queries by primary key, wherein each of the index tables having a portion of the index rows stored on the first storage device and another portion of the index rows stored on the second storage device is stored across the first and second storage device, wherein the execution of the processor-executable code by the computer processor further causes the computing device to: generate a counter for each of the index rows, wherein an initial counter value of each of the counters equals to zero, wherein the executing of each of the queries by primary key further comprises increasing by unity of the counter value of the respective index row comprising the primary key specified in the each of the queries by primary key; and after an overall sum of the counter values exceeds a threshold value perform the following: identifying an index row set of index rows, wherein each of the index rows of the index row set has the respective counter value higher than any of the counter values of the counters of the index rows, which do not belong to the index row set, and a data volume of the index row set is below a threshold data volume; moving each of the index rows of the index row set from the second storage device to the first storage device if the each of the index rows of the index row set is stored on the second storage device; moving each of the index rows, which does not belong to the index row set, from the first storage device to the second storage device if the each of the index rows, which does not belong to the index row set, is stored on the first storage device; and after the identifying of the index row set stetting all of the counter values to zero.</li></ol></p><p id="p0026" num="0026">In another embodiment each of some or all of the data rows comprises one or more secondary keys. Each of the secondary keys identifies a respective data row set of<!-- EPO <DP n="12"> --> the data rows. Each of the index rows of the respective primary key further comprises all secondary keys of the data row comprising the respective primary key if the data row comprising the respective primary key comprises at least one of the secondary keys. The execution of the processor-executable code by the computer processor further causes the computing device to: execute a query by secondary key on the database, wherein one of the secondary keys is specified in the query by secondary key, wherein the executing of the query by secondary key comprises: identifying all of the partition identifications stored in the index rows comprising the specified secondary key; and executing a query by secondary key on all of the partitions having their partition identification identified using the specified secondary key. In another embodiment the index rows stored on the first storage are searched first in order to identify the partition identification associated with the primary key specified in the query by primary key. lf the index rows stored on the first storage do not comprise said primary key then the index rows stored on the second storage are searched in order to identify the partition identification associated with the primary key specified in said query by the primary key.</p><p id="p0027" num="0027">In the aforementioned embodiments and in the following detailed description the partition identification is a code used for identification of the partitions. Each of the partition identifications uniquely identifies only one respective partition. Each of the partitions has the respective partition identification being different from partition identifications of the other partitions. For instance, partitions can be numbered, as it will be described in the detailed description.</p><p id="p0028" num="0028">In the aforementioned embodiments and in the following detailed description the primary key is a code used for identification of the data rows. The code can be for instance one or more number, one or more text words, or one or more combinations of text symbols and digits. Each of the primary key uniquely identifies only one respective data rows. Each of the data rows has the respective primary key being different from the primary keys of the other data rows. Execution of query by primary key returns only one data row comprising the primary key specified in the query by primary key if the data base comprises said data row, otherwise the execution of said query by primary key delivers no data rows. Examples of the primary keys will be illustrated in the detailed description.</p><p id="p0029" num="0029">In the aforementioned embodiments and in the following detailed description the secondary key is a code used for identification of the respective set of data rows.<!-- EPO <DP n="13"> --></p><p id="p0030" num="0030">The code can be for instance one or more number, one or more text words, or one or more combinations of text symbols and digits. Execution of query by secondary key returns all data rows of the respective set, if the data base comprises said set, otherwise the execution of said query by secondary key delivers no data rows, wherein each data row of said set comprises the secondary key specified in said query by secondary key. Examples of the secondary keys will be illustrated in the detailed description.<!-- EPO <DP n="14"> --></p><heading id="h0004">Figures</heading><p id="p0031" num="0031"><ul><li><figref idrefs="f0001">Fig. 1</figref> is a block diagram of a system.</li><li><figref idrefs="f0002">Figs. 2a</figref>, <figref idrefs="f0003">b</figref> is an example database stored across partitions.</li><li><figref idrefs="f0004">Fig. 3</figref> illustrates index rows of the example database.</li><li><figref idrefs="f0005">Figs. 4a</figref>, <figref idrefs="f0003">b</figref> is the example database after update.</li><li><figref idrefs="f0007">Fig. 5</figref> is illustrates the index rows of the example database after update.</li><li><figref idrefs="f0008">Fig. 6</figref> is a flow chart of a method for providing access to a database on a system.</li><li><figref idrefs="f0009">Fig. 7</figref> is a flow chart of a method for moving entries between partitions.</li><li><figref idrefs="f0010">Fig. 8</figref> is a flow chart of a method for storing frequently used index rows on a first storage.</li></ul></p><heading id="h0005"><b>Detailed description</b></heading><p id="p0032" num="0032">In the following description, reference is made to the accompanying drawings that form a part hereof, and in which is shown by way of illustration specific embodiments which may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention, and it is to be understood that other embodiments may be utilized and that structural, electrical, and optical changes may be made without departing from the scope of the present invention. The following description of example embodiments is, therefore, not to be taken in a limited sense, and the scope of the present invention is defined by the appended claims.</p><p id="p0033" num="0033"><figref idrefs="f0001">Fig. 1</figref> illustrates a an exemplary system 195 that can provide a transparent access to a data base 191 stored across partitions "Partition 0"-"Parition N" 130-133. The system comprises a first storage device 140 and a second storage device 141. "Partition 0" is stored on the first storage device, while all other partitions "Partition 1"-"Partition N" are stored on the second storage device. In another implementation the partitions may be stored across the first and the second storage device in an arbitrary way. For instance, "Partition 0", "Partition 1 ", and "Partition 2" are stored on the first storage device and all other partitions "Partition 3"-"Partition N" are stored on the second storage device. The first storage device has a shorter access time than the second storage device. The first storage device may be implemented using Dynamic Random Access Memory (DRAM) and/or Static Random Access Memory (SRAM), while the second storage device may be implemented using one or more Hard Disk Drives (HDD) and/or one or more Solid State Drives (SSD). When the<!-- EPO <DP n="15"> --> first and the second storage device are implemented as described above, then the first storage device comprises as usual only one of the partitions, because of the cost limiting factors determining that the first storage device is smaller than the second storage device. In this case storing a portion of the data base across several partitions on the first storage device may not result in acceleration of access to the data of the database stored on the first storage device. It will be necessary to search for required data in said several partitions having much smaller sizes in comparison to the partitions stored on the second storage device, while said several partitions united in one on the first storage device can be effectively searched as one massive of data. The single partition on the first storage device can be implemented as in-memory data base. The system further comprises a computing device. The computing device comprises a memory 193 storing processor-executable program code, and a computer processor (192) to execute the processor-executable program code in order to cause the computing device to provide access to the data base, to perform updates of the database, to execute query or a request to obtain specific data (e.g. query by primary key, query by secondary key), and to move entries of the database between the partitions. The queries may be formulated using the structured query language (SQL). The processor is communicatively coupled to the memory, the first storage device, and the second storage device. The processor may be further communicatively coupled to the I/O interface 194 for communicating with users and/or other computing devices/systems.</p><p id="p0034" num="0034">The database 191 may comprise any query-responsive data sources, e.g., an SQL relational database management system. In some implementations, the data source can include a relational database, a multi-dimensional database, an eXtendable Markup Language ("XML") document, or any other data storage system storing structured and/or unstructured data. The data stored in the database 191 can be distributed among several relational databases, warehouses, multi-dimensional databases, and/or any other data sources, and/or any combinations thereof. The data source can include one or more On-Line Analytical Processing ("OLAP") databases, spreadsheets, text documents, presentations, etc. Further, the database may comprise tabular data, row-based data stored in row format, column-based data stored in columnar format, and object-based data. Data of the database can be indexed and/or selectively replicated in an index to allow fast searching and retrieval.<!-- EPO <DP n="16"> --></p><p id="p0035" num="0035">In some implementations, the current subject matter system can retrieve business object data or any other data from the database in response to queries based on various selection criteria or parameter(s) which can have a correlation to time-based criteria that can be used for partitioning. In a typical access pattern, a date restriction or a status restriction can be used. A status restriction can be part of logic for separating hot data from cold data, which is discussed below. The date restriction can include criteria to partition the hot data from the cold data as well as partition the cold data sorted on the second storage device itself.</p><p id="p0036" num="0036">Each of the partitions has a respective partition identification. Each of the entries of the database comprises at least one data value indicative of allocation of the each of the entries in one of the partitions. Each of the entries is stored in one or more data rows of data tables stored in the database. Each of the data rows comprises a respective primary key for unique identification of the each of the data rows in the database. Each of some or all of the data rows comprises one or more secondary keys. Each of the secondary keys identifies a respective data row set of the data rows. Each of some or all of the data rows comprises data values.</p><p id="p0037" num="0037">Each of some or all of the data tables are being stored across at least two partitions. Each of the tables being stored across partitions is split in table portions comprising the data rows stored in each of the partitions across which the each of the tables is stored. Each of the table portions of the same table have the same table metadata describing the data table, i.e. names of the columns, sequence of the columns in the table, etc. The data tables are column store data tables. Each column of each of the data tables stored only in one of the partitions is stored as a contiguous compressed data record in the only one of the partitions. Each column of each of the table portions stored in the respective partition is stored as the contiguous compressed data record in the respective partition. Various data compression methods may be used for the contiguous data records of the data tables. Any entry of the database can be moved between partitions when one or more indicative data values of the any entry is modified. For instance, moving of the entries between partitions may be executed in the framework of aging of data, when the status of a portion of the entries is changed from "hot" to "cold".</p><p id="p0038" num="0038"><figref idrefs="f0002">Figs. 2a</figref> and <figref idrefs="f0003">2b</figref> illustrate an example database corresponding to the general description of the database mentioned above. The example data base is stored across 3 partitions 0-2 130-132. The "Partition 0" is stored on the first storage device 140<!-- EPO <DP n="17"> --> and comprises "hot" data/entries. "Partition 1" and "Partition 2" are stored on the second storage device 141 and comprise "cold" data/entries. The data base comprises "Oder table" 100 and "Position table" 110. Both of the data tables are stored across 3 partitions. The rows 160, 161, and 162 of the data table 100 are stored in the "Partition 0". The row 167 of the data table 100 is stored in the "Partition 1" and the row 169 of the data table 100 is stored in the "Partition 2". The rows 163-166 of the data table 110 are stored in the "Partition 0". The row 168 of the data table 110 is stored in the "Partition 1" and the row 170 of the data table 110 is stored in the "Partition 2".</p><p id="p0039" num="0039">The "Order table" 100 represents a list of purchase orders. The "Position table" represents details of purchase orders. The "Order table" has 4 columns "Order ID", "Custormer ID", "Order Status", and "Date closed". The "Order ID" column comprises order specifications 101 being primary keys for unique identification of each of the orders/entries in the database. The "Customer ID" column comprises customer identifications 102 being secondary keys for identification of a set of orders for each of the customers. The column "Order status" comprises data values 103 being indicative whether the order is closed or not, e.g. whether the products are delivered to customer or not. The column "Data closed" comprises dates when the orders are closed. If the order is not closed then the value in the column "Date closed" equals to 0. Each of the orders/entries has a respective unique row 160, 161, 162, 167, and 169 in the data table 100.</p><p id="p0040" num="0040">The "Position table" 110 comprises 5 columns "Order ID", "Position ID", "Product ID", "Amount", and "Date closed". The column "Order ID" in the data table 110 comprises customer identifications being secondary keys 111 for identification of sets of products of each of the orders/entries in the database. The column "Position ID" comprises position identifications 112 being primary keys for deification of each of the order position in the data table 110. The column "Product ID" comprises product identifications 113 being secondary keys for identification of sets of identical products in the data table 110. The column "Amount" comprises data values 114 specifying amount of products ordered in each of the positions. The column "Date closed" of the data table 110 comprises dates when the orders are closed. If the order is not closed then the value in the column "Date closed" equals to 0. Each of the positions in the data table 110 has a respective unique row 163-166, 168, 170.<!-- EPO <DP n="18"> --></p><p id="p0041" num="0041">The values in the columns "Date closed" are used as indicative data values for storing the data rows of data tables 110 and 100 across partitions. If the value in the column "Date closed" equals to 0, then the data row comprising this value is stored in the "Partition 0". If the order is closed in a year 2013, then the data row comprising this value is stored in the "Partition 1". If the order is closed in a year 2012, then the data row comprising this value is stored in the "Partition 2". The columns "Order ID" in the data tables 100 and 110 are linked by a foreign key relationship 151. Data table portions of the data tables 100 and 110 are stored column wise in each of the respective partitions. Each of the columns of each of the data table portions is stored as a contiguous data record in the respective partition. Data compression may be applied to each of the data records. For instance, the portion of the data table 110 is stored in the "Partition 0" as series of contiguous data records 111a, 112a, 113a, 114a, 115a (<figref idrefs="f0002">Fig. 2a</figref>).</p><p id="p0042" num="0042">In order to facilitate access to the database, e.g. to execute queries by primary or secondary key not on entire database but only on partitions comprising data rows having primary keys or secondary keys specified in the queries, a row store index is generated. Index tables comprising index rows are illustrated on <figref idrefs="f0004">Fig. 3</figref>. Each data table of the database has a respective index table. The "order table" 100 has the respective "index table of the order table" 160. The "position table" 110 has the respective "index table of the position table" 170. Each data row has the respective index row and both rows comprise the same primary key (101, 161; 111, 171). Each of the index tables further comprises all secondary keys of the respective data row (102, 162; 112, 172; 113, 173) and the partition number (163, 174) of the respective data row. The pairs of the data rows and their respective index rows are listed as follows: 160, 180; 161, 181; 162, 182; 163, 185; 164, 186; 165, 187; 166, 188; 167, 182; 168, 189; 169, 184; 170, 190. The index rows of each of the index tables are stored row wise as contiguous data records. For instance, the index rows of the table 170 are stored as the contiguous data records 185a, 186a, 187a, 188a, 189a, 190a (<figref idrefs="f0004">Fig. 3</figref>).</p><p id="p0043" num="0043"><figref idrefs="f0005">Figs. 4a</figref> and <figref idrefs="f0006">4b</figref> illustrated the example database after completion of the order "O7". The order was closed on 01.06.13. Since the column "Date closed" comprises data values being indicative for allocation of the entry in one of the partitions and the aforementioned allocation criterion indicates that the entry of order "O7" has to be moved to the "Partition 1", the row 162 is moved from a table portion of the data table<!-- EPO <DP n="19"> --> 100 in the "Partition 0" to a table portion of the data table 100 in the "Partition 1" and the row 166 is moved from a table portion of the data table 110 in the "Partition 0" to a table portion of the data table 110 in the "Partition 1 ".</p><p id="p0044" num="0044"><figref idrefs="f0007">Fig. 5</figref> illustrate a corresponding change in the index tables after the change in the database depicted on the <figref idrefs="f0005">Figs. 4a</figref> and <figref idrefs="f0006">4b</figref>. Since the row 162 is moved to the "Partition 1" the partition number in the respective index row 182 is updated accordingly. Since the row 166 is moved to the "Partition 1" the partition number in the respective index row 188 is updated accordingly.</p><p id="p0045" num="0045"><figref idrefs="f0008">Fig. 6</figref> illustrates a flow chart of a computer-implemented method for providing access to the database 191 on the system 195. In a process block 300 one index row for each of the primary keys of the data rows in the database is generated. Each of the index rows comprises the respective primary key and the partition identification associated with said respective primary key. Each of the primary keys of the respective data row is associated with the partition name of the partition in which said respective data row is stored. An example of execution of this process block is depicted on the <figref idrefs="f0004">Fig. 3</figref> described above.</p><p id="p0046" num="0046">In a process block 301 at least a portion of the generated index rows is stored on the first storage device and the rest of the generated index rows are stored on the second storage device. The index rows stored on the first storage device comply with an index allocation criterion. Details regarding splitting of the index rows between the first and the second index storage will be discussed further on.</p><p id="p0047" num="0047">After execution of the process block 301 various processes may be executed. The choice of a particular process depends on particular task being executed by an application operating on the database. The branch of process blocks 302-304 is used for execution of a query by primary key. The branch of process blocks 305 and 306 is used for moving an entry from one partition to another. The branch of process blocks 307-309 is used for execution of a query by the secondary key.</p><p id="p0048" num="0048">In the process block 302 a query by primary key is received. One of the primary keys is specified in the query by primary key. In the process block 303 the partition identification associated with the specified primary key using the index rows stored on the first storage device is identified if the index rows stored on the first storage device comprise the specified primary key, otherwise the partition identification associated with the specified primary key using the index rows stored on the second storage device. In the process block 304 the query by primary key is executed on<!-- EPO <DP n="20"> --> the partition having the identified partition identification using the specified primary key.</p><p id="p0049" num="0049">Execution of the process blocks 302-304 may be illustrated on the following example using the example database depicted in the <figref idrefs="f0002">Figs. 2a</figref> and <figref idrefs="f0003">2b</figref>. For instance, the primary key "O2" is specified in the query by primary key. When this query is received in the process block 302, the partition identification "0" associated with the primary key "O2" is identified using index row 180 of the index table 160 on the <figref idrefs="f0004">Fig. 3</figref> in the process block 303. Afterwards in the process block 304 the query by the primary key "O2" is executed in the "Partition 0" and delivers the row 160.</p><p id="p0050" num="0050">In the process block 307 a query by secondary key is received. One of the secondary keys is specified in the received query by secondary key. In the process block 308 all of the partition identifications stored in the index rows comprising the specified secondary key are identified. In the process block 309 the query by secondary key is executed in all of the partitions having their partition identification identified using the specified secondary key.</p><p id="p0051" num="0051">Execution of the process blocks 307-309 may be illustrated on the following example using the example database depicted in the <figref idrefs="f0002">Figs. 2a</figref> and <figref idrefs="f0003">2b</figref>. For instance, the secondary key "C17" is specified in the query by secondary key. When this query is received in the process block 307, the partition identifications "1" and "2" associated with the secondary key "C17" are identified using index rows 183 and 184 of the index table 160 on the <figref idrefs="f0004">Fig. 3</figref> in the process block 308. Afterwards in the process block 307 the query by the secondary key "C17" is executed in the "Partition 1" and in the "Partition 2" and delivers the rows 167 and 169.</p><p id="p0052" num="0052">In the process bock 305 one or more indicative data values of the entry are modified. The indicative data values are data values determining allocation of the respective entries in one of the partitions. In the process block 306 the entry is moved to the target partition if at least one data value indicative of allocation of the entry to be moved is modified and the at the least one modified data value indicates that the entry has to be moved to the target partition form the source partition in which it is currently stored, wherein all index rows comprising the respective primary keys of the data rows of the entry to be moved are updated after the entry to be moved is moved. In each of the updated index rows the partition identification of the source partition is substituted by the partition identification of the target partition. The<!-- EPO <DP n="21"> --> source partition is one of the partitions and the target partition is another one of the target partitions.</p><p id="p0053" num="0053">Execution of the process blocks 305 and 306 is illustrated above in the example when order "O7" is closed.</p><p id="p0054" num="0054">The data tables stored in the data base may be stored in a column store way, wherein each column of each table portion (or a complete data table) stored in one or the partitions is stored as a contiguous data record. Further each of the contiguous data records may be stored in the compressed way. This way of data storing has advantages because data compression saves storage space and storing of data tables in a column store way is beneficial for analytical tools operating on columns of data such as OLAP. On the other hand moving of data entries from one partition to another requires a special computer-implemented method depicted on <figref idrefs="f0009">Fig. 7</figref>. Since executing of this method may require substantial computing resources it may be executed only in predetermined non-overlapping time intervals. As it is mentioned in an extended version of the process block 306 on the <figref idrefs="f0009">Fig. 7</figref> the moving of the entry from its source partition to its target partition comprises moving each data row of the entry to be moved from the respective source table being stored in said source partition and comprising the each data row to the respective target table being stored in said target partition. The respective source table comprising the each data row and the respective target table used for inserting of the each data row are table portions of one of the data tables being stored across at least said source and said target partition and comprising the each data row. Details of this procedure are described in the process blocks 306a-306e. These process blocks are executed for the each data row to be moved.</p><p id="p0055" num="0055">In the process block 306a each of the compressed contiguous data records corresponding to the columns of the source table comprising the each data row are decompressed and in the process block 306b each of the contiguous compressed data records corresponding to the columns of the target table in which the each data row to be added are decompressed. Those skilled in the art will understand that the process blocks 306a and 306b can be executed in any sequence or in parallel.</p><p id="p0056" num="0056">It is necessary to mention that moving of one of the data rows of the entry to be moved may be performed in case when said data row has to be moved to a partition where target table does not exist. In this case the target table is created using<!-- EPO <DP n="22"> --> metadata of the source table and execution of the process block 306b is not necessary.</p><p id="p0057" num="0057">In the process block 306c each of data entities of the each data row of the entry to be moved is moved from the respective decompressed data record of the source table to the respective decompressed data record of the target table. The respective decompressed data record of the source table and the respective decompressed data record of the target table correspond to one of the columns of the one of the data tables and the one of the columns comprises the each of the data entities, wherein each of the columns of the one of the data tables comprises the respective data entity of the each data row. Each of the data entities may be but is not limited to: the primary key, the secondary key, or the data value.</p><p id="p0058" num="0058">When all data entities of each data row are moved from the source table to the target table, the process blocks 306d and 306e are executed. In the process block 306d each of the decompressed contiguous data records corresponding to the columns of the source table is compressed. In the process block 306e each of the decompressed contiguous data records corresponding to the columns of the target table is compressed. Those skilled in the art will understand that the process blocks 306d and 306e can be executed in any sequence or in parallel.</p><p id="p0059" num="0059">Execution of the process blocks 306a and 306b can be illustrated on the aforementioned example when the order "O7" is closed. The entry/order "O7" has two rows 162 and 166 in the data tables 100 and 110 correspondingly. In order to move the rows 162 and 166 to the "Partition 1" all columns of table portions of these data tables in the "Partition 0" and the "Partition 1" have to be decompressed.</p><p id="p0060" num="0060">Execution of the process blocks 306c and 306b can be illustrated as a continuation of the aforementioned example. The entities of the row 162 are moved one by one from the source portion of the data table 100 in the "Partition 0" to the target portion of the data table 100 in the "Partition 1 ". In particular, the data entity "O7" is deleted in the decompressed contiguous data record comprising data entity "O2" in the data row 160, data entity "O6" in the data row 161, and to be deleted entity "O7" in the data row 162. The data entity is added to the decompressed contiguous data record comprising data entity "O8" in the row 167. The rest of the data entities of the row 162 are processed in the same way. The row 166 is processed in the same way as the row 162.<!-- EPO <DP n="23"> --></p><p id="p0061" num="0061">Execution of the process blocks 306d and 306e can be illustrated as a continuation of the aforementioned example as well. Al contiguous decompressed data records of the columns of the source and the target table portions stored in the "Partition 0" and in the "Partition 1" are compressed.</p><p id="p0062" num="0062">The index rows are stored in index tables. The index tables are row store tables. Each of the data rows and its corresponding index row comprise the identical primary key. Each row of each of the index tables is stored as a contiguous data record. Each of the index tables has the respective data table comprising an identical set of the primary keys as the each of the index tables. This way of storage of the index tables enables easy moving of the index rows between the first and the second storage device. The contiguous data records of the index rows are not compressed and moving of each of the index rows from one storage device to another requires processing of only one contiguous data record. As a result thereof and in contrast to the data rows the index records can be moved between storage devices at any time without overloading computer resources. The primary benefit of this solution is that a portion of the index rows stored on the first storage device can be instantly updated. This feature is important because memory space on the first storage device is much more expensive and therefore smaller than memory space on the second storage device. Storing of all index rows on the first device storage may require substantial reduction of memory space on the first storage device used for storing of the "hot" data.</p><p id="p0063" num="0063">Depending on particular implementation based on the discussion of possible constraints above the index allocation criterion can be selected from a group consisting of the following index allocation criteria a)-c).
<ol><li>a) All index rows are stored on the first storage device. This solution can be applied when the memory space of the first storage device used for storing of the index rows is not limited by any constraints.</li><li>b) The index rows corresponding to the data rows stored on the first storage device are stored on the first storage device and the index rows corresponding to the data rows stored on the second storage device are stored on the second storage device. Each of the index tables having a portion of the index rows stored on the first storage device and another portion of the index rows stored on the second storage device is stored across the first and second storage device. Each of the index tables being stored across the first storage device and the second storage device is split in<!-- EPO <DP n="24"> --> two index table portions comprising the index rows stored on each of the storage devices. Each of the index table portions of the same index table have the same table metadata describing the index table, i.e. names of the columns, sequence of the columns in the table, etc. The moving of the each data row in the process block 306 further comprises moving of the contiguous data record of the respective index row comprising the same primary index as the each data row from the first storage device to the second storage device if the each data row is moved from the first storage device to the second storage device, and the moving of the each data row in the process block 306 further comprises moving of the contiguous data record of the respective index row comprising the same primary index as the each data row from the second storage device to the first storage device if the each data row is moved from the second storage device to the first storage device, wherein the index table comprising the respective index row is stored across the first storage device and the second storage device. This solution can be applied when the memory space of the first storage device used for storing of the index rows is limited and all index rows cannot be stored on the first storage device.</li><li>c) The following solution/algorithm can be used when the data volume of a data volume of the index rows is limited by a threshold data volume. After the index rows are generated in the process block 300 a sequence of process blocks 301a-301f depicted on <figref idrefs="f0010">Fig. 8</figref> are executed.</li></ol></p><p id="p0064" num="0064">In the process block 301a the index rows corresponding to the data rows stored on the first storage device are stored on the first storage device and the index rows corresponding to the data rows stored on the second storage device are stored the second storage device, wherein each of the index tables having a portion of the index rows stored on the first storage device and another portion of the index rows stored on the second storage device is stored across the first and second storage device. Alternatively all index rows can be stored on the second storage device, or a portion of the index rows corresponding to the data rows stored on the first storage device is stored on the first storage device if a data volume of all index rows corresponding to the data rows stored on the first storage device is above the data threshold volume, wherein a data volume of the portion of the index rows is below the threshold data volume. The index rows of this portion may be selected at random. Preferably this process block is executed before executing of any of the queries by primary key.<!-- EPO <DP n="25"> --></p><p id="p0065" num="0065">In the process block 301 b a counter for each of the index rows is generated. This may be implemented by adding a counter column to each of the index tables. In each counter column cell of the respective index row a value of the counter of the respective index row is stored. An initial counter value of each of the counters equals to zero.</p><p id="p0066" num="0066">In the process block 301c queries by primary key are executed. The executing of each of the queries by primary key (Process blocks 302-304) further comprises increasing by unity of the counter value of the respective index row comprising the primary key specified in the each of the queries by primary key. The decision process block 304d cause execution of the process block 301c until an overall sum of the counter values exceeds a threshold value. The threshold value may be selected big enough in order to provide a meaningful statistics for identifying the most frequently used index rows.</p><p id="p0067" num="0067">When the overall sum of the of the counter values exceeds a threshold value the decision process block 301d cause execution of the process block 301e. In the process block 301e an index row set of index rows is identified. Each of the index rows of the index row set has the respective counter value higher than any of the counter values of the counters of the index rows, which do not belong to the index row set. A data volume of the index row set is below a threshold data volume. In this way the most frequently used index rows are selected into the index row set. Afterwards in the process blocks 301f and 301g the index rows are moved between the first storage device and the second storage device in order to reach a sate when all of the index rows of the index row set are stored on the first storage device and the rest of the index rows are stored on the second storage device. As a result thereof the most frequently index rows are stored on the first storage device and their data volume is below the threshold data volume.</p><p id="p0068" num="0068">In the process block 301f each of the index rows of the index row set is moved from the second storage device to the first storage device if the each of the index rows of the index row set is stored on the second storage device.</p><p id="p0069" num="0069">In the process block 301g each of the index rows, which does not belong to the index row set, is moved from the first storage device to the second storage device if the each of the index rows, which does not belong to the index row set, is stored on the first storage device. The process blocks 301f and 301 g can be executed in any sequence or in parallel.<!-- EPO <DP n="26"> --></p><p id="p0070" num="0070">Different processes may be executed on the data base, as a result thereof a list of the most frequently used index rows may change in time. Thus process blocks 301 c, 301e, 301f, 301g and the decision process block 301d have to be repeated in order to follow the trend of changing of the list of the most frequently used index rows. In order to avoid overflow of the counter values all of the counter values are set to zero in the process block 301 h. The process block 301 h is executed after the process block 301 e. Execution of the process blocks 301 f, 301 g, and 301 h causes execution of the process block 301 c if the next iteration, wherein the next index row set of the most frequently used index rows needs to be determined, has to be executed.</p></description><claims mxw-id="PCLM90459476" lang="EN" load-source="patent-office"><!-- EPO <DP n="27"> --><claim id="c-en-0001" num="0001"><claim-text>A system (195) comprising:
<claim-text>a first storage device (140);</claim-text>
<claim-text>a second storage device (141), wherein a database (191), containing entries, is stored across partitions (130-133), the first storage device comprises one partition (130) of the partitions, the second storage device comprises the other partitions (131-133) except the one of the first storage device, each of the partitions having a respective partition identification for identification of that partition, wherein each of the entries is stored in one or more data rows (160, 163, 164; 161, 165; 162, 166; 167, 168; 169, 170) of data tables (100, 110) stored in the database, wherein each of the data rows comprises a respective primary key (101, 112) for identification of that data row, wherein each of the entries comprises at least one data value (104, 115) indicative of allocation of the each of the entries in one of the partitions; and</claim-text>
<claim-text>a computing device comprising:
<claim-text>a memory (193) storing processor-executable program code, and</claim-text>
<claim-text>a computer processor (192) to execute the processor-executable program code in order to cause the computing device to:
<claim-text>• generate, for each of the primary keys (101, 112), a respective index row (180-190) comprising the respective primary key and the partition identification associated with said respective primary key (300); and</claim-text>
<claim-text>• execute a query by primary key on the database, wherein one of the primary keys is specified in the query by primary key, wherein the executing of the query by primary key comprises:
<claim-text>■ identifying the partition identification associated with the specified primary key using the index rows (303); and</claim-text>
<claim-text>■ executing a query by primary key on the partition having the identified partition identification using the specified primary key (304).</claim-text></claim-text></claim-text></claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The system of claim 1, wherein an access time of the first storage device is shorter than an access time of the second storage device.</claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The system of any one of the preceding claims, wherein the execution of the processor-executable code by the computer processor further causes the computing device to:<!-- EPO <DP n="28"> -->
<claim-text>• store at least a portion of the index rows on the first storage device, and storing all index rows, which are not stored on the first storage device, on the second storage device, wherein the index rows stored on the first storage device comply with an index allocation criterion (301), wherein the identifying of the partition identification associated with the specified primary key is performed using the index rows stored on the first storage device if the index rows stored on the first storage device comprise the specified primary key otherwise the identifying of the partition identification associated with the specified primary key is performed using the index rows stored on the second storage device.</claim-text></claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The system of any one of the preceding claims, wherein the execution of the processor-executable code by the computer processor further causes the computing device to:
<claim-text>• modify the one or more indicative data values of the entry (305); and</claim-text>
<claim-text>• move the entry to the target partition if at least one data value indicative of allocation of the entry to be moved is modified and the at the least one modified data value indicates that the entry has to be moved to the target partition form the source partition in which it is currently stored, wherein all index rows comprising the respective primary keys of the data rows of the entry to be moved are updated after the entry to be moved is moved, wherein in each of the updated index rows the partition identification of the source partition is substituted by the partition identification of the target partition, wherein the source partition is one of the partitions and the target partition is another one of the target partitions (306).</claim-text></claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The system of claim 4, wherein each of some or all of the data tables are stored across partitions, wherein each of the tables being stored across partitions is split in table portions comprising the data rows stored in each of the partitions across which the each of the tables is stored, wherein the data tables are column store data tables, wherein each column of each of the data tables stored only in one of the partitions<!-- EPO <DP n="29"> --> is stored as a contiguous compressed data record in the only one of the partitions, wherein each column of each of the table portions stored in the respective partition is stored as the contiguous compressed data record (111 a, 112a, 113a, 114a, 115a) in the respective partition, wherein the moving of the entries is performed only in predetermined non-overlapping time intervals, wherein the moving of the entry from its source partition to its target partition comprises moving each data row of the entry to be moved from the respective source table being stored in said source partition and comprising the each data row to the respective target table being stored in said target partition, wherein the respective source table comprising the each data row and the respective target table used for inserting of the each data row are table portions of one of the data tables being stored across at least said source and said target partition and comprising the each data row, wherein the moving of the each data row comprises:
<claim-text>decompressing each of the compressed contiguous data records corresponding to the columns of the source table (306a);</claim-text>
<claim-text>decompressing each of the contiguous compressed data records corresponding to the columns of the target table (306b);</claim-text>
<claim-text>moving each of data entities of the each data row from the respective decompressed data record of the source table to the respective decompressed data record of the target table, wherein the respective decompressed data record of the source table and the respective decompressed data record of the target table correspond to one of the columns of the one of the data tables and the one of the columns comprises the each of the data entities, wherein each of the columns of the one of the data tables comprises the respective data entity of the each data row, wherein the each data entity is the primary key, or a secondary key, or the data value (306c);</claim-text>
<claim-text>after the moving of the each of the data entities compressing each of the decompressed contiguous data records corresponding to the columns of the source table (306d); and</claim-text>
<claim-text>after the moving of the each of the data entities compressing each of the decompressed contiguous data records corresponding to the columns of the target table (306e).</claim-text></claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The system of claims 3 and 5, wherein the index rows are stored in index tables, the index tables are row store tables, each of the data rows and its corresponding index row comprise the identical primary key, each row of each of the index tables is<!-- EPO <DP n="30"> --> stored as a contiguous data record (185a, 186a, 187a, 189a, 190a), each of the index tables has the respective data table comprising an identical set of the primary keys as the each of the index tables, wherein the index allocation criterion is selected from a group consisting of the following index allocation criteria a)-c):
<claim-text>a) all index rows are stored on the first storage device;</claim-text>
<claim-text>b) the index rows corresponding to the data rows stored on the first storage device are stored on the first storage device and the index rows corresponding to the data rows stored on the second storage device are stored on the second storage device, wherein each of the index tables having a portion of the index rows stored on the first storage device and another portion of the index rows stored on the second storage device is stored across the first and second storage device, wherein the moving of the each data row further comprises moving of the contiguous data record of the respective index row comprising the same primary index as the each data row from the first storage device to the second storage device if the each data row is moved from the first storage device to the second storage device, wherein the moving of the each data row further comprises moving of the contiguous data record of the respective index row comprising the same primary index as the each data row from the second storage device to the first storage device if the each data row is moved from the second storage device to the first storage device, wherein the index table comprising the respective index row is stored across the first storage device and the second storage device;</claim-text>
<claim-text>c) the index rows corresponding to the data rows stored on the first storage device are stored on the first storage device and the index rows corresponding to the data rows stored on the second storage device are stored the second storage device before the executing of any of the queries by primary key (301a), wherein each of the index tables having a portion of the index rows stored on the first storage device and another portion of the index rows stored on the second storage device is stored across the first storage device and the second storage device, wherein the execution of the processor-executable code by the computer processor further causes the computing device to:
<claim-text>• generate a counter for each of the index rows (301 b), wherein an initial counter value of each of the counters equals to zero, wherein the executing of each of the queries by primary key further comprises increasing by unity of the counter value of the respective index<!-- EPO <DP n="31"> --> row comprising the primary key specified in the each of the queries by primary key (301c); and</claim-text>
<claim-text>• after an overall sum of the counter values exceeds a threshold value (301 d) perform the following:
<claim-text>■ identifying an index row set of index rows, wherein each of the index rows of the index row set has the respective counter value higher than any of the counter values of the counters of the index rows, which do not belong to the index row set, and a data volume of the index row set is below a threshold data volume (301 e);</claim-text>
<claim-text>■ moving each of the index rows of the index row set from the second storage device to the first storage device if the each of the index rows of the index row set is stored on the second storage device (301f);</claim-text>
<claim-text>■ moving each of the index rows, which does not belong to the index row set, from the first storage device to the second storage device if the each of the index rows, which does not belong to the index row set, is stored on the first storage device (301g); and</claim-text>
<claim-text>■ after the identifying of the index row set stetting all of the counter values to zero (301 h).</claim-text></claim-text></claim-text></claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>The system of any one of the preceding claims, wherein each of some or all of the data rows comprises one or more secondary keys (101, 102, 111-113), each of the secondary keys identifies a respective data row set of the data rows, wherein each of the index rows of the respective primary key further comprises all secondary keys of the data row comprising the respective primary key if the data row comprising the respective primary key comprises at least one of the secondary keys, wherein the execution of the processor-executable code by the computer processor further causes the computing device to:
<claim-text>• execute a query by secondary key on the database, wherein one of the secondary keys is specified in the query by secondary key, wherein the executing of the query by secondary key comprises:
<claim-text>■ identifying all of the partition identifications stored in the index rows comprising the specified secondary key (308); and<!-- EPO <DP n="32"> --></claim-text>
<claim-text>■ executing a query by secondary key on all of the partitions having their partition identification identified using the specified secondary key (309).</claim-text></claim-text></claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>A computer-implemented method for providing access to a database on a system (195), wherein the database (191), comprising entries, is stored across partitions (130-133), the system comprising a first storage device (140), a second storage device (141), and a computing device, the first storage device comprising one partition (130) of the partitions, the second storage device comprising the other partitions (131-132) except the one of the first storage device, each of the partitions having a respective partition identification for identification of that partition, wherein each of the entries is stored in one or more data rows (160, 163, 164; 161, 165; 162, 166; 167, 168; 169, 170) of data tables (100, 110) stored in the database, wherein each of the data rows comprises a respective primary key (101, 112) for identification of that data row, wherein the computing device comprises a memory (193) storing processor-executable program code and a computer processor (192) to execute the processor-executable program code in order to cause the computing device to perform the computer-implemented method, wherein each of the entries comprises at least one data value (104, 115) indicative of allocation of the each of the entries in one of the partitions, the computer-implemented method comprising:
<claim-text>• generating, for each of the primary keys (101, 112), a respective index row (180-190) comprising the respective primary key and the partition identification associated with said respective primary key; and</claim-text>
<claim-text>• executing a query by primary key on the database, wherein one of the primary keys is specified in the query by primary key, wherein the executing of the query by primary key comprises:
<claim-text>■ identifying the partition identification associated with the specified primary key using the index rows (303); and</claim-text>
<claim-text>■ executing a query by primary key on the partition having the identified partition identification using the specified primary key (304).</claim-text></claim-text></claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>The computer-implemented method of claim 8, wherein an access time of the first storage device is shorter than an access time of the second storage device.<!-- EPO <DP n="33"> --></claim-text></claim><claim id="c-en-0010" num="0010"><claim-text>The computer-implemented method of one of the preceding claims 8 or 9 further comprising:
<claim-text>• storing at least a portion of the index rows on the first storage device, and storing all index rows, which are not stored on the first storage device, on the second storage device, wherein the index rows stored on the first storage device comply with an index allocation criterion (301), wherein the identifying of the partition identification associated with the specified primary key is performed using the index rows stored on the first storage device if the index rows stored on the first storage device comprise the specified primary key otherwise the identifying of the partition identification associated with the specified primary key is performed using the index rows stored on the second storage device.</claim-text></claim-text></claim><claim id="c-en-0011" num="0011"><claim-text>The computer-implemented method of one of the preceding claims 8-10, the computer-implemented method further comprising:
<claim-text>• modifying the one or more indicative data values of the entry (305); and</claim-text>
<claim-text>• moving the entry to the target partition if at least one data value indicative of allocation of the entry to be moved is modified and the at the least one modified data value indicates that the entry has to be moved to the target partition form the source partition in which it is currently stored, wherein all index rows comprising the respective primary keys of the data rows of the entry to be moved are updated after the entry to be moved is moved, wherein in each of the updated index rows the partition identification of the source partition is substituted by the partition identification of the target partition, wherein the source partition is one of the partitions and the target partition is another one of the target partitions (306).</claim-text></claim-text></claim><claim id="c-en-0012" num="0012"><claim-text>The computer-implemented method of claim 11, each of some or all of the data tables being stored across at least two partitions, wherein each of some or all of the data tables are stored across partitions, wherein each of the tables being stored across partitions is split in table portions comprising the data rows stored in each of<!-- EPO <DP n="34"> --> the partitions across which the each of the tables is stored, wherein the data tables are column store data tables, wherein each column of each of the data tables stored only in one of the partitions is stored as a contiguous compressed data record in the only one of the partitions, wherein each column of each of the table portions stored in the respective partition is stored as the contiguous compressed data record (111a, 112a, 113a, 114a, 115a) in the respective partition, wherein the moving of the entries is performed only in predetermined non-overlapping time intervals, wherein the moving of the entry from its source partition to its target partition comprises moving each data row of the entry to be moved from the respective source table being stored in said source partition and comprising the each data row to the respective target table being stored in said target partition, wherein the respective source table comprising the each data row and the respective target table used for inserting of the each data row are table portions of one of the data tables being stored across at least said source and said target partition and comprising the each data row, wherein the moving of the each data row comprises:
<claim-text>decompressing each of the compressed contiguous data records corresponding to the columns of the source table (306a);</claim-text>
<claim-text>decompressing each of the contiguous compressed data records corresponding to the columns of the target table (306b);</claim-text>
<claim-text>moving each of data entities of the each data row from the respective decompressed data record of the source table to the respective decompressed data record of the target table, wherein the respective decompressed data record of the source table and the respective decompressed data record of the target table correspond to one of the columns of the one of the data tables and the one of the columns comprises the each of the data entities, wherein each of the columns of the one of the data tables comprises the respective data entity of the each data row, wherein the each data entity is the primary key, or a secondary key, or the data value (306c);</claim-text>
<claim-text>after the moving of the each of the data entities compressing each of the decompressed contiguous data records corresponding to the columns of the source table (306d); and</claim-text>
<claim-text>after the moving of the each of the data entities compressing each of the decompressed contiguous data records corresponding to the columns of the target table(306e).</claim-text><!-- EPO <DP n="35"> --></claim-text></claim><claim id="c-en-0013" num="0013"><claim-text>The computer-implemented method of claims 10 and 12, wherein the index rows are stored in index tables, the index tables are row store tables, each of the data rows and its corresponding index row comprise the identical primary key, each row of each of the index tables is stored as a contiguous data record (185a, 186a, 187a, 189a, 190a), each of the index tables has the respective data table comprising an identical set of the primary keys as the each of the index tables, wherein the index allocation criterion is selected from a group consisting of the following index allocation criteria a)-c):
<claim-text>a) all index rows are stored on the first storage device;</claim-text>
<claim-text>b) the index rows corresponding to the data rows stored on the first storage device are stored on the first storage device and the index rows corresponding to the data rows stored on the second storage device are stored on the second storage device, wherein each of the index tables having a portion of the index rows stored on the first storage device and another portion of the index rows stored on the second storage device is stored across the first and second storage device, wherein the moving of the each data row further comprises moving of the contiguous data record of the respective index row comprising the same primary index as the each data row from the first storage device to the second storage device if the each data row is moved from the first storage device to the second storage device, wherein the moving of the each data row further comprises moving of the contiguous data record of the respective index row comprising the same primary index as the each data row from the second storage device to the first storage device if the each data row is moved from the second storage device to the first storage device, wherein the index table comprising the respective index row is stored across the first storage device and the second storage device;</claim-text>
<claim-text>c) the index rows corresponding to the data rows stored on the first storage device are stored on the first storage device and the index rows corresponding to the data rows stored on the second storage device are stored the second storage device before the executing of any of the queries by primary key (301 a), wherein each of the index tables having a portion of the index rows stored on the first storage device and another portion of the index rows stored on the second storage device is stored across the first storage device and the second storage device, wherein the computer-implemented method further comprises:<!-- EPO <DP n="36"> -->
<claim-text>• generating a counter for each of the index rows (301b), wherein an initial counter value of each of the counters equals to zero, wherein the executing of each of the queries by primary key further comprises increasing by unity of the counter value of the respective index row comprising the primary key specified in the each of the queries by primary key (301c); and</claim-text>
<claim-text>• after an overall sum of the counter values exceeds a threshold value (301d) perform the following:
<claim-text>■ identifying an index row set of index rows, wherein each of the index rows of the index row set has the respective counter value higher than any of the counter values of the counters of the index rows, which do not belong to the index row set, and a data volume of the index row set is below a threshold data volume (301e);</claim-text>
<claim-text>■ moving each of the index rows of the index row set from the second storage device to the first storage device if the each of the index rows of the index row set is stored on the second storage device (301f);</claim-text>
<claim-text>■ moving each of the index rows, which does not belong to the index row set, from the first storage device to the second storage device if the each of the index rows, which does not belong to the index row set, is stored on the first storage device (301g); and</claim-text>
<claim-text>■ after the identifying of the index row set stetting all of the counter values to zero (301 h).</claim-text></claim-text></claim-text></claim-text></claim><claim id="c-en-0014" num="0014"><claim-text>The computer-implemented method of one of the preceding claims 8-13, wherein each of some or all of the data rows comprises one or more secondary keys (101, 102, 111-113), each of the secondary keys identifies a respective data row set of the data rows, wherein each of the index rows of the respective primary key further comprises all secondary keys of the data row comprising the respective primary key if the data row comprising the respective primary key comprises at least one of the secondary keys, wherein the computer-implemented method further comprises:<!-- EPO <DP n="37"> -->
<claim-text>• executing a query by secondary key on the database, wherein one of the secondary keys is specified in the query by secondary key, wherein the executing of the query by secondary key comprises:
<claim-text>■ identifying all of the partition identifications stored in the index rows comprising the specified secondary key (308); and</claim-text>
<claim-text>■ executing a query by secondary key on all of the partitions having their partition identification identified using the specified secondary key (309).</claim-text></claim-text></claim-text></claim><claim id="c-en-0015" num="0015"><claim-text>A computer readable medium having stored thereon a computer executable program code for execution by a computer processor controlling a computing device of a system, the system comprising a first storage device, a second storage device, and the computing device, wherein execution of the instructions of the executable program code causes the computing device to perform the computer-implemented method of claims 8-14 on the system.</claim-text></claim></claims><amended-claims mxw-id="PCLM90459475" lang="EN" load-source="patent-office" amended-claim-type="EPC"><heading id="h0006">Amended claims in accordance with Rule 137(2) EPC.</heading><claim id="ac-en-0001" num="0001"><claim-text>A system (195) comprising:
<claim-text>a first storage device (140);</claim-text>
<claim-text>a second storage device (141), wherein a database (191), containing entries, is stored across partitions (130-133), the first storage device comprises one partition (130) of the partitions, the second storage device comprises the other partitions (131-133) except the one of the first storage device, each of the partitions having a respective partition identification for identification of that partition, wherein each of the entries is stored in one or more data rows (160, 163, 164; 161, 165; 162, 166; 167, 168; 169, 170) of data tables (100, 110) stored in the database, wherein each of the data rows comprises a respective primary key (101, 112) for identification of that data row, wherein each of the entries comprises at least one data value (104, 115) indicative of allocation of the each of the entries in one of the partitions; and a computing device comprising:
<claim-text>a memory (193) storing processor-executable program code, and</claim-text>
<claim-text>a computer processor (192) to execute the processor-executable program code in order to cause the computing device to:
<claim-text>• generate, for each of the primary keys (101, 112), a respective index row (180-190) comprising the respective primary key and the partition identification associated with said respective primary key (300); and</claim-text>
<claim-text>• execute a query by primary key on the database, wherein one of the primary keys is specified in the query by primary key, wherein the executing of the query by primary key comprises:
<claim-text>▪ identifying the partition identification associated with the specified primary key using the index rows (303);</claim-text>
<claim-text>▪ executing a query by primary key on the partition having the identified partition identification using the specified primary key (304);</claim-text></claim-text>
<claim-text>• store at least a portion of the index rows on the first storage device, and storing all index rows, which are not stored on the first storage device, on the second storage device, wherein the index rows stored on the first storage device comply with an index allocation criterion (301), wherein the identifying of the partition identification associated with the specified primary key is performed using the index rows stored on the first storage device if the index rows stored on the first storage device comprise the specified primary key otherwise the identifying of the partition identification associated with the specified primary key is performed using the index rows stored on the second storage device;</claim-text>
<claim-text>• modify the one or more indicative data values of the entry (305); and</claim-text>
<claim-text>• move the entry to the target partition if at least one data value indicative of allocation of the entry to be moved is modified and the at the least one modified data value indicates that the entry has to be moved to the target partition form the source partition in which it is currently stored, wherein all index rows comprising the respective primary keys of the data rows of the entry to be moved are updated after the entry to be moved is moved, wherein in each of the updated index rows the partition identification of the source partition is substituted by the partition identification of the target partition, wherein the source partition is one of the partitions and the target partition is another one of the target partitions (306), wherein each of some or all of the data tables are stored across partitions, wherein each of the tables being stored across partitions is split in table portions comprising the data rows stored in each of the partitions across which the each of the tables is stored, wherein the moving of the entry from its source partition to its target partition comprises moving each data row of the entry to be moved from the respective source table being stored in said source partition and comprising the each data row to the respective target table being stored in said target partition, wherein the respective source table comprising the each data row and the respective target table used for inserting of the each data row are table portions of one of the data tables being stored across at least said source and said target partition and comprising the each data row, wherein the moving of the entry from its source partition to its target partition comprises moving each data row of the entry to be moved from the respective source data table being stored in said source partition and comprising the each data row to the respective target data table being stored in said target partition, wherein the respective source table comprising the each data row and the respective target table used for inserting of the each data row are table portions of one of the data tables being stored across at least said source and said target partition and comprising the each data row,</claim-text></claim-text></claim-text>
wherein the system is <b>characterized in that</b>, that the index rows are stored in index tables, wherein the index tables are row store tables, wherein each of the data rows and its corresponding index row comprise the identical primary key, each row of each of the index tables is stored as a contiguous data record (185a, 186a, 187a, 189a, 190a), each of the index tables has the respective data table comprising an identical set of the primary keys as the each of the index tables, wherein the index allocation criterion is selected from a group consisting of the following index allocation criteria a)-c):
<claim-text>a) all index rows are stored on the first storage device;</claim-text>
<claim-text>b) the index rows corresponding to the data rows stored on the first storage device are stored on the first storage device and the index rows corresponding to the data rows stored on the second storage device are stored on the second storage device, wherein each of the index tables having a portion of the index rows stored on the first storage device and another portion of the index rows stored on the second storage device is stored across the first and second storage device, wherein the moving of the each data row further comprises moving of the contiguous data record of the respective index row comprising the same primary index as the each data row from the first storage device to the second storage device if the each data row is moved from the first storage device to the second storage device, wherein the moving of the each data row further comprises moving of the contiguous data record of the respective index row comprising the same primary index as the each data row from the second storage device to the first storage device if the each data row is moved from the second storage device to the first storage device, wherein the index table comprising the respective index row is stored across the first storage device and the second storage device;</claim-text>
<claim-text>c) the index rows corresponding to the data rows stored on the first storage device are stored on the first storage device and the index rows corresponding to the data rows stored on the second storage device are stored the second storage device before the executing of any of the queries by primary key (301 a), wherein each of the index tables having a portion of the index rows stored on the first storage device and another portion of the index rows stored on the second storage device is stored across the first storage device and the second storage device, wherein the execution of the processor-executable code by the computer processor further causes the computing device to:
<claim-text>• generate a counter for each of the index rows (301 b), wherein an initial counter value of each of the counters equals to zero, wherein the executing of each of the queries by primary key further comprises increasing by unity of the counter value of the respective index row comprising the primary key specified in the each of the queries by primary key (301 c); and</claim-text>
<claim-text>• after an overall sum of the counter values exceeds a threshold value (301d) perform the following:
<claim-text>▪ identifying an index row set of index rows, wherein each of the index rows of the index row set has the respective counter value higher than any of the counter values of the counters of the index rows, which do not belong to the index row set, and a data volume of the index row set is below a threshold data volume (301e);</claim-text>
<claim-text>▪ moving each of the index rows of the index row set from the second storage device to the first storage device if the each of the index rows of the index row set is stored on the second storage device (301f);</claim-text>
<claim-text>▪ moving each of the index rows, which does not belong to the index row set, from the first storage device to the second storage device if the each of the index rows, which does not belong to the index row set, is stored on the first storage device (301g); and</claim-text>
<claim-text>▪ after the identifying of the index row set stetting all of the counter values to zero (301 h).</claim-text></claim-text></claim-text></claim-text></claim><claim id="ac-en-0002" num="0002"><claim-text>The system of claim 1, wherein an access time of the first storage device is shorter than an access time of the second storage device.</claim-text></claim><claim id="ac-en-0003" num="0003"><claim-text>The system of claims 1 or 2, wherein the data tables are column store data tables, wherein each column of each of the data tables stored only in one of the partitions is stored as a contiguous compressed data record in the only one of the partitions, wherein each column of each of the table portions stored in the respective partition is stored as the contiguous compressed data record (111 a, 112a, 113a, 114a, 115a) in the respective partition, wherein the moving of the entries is performed only in predetermined non-overlapping time intervals, wherein the moving of the each data row comprises:
<claim-text>decompressing each of the compressed contiguous data records corresponding to the columns of the source table (306a);</claim-text>
<claim-text>decompressing each of the contiguous compressed data records corresponding to the columns of the target table (306b);</claim-text>
<claim-text>moving each of data entities of the each data row from the respective decompressed data record of the source table to the respective decompressed data record of the target table, wherein the respective decompressed data record of the source table and the respective decompressed data record of the target table correspond to one of the columns of the one of the data tables and the one of the columns comprises the each of the data entities, wherein each of the columns of the one of the data tables comprises the respective data entity of the each data row, wherein the each data entity is the primary key, or a secondary key, or the data value (306c);</claim-text>
<claim-text>after the moving of the each of the data entities compressing each of the decompressed contiguous data records corresponding to the columns of the source table (306d); and</claim-text>
<claim-text>after the moving of the each of the data entities compressing each of the decompressed contiguous data records corresponding to the columns of the target table (306e).</claim-text></claim-text></claim><claim id="ac-en-0004" num="0004"><claim-text>The system of any one of the preceding claims, wherein each of some or all of the data rows comprises one or more secondary keys (101, 102, 111-113), each of the secondary keys identifies a respective data row set of the data rows, wherein each of the index rows of the respective primary key further comprises all secondary keys of the data row comprising the respective primary key if the data row comprising the respective primary key comprises at least one of the secondary keys, wherein the execution of the processor-executable code by the computer processor further causes the computing device to:
<claim-text>• execute a query by secondary key on the database, wherein one of the secondary keys is specified in the query by secondary key, wherein the executing of the query by secondary key comprises:
<claim-text>▪ identifying all of the partition identifications stored in the index rows comprising the specified secondary key (308); and</claim-text>
<claim-text>▪ executing a query by secondary key on all of the partitions having their partition identification identified using the specified secondary key (309).</claim-text></claim-text></claim-text></claim><claim id="ac-en-0005" num="0005"><claim-text>A computer-implemented method for providing access to a database on a system (195), wherein the database (191), comprising entries, is stored across partitions (130-133), the system comprising a first storage device (140), a second storage device (141), and a computing device, the first storage device comprising one partition (130) of the partitions, the second storage device comprising the other partitions (131-132) except the one of the first storage device, each of the partitions having a respective partition identification for identification of that partition, wherein each of the entries is stored in one or more data rows (160, 163, 164; 161, 165; 162, 166; 167, 168; 169, 170) of data tables (100, 110) stored in the database, wherein each of the data rows comprises a respective primary key (101, 112) for identification of that data row, wherein the computing device comprises a memory (193) storing processor-executable program code and a computer processor (192) to execute the processor-executable program code in order to cause the computing device to perform the computer-implemented method, wherein each of the entries comprises at least one data value (104, 115) indicative of allocation of the each of the entries in one of the partitions, the computer-implemented method comprising:
<claim-text>• generating, for each of the primary keys (101, 112), a respective index row (180-190) comprising the respective primary key and the partition identification associated with said respective primary key; and</claim-text>
<claim-text>• executing a query by primary key on the database, wherein one of the primary keys is specified in the query by primary key, wherein the executing of the query by primary key comprises:
<claim-text>▪ identifying the partition identification associated with the specified primary key using the index rows (303);</claim-text>
<claim-text>▪ executing a query by primary key on the partition having the identified partition identification using the specified primary key (304);</claim-text></claim-text>
<claim-text>• storing at least a portion of the index rows on the first storage device, and storing all index rows, which are not stored on the first storage device, on the second storage device, wherein the index rows stored on the first storage device comply with an index allocation criterion (301), wherein the identifying of the partition identification associated with the specified primary key is performed using the index rows stored on the first storage device if the index rows stored on the first storage device comprise the specified primary key otherwise the identifying of the partition identification associated with the specified primary key is performed using the index rows stored on the second storage device;</claim-text>
<claim-text>• modifying the one or more indicative data values of the entry (305); and</claim-text>
moving the entry to the target partition if at least one data value indicative of allocation of the entry to be moved is modified and the at the least one modified data value indicates that the entry has to be moved to the target partition form the source partition in which it is currently stored, wherein all index rows comprising the respective primary keys of the data rows of the entry to be moved are updated after the entry to be moved is moved, wherein in each of the updated index rows the partition identification of the source partition is substituted by the partition identification of the target partition, wherein the source partition is one of the partitions and the target partition is another one of the target partitions (306), each of some or all of the data tables being stored across at least two partitions, wherein each of some or all of the data tables are stored across partitions, wherein each of the tables being stored across partitions is split in table portions comprising the data rows stored in each of the partitions across which the each of the tables is stored, wherein the moving of the entry from its source partition to its target partition comprises moving each data row of the entry to be moved from the respective source data table being stored in said source partition and comprising the each data row to the respective target data table being stored in said target partition, wherein the respective source table comprising the each data row and the respective target table used for inserting of the each data row are table portions of one of the data tables being stored across at least said source and said target partition and comprising the each data row, wherein the index rows are stored in index tables, the index tables are row store tables, each of the data rows and its corresponding index row comprise the identical primary key, each row of each of the index tables is stored as a contiguous data record (185a, 186a, 187a, 189a, 190a), each of the index tables has the respective data table comprising an identical set of the primary keys as the each of the index tables, wherein the index allocation criterion is selected from a group consisting of the following index allocation criteria a)-c):
<claim-text>a) all index rows are stored on the first storage device;</claim-text>
<claim-text>b) the index rows corresponding to the data rows stored on the first storage device are stored on the first storage device and the index rows corresponding to the data rows stored on the second storage device are stored on the second storage device, wherein each of the index tables having a portion of the index rows stored on the first storage device and another portion of the index rows stored on the second storage device is stored across the first and second storage device, wherein the moving of the each data row further comprises moving of the contiguous data record of the respective index row comprising the same primary index as the each data row from the first storage device to the second storage device if the each data row is moved from the first storage device to the second storage device, wherein the moving of the each data row further comprises moving of the contiguous data record of the respective index row comprising the same primary index as the each data row from the second storage device to the first storage device if the each data row is moved from the second storage device to the first storage device, wherein the index table comprising the respective index row is stored across the first storage device and the second storage device;</claim-text>
<claim-text>c) the index rows corresponding to the data rows stored on the first storage device are stored on the first storage device and the index rows corresponding to the data rows stored on the second storage device are stored the second storage device before the executing of any of the queries by primary key (301 a), wherein each of the index tables having a portion of the index rows stored on the first storage device and another portion of the index rows stored on the second storage device is stored across the first storage device and the second storage device, wherein the computer-implemented method further comprises:
<claim-text>• generating a counter for each of the index rows (301 b), wherein an initial counter value of each of the counters equals to zero, wherein the executing of each of the queries by primary key further comprises increasing by unity of the counter value of the respective index row comprising the primary key specified in the each of the queries by primary key (301 c); and</claim-text>
<claim-text>• after an overall sum of the counter values exceeds a threshold value (301d) perform the following:
<claim-text>▪ identifying an index row set of index rows, wherein each of the index rows of the index row set has the respective counter value higher than any of the counter values of the counters of the index rows, which do not belong to the index row set, and a data volume of the index row set is below a threshold data volume (301e);</claim-text>
<claim-text>▪ moving each of the index rows of the index row set from the second storage device to the first storage device if the each of the index rows of the index row set is stored on the second storage device (301f);</claim-text>
<claim-text>▪ moving each of the index rows, which does not belong to the index row set, from the first storage device to the second storage device if the each of the index rows, which does not belong to the index row set, is stored on the first storage device (301g); and</claim-text>
<claim-text>▪ after the identifying of the index row set stetting all of the counter values to zero (301 h).</claim-text></claim-text></claim-text></claim-text></claim><claim id="ac-en-0006" num="0006"><claim-text>The computer-implemented method of claim 5, wherein an access time of the first storage device is shorter than an access time of the second storage device.</claim-text></claim><claim id="ac-en-0007" num="0007"><claim-text>The computer-implemented method of claims 5 or 6, wherein the data tables are column store data tables, wherein each column of each of the data tables stored only in one of the partitions is stored as a contiguous compressed data record in the only one of the partitions, wherein each column of each of the table portions stored in the respective partition is stored as the contiguous compressed data record (111a, 112a, 113a, 114a, 115a) in the respective partition, wherein the moving of the entries is performed only in predetermined non-overlapping time intervals, wherein the moving of the each data row comprises:
<claim-text>decompressing each of the compressed contiguous data records corresponding to the columns of the source table (306a);</claim-text>
<claim-text>decompressing each of the contiguous compressed data records corresponding to the columns of the target table (306b);</claim-text>
<claim-text>moving each of data entities of the each data row from the respective decompressed data record of the source table to the respective decompressed data record of the target table, wherein the respective decompressed data record of the source table and the respective decompressed data record of the target table correspond to one of the columns of the one of the data tables and the one of the columns comprises the each of the data entities, wherein each of the columns of the one of the data tables comprises the respective data entity of the each data row, wherein the each data entity is the primary key, or a secondary key, or the data value (306c);</claim-text>
<claim-text>after the moving of the each of the data entities compressing each of the decompressed contiguous data records corresponding to the columns of the source table (306d); and</claim-text>
<claim-text>after the moving of the each of the data entities compressing each of the decompressed contiguous data records corresponding to the columns of the target table(306e).</claim-text></claim-text></claim><claim id="ac-en-0008" num="0008"><claim-text>The computer-implemented method of one of the preceding claims 5-7, wherein each of some or all of the data rows comprises one or more secondary keys (101, 102, 111-113), each of the secondary keys identifies a respective data row set of the data rows, wherein each of the index rows of the respective primary key further comprises all secondary keys of the data row comprising the respective primary key if the data row comprising the respective primary key comprises at least one of the secondary keys, wherein the computer-implemented method further comprises:
<claim-text>• executing a query by secondary key on the database, wherein one of the secondary keys is specified in the query by secondary key, wherein the executing of the query by secondary key comprises:
<claim-text>▪ identifying all of the partition identifications stored in the index rows comprising the specified secondary key (308); and</claim-text>
<claim-text>▪ executing a query by secondary key on all of the partitions having their partition identification identified using the specified secondary key (309).</claim-text></claim-text></claim-text></claim><claim id="ac-en-0009" num="0009"><claim-text>A computer readable medium having stored thereon a computer executable program code for execution by a computer processor controlling a computing device of a system, the system comprising a first storage device, a second storage device, and the computing device, wherein execution of the instructions of the executable program code causes the computing device to perform the computer-implemented method of claims 5-8 on the system.</claim-text></claim></amended-claims><drawings mxw-id="PDW20422202" load-source="patent-office"><!-- EPO <DP n="38"> --><figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="126" he="203" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="39"> --><figure id="f0002" num="2a"><img id="if0002" file="imgf0002.tif" wi="158" he="203" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="40"> --><figure id="f0003" num="2b"><img id="if0003" file="imgf0003.tif" wi="158" he="204" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="41"> --><figure id="f0004" num="3"><img id="if0004" file="imgf0004.tif" wi="123" he="206" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="42"> --><figure id="f0005" num="4a"><img id="if0005" file="imgf0005.tif" wi="160" he="204" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="43"> --><figure id="f0006" num="4b"><img id="if0006" file="imgf0006.tif" wi="160" he="205" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="44"> --><figure id="f0007" num="5"><img id="if0007" file="imgf0007.tif" wi="120" he="199" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="45"> --><figure id="f0008" num="6"><img id="if0008" file="imgf0008.tif" wi="148" he="189" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="46"> --><figure id="f0009" num="7"><img id="if0009" file="imgf0009.tif" wi="144" he="188" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="47"> --><figure id="f0010" num="8"><img id="if0010" file="imgf0010.tif" wi="157" he="189" img-content="drawing" img-format="tif"/></figure></drawings><search-report-data><doc-page id="srep0001" file="srep0001.tif" wi="158" he="233" type="tif"/><doc-page id="srep0002" file="srep0002.tif" wi="158" he="233" type="tif"/></search-report-data><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
