<?xml version="1.0" encoding="UTF-8"?>
<patent-document ucid="EP-2961176-A1" country="EP" doc-number="2961176" kind="A1" date="20151230" family-id="51059279" file-reference-id="311204" date-produced="20180824" status="corrected" lang="EN"><bibliographic-data><publication-reference fvid="160451166" ucid="EP-2961176-A1"><document-id><country>EP</country><doc-number>2961176</doc-number><kind>A1</kind><date>20151230</date><lang>EN</lang></document-id></publication-reference><application-reference ucid="EP-14173422-A" is-representative="YES"><document-id mxw-id="PAPP193865300" load-source="docdb" format="epo"><country>EP</country><doc-number>14173422</doc-number><kind>A</kind><date>20140623</date><lang>EN</lang></document-id><document-id mxw-id="PAPP193865301" load-source="patent-office" format="original"><country>EP</country><doc-number>14173422.8</doc-number><date>20140623</date><lang>EN</lang></document-id></application-reference><priority-claims><priority-claim mxw-id="PPC162029989" ucid="EP-14173422-A" load-source="docdb"><document-id format="epo"><country>EP</country><doc-number>14173422</doc-number><kind>A</kind><date>20140623</date></document-id></priority-claim></priority-claims><technical-data><classifications-ipcr><classification-ipcr mxw-id="PCL-1988525051" load-source="docdb">H04N  21/4385      20110101AFI20141203BHEP        </classification-ipcr></classifications-ipcr><classifications-cpc><classification-cpc mxw-id="PCL-1987768007" load-source="docdb" scheme="CPC">H04N  21/4385      20130101 FI20141128BHEP        </classification-cpc></classifications-cpc><invention-title mxw-id="PT165544964" lang="DE" load-source="patent-office">Fehlerkorrektur in einem digitalen Medientransportstrom</invention-title><invention-title mxw-id="PT165544965" lang="EN" load-source="patent-office">Correcting errors in a digital media transport stream</invention-title><invention-title mxw-id="PT165544966" lang="FR" load-source="patent-office">Correction d'erreurs dans un flux de transport multimédia numérique</invention-title><citations><patent-citations><patcit mxw-id="PCIT335961698" load-source="docdb" ucid="US-4748619-A"><document-id format="epo"><country>US</country><doc-number>4748619</doc-number><kind>A</kind><date>19880531</date></document-id><sources><source name="SEA" category="I" created-by-npl="N"/></sources></patcit></patent-citations><non-patent-citations><nplcit><text>None</text><sources><source mxw-id="PNPL59518639" load-source="docdb" name="APP"/></sources></nplcit><nplcit><text>SCHMIDT FLORIAN ET AL: "A heuristic header error recovery scheme for RTP", 2013 10TH ANNUAL CONFERENCE ON WIRELESS ON-DEMAND NETWORK SYSTEMS AND SERVICES (WONS), IEEE, 18 March 2013 (2013-03-18), pages 186 - 190, XP032476924, ISBN: 978-1-4799-0747-2, [retrieved on 20130812], DOI: 10.1109/WONS.2013.6578345</text><sources><source mxw-id="PNPL57937136" load-source="docdb" name="SEA" category="I"/></sources></nplcit><nplcit><text>XAVI ARTIGAS ET AL: "The DISCOVER Codec: Architecture, Techniques And Evaluation (Abstract)", 26. PICTURE CODING SYMPOSIUM;7-11-2007 - 9-11-2007; LISBON,, 7 November 2007 (2007-11-07), XP030080480</text><sources><source mxw-id="PNPL57937137" load-source="docdb" name="SEA" category="A"/></sources></nplcit></non-patent-citations></citations></technical-data><parties><applicants><applicant mxw-id="PPAR1103329149" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>HARMAN BECKER AUTOMOTIVE SYS</last-name><address><country>DE</country></address></addressbook></applicant><applicant mxw-id="PPAR1103334480" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>HARMAN BECKER AUTOMOTIVE SYSTEMS GMBH</last-name></addressbook></applicant><applicant mxw-id="PPAR1101647062" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Harman Becker Automotive Systems GmbH</last-name><iid>100136453</iid><address><street>Becker-Göring-Strasse 16</street><city>76307 Karlsbad</city><country>DE</country></address></addressbook></applicant></applicants><inventors><inventor mxw-id="PPAR1103324186" load-source="docdb" sequence="1" format="epo"><addressbook><last-name>IQBAL MUHAMMAD IMRAN</last-name><address><country>SE</country></address></addressbook></inventor><inventor mxw-id="PPAR1103310942" load-source="docdb" sequence="1" format="intermediate"><addressbook><last-name>Iqbal, Muhammad Imran</last-name></addressbook></inventor><inventor mxw-id="PPAR1101652533" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Iqbal, Muhammad Imran</last-name><address><street>Älgbacken 9c</street><city>37234 Ronneby</city><country>SE</country></address></addressbook></inventor><inventor mxw-id="PPAR1103338668" load-source="docdb" sequence="2" format="epo"><addressbook><last-name>ZEPERNICK HANS-JÜRGEN</last-name><address><country>SE</country></address></addressbook></inventor><inventor mxw-id="PPAR1103327819" load-source="docdb" sequence="2" format="intermediate"><addressbook><last-name>Zepernick, Hans-Jürgen</last-name></addressbook></inventor><inventor mxw-id="PPAR1101651427" load-source="patent-office" sequence="2" format="original"><addressbook><last-name>Zepernick, Hans-Jürgen</last-name><address><street>Vallhallavägen 2</street><city>37140 Karlskrona</city><country>SE</country></address></addressbook></inventor><inventor mxw-id="PPAR1103313277" load-source="docdb" sequence="3" format="epo"><addressbook><last-name>KHATIBI SIAMAK</last-name><address><country>SE</country></address></addressbook></inventor><inventor mxw-id="PPAR1103303520" load-source="docdb" sequence="3" format="intermediate"><addressbook><last-name>Khatibi, Siamak</last-name></addressbook></inventor><inventor mxw-id="PPAR1101648805" load-source="patent-office" sequence="3" format="original"><addressbook><last-name>Khatibi, Siamak</last-name><address><street>Äggsvampsgatan 9</street><city>38632 Färjestaden</city><country>SE</country></address></addressbook></inventor></inventors><agents><agent mxw-id="PPAR1101641263" load-source="patent-office" sequence="1" format="original"><addressbook><last-name>Bertsch, Florian Oliver</last-name><suffix>et al</suffix><iid>100051650</iid><address><street>Kraus &amp; Weisert Patentanwälte PartGmbB Thomas-Wimmer-Ring 15</street><city>80539 München</city><country>DE</country></address></addressbook></agent></agents></parties><international-convention-data><designated-states><ep-contracting-states><country mxw-id="DS660604856" load-source="docdb">AL</country><country mxw-id="DS660603614" load-source="docdb">AT</country><country mxw-id="DS660604858" load-source="docdb">BE</country><country mxw-id="DS660680868" load-source="docdb">BG</country><country mxw-id="DS660683067" load-source="docdb">CH</country><country mxw-id="DS660605026" load-source="docdb">CY</country><country mxw-id="DS660603615" load-source="docdb">CZ</country><country mxw-id="DS660604871" load-source="docdb">DE</country><country mxw-id="DS660605031" load-source="docdb">DK</country><country mxw-id="DS660605032" load-source="docdb">EE</country><country mxw-id="DS660680866" load-source="docdb">ES</country><country mxw-id="DS660680869" load-source="docdb">FI</country><country mxw-id="DS660683068" load-source="docdb">FR</country><country mxw-id="DS660604872" load-source="docdb">GB</country><country mxw-id="DS660605033" load-source="docdb">GR</country><country mxw-id="DS660604873" load-source="docdb">HR</country><country mxw-id="DS660603616" load-source="docdb">HU</country><country mxw-id="DS660680875" load-source="docdb">IE</country><country mxw-id="DS660605034" load-source="docdb">IS</country><country mxw-id="DS660680870" load-source="docdb">IT</country><country mxw-id="DS660605043" load-source="docdb">LI</country><country mxw-id="DS660680895" load-source="docdb">LT</country><country mxw-id="DS660781968" load-source="docdb">LU</country><country mxw-id="DS660680896" load-source="docdb">LV</country><country mxw-id="DS660680897" load-source="docdb">MC</country><country mxw-id="DS660781969" load-source="docdb">MK</country><country mxw-id="DS660781970" load-source="docdb">MT</country><country mxw-id="DS660781971" load-source="docdb">NL</country><country mxw-id="DS660603617" load-source="docdb">NO</country><country mxw-id="DS660781972" load-source="docdb">PL</country><country mxw-id="DS660605044" load-source="docdb">PT</country><country mxw-id="DS660680768" load-source="docdb">RO</country><country mxw-id="DS660605045" load-source="docdb">RS</country><country mxw-id="DS660781973" load-source="docdb">SE</country><country mxw-id="DS660604879" load-source="docdb">SI</country><country mxw-id="DS660603618" load-source="docdb">SK</country><country mxw-id="DS660603619" load-source="docdb">SM</country><country mxw-id="DS660680876" load-source="docdb">TR</country></ep-contracting-states><ep-extended-states><ep-extended-state-data><country>BA</country></ep-extended-state-data><ep-extended-state-data><country>ME</country></ep-extended-state-data></ep-extended-states></designated-states></international-convention-data></bibliographic-data><abstract mxw-id="PA166479536" lang="EN" load-source="patent-office"><p id="pa01" num="0001">The present invention relates to a method for correcting errors in a digital media transport stream. The media transport stream comprises a stream of digital data packets comprising at least one header data field and payload data uniquely identifying a packet type of the digital data packet. According to the method a plurality of header masks is retrieved (43) from error-free packets of the underlying media stream or from a storage device and each header mask is associated with a corresponding packet type of the plurality of packet types. Each header mask identifies the header data fields which uniquely identify the associated packet type. A digital data packet of the digital media transport stream is received (44) and for each header mask the header data fields of the received digital data packet are compared with the header data fields of the header mask. Based on the comparison, a packet type of the received digital data packet is determined (45) and the received digital data packet is corrected (48) based on the determined packet type.
<img id="iaf01" file="imgaf001.tif" wi="81" he="79" img-content="drawing" img-format="tif"/></p></abstract><abstract mxw-id="PA166759348" lang="EN" source="EPO" load-source="docdb"><p>The present invention relates to a method for correcting errors in a digital media transport stream. The media transport stream comprises a stream of digital data packets comprising at least one header data field and payload data uniquely identifying a packet type of the digital data packet. According to the method a plurality of header masks is retrieved (43) from error-free packets of the underlying media stream or from a storage device and each header mask is associated with a corresponding packet type of the plurality of packet types. Each header mask identifies the header data fields which uniquely identify the associated packet type. A digital data packet of the digital media transport stream is received (44) and for each header mask the header data fields of the received digital data packet are compared with the header data fields of the header mask. Based on the comparison, a packet type of the received digital data packet is determined (45) and the received digital data packet is corrected (48) based on the determined packet type.</p></abstract><description mxw-id="PDES98404237" lang="EN" load-source="patent-office"><!-- EPO <DP n="1"> --><heading id="h0001">Technical Field</heading><p id="p0001" num="0001">The present invention relates to a method for correcting errors in a digital media transport stream, especially digital media transport streams of digital multimedia broadcasting and digital video broadcasting signals. The present invention furthermore relates to a correction device and an electronic device implementing the method.</p><heading id="h0002">Background</heading><p id="p0002" num="0002">Digital broadcasting systems, for example digital multimedia broadcasting (DMB) and digital video broadcasting (DVB) systems, have become part of our daily life. They provide information and entertainment at home, during travelling by car, train or ship, or during walking around. In digital broadcasting systems the video streams and audio streams have to pass through a radio frequency channel from a sender to a receiver. However, radio frequency signals may be disturbed by environmental influences and may have a varying quality due to a transmission distance and a transmission environment. A disturbed radio frequency channel may inflict errors to the video and audio streams. As a result, the quality of service associated to these broadcasting systems may be degraded. Especially reception quality may be poor due to, for example bad weather and poor or no coverage in certain places, for example in tunnels. Therefore, to maintain the quality of these services, a forward error correction (FEC) is provided and is essential for such systems. However, FEC requires additional data to be transmitted from the sender to the receiver, which in turn reduces the bandwidth for the actual services. Furthermore, the error correction capabilities for an error control code used for FEC depends on the amount of additional data (for example parity data) available for the FEC. As bandwidth is limited, this additional data must also be very<!-- EPO <DP n="2"> --> limited which limits the error correction capabilities of the used FEC technique. As a result, in times of bad reception, the quality of audio and video streams of a multimedia broadcasting system may be degraded.</p><p id="p0003" num="0003">Therefore, there is a need for an improved error correction for digital broadcasting systems.</p><heading id="h0003">Summary</heading><p id="p0004" num="0004">According to the present invention, this objective is achieved by a method for correcting errors in a digital media transport stream as defined in claim 1, a correction device as defined in claim 13 and an electronic device as defined in claim 15. The dependent claims define preferred and advantageous embodiments of the invention.</p><p id="p0005" num="0005">According to the present invention, a method for correcting errors in a digital media transport stream is provided. The digital media transport stream may comprise, for example, a transport stream of a digital multimedia broadcasting (DMB) or a digital video broadcasting (DVB) system. The digital media transport stream comprises a stream of digital data packets. Each digital data packet comprises at least one header data field and payload data which uniquely identify the packet type of the corresponding digital data packet. Especially, as will be described below, the header data field may comprise a plurality of information blocks with some of the information blocks uniquely identifying the packet type of the corresponding digital data packet. In other words, a subset of the header data fields may uniquely identify the packet type. Furthermore, as will be described below, additionally the payload data may comprise information blocks which may contribute to identify the packet type. The packet type is one of a plurality of packet types which are predefined for the digital media transport stream. The packet types may comprise, for example, a video data packet, an audio data packet, a program association table (PAT) packet, a program map table (PMT) packet, a scene description (SD) packet, an object description (OD) packet or a Null packet. According to the method, a plurality of header masks is retrieved by a program code of a software running on the system with the help of the characteristics of the digital media stream. As<!-- EPO <DP n="3"> --> an alternative or additionally, the header masks may be retrieved from an already stored place in a storage device. As an alternative, the header masks may be created by a program code of a software running on the system or may be hard coded in the software of the system. Each header mask is associated with a corresponding packet type of the plurality of packet types. Each header mask identifies those header data fields which uniquely identify the associated packet type. The header mask may comprise, for example, for each header data field an indicator indicating if this header data field may be used for uniquely identifying the packet type or not. In case the header data field is suitable for identifying the packet type, a corresponding expected value or value range for this header data field is provided in the header mask. According to the method, a digital data packet of the digital media transport stream is received and for each header mask of the plurality of header masks the header data fields of the received digital data packet are compared with the header data fields of the header mask. Based on the comparison with the plurality of header masks, the packet type of the received digital data packet is determined. Based on the determined packet type, the received digital data packet is corrected.</p><p id="p0006" num="0006">The above-described method may be combined with a traditional forward error correction (FEC). Especially, the above-described method may be performed after the transport stream has been corrected by the FEC. In this case, the above-described method may improve the quality of the digital media transport stream by correcting errors in the digital media transport stream packets, in particular when the FEC fails to correct these errors. The above-described method may be performed at the receiver side only and does therefore not put any demands on the sender or broadcaster sending the digital media transport stream. Furthermore, the above-described method does not need any additional data, for example parity data, which has to be transmitted together with the transport stream and therefore, the above-described method does not demand any additional transmission bandwidth. The above-described method may additionally comprise the step of receiving the digital data packets of the digital media transport stream wirelessly via, for example, a radio frequency channel. However, the above-described method is not restricted to transport streams transmitted via radio frequency channels, but may also be used in connection with transport streams which are<!-- EPO <DP n="4"> --> transmitted via an electrical or optical connection or wirelessly via infrared. The method may furthermore comprise processing the corrected digital data packets, for example for extracting video and audio data, and the method may furthermore comprise displaying or outputting the extracted video and audio data. Furthermore, the method may comprise processing the corrected digital data packets and outputting the corrected digital data packets to a device which outputs the content of the digital data packets to a user or which forwards the digital data packets or the content of the digital data packets to another device.</p><p id="p0007" num="0007">According to an embodiment, correcting the received digital data packet comprises the following steps. A header error rate of the received digital data packet is estimated based on the determined packet type. The header error rate may comprise. for example. a number of erroneous bits or a percentage of erroneous bits. The header error rate is compared to a packet-type specific header error rate threshold. The header error rate threshold is predetermined for each packet type of the plurality of packet types. The received digital data packet is selectively corrected based on the comparison of the estimated header error rate with the predetermined header error rate threshold. For example, the received digital data packet may be corrected only, if the estimated header error rate does not exceed the predetermined header error rate threshold.</p><p id="p0008" num="0008">A further processing of the received digital data packets may be very sensitive to errors and may cause a decoder, for example a video or audio decoder, to crash. Hence, correction of digital data packet has to be performed carefully. Therefore, the following header error rate threshold may be recommended for the different packet types. For video data packets, the header error rate threshold may be in the range from zero to three bit errors and for audio packets the header error rate threshold may in a value range from zero to four bit errors. For other packet types, for example a program association table packet, a program map table packet, a scene description packet, an object description packet or a Null packet, the header error rate threshold may be set to a value of zero. For video data packets and audio data packets, a higher threshold means more repair, but it also may result in a higher risk of a decoder or player crashing due to an erroneous correction. Therefore, a trade of between the amount of repair and the risk<!-- EPO <DP n="5"> --> of decoder crashing is to be considered. The header error rate thresholds of the packet types PAT, PMT, and OD may be set to zero as these packets are extremely sensitive to errors. Even a single bit error may potentially cause a decoder to crash. Furthermore, these packets appear at least twice every second in a typical digital media broadcasting transport stream and the decoder only needs to decode one set of these packets to decode the entire subsequent digital media stream. The header error rate threshold of a scene description (SD) packet may be set to zero such that SD packets having an erroneous header may not be corrected as it has been observed from a large number of digital media broadcasting videos that these packets have no effect on video quality. Null packets may be ignored as these packets contain no information or data.</p><p id="p0009" num="0009">It has to be noticed that the above-described header error rate thresholds relate only to errors in the header data field of the digital data packets. With the above-proposed header error rate thresholds, video and audio data packets may be corrected even if already the header data fields comprise errors. The correction in general may relate to a correction of header data fields and/or a correction of the payload data. Digital data packets of the other packet types (PAT, PMT, SD, OD or Null) are corrected only if no errors have been detected in the header data fields. Therefore, in these packet types the correction relates only to the payload data. The correction of payload data will be described in other embodiments below.</p><p id="p0010" num="0010">According to an embodiment, comparing the header data fields of the received digital data packet with the header data fields of the header mask comprises for each header mask a determination of a Hamming distance between the header data fields of the received digital data packet and header data fields of the header mask. As a result, for each packet type, a corresponding Hamming distance is determined. The Hamming distance is the number of positions at which the header data fields of the received data packet and the header data fields of the header mask is different. The larger the Hamming distance, the lower is the probability that the received digital data packet is of the packet type of the corresponding header mask. If the Hamming distance is zero, there is no difference between the header data fields of the received digital data packet and the header data fields of the corresponding header mask. Therefore, the Hamming<!-- EPO <DP n="6"> --> distance gives an indication by single number indicating the probability that the received digital data packet is a digital data packet of a specific packet type. Based on the Hamming distance the packet type of the received digital data packet can be easily determined.</p><p id="p0011" num="0011">According to an embodiment, the packet type of the received data packet is determined based on the Hamming distance in the following way. In case the Hamming distance between the header data fields of received data packet and the header data fields of one of the header masks is zero, the packet type of the one header mask which resulted in the zero Hamming distance is determined as packet type of the received digital data packet. In case the determined Hamming distance between the header data fields of the received digital data packet and the header data fields of none of the header masks is zero, a predefined number of packet types associated with those header masks having the smallest Hamming distance with respect to the received digital data packet is determined. In other words, a predefined number of packet types for which the lowest Hamming distances have been determined, are determined and will be considered only. For example, if the predefined number is three, then the three packet types for which the lowest Hamming distances have been determined, will be considered.</p><p id="p0012" num="0012">For example, for the packet type "video data packet" a Hamming distance of one has been determined, for the packet type "program association table packet" a Hamming distance of one has been determined, and for the packet type "scene description packet" a Hamming distance of two has been determined, and for all other packet types a Hamming distance of three or more has been determined. Therefore, only the video data packet type, the program association table packet type and the scene description packet type will be considered as will be described in the following. For each of the predefined number of packet types which have been determined based on the Hamming distances, a corresponding confidence factor is determined. The confidence factor is determined based on a comparison of additional data of the received digital data packet and expected additional data which is predefined for the corresponding packet type. The additional data comprises predefined parts of the payload data which may be arranged subsequently to the header data fields. The expected additional data is predefined<!-- EPO <DP n="7"> --> specifically for each packet type. The packet type with the highest confidence factor is determined as the packet type of the received digital data packet. The confidence factor may additionally include the Hamming distance described above. In other words, the packet type of the received digital data packet is determined by analyzing not only the header data fields, but also parts of the payload data which have a fixed structure or fixed values or predefined value ranges. Thus, a packet type of the received digital data packet can be determined reliably and with a high confidence.</p><p id="p0013" num="0013">According to another embodiment, the received digital data packet is corrected additionally based on the additional data and the expected additional data described above. In detail, the additional data of the received digital data packet is determined, wherein the additional data comprises predefined parts of the payload data subsequent to the header data fields. Furthermore, expected additional data is retrieved from, for example the error-free packets of the same digital media stream or from a storage device. As described above, the expected additional data is predefined specifically for each packet type. Based on the additional data and the expected additional data, the payload data is corrected. For example, the additional data and the expected additional data may be compared and bits or data structures having a fixed value may be adapted in the payload data of the received digital data packet if there is a difference to expected values defined in the expected additional data. Thus, based on the previously determined packet type, the payload data may be corrected in view of the determined packet type.</p><p id="p0014" num="0014">For example, in case of a received video data packet, the additional data may comprise a packet start code prefix indicating the start of a next packetized elementary stream packet. The packet start code prefix may comprise a fixed value. Furthermore, the additional data may comprise a video stream identifier which may also comprise a fixed value at a fixed position within the payload data. Furthermore, the additional data may comprise an adaption field presence flag, a payload start indicator flag and flags of an adaption field. Depending on a start or end of a packetized elementary stream packets, only certain combinations of the above-mentioned flags are possible. Therefore, depending on a comparison of the possible flags with the actually received flags of the<!-- EPO <DP n="8"> --> received digital data packet, the confidence factor may be determined or the received payload data may be corrected. Additionally, any other characteristic of the video data packets of the underlying media stream that may be useful for correcting errors may be used as the additional data.</p><p id="p0015" num="0015">In case the received digital data packet comprises an audio data packet, the additional data may comprise, for example, a packet start code prefix, a fixed audio stream identifier, an adaption field presence flag, a packetized elementary stream header length and/or a packetized elementary stream packet length. The header length and the packet length may have restrictions in their value ranges and in relation to one another. Fulfillment of these restriction in the received digital data packet may be used to determine the confidence factor or to correct the payload data. Additionally, any other characteristic of the audio data packets of the underlying media stream that may be useful for correcting errors may be used as the additional data.</p><p id="p0016" num="0016">For a received program association table packet, the additional data comprises, for example, a payload unit start indicator, adaption field control bits, an adaption field length, a section length, a section number, a last section number, bytes in the packet after the section length information, a cyclic redundancy check information, and a table identifier. Required relations between the length and number data may advantageously used for determining the confidence factor and for correcting the program association table packet. Additionally, any other characteristic of the program association table packets of the underlying media stream that may be useful for correcting errors may be used as the additional data.</p><p id="p0017" num="0017">For a received program map table packet, the additional data comprises, for example, the payload unit start indicator, adaption field control bits, an adaption field length, a section length, a section number, a last section number, bytes in the packet after the section length information, a cyclic redundancy check information, a table identifier, a two-byte information following the last section number relating to the program information length. It also contains the PID of the packet that contains the program clock reference (PCR). In DMB usually, PCR is kept in audio packets but it may be<!-- EPO <DP n="9"> --> different for different streams. Additionally, any other characteristic of the program map table packets of the underlying media stream that may be useful for correcting errors may be used as the additional data.</p><p id="p0018" num="0018">For a received object description packet, the additional data may comprise, for example, a payload unit start indicator, adaption field control bits, an adaption field length, a table identifier, a section length, a section number, a last section number, bytes in the packet after the section length information and/or a cyclic redundancy check information. Additionally, any other characteristic of the object description packets of the underlying media stream that may be useful for correcting errors may be used as the additional data.</p><p id="p0019" num="0019">The additional data for a received scene description packet may comprise, for example, a payload unit start indicator, adaption field control bits, an adaption field length, a table identifier, a section length, a section number, a last section number, bytes in the packet after the section length information and/or a cyclic redundancy check information. Finally, for a received Null packet, the additional data may comprise for example a payload unit start indicator having a fixed value, and the condition that the adaption field is never present and all payload bytes have a fixed value. Additionally, any other characteristic of the scene description packets of the underlying media stream that may be useful for correcting errors may be used as the additional data.</p><p id="p0020" num="0020">In addition to setting header error thresholds and deciding whether to repair or not to repair a particular type of digital data packet, the above-listed large number of additional data providing fixed or structural information of the different types of digital data packets may be taken into account. The specific characteristics of these packet types may assist in correcting certain errors. Some of the additional data may be fixed while others may be variable, but constrained to certain value ranges or constrained to certain conditions or interdependent among different field values.</p><p id="p0021" num="0021">According to the present invention, a correction device for correcting errors in a digital media transport stream is provided. The digital media transport stream comprises a<!-- EPO <DP n="10"> --> stream of digital data packets. Each digital data packet of the stream of digital data packets comprises at least one header data field and payload data uniquely identifying a packet type of the corresponding digital data packet. The packet type is one of a plurality of packet types which are predefined for the digital media transport stream. The correction device comprises a processing unit which is configured to receive a digital data packet of the digital media transport stream and to retrieve a plurality of header masks from a storage device or from the error-free packets of the live broadcasted stream. Each header mask is associated with a corresponding packet type of the plurality of packet types and each header mask identifies the header data fields for uniquely identifying the associated packet type. The processing unit is furthermore configured to compare for each header mask of the plurality of header masks the header data fields of the received digital data packet with the header fields of the header mask. Based on the comparison with the plurality of header masks, the packet type of the received digital data packet is determined and the received digital data packet is corrected based on the determined packet type.</p><p id="p0022" num="0022">The correction devices may be configured to perform the above-described methods and therefore also provides the above-described advantages.</p><p id="p0023" num="0023">According to the present invention, an electronic device, for example a terminal device or a user equipment, is provided. The electronic device comprises a receiver device for receiving digital data packets of a digital media transport stream, and a correction device as defined above. The receiver device may also include channel decoding using, for example, a Read-Solomon decoder. The correction device is coupled to the receiver device for receiving the digital data packets from the receiver device. The electronic device furthermore comprises an output device coupled to the correction device for receiving the corrected digital data packets from the correction device and for outputting the corrected data packets. The electronic device may comprise, for example, a digital broadcast television receiver, a mobile telephone, a mobile media player or a television set.<!-- EPO <DP n="11"> --></p><p id="p0024" num="0024">Although specific features described in the above summary and the following detailed description as described in connection with specific embodiments and aspects of the present invention, it should be noted that the features of the embodiments and aspects described herein may be combined with each other unless specifically noted otherwise.</p><heading id="h0004">Brief description of the Drawings</heading><p id="p0025" num="0025">The present invention will now be described with reference to the accompanying drawings.
<ul><li><figref idrefs="f0001">Fig. 1</figref> shows schematically an electronic device according to an embodiment of the present invention.</li><li><figref idrefs="f0001">Fig. 2</figref> shows a method according to an embodiment of the present invention.</li></ul></p><heading id="h0005">Detailed description</heading><p id="p0026" num="0026">Due to broadcasting nature of digital multimedia broadcasting television (DMB TV) and similar services, the associated video and audio streams are exposed to an error prone wireless channel. The wireless channel introduces errors into these streams. This may in particular raise a problem in bad reception conditions, for example in street canyons or rural areas far away from the next transmitter. These errors degrade the quality of service, in particular the audio and video quality. Furthermore, these errors may also cause a decoder, for example a video or audio decoder, to crash such that the user may have to restart the decoder resulting in a degraded quality of usability.</p><p id="p0027" num="0027">Therefore, multimedia systems are usually equipped with a forward error correction (FEC) to correct the channel errors. In particular, in DMB systems, this may be achieved with the aid of Reed-Solomon (RS) codes, for example (204, 188) RS. However, the error correction capability of this code is rather limited, for example the above code can correct up to eight byte errors from a packet of 204 bytes. As a result,<!-- EPO <DP n="12"> --> these codes are ineffective in keeping a good quality of service if the number of errors in the packets is higher than the error correction capabilities.</p><p id="p0028" num="0028"><figref idrefs="f0001">Fig. 1</figref> shows an electronic device 10, for example a mobile telephone or a television set for a vehicle, receiving a digital media stream via a wireless channel 20 from a sender 30. The electronic device 10 comprises an antenna 11 and a receiver device 12 for receiving and channel decoding the digital multimedia stream, and a decoding and correction device 13 coupled to the receiver device 12. The decoding and correction device 13 may be configured to perform the above-described forward error correction as well as a decoding of the received digital multimedia stream for outputting video and audio data to output devices 14, 15 of the electronic device 10, for example to a display 14, and a loudspeaker 15. Furthermore, the decoding and correction device 13 may be configured to perform a correction method which will be described in more detail in the following in connection with <figref idrefs="f0001">Fig. 2</figref>.</p><p id="p0029" num="0029"><figref idrefs="f0001">Fig. 2</figref> shows a method 40 for receiving and processing a digital media transport stream. The method 40 comprises method steps 41 to 49. The digital media transport stream (TS) comprises a stream of digital data packets and each digital data packet of the stream comprises at least one header data field and payload data. The header data field uniquely identifies a packet type of the corresponding digital data packet. The packet type is one of a plurality of packet types which are predefined for the digital media transport stream. For example, the digital media transport stream may comprise video data packets, audio data packets, program association table (PAT) packets, program map table (PMT) packets, scene description (SD) packets, object description (OD) packets, and Null packets. In step 41 for each packet type an individual error threshold is set. As will be described below, these error thresholds will be used to avoid running the packet correction algorithm when too many errors are observed, which could cause the algorithm to fail improving quality, but may cause worse results. Once these error thresholds have been set, information about the digital media broadcasting transport stream is gathered for the different types of packets. Apart from general information about the digital media broadcasting transport stream, also a number of packet-type specific information will be taken into account as will be described below. In step 42,<!-- EPO <DP n="13"> --> digital media transport stream information is gathered. This information will be later useful in error correction. This information may be obtained from the underlying stream by means of error-free packets or it may be obtained from a storage device. Then, in step 43, header masks for the different types of packets are generated using the stream related information gathered in step 42or retrieved from a storage device, and for each erroneous packet of the digital media broadcasting transport stream which is received in step 44, a packet type is determined in step 45. In order to utilize the error threshold, in step 46, a header error rate is estimated. The result of this estimate is then used in step 47 to decide on repairing the underlying erroneous packet. Finally, if the decision is to go ahead with the correction, the packet is repaired in step 48. If the packet is repaired it is furthermore decoded and output in step 48. However, if it is not repaired because of high error rate, it is just discarded in step 49. Then, the method 40 continues in step 44 with the next erroneous packet of the digital media broadcasting stream.</p><p id="p0030" num="0030">In the following, steps 41 to 49 will be described in more detail.</p><p id="p0031" num="0031">In step 41, the error thresholds are set. The error thresholds define the maximum amount of errors in a packet that the algorithm should attempt to correct. A suitable range for the error thresholds may be 0 to 25. Individual thresholds may be set for each type of packet depending on the error sensitivity of that packet type and the error correction gain. The higher the error sensitivity of a packet type, the lower the threshold for this packet type may be set. A higher threshold means more repair, but it also means a higher risk of a decoder/player crashing. Therefore, a good trade-off between the amount of repair and the risk of the decoder crashing is to be considered. As the error sensitivity level of the audio and video packets is medium to high, the corresponding error thresholds may be set, depending on error rate, in a range of zero to three for video packets and in a range of zero to four for audio packets. The error threshold for PAT, PMT and OD packets may be set to zero. These packets are extremely sensitive to errors and even a single residual bit error may potentially cause the decoder to crash. Furthermore, these packets appear at least twice every second and the decoder only needs to decode one set of these packets. As such, the decoder can simply ignore these packets after that set. This will also save processing resources. The error threshold for<!-- EPO <DP n="14"> --> SD packets may also be set to zero, as it has been observed that these packets have no effect on video quality. Finally, Null packets may be ignored as these packets contain no information or data, and therefore the error threshold may also be set to zero.</p><p id="p0032" num="0032">In step 42, the digital media stream information is gathered. There are two ways it can be achieved. Either it is retrieved from a storage device or it is obtained from viewing error-free packets of the live stream. The stream information may relate, for example, to general information like packet IDs (PIDs) of the associated packets, a transport priority, a scrambling control, an adaption field control type, and continuity counters of previous packets of all types. Furthermore, the stream information may comprise packet-specific information, for example for video packets a stream type and an adaption field presence type, and for audio packets a stream type and PCR reserve bit values (all zero or all one) etc.</p><p id="p0033" num="0033">In step 43, header masks are generated. The header masks may be based on the obtained digital media stream information. As an alternative, the header masks may be retrieved from a storage device of the electronic device 10 or may be hard code in a software of the correction device 13 or may be obtained from the stream information gathered in step 42. For creating the packet header masks all the known bits of a header type are set. Each type of packet associated to a program has its own mask. The following table shows a typical example header masks for PMT, PAT, audio and video packets. All the known bits of the header are indicated by a zero or one. The unknown bits are indicated by an "x".<!-- EPO <DP n="15"> -->
<tables id="tabl0001" num="0001"><table frame="all"><tgroup cols="6"><colspec colnum="1" colname="col1" colwidth="12mm"/><colspec colnum="2" colname="col2" colwidth="12mm"/><colspec colnum="3" colname="col3" colwidth="15mm"/><colspec colnum="4" colname="col4" colwidth="14mm"/><colspec colnum="5" colname="col5" colwidth="24mm"/><colspec colnum="6" colname="col6" colwidth="34mm"/><thead><row><entry align="center" valign="middle"><b>PMT</b></entry><entry align="center" valign="middle"><b>PAT</b></entry><entry align="center" valign="middle"><b>Audio</b></entry><entry align="center" valign="middle"><b>Video</b></entry><entry align="center" valign="middle"><b>Bit Position</b></entry><entry align="center" valign="middle"/></row></thead><tbody><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">1</entry><entry morerows="7" align="center" valign="middle">Sync Byte</entry></row><row><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">2</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">3</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">4</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">5</entry></row><row><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">6</entry></row><row><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">7</entry></row><row><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">8</entry></row><row><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">9</entry><entry align="center"/></row><row><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">10</entry><entry align="center"/></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">11</entry><entry align="center">Priority</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">12</entry><entry morerows="12" align="center">Packet ID (PID)</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">13</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">14</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">15</entry></row><row><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">16</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">17</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">18</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">19</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">230</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">21</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">22</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">23</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">24</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">25</entry><entry morerows="1" align="center">Scrambling Ctrl</entry></row><row><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">0</entry><entry align="center" valign="middle">26</entry></row><row><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">27</entry><entry morerows="1" align="center">Adaptation Field Ctrl</entry></row><row><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">1</entry><entry align="center" valign="middle">28</entry></row><row><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">29</entry><entry align="center"/></row><!-- EPO <DP n="16"> --><row><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">30</entry><entry align="center" valign="middle"/></row><row><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">31</entry><entry align="center" valign="middle"/></row><row><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">X</entry><entry align="center" valign="middle">32</entry><entry align="center" valign="middle"/></row></tbody></tgroup></table></tables></p><p id="p0034" num="0034">In step 44, the next media transport stream packet is obtained and if it has no errors it will be passed on to be decoded and output. However, if the packet is erroneous, it will be passed on to 45. In step 45, the packet type is determined. Determining the packet type may be performed by an identification step and a verification step. In the identification step, a potential type of an erroneous packet, such as audio, video, PMT and so on is determined by computing a Hamming distance between each of the masks and the received packet. If the Hamming distance between any of the header masks and the considered packet is zero, then the type of the erroneous packet is declared to be the same as the packet that has that header mask. Otherwise, the step of verification is done. For the verification, for example the top three identified candidates in terms of the Hamming distance may be selected for the verification. For the verification, additional packet information is compared, which will be described in more detail below. Based on the following equation, a confidence factor (CF) is defined: <maths id="math0001" num=""><math display="block"><mi>CF</mi><mo>=</mo><mi>½</mi><mo>⁢</mo><mfenced separators=""><mfrac><mi>Number of identical masks bits</mi><mi>Total number of bits in the hearder mask</mi></mfrac><mo>+</mo><mfrac><mi>Number of identical additional information bits</mi><mi>Total number of additional information bits</mi></mfrac></mfenced></math><img id="ib0001" file="imgb0001.tif" wi="140" he="12" img-content="math" img-format="tif"/></maths></p><p id="p0035" num="0035">The header type candidate with the highest confidence factor is declared to be the packet type of the erroneous packet.</p><p id="p0036" num="0036">In step 46, the header error rate is estimated, for example based on the following equation: <maths id="math0002" num=""><math display="block"><mi>Error Rate</mi><mo>=</mo><mfrac><mi>Number of erroneous bits</mi><mi>Total number of mask bits</mi></mfrac><mspace width="1em"/><mi>x</mi><mspace width="1em"/><mn>100</mn><mo>%</mo></math><img id="ib0002" file="imgb0002.tif" wi="86" he="12" img-content="math" img-format="tif"/></maths><br/>
where the number of erroneous bits is determined as the Hamming distance of the verified candidate mask.<!-- EPO <DP n="17"> --></p><p id="p0037" num="0037">In step 47, it is decided whether or not to repair the packet. If the error rate is lower than the error threshold, then in step 48 the packet is repaired. Else, the packet is discarded in step 49. An independent decision for repairing or not repairing is made for each packet.</p><p id="p0038" num="0038">In step 48, the packet is repaired in the following way. The header errors are repaired with the header mask. Furthermore, information of the packet beyond the header may be repaired using the additional packet information as will be described below. After repairing the packet, the packet will be decoded and output in step 48.</p><p id="p0039" num="0039">As described above in connection with steps 45 and 48, additional packet information may be taken into account for determining the packet type and for repairing the packet. The additional packet information may relate to an extended number of structural information of the different types of packets. In particular, it may be distinguished among video, audio, PAT, PMT, OD, SD and Null packets. The specific characteristics of these packet types may further assist for correcting certain errors. In other words, the manner in which different data is organized in the different types of packets may be utilized for determining the packet type and for repairing the packet. It is to be noted that some parts of the given packet type are fixed while other parts may be variable. In the following, a list of the characteristics for the different considered types of packets is provided. The characteristics are very useful in identifying and correcting these packets.</p><heading id="h0006"><b>Characteristics of video packets</b></heading><p id="p0040" num="0040"><ul><li>24-bit packet start code prefix = 0x00 00 01 is used to indicate the start of the next packetized elementary stream (PES) packet.</li><li>Video stream ID is fixed.</li><li>All flags in the adaptation field should be ZERO, except the random access flag, which could be zero or one.</li><li>If the 'Adaptation Field Presence Type' = 0, then
<ul><li>o Adaptation field is present ONLY to pad the TS packet in which a PES packet ends. As a consequence, both payload unit start indicator and adaptation field presence flags cannot be both = 1 for the same packet.</li></ul></li><li>If the 'Adaptation Field Presence Type' = 1, then<!-- EPO <DP n="18"> -->
<ul><li>o Adaptation field always comes ONLY
<ul><li>To pad the TS packet in which a PES packet ends</li><li>In all packets where a PES packet starts</li></ul></li></ul>
Any of the following cases could occur:
<ul><li>o Case 1: When ES packet starts with this TS packet but it does not end within this TS packet, we can verify with good confidence (as much as 40-bits known).</li><li>o Case 2: When ES packet ends with this TS packet but it did not started with this TS packet, we can verify with fair confidence (at lease 16-bits known).</li><li>∘ Case 3: When ES packet starts and ends in this TS packet, we can verify with fair confidence (at leaset 16-bits known).</li><li>∘ Case 4: When ES packet neither starts nor ends in this TS packet, we can verify with very little confidence (maybe through continuity-counter 4-bits known with some certainty).</li></ul></li></ul></p><heading id="h0007">Characteristics of audio packets</heading><p id="p0041" num="0041"><ul><li>Very often each of the TS packets contains a complete PES packet.</li><li>24-bit packet start code prefix = 0x00 00 01 is used to indicate the start of the next PES packet.</li><li>Audio stream ID is fixed.</li><li>Adaptation field is present in almost every packet.</li><li>PES header length is always less than PES packet length.</li></ul></p><heading id="h0008"><b>Characteristics of PAT packets</b></heading><p id="p0042" num="0042"><ul><li>Table ID = 0 (Byte # 6)</li><li>Section length must be 13 bytes long for all the examined DMB streams<br/>
→ Byte # 7 = 0xB0<br/>
→ Byte # 8 = 0x0D</li><li>Section length must be less than 32 bytes<br/>
→ Byte # 7 = 0xB0<br/>
→ Byte # 8 = Ob001x xxxx</li></ul><!-- EPO <DP n="19"> --></p><heading id="h0009"><b>Characteristics of PMT packets</b></heading><p id="p0043" num="0043"><ul><li>Table ID = 2 (Byte # 6)</li><li>Next two bytes after 'last sec. no' are 3-MSB = 0b111 &amp; 13-LSB = Audio PID (PID of the packets containing PCR)</li><li>In program info length (byte # 16-17) are 4-MSB = 0b1111 &amp; 12-LSB = program length &lt;= 188-17 = 171 → Byte#16 must be '11110000' or 0xF0</li></ul></p><heading id="h0010"><b>Common Characteristics PAT and PMT Packets</b></heading><p id="p0044" num="0044"><ul><li>Payload unit start indicator = 1</li><li>Adaptation field ctrl bits should be = '01'</li><li>Adaptation field length must be = 0x00</li><li>Section length &lt;= 180 bytes ==&gt; 4 bits (MSB) in section length must be zero.</li><li>Section number = 0x00</li><li>Last section number = 0x00</li><li>All bytes in the packet after the section length should be 0xFF, which verifies the section length</li><li>Cyclic redundancy check</li></ul></p><heading id="h0011"><b>Characteristics of OD Packets</b></heading><p id="p0045" num="0045"><ul><li>Payload unit start indicator = 1</li><li>Adaptation field ctrl bits should be = '01'</li><li>Adaptation field length must be = 0x00</li><li>Table ID = 0x05</li><li>Section length &lt;= 180 bytes ==&gt; 4 bits (MSB) in Section length must be zero</li><li>Section Number = 0x00</li><li>Last section number = 0x00</li><li>All bytes in the packet after the section length should be 0xFF, which verifies the Section length</li><li>Cyclic redundancy check</li></ul><!-- EPO <DP n="20"> --></p><heading id="h0012"><b>Characteristics of SD Packets</b></heading><p id="p0046" num="0046"><ul><li>Payload unit start indicator = 1</li><li>Adaptation field ctrl bits should be = '01'</li><li>Adaptation field length must be = 0x00</li><li>Table ID = 0x04</li><li>Section length &lt;= 180 bytes ==&gt; 4 bits (MSB) in section length must be zero</li><li>Section number = 0x00</li><li>Last section number = 0x00</li><li>All bytes in the packet after the section length should be 0xFF, which verifies the section length</li><li>Cyclic redundancy check</li></ul></p><heading id="h0013"><b>Characteristics of Null Packets</b></heading><p id="p0047" num="0047"><ul><li>Payload Unit start indicator is always = 0b0</li><li>Adaptation field is never present</li><li>All payload bytes have fixed value = 0xFF</li><li>If confirmed, the best treatment of the packet is to set TxErrIndicator = 1, without repair</li></ul></p><p id="p0048" num="0048">To sum up, the above-described method for receiving, repairing and processing packets of a digital media transport stream repairs the adaption field and some parts of the data in addition to the header. Furthermore, the method makes a decision to repair a packet or leave it untouched to not engage a repair if the number of errors is too high and hence may overload the algorithm and to reduce the risk of decoder crash/failure and/or further degradation of video quality.</p></description><claims mxw-id="PCLM90459167" lang="EN" load-source="patent-office"><!-- EPO <DP n="21"> --><claim id="c-en-0001" num="0001"><claim-text>A method for correcting errors in a digital media transport stream, wherein the digital media transport stream comprises a stream of digital data packets, wherein each digital data packet of the stream of digital data packets comprises at least one header data field and payload data uniquely identifying a packet type of the corresponding digital data packet, wherein the packet type is one of a plurality of packet types pre-defined for the digital media transport stream, the method comprising:
<claim-text>- retrieving (43) a plurality of header masks from error-free packets of the underlying media transport stream or from a storage device, wherein each header mask is associated with a corresponding packet type of the plurality of packet types and wherein each header mask identifies the header data fields for uniquely identifying the associated packet type,</claim-text>
<claim-text>- receiving (44) a digital data packet of the digital media transport stream,</claim-text>
<claim-text>- for each header mask of the plurality of header masks: comparing the header data fields of the received digital data packet with the header data fields of the header mask,</claim-text>
<claim-text>- determining (45) a packet type of the received digital data packet based on the comparisons with the plurality of header masks, and</claim-text>
<claim-text>- correcting (48) the received digital data packet based on the determined packet type.</claim-text></claim-text></claim><claim id="c-en-0002" num="0002"><claim-text>The method according to claim 1, wherein correcting the received digital data packet comprises:
<claim-text>- estimating (46) a header error rate of the received digital data packet based on the determined packet type,</claim-text>
<claim-text>- comparing (47) the header error rate with a header error rate threshold predetermined for each packet type of the plurality of packet types, and<!-- EPO <DP n="22"> --></claim-text>
<claim-text>- selectively correcting (48) the received digital data packet based on the comparison of the estimated header error rate with the predetermined header error rate threshold.</claim-text></claim-text></claim><claim id="c-en-0003" num="0003"><claim-text>The method according to claim 2, wherein the predetermined header error rate threshold comprises at least one of:
<claim-text>- a header error rate depending value between 0 and 3 for a video data packet,</claim-text>
<claim-text>- a header error rate depending value between 0 and 4 for an audio data packet,</claim-text>
<claim-text>- a value of 0 for a program association table packet,</claim-text>
<claim-text>- a value of 0 for a program map table packet,</claim-text>
<claim-text>- a value of 0 for a scene description packet,</claim-text>
<claim-text>- a value of 0 for an object description packet, and</claim-text>
<claim-text>- a value of 0 for a Null packet.</claim-text></claim-text></claim><claim id="c-en-0004" num="0004"><claim-text>The method according to any one of the preceding claims, wherein comparing the header data fields of the received digital data packet with the header data fields of the header mask for each header mask of the plurality of header masks comprises for each header mask of the plurality of header masks:
<claim-text>- determining a Hamming distance between the header data fields of the received digital data packet and the header data fields of the header mask.</claim-text></claim-text></claim><claim id="c-en-0005" num="0005"><claim-text>The method according to claim 4, wherein determining (45) the packet type of the received digital data packet comprises:
<claim-text>- in case the determined Hamming distance between the header data fields of the received digital data packet and the header data fields of one of the header masks is zero: determining the packet type of the one header mask as the packet type of the received digital data packet, and</claim-text>
<claim-text>- in case the determined Hamming distance between the header data fields of the received digital data packet and the header data fields of none of the header masks is zero:<!-- EPO <DP n="23"> --></claim-text>
<claim-text>- determining a predefined number of the packet types associated with those header masks having the smallest Hamming distances with respect to the received digital data packet,</claim-text>
<claim-text>- determining for each determined packet type a confidence factor based on a comparison of additional data of the received digital data packet and expected additional data predefined for the corresponding packet type, wherein the additional data comprises predefined parts of the payload data subsequent to the header data fields, wherein the expected additional data is predefined specifically for each packet type, and</claim-text>
<claim-text>- determining the packet type with the highest confidence factor as the packet type of the received digital data packet.</claim-text></claim-text></claim><claim id="c-en-0006" num="0006"><claim-text>The method according to any one of the preceding claims, wherein correcting (48) the received digital data packet comprises:
<claim-text>- determining additional data of the received digital data packet, wherein the additional data comprises predefined parts of the payload data subsequent to the header data fields,</claim-text>
<claim-text>- retrieving expected additional data from error-free packets of the underlying media transport stream or from a storage device, wherein the expected additional data is predefined specifically for each packet type, and</claim-text>
<claim-text>- correcting the payload data based on the additional data and the expected additional data.</claim-text></claim-text></claim><claim id="c-en-0007" num="0007"><claim-text>The method according to claim 5 or 6, wherein the additional data for a received video data packet comprises at least one of
<claim-text>- a packet start code prefix indicating a start of a next packetized elementary stream package,</claim-text>
<claim-text>- a video stream identifier,</claim-text>
<claim-text>- an adaption field presence flag,</claim-text>
<claim-text>- a payload start indicator flag, and</claim-text>
<claim-text>- flags of an adaption field.</claim-text><!-- EPO <DP n="24"> --></claim-text></claim><claim id="c-en-0008" num="0008"><claim-text>The method according to any one of claims 5-7, wherein the additional data for a received audio data packet comprises at least one of
<claim-text>- a packet start code prefix indicating a start of a next packetized elementary stream package,</claim-text>
<claim-text>- an audio stream identifier,</claim-text>
<claim-text>- an adaption field presence flag,</claim-text>
<claim-text>- a packetized elementary stream header length, and</claim-text>
<claim-text>- a packetized elementary stream packet length.</claim-text></claim-text></claim><claim id="c-en-0009" num="0009"><claim-text>The method according to any one of claims 5-8, wherein the additional data for a received program association table packet comprises at least one of
<claim-text>- a payload unit start indicator,</claim-text>
<claim-text>- adaption field control bits,</claim-text>
<claim-text>- an adaption field length,</claim-text>
<claim-text>- a section length,</claim-text>
<claim-text>- a section number,</claim-text>
<claim-text>- a last section number,</claim-text>
<claim-text>- bytes in the packet after the section length information,</claim-text>
<claim-text>- a cyclic redundancy check information, and</claim-text>
<claim-text>- a table identifier.</claim-text></claim-text></claim><claim id="c-en-0010" num="0010"><claim-text>The method according to any one of claims 5-9, wherein the additional data for a received program map table packet comprises at least one of
<claim-text>- a payload unit start indicator,</claim-text>
<claim-text>- adaption field control bits,</claim-text>
<claim-text>- an adaption field length,</claim-text>
<claim-text>- a section length,</claim-text>
<claim-text>- a section number,</claim-text>
<claim-text>- a last section number,</claim-text>
<claim-text>- bytes in the packet after the section length information,</claim-text>
<claim-text>- a cyclic redundancy check information,</claim-text>
<claim-text>- a table identifier,<!-- EPO <DP n="25"> --></claim-text>
<claim-text>- a two-byte information following the last section number relating to audio PID, and</claim-text>
<claim-text>- a program information length.</claim-text></claim-text></claim><claim id="c-en-0011" num="0011"><claim-text>The method according to any one of claims 5-10, wherein the additional data for a received object description packet comprises at least one of
<claim-text>- a payload unit start indicator,</claim-text>
<claim-text>- adaption field control bits,</claim-text>
<claim-text>- an adaption field length,</claim-text>
<claim-text>- a table identifier,</claim-text>
<claim-text>- a section length,</claim-text>
<claim-text>- a section number,</claim-text>
<claim-text>- a last section number,</claim-text>
<claim-text>- bytes in the packet after the section length information, and</claim-text>
<claim-text>- a cyclic redundancy check information.</claim-text></claim-text></claim><claim id="c-en-0012" num="0012"><claim-text>The method according to any one of claims 5-11, wherein the additional data for a received scene description packet comprises at least one of
<claim-text>- a payload unit start indicator,</claim-text>
<claim-text>- adaption field control bits,</claim-text>
<claim-text>- an adaption field length,</claim-text>
<claim-text>- a table identifier,</claim-text>
<claim-text>- a section length,</claim-text>
<claim-text>- a section number,</claim-text>
<claim-text>- a last section number,</claim-text>
<claim-text>- bytes in the packet after the section length information, and</claim-text>
<claim-text>- a cyclic redundancy check information.</claim-text></claim-text></claim><claim id="c-en-0013" num="0013"><claim-text>A correction device for correcting errors in a digital media transport stream, wherein the digital media transport stream comprises a stream of digital data packets, wherein each digital data packet of the stream of digital data packets comprises at least one header data field and payload data uniquely identifying a<!-- EPO <DP n="26"> --> packet type of the corresponding digital data packet, wherein the packet type is one of a plurality of packet types pre-defined for the digital media transport stream, the correction device (13) comprising a processing unit configured to
<claim-text>- receive a digital data packet of the digital media transport stream,</claim-text>
<claim-text>- retrieve a plurality of header masks from a storage device, wherein each header mask is associated with a corresponding packet type of the plurality of packet types and wherein each header mask identifies the header data fields for uniquely identifying the associated packet type,</claim-text>
<claim-text>- compare for each header mask of the plurality of header masks the header data fields of the received digital data packet with the header data fields of the header mask,</claim-text>
<claim-text>- determine a packet type of the received digital data packet based on the comparisons with the plurality of header masks, and</claim-text>
<claim-text>- correct the received digital data packet based on the determined packet type.</claim-text></claim-text></claim><claim id="c-en-0014" num="0014"><claim-text>The correction device according to claim 13, wherein the correction device (13) is configured to perform the method according to any one of claims 1-12.</claim-text></claim><claim id="c-en-0015" num="0015"><claim-text>An electronic device, comprising:
<claim-text>- a receiver device (12) for receiving digital data packets of a digital media transport stream,</claim-text>
<claim-text>- a correction device (13) according to claim 13 or 14 coupled to the receiver device for receiving the digital data packets, and</claim-text>
<claim-text>- an output device (14, 15) coupled to the correction device (13) for receiving the corrected digital data packets form the correction device (13) and configured to output the corrected data packets.</claim-text></claim-text></claim></claims><amended-claims mxw-id="PCLM90459166" lang="EN" load-source="patent-office" amended-claim-type="EPC"><heading id="h0014">Amended claims in accordance with Rule 137(2) EPC.</heading><claim id="ac-en-0001" num="0001"><claim-text>A method for correcting errors in a digital media transport stream, wherein the digital media transport stream comprises a stream of digital data packets, wherein each digital data packet of the stream of digital data packets comprises at least one header data field and information blocks in payload data uniquely identifying a packet type of the corresponding digital data packet, wherein the packet type is one of a plurality of packet types pre-defined for the digital media transport stream, the method comprising:
<claim-text>- retrieving (43) a plurality of header masks from error-free packets of the underlying media transport stream or from a storage device, wherein each header mask is associated with a corresponding packet type of the plurality of packet types and wherein each header mask identifies those header data fields which uniquely identify the associated packet type and provides an expected value or value range for each of those header data fields,</claim-text>
<claim-text>- receiving (44) a digital data packet of the digital media transport stream,</claim-text>
<claim-text>- for each header mask of the plurality of header masks: comparing the header data fields of the received digital data packet with the header data fields of the header mask,</claim-text>
<claim-text>- determining (45) a packet type of the received digital data packet based on the comparisons with the plurality of header masks, and</claim-text>
<claim-text>- correcting (48) the received digital data packet based on the determined packet type.</claim-text></claim-text></claim><claim id="ac-en-0002" num="0002"><claim-text>The method according to claim 1, wherein correcting the received digital data packet comprises:
<claim-text>- estimating (46) a header error rate of the received digital data packet based on the determined packet type,</claim-text>
<claim-text>- comparing (47) the header error rate with a header error rate threshold predetermined for each packet type of the plurality of packet types, and</claim-text>
<claim-text>- correcting (48) the received digital data packet based on the comparison of the estimated header error rate with the predetermined header error rate threshold only, if the estimated header error rate does not exceed the predetermined header error rate threshold.</claim-text></claim-text></claim><claim id="ac-en-0003" num="0003"><claim-text>The method according to claim 2, wherein the predetermined header error rate threshold comprises at least one of:
<claim-text>- a header error rate depending value between 0 and 3 for a video data packet,</claim-text>
<claim-text>- a header error rate depending value between 0 and 4 for an audio data packet,</claim-text>
<claim-text>- a value of 0 for a program association table packet,</claim-text>
<claim-text>- a value of 0 for a program map table packet,</claim-text>
<claim-text>- a value of 0 for a scene description packet,</claim-text>
<claim-text>- a value of 0 for an object description packet, and</claim-text>
<claim-text>- a value of 0 for a Null packet.</claim-text></claim-text></claim><claim id="ac-en-0004" num="0004"><claim-text>The method according to any one of the preceding claims, wherein comparing the header data fields of the received digital data packet with the header data fields of the header mask for each header mask of the plurality of header masks comprises for each header mask of the plurality of header masks:
<claim-text>- determining a Hamming distance between the header data fields of the received digital data packet and the header data fields of the header mask.</claim-text></claim-text></claim><claim id="ac-en-0005" num="0005"><claim-text>The method according to claim 4, wherein determining (45) the packet type of the received digital data packet comprises:
<claim-text>- in case the determined Hamming distance between the header data fields of the received digital data packet and the header data fields of one of the header masks is zero: determining the packet type of the one header mask as the packet type of the received digital data packet, and</claim-text>
<claim-text>- in case the determined Hamming distance between the header data fields of the received digital data packet and the header data fields of none of the header masks is zero:</claim-text>
<claim-text>- determining a predefined number of the packet types associated with those header masks having the smallest Hamming distances with respect to the received digital data packet,</claim-text>
<claim-text>- determining for each determined packet type a confidence factor based on a comparison of additional data of the received digital data packet and expected additional data predefined for the corresponding packet type, wherein the additional data comprises predefined parts of the payload data subsequent to the header data fields, wherein the expected additional data is predefined specifically for each packet type, and</claim-text>
<claim-text>- determining the packet type with the highest confidence factor as the packet type of the received digital data packet.</claim-text></claim-text></claim><claim id="ac-en-0006" num="0006"><claim-text>The method according to claim 5, wherein the additional data for a received video data packet comprises at least one of
<claim-text>- a packet start code prefix indicating a start of a next packetized elementary stream package,</claim-text>
<claim-text>- a video stream identifier,</claim-text>
<claim-text>- an adaption field presence flag,</claim-text>
<claim-text>- a payload start indicator flag, and</claim-text>
<claim-text>- flags of an adaption field.</claim-text></claim-text></claim><claim id="ac-en-0007" num="0007"><claim-text>The method according to any one of claims 5-6, wherein the additional data for a received audio data packet comprises at least one of
<claim-text>- a packet start code prefix indicating a start of a next packetized elementary stream package,</claim-text>
<claim-text>- an audio stream identifier,</claim-text>
<claim-text>- an adaption field presence flag,</claim-text>
<claim-text>- a packetized elementary stream header length, and</claim-text>
<claim-text>- a packetized elementary stream packet length.</claim-text></claim-text></claim><claim id="ac-en-0008" num="0008"><claim-text>The method according to any one of claims 5-7, wherein the additional data for a received program association table packet comprises at least one of
<claim-text>- a payload unit start indicator,</claim-text>
<claim-text>- adaption field control bits,</claim-text>
<claim-text>- an adaption field length,</claim-text>
<claim-text>- a section length,</claim-text>
<claim-text>- a section number,</claim-text>
<claim-text>- a last section number,</claim-text>
<claim-text>- bytes in the packet after the section length information,</claim-text>
<claim-text>- a cyclic redundancy check information, and</claim-text>
<claim-text>- a table identifier.</claim-text></claim-text></claim><claim id="ac-en-0009" num="0009"><claim-text>The method according to any one of claims 5-8, wherein the additional data for a received program map table packet comprises at least one of
<claim-text>- a payload unit start indicator,</claim-text>
<claim-text>- adaption field control bits,</claim-text>
<claim-text>- an adaption field length,</claim-text>
<claim-text>- a section length,</claim-text>
<claim-text>- a section number,</claim-text>
<claim-text>- a last section number,</claim-text>
<claim-text>- bytes in the packet after the section length information,</claim-text>
<claim-text>- a cyclic redundancy check information,</claim-text>
<claim-text>- a table identifier,</claim-text>
<claim-text>- a two-byte information following the last section number relating to audio PID, and</claim-text>
<claim-text>- a program information length.</claim-text></claim-text></claim><claim id="ac-en-0010" num="0010"><claim-text>The method according to any one of claims 5-9, wherein the additional data for a received object description packet comprises at least one of
<claim-text>- a payload unit start indicator,</claim-text>
<claim-text>- adaption field control bits,</claim-text>
<claim-text>- an adaption field length,</claim-text>
<claim-text>- a table identifier,</claim-text>
<claim-text>- a section length,</claim-text>
<claim-text>- a section number,</claim-text>
<claim-text>- a last section number,</claim-text>
<claim-text>- bytes in the packet after the section length information, and</claim-text>
<claim-text>- a cyclic redundancy check information.</claim-text></claim-text></claim><claim id="ac-en-0011" num="0011"><claim-text>The method according to any one of claims 5-10, wherein the additional data for a received scene description packet comprises at least one of
<claim-text>- a payload unit start indicator,</claim-text>
<claim-text>- adaption field control bits,</claim-text>
<claim-text>- an adaption field length,</claim-text>
<claim-text>- a table identifier,</claim-text>
<claim-text>- a section length,</claim-text>
<claim-text>- a section number,</claim-text>
<claim-text>- a last section number,</claim-text>
<claim-text>- bytes in the packet after the section length information, and</claim-text>
<claim-text>- a cyclic redundancy check information.</claim-text></claim-text></claim><claim id="ac-en-0012" num="0012"><claim-text>A correction device for correcting errors in a digital media transport stream, wherein the digital media transport stream comprises a stream of digital data packets, wherein each digital data packet of the stream of digital data packets comprises at least one header data field and information blocks in payload data uniquely identifying a packet type of the corresponding digital data packet, wherein the packet type is one of a plurality of packet types pre-defined for the digital media transport stream, the correction device (13) comprising a processing unit configured to
<claim-text>- receive a digital data packet of the digital media transport stream,</claim-text>
<claim-text>- retrieve a plurality of header masks from a storage device, wherein each header mask is associated with a corresponding packet type of the plurality of packet types and wherein each header mask identifies those header data fields which uniquely identify the associated packet type and provides an expected value or value range for each of those header data fields,</claim-text>
<claim-text>- compare for each header mask of the plurality of header masks the header data fields of the received digital data packet with the header data fields of the header mask,</claim-text>
<claim-text>- determine a packet type of the received digital data packet based on the comparisons with the plurality of header masks, and</claim-text>
<claim-text>- correct the received digital data packet based on the determined packet type.</claim-text></claim-text></claim><claim id="ac-en-0013" num="0013"><claim-text>The correction device according to claim 12, wherein the correction device (13) is configured to perform the method according to any one of claims 2-11.</claim-text></claim><claim id="ac-en-0014" num="0014"><claim-text>An electronic device, comprising:
<claim-text>- a receiver device (12) for receiving digital data packets of a digital media transport stream,</claim-text>
<claim-text>- a correction device (13) according to claim 12 or 13 coupled to the receiver device for receiving the digital data packets, and</claim-text>
<claim-text>- an output device (14, 15) coupled to the correction device (13) for receiving the corrected digital data packets form the correction device (13) and configured to output the corrected data packets.</claim-text></claim-text></claim></amended-claims><drawings mxw-id="PDW20421903" load-source="patent-office"><!-- EPO <DP n="27"> --><figure id="f0001" num="1,2"><img id="if0001" file="imgf0001.tif" wi="157" he="233" img-content="drawing" img-format="tif"/></figure></drawings><search-report-data><doc-page id="srep0001" file="srep0001.tif" wi="158" he="233" type="tif"/><doc-page id="srep0002" file="srep0002.tif" wi="158" he="233" type="tif"/></search-report-data><copyright>User acknowledges that Fairview Research LLC and its third party providers retain all right, title and interest in and to this xml under applicable copyright laws.  User acquires no ownership rights to this xml including but not limited to its format.  User hereby accepts the terms and conditions of the Licence Agreement</copyright></patent-document>
